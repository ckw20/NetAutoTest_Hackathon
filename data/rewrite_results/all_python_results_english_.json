[
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv2ControlOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发L2TPv2 Control Over UDP报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的L2TPv2 Control Over UDP头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Verify that the test instrument accurately counts L2TPv2 Control Over UDP packets sent\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Modify the L2TPv2 Control Over UDP header content of traffic StreamTemplate_1;;\n                   Test Step 3: Configure packet capture filtering;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set port transmission mode to burst;\n                   Test Step 6: Transmit all traffic and wait for a period;\n                   Test Step 7: Stop all traffic and examine StreamBlockStats statistics;;\n\nCriteria    \t:   Expected Result 1: In step 6, traffic StreamTemplate_1 shows equal transmitted and received packets;\n\nCreated by   \t:  \tTester-004\n\nBugs   \t    :  \tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv2Control头部\n    header = edit_header_l2tpv2_control(Stream=stream, Level=0, Reserved1=11, Ns=5, Nr=6)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header['Nr'],\n                  Type='Increment', Count=10)\n    # 修改l2tp control option\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=0, Types='GeneralTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=1, Types='MessageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=2, Types='ResultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ErrorMessage'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=3, Types='ProtocolVersion', Ver='1', Rev='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Ver'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=4, Types='FramingCapabilities', Abit='1', Sbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Abit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=5, Types='BearerCapabilities', Abit='1', Dbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Dbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=6, Types='TieBreaker', TieBreakerValue='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['TieBreakerValue'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=7, Types='FirmwareRevision', FirmwareRevision='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['FirmwareRevision'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=8, Types='AssignedTunnelId', TunnelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['TunnelId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=9, Types='ReceiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=10, Types='AssignedSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=11, Types='Response', ResponseValue='00000000000000000000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ResponseValue'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=12, Types='CallSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=13, Types='MinimumBps', MinimumBps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MinimumBps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=14, Types='MaximumBps', MaximumBps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MaximumBps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=15, Types='BearerType', Abit='1', Dbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Dbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=16, Types='FramingType', Abit='1', Sbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Sbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=17, Types='TxConnectSpeed', Bps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Bps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=18, Types='RxConnectSpeed', HighBPS='1', LowBPS='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['HighBPS'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=19, Types='PhysicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=20, Types='ProxyAuthenType', AuthenType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AuthenType'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=21, Types='ProxyAuthenId', AuthenId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AuthenId'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv2Control_1.ns',\n                                               Value='5', MaxValue='5')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using the specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) for testing.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with auto frame length.\",\n  \"Subtask 4\": \"Configure the stream header with EthernetII, IPv4, UDP, and L2TPv2 Control protocols.\",\n  \"Subtask 5\": \"Modify the L2TPv2 Control header fields including Reserved1, Ns, Nr, and various option attributes.\",\n  \"Subtask 6\": \"Apply increment modifiers to specific L2TPv2 Control header fields with count=10.\",\n  \"Subtask 7\": \"Create a PDU capture pattern on Port_2 filtering for L2TPv2 Control packets with ns=5.\",\n  \"Subtask 8\": \"Configure packet capture filter on Port_2 using the created PDU pattern.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Set Port_1 transmission mode to burst with burst count=100.\",\n  \"Subtask 11\": \"Save the test configuration to a file.\",\n  \"Subtask 12\": \"Start packet capture on Port_2.\",\n  \"Subtask 13\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 14\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission.\",\n  \"Subtask 16\": \"Stop packet capture.\",\n  \"Subtask 17\": \"Wait 3 seconds for statistics stabilization.\",\n  \"Subtask 18\": \"Download captured packets from Port_2 for analysis.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats for the transmitted stream.\",\n  \"Subtask 20\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 21\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Verify that the test instrument accurately counts L2TPv2 Control Over UDP packets sent\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Modify the L2TPv2 Control Over UDP header content of traffic StreamTemplate_1;;\n                   Test Step 3: Configure packet capture filtering;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set port transmission mode to burst;\n                   Test Step 6: Transmit all traffic and wait for a period;\n                   Test Step 7: Stop all traffic and examine StreamBlockStats statistics;;\n\nCriteria    \t:   Expected Result 1: In step 6, traffic StreamTemplate_1 shows equal transmitted and received packets;\n\nCreated by   \t:  \tTester-004\n\nBugs   \t    :  \tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv2Control头部\n    header = edit_header_l2tpv2_control(Stream=stream, Level=0, Reserved1=11, Ns=5, Nr=6)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header['Nr'],\n                  Type='Increment', Count=10)\n    # 修改l2tp control option\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=0, Types='GeneralTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=1, Types='MessageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=2, Types='ResultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ErrorMessage'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=3, Types='ProtocolVersion', Ver='1', Rev='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Ver'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=4, Types='FramingCapabilities', Abit='1', Sbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Abit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=5, Types='BearerCapabilities', Abit='1', Dbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Dbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=6, Types='TieBreaker', TieBreakerValue='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['TieBreakerValue'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=7, Types='FirmwareRevision', FirmwareRevision='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['FirmwareRevision'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=8, Types='AssignedTunnelId', TunnelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['TunnelId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=9, Types='ReceiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=10, Types='AssignedSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=11, Types='Response', ResponseValue='00000000000000000000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ResponseValue'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=12, Types='CallSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=13, Types='MinimumBps', MinimumBps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MinimumBps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=14, Types='MaximumBps', MaximumBps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MaximumBps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=15, Types='BearerType', Abit='1', Dbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Dbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=16, Types='FramingType', Abit='1', Sbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Sbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=17, Types='TxConnectSpeed', Bps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Bps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=18, Types='RxConnectSpeed', HighBPS='1', LowBPS='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['HighBPS'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=19, Types='PhysicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=20, Types='ProxyAuthenType', AuthenType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AuthenType'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=21, Types='ProxyAuthenId', AuthenId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AuthenId'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv2Control_1.ns',\n                                               Value='5', MaxValue='5')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv1Report.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发igmpv1 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的igmpv1 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Purpose: Verify the test instrument correctly counts IGMPv1 report packets.\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n     Test Step 2: Modify the IGMPv1 report header content of traffic StreamTemplate_1;\n     Test Step 3: Configure packet capture filtering;\n     Test Step 4: Subscribe to StreamBlockStats counters;\n     Test Step 5: Set port transmission mode to burst;\n     Test Step 6: Transmit all traffic and wait for a period;\n     Test Step 7: Stop all traffic and check StreamBlockStats counters;\n\nCriteria: Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv1']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv1_report(Stream=stream, Level=0, Type=99, Unused='255', Checksum='ffff',\n                              GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.GroupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv1_report:修改测试仪表流量模板中IGMPv1 Report报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (DarYu or provided argument).\",\n  \"Subtask 2\": \"Reserve two ports at given locations (default: '//10.0.11.191/1/3' and '//10.0.11.191/1/4').\",\n  \"Subtask 3\": \"Create a stream on the first reserved port with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv4, and IGMPv1.\",\n  \"Subtask 5\": \"Modify IGMPv1 report header fields: Type=99, Unused=255, Checksum='ffff', GroupAddress='10.1.1.1'.\",\n  \"Subtask 6\": \"On second reserved port, create PDU pattern for IGMPv1 type field matching value 99.\",\n  \"Subtask 7\": \"On second reserved port, create PDU pattern for IGMPv1 Checksum field matching value 'ffff'.\",\n  \"Subtask 8\": \"On second reserved port, create PDU pattern for IGMPv1 GroupAddress field matching value '10.1.1.1'.\",\n  \"Subtask 9\": \"Set capture filter on second port using logical AND of the three PDU patterns.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 11\": \"Configure first port's transmit mode as burst with burst count=100.\",\n  \"Subtask 12\": \"Save test configuration to file in xcfg subdirectory using script's base name.\",\n  \"Subtask 13\": \"Start packet capture on second port.\",\n  \"Subtask 14\": \"Begin stream transmission on first port.\",\n  \"Subtask 15\": \"Wait for 10 seconds during traffic transmission and capture.\",\n  \"Subtask 16\": \"Stop stream transmission.\",\n  \"Subtask 17\": \"Stop packet capture.\",\n  \"Subtask 18\": \"Download captured packets from second port to pcap directory.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats for the stream to get TxStreamFrames and RxStreamFrames.\",\n  \"Subtask 20\": \"Verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 21\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Purpose: Verify the test instrument correctly counts IGMPv1 report packets.\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n     Test Step 2: Modify the IGMPv1 report header content of traffic StreamTemplate_1;\n     Test Step 3: Configure packet capture filtering;\n     Test Step 4: Subscribe to StreamBlockStats counters;\n     Test Step 5: Set port transmission mode to burst;\n     Test Step 6: Transmit all traffic and wait for a period;\n     Test Step 7: Stop all traffic and check StreamBlockStats counters;\n\nCriteria: Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv1']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv1_report(Stream=stream, Level=0, Type=99, Unused='255', Checksum='ffff',\n                              GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.GroupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv1_report:修改测试仪表流量模板中IGMPv1 Report报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2TPv3ControlOverIp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Control Over Ip头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify the accuracy of traffic statistics generated by the test instrument  \n\nStep:  \nStep 1: Reserve two loopback ports: Port_1 and Port_2  \nStep 2: Create a traffic stream StreamTemplate_1 on port Port_1  \nStep 3: Modify the L2TPv3 Control Over IP header content in StreamTemplate_1  \nStep 4: Subscribe to StreamBlockStats  \nStep 5: Transmit all traffic and wait for a period  \nStep 6: Stop all traffic and check StreamBlockStats information  \n\nCriteria:  \nExpected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal  \n\nCreated by: Tester-003  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3ControlOverIp'])\n\n    # 修改l2tpv3 control over ip头部\n    edit_header_l2tpv3_control_over_ip(Stream=stream, Level=0,\n                                       SessionId=1,\n                                       Type=1,\n                                       UseLength=1,\n                                       ExcludeSessionLength=1,\n                                       )\n\n    # 修改l2tpv3 control over ip头部，添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='circuitError',\n                                      AlignmentOverruns=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='routeId',\n                                      RouteId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='assignedConnection',\n                                      ConnectionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='localSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='remoteSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='assignedCookie',\n                                      Cookie4Byte='00000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='pwType',\n                                      PwType=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='l2SpecificSub',\n                                      L2SpecificSublayer=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='dataSequencing',\n                                      DataSequencing=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='txConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='rxConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='circuitStatus',\n                                      Nbit=1,\n                                      Abit=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3ControlOverIp'],\n                                             FieldName='l2tpv3ControlOverIp_1.type',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with the specified product type (e.g., DarYu).\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using their network locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with a fixed frame length of 512 bytes.\",\n  \"Subtask 4\": \"Configure the traffic stream to include Ethernet II, IPv4, and L2TPv3 Control over IP headers.\",\n  \"Subtask 5\": \"Modify the base L2TPv3 Control over IP header parameters: SessionId=1, Type=1, UseLength=1, ExcludeSessionLength=1.\",\n  \"Subtask 6\": \"Add 18 distinct L2TPv3 Control over IP header options to the stream with specified parameters (e.g., Types, AttributeValue, SessionId).\",\n  \"Subtask 7\": \"Configure packet capture on Port_2 to filter L2TPv3 Control over IP packets with type=1.\",\n  \"Subtask 8\": \"Subscribe to PortStats and StreamBlockStats statistical views.\",\n  \"Subtask 9\": \"Configure Port_1 to transmit traffic in burst mode with a burst count of 100 packets.\",\n  \"Subtask 10\": \"Save the current test configuration to a file.\",\n  \"Subtask 11\": \"Start packet capture on Port_2.\",\n  \"Subtask 12\": \"Initiate traffic transmission from Port_1.\",\n  \"Subtask 13\": \"Wait for traffic transmission to complete.\",\n  \"Subtask 14\": \"Stop packet capture on Port_2.\",\n  \"Subtask 15\": \"Wait 3 seconds to ensure statistics stabilization.\",\n  \"Subtask 16\": \"Download captured packets from Port_2 and verify captured count equals transmitted burst count (100).\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats for the traffic stream.\",\n  \"Subtask 18\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both equal the burst count (100).\",\n  \"Subtask 19\": \"Retrieve port statistics for Port_2 to check Rx filter counts.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify the accuracy of traffic statistics generated by the test instrument  \n\nStep:  \nStep 1: Reserve two loopback ports: Port_1 and Port_2  \nStep 2: Create a traffic stream StreamTemplate_1 on port Port_1  \nStep 3: Modify the L2TPv3 Control Over IP header content in StreamTemplate_1  \nStep 4: Subscribe to StreamBlockStats  \nStep 5: Transmit all traffic and wait for a period  \nStep 6: Stop all traffic and check StreamBlockStats information  \n\nCriteria:  \nExpected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal  \n\nCreated by: Tester-003  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3ControlOverIp'])\n\n    # 修改l2tpv3 control over ip头部\n    edit_header_l2tpv3_control_over_ip(Stream=stream, Level=0,\n                                       SessionId=1,\n                                       Type=1,\n                                       UseLength=1,\n                                       ExcludeSessionLength=1,\n                                       )\n\n    # 修改l2tpv3 control over ip头部，添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='circuitError',\n                                      AlignmentOverruns=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='routeId',\n                                      RouteId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='assignedConnection',\n                                      ConnectionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='localSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='remoteSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='assignedCookie',\n                                      Cookie4Byte='00000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='pwType',\n                                      PwType=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='l2SpecificSub',\n                                      L2SpecificSublayer=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='dataSequencing',\n                                      DataSequencing=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='txConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='rxConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='circuitStatus',\n                                      Nbit=1,\n                                      Abit=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3ControlOverIp'],\n                                             FieldName='l2tpv3ControlOverIp_1.type',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/IPv4.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv4报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv4头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify the test instrument correctly counts transmitted IPv4 packets\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Step 2: Modify the IPv4 header content of traffic StreamTemplate_1;\n      Step 3: Configure filtered packet capture;\n      Step 4: Subscribe to StreamBlockStats;\n      Step 5: Set port transmission mode to burst;\n      Step 6: Transmit all traffic and wait for a period;\n      Step 7: Stop all traffic and check StreamBlockStats information;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packet counts for StreamTemplate_1 are equal\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port1, port2 = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=port1, FixedLength=256)\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n    # 修改ipv4头部\n    HeaderOption = ['Security', 'RouterAlert']\n    attribute_dict = edit_header_ipv4(Stream=stream, Level=0, TTL=200, Source='10.1.1.2', Destination='20.1.1.2',\n                                      Flags=111, HeaderOption=HeaderOption)\n    # ipv4头部Source字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=10, Step=2)\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 修改ipv4头部，添加一个Security\n    attribute_dict_security = edit_header_ipv4_option(Stream=stream, Index=0, Option='Security', Security=1)\n    # ipv4头部Security的Security字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_security['Security'],\n                  Type='List', List=[1, 11, 111])\n    # ipv4头部RouterAlert的Length字段添加Random跳变\n    attribute_dict_RouterAlert = edit_header_ipv4_option(Stream=stream, Index=1, Option='RouterAlert', Length=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_RouterAlert['Length'],\n                  Type='Random', Range=15)\n    # 修改ipv4头部，添加一个LooseSourceRoute节点\n    attribute_dict_loose = edit_header_ipv4_option(Stream=stream, Index=2, Option='LooseSourceRoute',\n                                                   AddressList=['1.1.1.1', '2.2.2.2'])\n    # 修改其中一个地址的跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_loose['AddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n    # 修改ipv4头部，添加一个TimeStamp节点\n    timestamp = edit_header_ipv4_option(Stream=stream, Index=3, Option='TimeStamp',\n                                        TimeStampSet=['10203040', '50607080'])\n    # 修改其中一个地址的跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=timestamp['TimeStampSet: 50607080'],\n                  Type='Increment', Count=10)\n    # 使用Level和Attribute参数添加pdu_pattern\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=port2, HeaderTypes=['EthernetII', 'IPv4'],\n                                               Level=1,\n                                               Attribute=attribute_dict_security['Security'],\n                                               Value=1, MaxValue=1)\n    # 使用FieldName参数添加pdu_pattern\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=port2, HeaderTypes=['EthernetII', 'IPv4'],\n                                               FieldName='ipv4_1.ipv4HeaderOption.ipv4HeaderOptionList_1.optionRouterAlert.length',\n                                               Value=10, MaxValue=10)\n\n    edit_capture_filter(Port=port2, Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=port1, TransmitMode='BURST', BurstCount=100)\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    PackagesPath = download_packages(Port=port2, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    Result = get_streamblock_statistic(Stream=stream)\n    TxStreamFrames = Result['TxStreamFrames']\n    RxStreamFrames = Result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    release_port(locations)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "edit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (default: 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports at given locations as Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers to include EthernetII and IPv4 protocol layers.\",\n  \"Subtask 5\": \"Edit IPv4 header (level 0) to set TTL=200, Source='10.1.1.2', Destination='20.1.1.2', Flags=111, and HeaderOptions=['Security','RouterAlert'].\",\n  \"Subtask 6\": \"Add increment modifier to IPv4 Source field (count=10, step=2).\",\n  \"Subtask 7\": \"Edit IPv4 Security option (index 0) to set Security=1.\",\n  \"Subtask 8\": \"Add list modifier to Security option field with values [1,11,111].\",\n  \"Subtask 9\": \"Edit IPv4 RouterAlert option (index 1) to set Length=10.\",\n  \"Subtask 10\": \"Add random modifier to RouterAlert Length field with range=15.\",\n  \"Subtask 11\": \"Edit IPv4 to add LooseSourceRoute option (index 2) with AddressList=['1.1.1.1','2.2.2.2'].\",\n  \"Subtask 12\": \"Add increment modifier to '2.2.2.2' address in LooseSourceRoute option.\",\n  \"Subtask 13\": \"Edit IPv4 to add TimeStamp option (index 3) with TimeStampSet=['10203040','50607080'].\",\n  \"Subtask 14\": \"Add increment modifier to '50607080' timestamp in TimeStamp option.\",\n  \"Subtask 15\": \"Create first PDU pattern on Port_2 matching IPv4 Security option value=1.\",\n  \"Subtask 16\": \"Create second PDU pattern on Port_2 matching IPv4 RouterAlert Length=10 using field name.\",\n  \"Subtask 17\": \"Set capture filter on Port_2 to logical AND of both PDU patterns.\",\n  \"Subtask 18\": \"Subscribe to StreamBlockStats view.\",\n  \"Subtask 19\": \"Configure Port_1 transmission mode as burst with burst count=100.\",\n  \"Subtask 20\": \"Start packet capture on Port_2.\",\n  \"Subtask 21\": \"Transmit traffic stream from Port_1.\",\n  \"Subtask 22\": \"Wait 10 seconds during transmission.\",\n  \"Subtask 23\": \"Stop traffic transmission.\",\n  \"Subtask 24\": \"Stop packet capture.\",\n  \"Subtask 25\": \"Download captured packets from Port_2 to local directory.\",\n  \"Subtask 26\": \"Retrieve StreamBlockStats for the traffic stream.\",\n  \"Subtask 27\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 28\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify the test instrument correctly counts transmitted IPv4 packets\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Step 2: Modify the IPv4 header content of traffic StreamTemplate_1;\n      Step 3: Configure filtered packet capture;\n      Step 4: Subscribe to StreamBlockStats;\n      Step 5: Set port transmission mode to burst;\n      Step 6: Transmit all traffic and wait for a period;\n      Step 7: Stop all traffic and check StreamBlockStats information;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packet counts for StreamTemplate_1 are equal\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port1, port2 = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=port1, FixedLength=256)\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n    # 修改ipv4头部\n    HeaderOption = ['Security', 'RouterAlert']\n    attribute_dict = edit_header_ipv4(Stream=stream, Level=0, TTL=200, Source='10.1.1.2', Destination='20.1.1.2',\n                                      Flags=111, HeaderOption=HeaderOption)\n    # ipv4头部Source字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=10, Step=2)\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 修改ipv4头部，添加一个Security\n    attribute_dict_security = edit_header_ipv4_option(Stream=stream, Index=0, Option='Security', Security=1)\n    # ipv4头部Security的Security字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_security['Security'],\n                  Type='List', List=[1, 11, 111])\n    # ipv4头部RouterAlert的Length字段添加Random跳变\n    attribute_dict_RouterAlert = edit_header_ipv4_option(Stream=stream, Index=1, Option='RouterAlert', Length=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_RouterAlert['Length'],\n                  Type='Random', Range=15)\n    # 修改ipv4头部，添加一个LooseSourceRoute节点\n    attribute_dict_loose = edit_header_ipv4_option(Stream=stream, Index=2, Option='LooseSourceRoute',\n                                                   AddressList=['1.1.1.1', '2.2.2.2'])\n    # 修改其中一个地址的跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_loose['AddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n    # 修改ipv4头部，添加一个TimeStamp节点\n    timestamp = edit_header_ipv4_option(Stream=stream, Index=3, Option='TimeStamp',\n                                        TimeStampSet=['10203040', '50607080'])\n    # 修改其中一个地址的跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=timestamp['TimeStampSet: 50607080'],\n                  Type='Increment', Count=10)\n    # 使用Level和Attribute参数添加pdu_pattern\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=port2, HeaderTypes=['EthernetII', 'IPv4'],\n                                               Level=1,\n                                               Attribute=attribute_dict_security['Security'],\n                                               Value=1, MaxValue=1)\n    # 使用FieldName参数添加pdu_pattern\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=port2, HeaderTypes=['EthernetII', 'IPv4'],\n                                               FieldName='ipv4_1.ipv4HeaderOption.ipv4HeaderOptionList_1.optionRouterAlert.length',\n                                               Value=10, MaxValue=10)\n\n    edit_capture_filter(Port=port2, Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=port1, TransmitMode='BURST', BurstCount=100)\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    PackagesPath = download_packages(Port=port2, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    Result = get_streamblock_statistic(Stream=stream)\n    TxStreamFrames = Result['TxStreamFrames']\n    RxStreamFrames = Result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    release_port(locations)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nedit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Sr.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Sr头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify the accuracy of IPv6 packet statistics transmitted by the test instrument  \n\nStep:  \nTest Step 1: Reserve two loopback ports, Port_1 and Port_2.  \nTest Step 2: Modify the IPv6 SR header content in traffic StreamTemplate_1.  \nTest Step 3: Configure packet filtering and capture.  \nTest Step 4: Subscribe to StreamBlockStats statistics.  \nTest Step 5: Set port transmission mode to burst packets.  \nTest Step 6: Transmit all traffic and wait for a period.  \nTest Step 7: Stop all traffic and inspect StreamBlockStats statistics.  \n\nCriteria:  \nExpected Result 1: Packets sent and received for StreamTemplate_1 in Step 6 are equal.  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0])\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6srheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_sr(Stream=stream, SRHeaderFlag='10101010',\n                               SRHOption=['sRSegment', 'sRSegment'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6srheader', Attribute=attr['SRHeaderFlag'],\n                  Type='Increment', Count=10, Step=2)\n    attr_segment = edit_header_ipv6_sr_option(Stream=stream, Option='sRSegment', Index=1,\n                                              Segment='2033::3')\n    edit_modifier(Stream=stream, Attribute=attr_segment['Segment'],\n                  Type='Increment', Count=10, HeaderType='ipv6srheader')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using the init_tester API to prepare for testing.\",\n  \"Subtask 2\": \"Reserve two loopback ports using reserve_port API with specified locations.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port using add_stream API.\",\n  \"Subtask 4\": \"Edit the stream parameters to set frame length type to 'AUTO' using edit_stream API.\",\n  \"Subtask 5\": \"Create stream headers (EthernetII, IPv6, ipv6srheader) using create_stream_header API.\",\n  \"Subtask 6\": \"Modify IPv6 SR header content by setting SRHeaderFlag and SRHOption using edit_header_ipv6_sr API.\",\n  \"Subtask 7\": \"Apply increment modifier to SRHeaderFlag attribute with count=10 and step=2 using edit_modifier API.\",\n  \"Subtask 8\": \"Edit IPv6 SR header option for sRSegment at index 1 using edit_header_ipv6_sr_option API.\",\n  \"Subtask 9\": \"Apply increment modifier to Segment attribute with count=10 and step=2 using edit_modifier API.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 11\": \"Configure port transmission mode to burst with burst count=100 using edit_port_load_profile API.\",\n  \"Subtask 12\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 13\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 14\": \"Wait for 10 seconds to allow traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats using get_streamblock_statistic API.\",\n  \"Subtask 17\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 18\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify the accuracy of IPv6 packet statistics transmitted by the test instrument  \n\nStep:  \nTest Step 1: Reserve two loopback ports, Port_1 and Port_2.  \nTest Step 2: Modify the IPv6 SR header content in traffic StreamTemplate_1.  \nTest Step 3: Configure packet filtering and capture.  \nTest Step 4: Subscribe to StreamBlockStats statistics.  \nTest Step 5: Set port transmission mode to burst packets.  \nTest Step 6: Transmit all traffic and wait for a period.  \nTest Step 7: Stop all traffic and inspect StreamBlockStats statistics.  \n\nCriteria:  \nExpected Result 1: Packets sent and received for StreamTemplate_1 in Step 6 are equal.  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0])\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6srheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_sr(Stream=stream, SRHeaderFlag='10101010',\n                               SRHOption=['sRSegment', 'sRSegment'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6srheader', Attribute=attr['SRHeaderFlag'],\n                  Type='Increment', Count=10, Step=2)\n    attr_segment = edit_header_ipv6_sr_option(Stream=stream, Option='sRSegment', Index=1,\n                                              Segment='2033::3')\n    edit_modifier(Stream=stream, Attribute=attr_segment['Segment'],\n                  Type='Increment', Count=10, HeaderType='ipv6srheader')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4EchoReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的icmpv4 echo reply头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify correct flow transmission statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n                   Test Step 3: Modify icmpv4 echo reply header content in stream StreamTemplate_1;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Transmit all traffic and wait for a duration;\n                   Test Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, traffic stream StreamTemplate_1 shows equal sent/received packets;\n\nCreated by   \t:   Tester-001\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'Icmpv4EchoReply'])\n\n    # 修改icmpv4 echo reply头部\n    attr = edit_header_icmp_echo_reply(Stream=stream, Level=0,\n                                       Type=2,\n                                       Code=4,\n                                       Identifier=65535,\n                                       SequenceNumber=65535)\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=2, Attribute=attr['SequenceNumber'],\n                  Start=100,\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'Icmpv4EchoReply'],\n                                             FieldName='Icmpv4EchoReply_1.code',\n                                             Value=4,\n                                             MaxValue=4,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_echo_reply:修改测试仪表流量模板中Icmp Echo Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1.\",\n  \"Subtask 4\": \"Build stream headers for the traffic stream with EthernetII, IPv4, and Icmpv4EchoReply layers.\",\n  \"Subtask 5\": \"Modify the ICMPv4 Echo Reply header in the stream to set Type=2, Code=4, Identifier=65535, and SequenceNumber=65535.\",\n  \"Subtask 6\": \"Apply an increment modifier to the SequenceNumber field starting at 100 with step 1 for 5 packets.\",\n  \"Subtask 7\": \"Create a PDU pattern on Port_2 to capture ICMPv4 Echo Reply packets with code=4.\",\n  \"Subtask 8\": \"Set capture filter on Port_2 using the created PDU pattern.\",\n  \"Subtask 9\": \"Subscribe to PortStats and StreamBlockStats statistics views.\",\n  \"Subtask 10\": \"Configure Port_1's load profile for burst transmission mode with burst count=100.\",\n  \"Subtask 11\": \"Save the current test configuration to a file.\",\n  \"Subtask 12\": \"Start packet capture on Port_2.\",\n  \"Subtask 13\": \"Begin traffic transmission from Port_1.\",\n  \"Subtask 14\": \"Wait until traffic transmission completes.\",\n  \"Subtask 15\": \"Stop packet capture on Port_2.\",\n  \"Subtask 16\": \"Wait 3 seconds to ensure statistics stabilization.\",\n  \"Subtask 17\": \"Download captured packets from Port_2 and retrieve capture information.\",\n  \"Subtask 18\": \"Verify captured packet count equals downloaded packet count and matches burst count (100).\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats for the traffic stream.\",\n  \"Subtask 20\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and match burst count (100).\",\n  \"Subtask 21\": \"Retrieve port statistics for filter counts on Port_2.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify correct flow transmission statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n                   Test Step 3: Modify icmpv4 echo reply header content in stream StreamTemplate_1;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Transmit all traffic and wait for a duration;\n                   Test Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, traffic stream StreamTemplate_1 shows equal sent/received packets;\n\nCreated by   \t:   Tester-001\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'Icmpv4EchoReply'])\n\n    # 修改icmpv4 echo reply头部\n    attr = edit_header_icmp_echo_reply(Stream=stream, Level=0,\n                                       Type=2,\n                                       Code=4,\n                                       Identifier=65535,\n                                       SequenceNumber=65535)\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=2, Attribute=attr['SequenceNumber'],\n                  Start=100,\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'Icmpv4EchoReply'],\n                                             FieldName='Icmpv4EchoReply_1.code',\n                                             Value=4,\n                                             MaxValue=4,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_echo_reply:修改测试仪表流量模板中Icmp Echo Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4TimeStampReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 time stamp reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 time stamp reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Verify the test instrument accurately counts ICMPv4 Timestamp Reply packets  \n\nStep:  \n1. Reserve two loopback ports: Port_1 and Port_2  \n2. Modify the ICMPv4 Timestamp Reply header content in traffic stream StreamTemplate_1  \n3. Configure packet capture filtering  \n4. Subscribe to StreamBlockStats counters  \n5. Set port transmission mode to burst  \n6. Transmit all traffic and wait  \n7. Stop all traffic and check StreamBlockStats counters  \n\nCriteria:  \n1. During Step 6, StreamTemplate_1's transmitted/received packet counts must match  \n\nCreated by: Tester-004  \nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimestampReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 TimestampReply头部\n    edit_header_icmp_time_stamp_reply(Stream=stream, Level=0,\n                                      Identifier='100', SequenceNumber='200', OriginateTimestamp='111',\n                                      ReceiveTimestamp='222', TransmitTimestamp='333')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampReply_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampReply_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_time_stamp_reply:修改测试仪表流量模板中Icmp Time Stamp Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations (e.g., '//10.0.11.191/1/3' and '//10.0.11.191/1/4') using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers to include EthernetII, IPv4, and TimestampReply layers using create_stream_header API.\",\n  \"Subtask 5\": \"Modify ICMPv4 Timestamp Reply header fields: set Identifier=100, SequenceNumber=200, OriginateTimestamp=111, ReceiveTimestamp=222, TransmitTimestamp=333 using edit_header_icmp_time_stamp_reply API.\",\n  \"Subtask 6\": \"Create two PDU patterns on the second port for capture filtering: one matching Identifier=100 and another matching SequenceNumber=200 using create_capture_pdu_pattern API.\",\n  \"Subtask 7\": \"Configure capture filter on the second port using logical AND expression combining both PDU patterns via edit_capture_filter API.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats counter view using subscribe_result API.\",\n  \"Subtask 9\": \"Set transmission mode of first port to BURST with burst count=100 using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 11\": \"Start packet capture on the second port using start_capture API.\",\n  \"Subtask 12\": \"Transmit traffic stream from the first port using start_stream API.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 14\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 15\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 16\": \"Download captured packets from the second port to specified directory using download_packages API.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 18\": \"Verify transmitted packet count (TxStreamFrames) equals received packet count (RxStreamFrames).\",\n  \"Subtask 19\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Verify the test instrument accurately counts ICMPv4 Timestamp Reply packets  \n\nStep:  \n1. Reserve two loopback ports: Port_1 and Port_2  \n2. Modify the ICMPv4 Timestamp Reply header content in traffic stream StreamTemplate_1  \n3. Configure packet capture filtering  \n4. Subscribe to StreamBlockStats counters  \n5. Set port transmission mode to burst  \n6. Transmit all traffic and wait  \n7. Stop all traffic and check StreamBlockStats counters  \n\nCriteria:  \n1. During Step 6, StreamTemplate_1's transmitted/received packet counts must match  \n\nCreated by: Tester-004  \nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimestampReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 TimestampReply头部\n    edit_header_icmp_time_stamp_reply(Stream=stream, Level=0,\n                                      Identifier='100', SequenceNumber='200', OriginateTimestamp='111',\n                                      ReceiveTimestamp='222', TransmitTimestamp='333')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampReply_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampReply_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_time_stamp_reply:修改测试仪表流量模板中Icmp Time Stamp Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahItag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify correct traffic statistics from the test instrument\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\nTest Step 3: Modify the 802.1ah header contents of stream StreamTemplate_1;\nTest Step 4: Subscribe to StreamBlockStats;\nTest Step 5: Transmit all traffic and wait for a period;\nTest Step 6: Stop all traffic and check StreamBlockStats information;\n\nCriteria: Expected Result 1: In Step 6, received packets equal sent packets for stream StreamTemplate_1;\n\nCreated by: Tester-002\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['itag', 'ipv4'])\n\n    # 修改itag头部\n    attr = edit_header_8021ah_iTag(Stream=stream, Level=0,\n                                   EncapCusDstAddr='22:00:00:00:00:00',\n                                   SourceMacAdd='22:11:11:11:11:11')\n    edit_modifier(Stream=stream, Attribute=attr['EncapCusDstAddr'],\n                  Type='Increment', Count=10, HeaderType='itag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (default 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two loopback ports at provided locations (default '//10.0.11.191/1/5' and '//10.0.11.191/1/6') using reserve_port API, assigning them as Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers to include 'itag' and 'ipv4' using create_stream_header API.\",\n  \"Subtask 5\": \"Modify the 802.1ah (iTag) header at level 0 by setting EncapCusDstAddr to '22:00:00:00:00:00' and SourceMacAdd to '22:11:11:11:11:11' using edit_header_8021ah_iTag API.\",\n  \"Subtask 6\": \"Apply increment modifier to EncapCusDstAddr field with count=10 using edit_modifier API.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats and PortStats using subscribe_result API.\",\n  \"Subtask 8\": \"Configure port load profile on Port_UP with transmit_mode='BURST' and burst_count=100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Save current configuration to file using save_case API.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete using wait_stream_state API, then delay 3 seconds for statistics stabilization.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats using get_streamblock_statistic API and verify TxStreamFrames equals RxStreamFrames equals 100.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify correct traffic statistics from the test instrument\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\nTest Step 3: Modify the 802.1ah header contents of stream StreamTemplate_1;\nTest Step 4: Subscribe to StreamBlockStats;\nTest Step 5: Transmit all traffic and wait for a period;\nTest Step 6: Stop all traffic and check StreamBlockStats information;\n\nCriteria: Expected Result 1: In Step 6, received packets equal sent packets for stream StreamTemplate_1;\n\nCreated by: Tester-002\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['itag', 'ipv4'])\n\n    # 修改itag头部\n    attr = edit_header_8021ah_iTag(Stream=stream, Level=0,\n                                   EncapCusDstAddr='22:00:00:00:00:00',\n                                   SourceMacAdd='22:11:11:11:11:11')\n    edit_modifier(Stream=stream, Attribute=attr['EncapCusDstAddr'],\n                  Type='Increment', Count=10, HeaderType='itag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahEncapsulatedCustomerEthernetII.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Purpose: Verify the test instrument's traffic statistics accuracy\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the 802.1ah header content of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a duration;\n      Step 6: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['encapEthernetII', 'ipv4'])\n\n    # 修改Encapsulated Customer EthernetII头部\n    attr = edit_header_8021ah_EncapsulatedCustomerEthernetII(Stream=stream, Level=0,\n                                                           ServiceTag=True,\n                                                           CustomerTag=True\n                                                           )\n    attr_service = edit_header_8021ah_EncapsulatedCustomerEthernetII_serviceTag(Stream=stream,\n                                                                              Vid='101010101010')\n    attr_customer = edit_header_8021ah_EncapsulatedCustomerEthernetII_customerTag(Stream=stream,\n                                                                                Id='110011001100')\n    edit_modifier(Stream=stream, Attribute=attr_service['Vid'],\n                  Type='Increment', Count=10, HeaderType='encapEthernetII')\n    edit_modifier(Stream=stream, Attribute=attr_customer['Id'],\n                  Type='Increment', Count=10, HeaderType='encapEthernetII')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) for traffic testing.\",\n  \"Subtask 3\": \"Create a traffic stream (StreamTemplate_1) on port Port_1.\",\n  \"Subtask 4\": \"Configure EthernetII and IPv4 headers for StreamTemplate_1.\",\n  \"Subtask 5\": \"Modify 802.1ah Encapsulated Customer EthernetII header in StreamTemplate_1 by enabling Service Tag and Customer Tag.\",\n  \"Subtask 6\": \"Set specific values for Service Tag VID (101010101010) and Customer Tag ID (110011001100) in StreamTemplate_1.\",\n  \"Subtask 7\": \"Apply increment modifiers to Service Tag VID and Customer Tag ID fields with count=10.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics collection.\",\n  \"Subtask 9\": \"Configure port Port_1 transmit mode as BURST with burst count=100.\",\n  \"Subtask 10\": \"Save current test configuration to file.\",\n  \"Subtask 11\": \"Start traffic transmission for all streams.\",\n  \"Subtask 12\": \"Wait until traffic transmission completes and streams stop.\",\n  \"Subtask 13\": \"Wait 3 seconds to ensure accurate statistics collection.\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats results for StreamTemplate_1 and record TxStreamFrames/RxStreamFrames values.\",\n  \"Subtask 15\": \"Verify TxStreamFrames equals RxStreamFrames and both equal configured burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Purpose: Verify the test instrument's traffic statistics accuracy\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the 802.1ah header content of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a duration;\n      Step 6: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['encapEthernetII', 'ipv4'])\n\n    # 修改Encapsulated Customer EthernetII头部\n    attr = edit_header_8021ah_EncapsulatedCustomerEthernetII(Stream=stream, Level=0,\n                                                           ServiceTag=True,\n                                                           CustomerTag=True\n                                                           )\n    attr_service = edit_header_8021ah_EncapsulatedCustomerEthernetII_serviceTag(Stream=stream,\n                                                                              Vid='101010101010')\n    attr_customer = edit_header_8021ah_EncapsulatedCustomerEthernetII_customerTag(Stream=stream,\n                                                                                Id='110011001100')\n    edit_modifier(Stream=stream, Attribute=attr_service['Vid'],\n                  Type='Increment', Count=10, HeaderType='encapEthernetII')\n    edit_modifier(Stream=stream, Attribute=attr_customer['Id'],\n                  Type='Increment', Count=10, HeaderType='encapEthernetII')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/DHCPv4Server.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv4 Server头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of traffic transmission statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Test Step 3: Modify the DHCPv4 Server header content of traffic stream StreamTemplate_1;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Transmit all traffic and wait for a period;\n                   Test Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-003\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Server'])\n\n    # 修改dhcpv4 server头部\n    edit_header_dhcpv4_server(Stream=stream, Level=0,\n                              MessageType=1,\n                              HardwareType=1,\n                              Hops=1,\n                              Bootpflags='0001',\n                              )\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='serverId',\n                                     ReqAddr='1.1.1.1',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ReqAddr'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='message',\n                                     Value='01',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='leaseTime',\n                                     LeaseTime=1,\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['LeaseTime'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='endOfOptions',\n                                     Type='01',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Type'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='messageSize',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='clientIdHW',\n                                     IdType='01',\n                                     ClientHWA='00:00:00:00:00:01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ClientHWA'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='clientIdNoneHW',\n                                     IdType='01',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='hostName',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='paramReqList',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reqAddr',\n                                     ReqAddr='1.1.1.1',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ReqAddr'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='optionOverload',\n                                     Overload=1,\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Overload='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Server'],\n                                             FieldName='dhcpv4Server_1.hops',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports: Port_1 and Port_2.\",\n  \"Subtask 2\": \"Create a traffic stream named StreamTemplate_1 on Port_1 with fixed frame length of 512 bytes.\",\n  \"Subtask 3\": \"Create stream header for StreamTemplate_1 with layers: EthernetII, IPv4, UDP, and dhcpv4Server.\",\n  \"Subtask 4\": \"Edit main dhcpv4Server header fields for StreamTemplate_1: set MessageType=1, HardwareType=1, Hops=1, Bootpflags='0001'.\",\n  \"Subtask 5\": \"Add and configure DHCPv4 options in StreamTemplate_1 header (serverId, message, leaseTime, endOfOptions, etc.) with specific parameters.\",\n  \"Subtask 6\": \"Apply increment modifiers to selected DHCPv4 option fields in StreamTemplate_1 to generate packet variations.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 8\": \"Configure Port_1 transmission mode as burst with specified burst count (e.g., 100 packets).\",\n  \"Subtask 9\": \"Start packet capture on Port_2 with PDU filter matching dhcpv4Server.hops=1.\",\n  \"Subtask 10\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete and stream state to stop.\",\n  \"Subtask 12\": \"Stop packet capture on Port_2 after traffic stops.\",\n  \"Subtask 13\": \"Wait 3 seconds for statistics stabilization after traffic stops.\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats for StreamTemplate_1 and capture TxStreamFrames/RxStreamFrames values.\",\n  \"Subtask 15\": \"Verify TxStreamFrames equals RxStreamFrames equals configured burst count.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of traffic transmission statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Test Step 3: Modify the DHCPv4 Server header content of traffic stream StreamTemplate_1;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Transmit all traffic and wait for a period;\n                   Test Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-003\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Server'])\n\n    # 修改dhcpv4 server头部\n    edit_header_dhcpv4_server(Stream=stream, Level=0,\n                              MessageType=1,\n                              HardwareType=1,\n                              Hops=1,\n                              Bootpflags='0001',\n                              )\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='serverId',\n                                     ReqAddr='1.1.1.1',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ReqAddr'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='message',\n                                     Value='01',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='leaseTime',\n                                     LeaseTime=1,\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['LeaseTime'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='endOfOptions',\n                                     Type='01',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Type'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='messageSize',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='clientIdHW',\n                                     IdType='01',\n                                     ClientHWA='00:00:00:00:00:01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ClientHWA'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='clientIdNoneHW',\n                                     IdType='01',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='hostName',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='paramReqList',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reqAddr',\n                                     ReqAddr='1.1.1.1',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ReqAddr'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='optionOverload',\n                                     Overload=1,\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Overload='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Server'],\n                                             FieldName='dhcpv4Server_1.hops',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6DestinationUnreachable.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 destination unreachable报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 destination unreachable头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify the test instrument correctly counts transmitted ICMPv6 Destination Unreachable packets\n\nStep: \nStep 1: Reserve two loopback ports Port_1 and Port_2;\nStep 2: Modify ICMPv6 Destination Unreachable header content in traffic StreamTemplate_1;;\nStep 3: Configure filtered packet capture;;\nStep 4: Subscribe to StreamBlockStats statistics;;\nStep 5: Set port transmission mode to burst;;\nStep 6: Transmit all traffic and wait for a period;;\nStep 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: \nCriteria 1: During Step 6, transmitted and received packet counts for StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'destinationunreachable']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 destination unreachable头部\n    header = edit_header_icmpv6_destination_unreachable(Stream=stream, Level=0,\n                                                        Code='3', HeaderData='1020304050607080',\n                                                        FlowLabel='2',\n                                                        HopLimit='250', Source='2022::2',\n                                                        Destination='2020::2', Gateway='2022::1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='destinationunreachable', Attribute=header['HeaderData'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='destinationunreachable', Attribute=header['Source'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.code',\n                                               Value='3', MaxValue='3')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.headerData.ipv6Header.hopLimit',\n                                               Value='250',\n                                               MaxValue='250')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.headerData.ipv6Header.destination',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_destination_unreachable:修改测试仪表流量模板中Icmpv6 Destination Unreachable报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) at given locations.\",\n  \"Subtask 3\": \"Create a stream on Port_1 with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: Ethernet II, IPv6, and ICMPv6 Destination Unreachable.\",\n  \"Subtask 5\": \"Edit ICMPv6 Destination Unreachable header fields: code=3, header data='1020304050607080', flow label=2, hop limit=250, source='2022::2', destination='2020::2', gateway='2022::1'.\",\n  \"Subtask 6\": \"Apply increment modifier to ICMPv6 Destination Unreachable HeaderData field: type=Increment, count=10.\",\n  \"Subtask 7\": \"Apply increment modifier to ICMPv6 Destination Unreachable Source field: type=Increment, count=10.\",\n  \"Subtask 8\": \"Create capture PDU pattern on Port_2 for ICMPv6 code field: value=3, max value=3.\",\n  \"Subtask 9\": \"Create capture PDU pattern on Port_2 for IPv6 hop limit field: value=250, max value=250.\",\n  \"Subtask 10\": \"Create capture PDU pattern on Port_2 for IPv6 destination field: value='2020::2', max value='2020::2'.\",\n  \"Subtask 11\": \"Set capture filter on Port_2 using logical AND expression combining all PDU patterns.\",\n  \"Subtask 12\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 13\": \"Configure Port_1 transmission mode: burst mode with burst count=100.\",\n  \"Subtask 14\": \"Start packet capture on Port_2.\",\n  \"Subtask 15\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 16\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 17\": \"Stop traffic transmission from Port_1.\",\n  \"Subtask 18\": \"Stop packet capture on Port_2.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats results for the stream.\",\n  \"Subtask 20\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames).\",\n  \"Subtask 21\": \"Release both reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify the test instrument correctly counts transmitted ICMPv6 Destination Unreachable packets\n\nStep: \nStep 1: Reserve two loopback ports Port_1 and Port_2;\nStep 2: Modify ICMPv6 Destination Unreachable header content in traffic StreamTemplate_1;;\nStep 3: Configure filtered packet capture;;\nStep 4: Subscribe to StreamBlockStats statistics;;\nStep 5: Set port transmission mode to burst;;\nStep 6: Transmit all traffic and wait for a period;;\nStep 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: \nCriteria 1: During Step 6, transmitted and received packet counts for StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'destinationunreachable']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 destination unreachable头部\n    header = edit_header_icmpv6_destination_unreachable(Stream=stream, Level=0,\n                                                        Code='3', HeaderData='1020304050607080',\n                                                        FlowLabel='2',\n                                                        HopLimit='250', Source='2022::2',\n                                                        Destination='2020::2', Gateway='2022::1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='destinationunreachable', Attribute=header['HeaderData'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='destinationunreachable', Attribute=header['Source'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.code',\n                                               Value='3', MaxValue='3')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.headerData.ipv6Header.hopLimit',\n                                               Value='250',\n                                               MaxValue='250')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.headerData.ipv6Header.destination',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_destination_unreachable:修改测试仪表流量模板中Icmpv6 Destination Unreachable报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/DHCPv6Client.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv6 Client头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     :   Objective: Verify the test instrument's traffic transmission statistics accuracy\n\nStep          :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                  Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                  Step 3: Modify the DHCPv6 Client header content of stream StreamTemplate_1;\n                  Step 4: Subscribe to StreamBlockStats statistics;\n                  Step 5: Transmit all traffic and wait for a period;\n                  Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by    :   Tester-003\n\nBugs          :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Client'])\n\n    # 修改dhcpv6 client头部\n    header = edit_header_dhcpv6_client(Stream=stream, Level=0,\n                              MessageType=2,\n                              TransId=2,\n                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='clientIdOption',\n                                     Duid='01',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Duid'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='serverIdOption',\n                                     DuidType=2,\n                                     HardwareType=2,\n                                     LinkAddress='00:00:00:00:00:02',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['LinkAddress'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='ianaOption',\n                                     Iaid='00000003',\n                                     T1=3,\n                                     T2=3,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['T1'],\n                  Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_address(Stream=stream, Index=2,\n                                                Type=5, Length=5, Ipv6Address='2020::1',\n                                                PreferredLifetime=1, ValidLifetime=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=ia_option['Ipv6Address'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='requestOption',\n                                     Value='04',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='elapsedTimeOption',\n                                     ElapseTime=5,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['ElapseTime'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='serverUnicastOption',\n                                     ServerAddress='2022::1',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['ServerAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='statusCodeOption',\n                                     StatusCode=7,\n                                     StatusMsg='0000000007',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['StatusMsg'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='rapidCommitOption',\n                                     Length=8,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Length'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='interfaceIdOption',\n                                     InterfaceId='0000000009',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['InterfaceId'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reconfigureAcceptOption',\n                                     Type=10,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Type'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='iapdOption',\n                                     Iaid='00000011',\n                                     T1=11,\n                                     T2=11,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Iaid'],\n    #               Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_prefix(Stream=stream, Index=10,\n                                                            Type=5, Length=5, Ipv6Address='2020::1',\n                                                            PreferredLifetime=1, ValidLifetime=1, PrefixLength=128)\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=ia_option['Ipv6Address'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Value='12',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='13',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Client'],\n                                             FieldName='dhcpv6Client_1.messageType',\n                                             Value=2,\n                                             MaxValue=2,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using provided locations, assigning Port_1 as sending port and Port_2 as receiving port.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 512 bytes.\",\n  \"Subtask 4\": \"Configure stream headers to include EthernetII, IPv6, UDP, and DHCPv6 Client protocols.\",\n  \"Subtask 5\": \"Modify DHCPv6 Client header by setting base parameters (message type, transaction ID) and adding multiple options (clientIdOption, serverIdOption, etc.), applying increment modifiers to selected fields with count=10.\",\n  \"Subtask 6\": \"Configure Port_1 transmission mode to burst with burst count=100 packets.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics for performance monitoring.\",\n  \"Subtask 8\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 9\": \"Wait until traffic transmission completes and wait 3 additional seconds for statistics stabilization.\",\n  \"Subtask 10\": \"Retrieve StreamBlockStats for the stream and verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames), both matching burst count of 100.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     :   Objective: Verify the test instrument's traffic transmission statistics accuracy\n\nStep          :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                  Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                  Step 3: Modify the DHCPv6 Client header content of stream StreamTemplate_1;\n                  Step 4: Subscribe to StreamBlockStats statistics;\n                  Step 5: Transmit all traffic and wait for a period;\n                  Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by    :   Tester-003\n\nBugs          :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Client'])\n\n    # 修改dhcpv6 client头部\n    header = edit_header_dhcpv6_client(Stream=stream, Level=0,\n                              MessageType=2,\n                              TransId=2,\n                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='clientIdOption',\n                                     Duid='01',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Duid'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='serverIdOption',\n                                     DuidType=2,\n                                     HardwareType=2,\n                                     LinkAddress='00:00:00:00:00:02',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['LinkAddress'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='ianaOption',\n                                     Iaid='00000003',\n                                     T1=3,\n                                     T2=3,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['T1'],\n                  Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_address(Stream=stream, Index=2,\n                                                Type=5, Length=5, Ipv6Address='2020::1',\n                                                PreferredLifetime=1, ValidLifetime=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=ia_option['Ipv6Address'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='requestOption',\n                                     Value='04',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='elapsedTimeOption',\n                                     ElapseTime=5,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['ElapseTime'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='serverUnicastOption',\n                                     ServerAddress='2022::1',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['ServerAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='statusCodeOption',\n                                     StatusCode=7,\n                                     StatusMsg='0000000007',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['StatusMsg'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='rapidCommitOption',\n                                     Length=8,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Length'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='interfaceIdOption',\n                                     InterfaceId='0000000009',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['InterfaceId'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reconfigureAcceptOption',\n                                     Type=10,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Type'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='iapdOption',\n                                     Iaid='00000011',\n                                     T1=11,\n                                     T2=11,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Iaid'],\n    #               Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_prefix(Stream=stream, Index=10,\n                                                            Type=5, Length=5, Ipv6Address='2020::1',\n                                                            PreferredLifetime=1, ValidLifetime=1, PrefixLength=128)\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=ia_option['Ipv6Address'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Value='12',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='13',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Client'],\n                                             FieldName='dhcpv6Client_1.messageType',\n                                             Value=2,\n                                             MaxValue=2,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Bier.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Bier头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Verify the accuracy of test instrument traffic statistics  \n\nStep:  \n1. Reserve two loopback ports: Port_1, Port_2  \n2. Create traffic stream StreamTemplate_1 on Port_1  \n3. Modify the BIER header content of StreamTemplate_1  \n4. Subscribe to StreamBlockStats  \n5. Transmit all traffic and wait  \n6. Stop all traffic and check StreamBlockStats statistics  \n\nCriteria:  \nExpected Result 1: In step 6, transmitted and received packets for StreamTemplate_1 are equal  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['bier'])\n\n    # 修改Bier头部\n    attr = edit_header_bier(Stream=stream, Level=0,\n                            BiftId=10,\n                            BierbitString=1)\n    edit_modifier(Stream=stream, Attribute=attr['BiftId'],\n                  Type='Increment', Count=10, HeaderType='bier')\n\n    bit_string = edit_header_bier_bit_string(Stream=stream,\n                                             BitString='1' * 32)\n    edit_modifier(Stream=stream, Attribute=bit_string['BitString'],\n                  Type='Increment', Count=10, HeaderType='bier')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1.\",\n  \"Subtask 4\": \"Add a BIER header to the created traffic stream.\",\n  \"Subtask 5\": \"Modify the BIER header's BiftID field with increment modifier (start=10, step=10).\",\n  \"Subtask 6\": \"Modify the BIER header's BitString field with increment modifier (start=32 ones, step=10).\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 8\": \"Configure Port_1's load profile to burst mode with burst count set to 100 packets.\",\n  \"Subtask 9\": \"Save the current test configuration to a file.\",\n  \"Subtask 10\": \"Start traffic transmission on all streams.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete and enter stopped state.\",\n  \"Subtask 12\": \"Wait 3 seconds after traffic stops to ensure accurate statistics collection.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats results for the created traffic stream.\",\n  \"Subtask 14\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Verify the accuracy of test instrument traffic statistics  \n\nStep:  \n1. Reserve two loopback ports: Port_1, Port_2  \n2. Create traffic stream StreamTemplate_1 on Port_1  \n3. Modify the BIER header content of StreamTemplate_1  \n4. Subscribe to StreamBlockStats  \n5. Transmit all traffic and wait  \n6. Stop all traffic and check StreamBlockStats statistics  \n\nCriteria:  \nExpected Result 1: In step 6, transmitted and received packets for StreamTemplate_1 are equal  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['bier'])\n\n    # 修改Bier头部\n    attr = edit_header_bier(Stream=stream, Level=0,\n                            BiftId=10,\n                            BierbitString=1)\n    edit_modifier(Stream=stream, Attribute=attr['BiftId'],\n                  Type='Increment', Count=10, HeaderType='bier')\n\n    bit_string = edit_header_bier_bit_string(Stream=stream,\n                                             BitString='1' * 32)\n    edit_modifier(Stream=stream, Attribute=bit_string['BitString'],\n                  Type='Increment', Count=10, HeaderType='bier')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Eoam.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Eoam头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify that the test instrument's traffic transmission statistics are accurate\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the Eoam header content of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['CCM'])\n\n    # 修改Eoam头部\n    attr = edit_header_eoam(Stream=stream, Level=0,\n                            MDlevel=7,\n                            Tlvs=['SenderIDTLV', 'PortStatusTLV', 'InterfaceStatusTLV',\n                                  'OrgSpecTLV', 'EndTLV'])\n    edit_modifier(Stream=stream, Attribute=attr['MDlevel'],\n                  Type='Increment', Count=10, HeaderType='CCM')\n\n    sender_attr = edit_header_eoam_sender_id_tlv(Stream=stream,\n                                                 Type='FF',\n                                                 theChassisID='ChassisComponent',\n                                                 theManagementAddressDomain='MADtDU4')\n    edit_modifier(Stream=stream, Attribute=sender_attr['Type'],\n                  Type='Increment', Count=10, HeaderType='CCM')\n\n    chassis_attr = edit_header_eoam_sender_id_tlv_chassis_id(Stream=stream,\n                                                             Type='ChassisComponent',\n                                                             ChassisID='TEST')\n    management_attr = edit_header_eoam_sender_id_tlv_management_address_domain(Stream=stream,\n                                                                               Type='MADtDU4',\n                                                                               IPv4='1.1.1.1')\n    end_attr = edit_header_eoam_end_tlv(Stream=stream, Index=4, Type='FF')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two ports (Port_1 and Port_2) on the tester using reserve_port API.\",\n  \"Subtask 2\": \"Create a traffic stream (StreamTemplate_1) on Port_1 using add_stream API.\",\n  \"Subtask 3\": \"Create CCM header for StreamTemplate_1 using create_stream_header API.\",\n  \"Subtask 4\": \"Modify Eoam header fields (MDlevel, TLVs) for StreamTemplate_1 using edit_modifier API.\",\n  \"Subtask 5\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 6\": \"Configure Port_1 transmission mode to BURST with specified burst count using edit_port_load_profile API.\",\n  \"Subtask 7\": \"Save current test configuration using save_case API.\",\n  \"Subtask 8\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 9\": \"Wait for traffic transmission completion using wait_stream_state API.\",\n  \"Subtask 10\": \"Wait 3 seconds after traffic stops to ensure statistics collection.\",\n  \"Subtask 11\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API.\",\n  \"Subtask 12\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify that the test instrument's traffic transmission statistics are accurate\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the Eoam header content of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['CCM'])\n\n    # 修改Eoam头部\n    attr = edit_header_eoam(Stream=stream, Level=0,\n                            MDlevel=7,\n                            Tlvs=['SenderIDTLV', 'PortStatusTLV', 'InterfaceStatusTLV',\n                                  'OrgSpecTLV', 'EndTLV'])\n    edit_modifier(Stream=stream, Attribute=attr['MDlevel'],\n                  Type='Increment', Count=10, HeaderType='CCM')\n\n    sender_attr = edit_header_eoam_sender_id_tlv(Stream=stream,\n                                                 Type='FF',\n                                                 theChassisID='ChassisComponent',\n                                                 theManagementAddressDomain='MADtDU4')\n    edit_modifier(Stream=stream, Attribute=sender_attr['Type'],\n                  Type='Increment', Count=10, HeaderType='CCM')\n\n    chassis_attr = edit_header_eoam_sender_id_tlv_chassis_id(Stream=stream,\n                                                             Type='ChassisComponent',\n                                                             ChassisID='TEST')\n    management_attr = edit_header_eoam_sender_id_tlv_management_address_domain(Stream=stream,\n                                                                               Type='MADtDU4',\n                                                                               IPv4='1.1.1.1')\n    end_attr = edit_header_eoam_end_tlv(Stream=stream, Index=4, Type='FF')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl2csnpHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective\t:\tTest Objective: Verify the accuracy of traffic transmission statistics on the test instrument\n\nStep\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                Test Step 3: Modify the ISIS header content of traffic stream StreamTemplate_1;\n                Test Step 4: Subscribe to StreamBlockStats statistics;\n                Test Step 5: Transmit all traffic and wait for a period;\n                Test Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria\t:\tExpected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nBugs\t\t:\tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2csnpheader'])\n\n    header = edit_header_isis_csnp(Stream=stream,\n                                   Version=10,\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2csnpheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries', LspEntries=2)\n\n    edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports Port_1 and Port_2 using the reserve_port API.\",\n  \"Subtask 2\": \"Create a traffic stream StreamTemplate_1 on Port_1 using the add_stream API.\",\n  \"Subtask 3\": \"Create EthernetII and l2csnpheader headers for StreamTemplate_1 using the create_stream_header API.\",\n  \"Subtask 4\": \"Modify the ISIS CSNP header version to 10 and set TLV options to ['IsIsLspEntries', 'AuthentionInfo'] using edit_header_isis_csnp.\",\n  \"Subtask 5\": \"Configure an increment modifier for the ISIS version field starting at 10 with count 10 using edit_modifier.\",\n  \"Subtask 6\": \"Set ISIS TLV header LSP entries to 2 using edit_header_isis_tlv_header.\",\n  \"Subtask 7\": \"Configure the first LSP entry (index 0) with remainTime=10 using edit_header_isis_lsp_entry.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode as BURST with BurstCount=100 using edit_port_load_profile.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete using wait_stream_state API, then wait 3 seconds for statistics stabilization.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API.\",\n  \"Subtask 13\": \"Verify transmitted packet count (TxStreamFrames) equals received packet count (RxStreamFrames).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective\t:\tTest Objective: Verify the accuracy of traffic transmission statistics on the test instrument\n\nStep\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                Test Step 3: Modify the ISIS header content of traffic stream StreamTemplate_1;\n                Test Step 4: Subscribe to StreamBlockStats statistics;\n                Test Step 5: Transmit all traffic and wait for a period;\n                Test Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria\t:\tExpected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nBugs\t\t:\tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2csnpheader'])\n\n    header = edit_header_isis_csnp(Stream=stream,\n                                   Version=10,\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2csnpheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries', LspEntries=2)\n\n    edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4AddressMaskRequest.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 address mask requset报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 address mask requset头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Purpose: Verify that the test instrument correctly counts sent ICMPv4 Address Mask Request packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Modify the ICMPv4 Address Mask Request header content in traffic StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst mode;\nTest Step 6: Send all traffic and wait for a period;\nTest Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IcmpMaskRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改IcmpMaskRequest头部\n    header = edit_header_icmp_mask_request(Stream=stream, Level=0,\n                          Identifier='100',SequenceNumber='200',AddrMask='24')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IcmpMaskRequest', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.Identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.AddrMask',\n                                               Value='24',\n                                               MaxValue='24')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_mask_request:修改测试仪表流量模板中Icmp Mask Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (default 'DarYu' or from argument).\",\n  \"Subtask 2\": \"Reserve two ports using provided locations (default '//10.0.11.191/1/3' and '//10.0.11.191/1/4' or from argument).\",\n  \"Subtask 3\": \"Create a traffic stream on first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv4, and IcmpMaskRequest layers.\",\n  \"Subtask 5\": \"Edit ICMPv4 Address Mask Request header fields: set Identifier=100, SequenceNumber=200, AddrMask=24.\",\n  \"Subtask 6\": \"Apply increment modifier to SequenceNumber field: increment type with count=10.\",\n  \"Subtask 7\": \"Create three PDU capture patterns on second port: filter by Identifier=100, SequenceNumber=200, AddrMask=24.\",\n  \"Subtask 8\": \"Set capture filter on second port using logical AND combination of all three PDU patterns.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Configure first port's transmission mode as burst with burst count=100.\",\n  \"Subtask 11\": \"Save current configuration to file in 'xcfg' directory using script name.\",\n  \"Subtask 12\": \"Start packet capture on second port.\",\n  \"Subtask 13\": \"Start traffic transmission from first port.\",\n  \"Subtask 14\": \"Wait 10 seconds during traffic transmission and capture.\",\n  \"Subtask 15\": \"Stop traffic transmission.\",\n  \"Subtask 16\": \"Stop packet capture.\",\n  \"Subtask 17\": \"Download captured packets from second port to 'pcap' directory with filename matching script.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats for the stream and compare TxStreamFrames with RxStreamFrames.\",\n  \"Subtask 19\": \"Assert transmitted frames equal received frames (TxStreamFrames == RxStreamFrames).\",\n  \"Subtask 20\": \"Release both reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Purpose: Verify that the test instrument correctly counts sent ICMPv4 Address Mask Request packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Modify the ICMPv4 Address Mask Request header content in traffic StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst mode;\nTest Step 6: Send all traffic and wait for a period;\nTest Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IcmpMaskRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改IcmpMaskRequest头部\n    header = edit_header_icmp_mask_request(Stream=stream, Level=0,\n                          Identifier='100',SequenceNumber='200',AddrMask='24')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IcmpMaskRequest', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.Identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.AddrMask',\n                                               Value='24',\n                                               MaxValue='24')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_mask_request:修改测试仪表流量模板中Icmp Mask Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6Redirect.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 redirect报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 redirect头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Verify the test instrument correctly counts transmitted ICMPv6 redirect packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Modify the ICMPv6 redirect header content in traffic stream template StreamTemplate_1;\nTest Step 3: Configure packet capture filtering;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Send all traffic and wait for a period;\nTest Step 7: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for traffic stream template StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'Icmpv6Redirect']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_redirect(Stream=stream, Level=0, Code=10,\n                                         HeaderOption=['OptionPrefixInformation', 'GeneralTLV'],\n                                         RedirectedHdrOption=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv6Redirect', Attribute=header['Code'],\n                  Type='Increment', Count=10)\n\n    option = edit_header_icmpv6_header_option(Stream=stream, Header='icmpv6redirect',\n                                              Option='GeneralTLV', Index=1,\n                                              Value='1020')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv6Redirect', Attribute=option['Value'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='icmpv6Redirect_1.code',\n                                               Value='10', MaxValue='10')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_header_option:修改测试仪表流量模板中ICMPv6报文头部Header Option内容",
      "edit_header_icmpv6_redirect:修改测试仪表流量模板中Icmpv6 Redirect报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform for network testing.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) from the tester.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers for the traffic: EthernetII, IPv6, and Icmpv6Redirect.\",\n  \"Subtask 5\": \"Modify ICMPv6 Redirect header: set code to 10 and include OptionPrefixInformation and GeneralTLV options.\",\n  \"Subtask 6\": \"Apply increment modifier to ICMPv6 Redirect code field with count of 10 packets.\",\n  \"Subtask 7\": \"Modify GeneralTLV option value in ICMPv6 header to '1020'.\",\n  \"Subtask 8\": \"Apply increment modifier to GeneralTLV option value field with count of 10 packets.\",\n  \"Subtask 9\": \"Create PDU pattern on Port_2 to filter ICMPv6 Redirect packets with code=10.\",\n  \"Subtask 10\": \"Apply capture filter expression using the created PDU pattern on Port_2.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 12\": \"Configure Port_1 transmission mode to burst with burst count of 100.\",\n  \"Subtask 13\": \"Save test configuration to file.\",\n  \"Subtask 14\": \"Start packet capture on Port_2.\",\n  \"Subtask 15\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 16\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 17\": \"Stop traffic transmission from Port_1.\",\n  \"Subtask 18\": \"Stop packet capture on Port_2.\",\n  \"Subtask 19\": \"Wait 3 seconds for capture finalization.\",\n  \"Subtask 20\": \"Download captured packets from Port_2 to local storage.\",\n  \"Subtask 21\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 22\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 23\": \"Release reserved ports (Port_1 and Port_2).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Verify the test instrument correctly counts transmitted ICMPv6 redirect packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Modify the ICMPv6 redirect header content in traffic stream template StreamTemplate_1;\nTest Step 3: Configure packet capture filtering;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Send all traffic and wait for a period;\nTest Step 7: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for traffic stream template StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'Icmpv6Redirect']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_redirect(Stream=stream, Level=0, Code=10,\n                                         HeaderOption=['OptionPrefixInformation', 'GeneralTLV'],\n                                         RedirectedHdrOption=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv6Redirect', Attribute=header['Code'],\n                  Type='Increment', Count=10)\n\n    option = edit_header_icmpv6_header_option(Stream=stream, Header='icmpv6redirect',\n                                              Option='GeneralTLV', Index=1,\n                                              Value='1020')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv6Redirect', Attribute=option['Value'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='icmpv6Redirect_1.code',\n                                               Value='10', MaxValue='10')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_header_option:修改测试仪表流量模板中ICMPv6报文头部Header Option内容;\nedit_header_icmpv6_redirect:修改测试仪表流量模板中Icmpv6 Redirect报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/DHCPv6Server.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv6 Server头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of flow statistics from the test instrument\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a traffic stream, StreamTemplate_1, on port Port_1;\n                   Step 3: Modify the DHCPv6 Server header content in traffic stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Transmit all traffic and wait for a period;\n                   Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:  \tTester-003\n\nBugs   \t    :  \tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Server'])\n\n    # 修改dhcpv6 server头部\n    header = edit_header_dhcpv6_server(Stream=stream, Level=0,\n                              MessageType=2,\n                              TransId=2,\n                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='clientIdOption',\n                                     Duid='01',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Duid'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='serverIdOption',\n                                     DuidType=2,\n                                     HardwareType=2,\n                                     LinkAddress='00:00:00:00:00:02',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['LinkAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='ianaOption',\n                                     Iaid='00000003',\n                                     T1=3,\n                                     T2=3,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Iaid'],\n                  Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_address(Stream=stream, Index=2,\n                                                Type=5, Length=5, Ipv6Address='2020::1',\n                                                PreferredLifetime=1, ValidLifetime=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=ia_option['Ipv6Address'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='requestOption',\n                                     Value='04',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='elapsedTimeOption',\n                                     ElapseTime=5,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['ElapseTime'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='serverUnicastOption',\n                                     ServerAddress='2022::1',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['ServerAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='statusCodeOption',\n                                     StatusCode=7,\n                                     StatusMsg='0000000007',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['StatusMsg'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='rapidCommitOption',\n                                     Length=8,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Length'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='interfaceIdOption',\n                                     InterfaceId='0000000009',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['InterfaceId'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reconfigureAcceptOption',\n                                     Type=10,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Type'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='iapdOption',\n                                     Iaid='00000011',\n                                     T1=11,\n                                     T2=11,\n                                     IaOption=1,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Iaid'],\n    #               Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_prefix(Stream=stream, Index=10,\n                                                            Type=5, Length=5, Ipv6Address='2020::1',\n                                                            PreferredLifetime=1, ValidLifetime=1, PrefixLength=128)\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=ia_option['Ipv6Address'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Value='12',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='13',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Server'],\n                                             FieldName='dhcpv6Server_1.messageType',\n                                             Value=2,\n                                             MaxValue=2,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports named Port_1 and Port_2 using the reserve_port API function.\",\n  \"Subtask 2\": \"Create a traffic stream named StreamTemplate_1 on Port_1 using the add_stream API function with fixed frame length configuration.\",\n  \"Subtask 3\": \"Modify DHCPv6 Server header content in StreamTemplate_1 using edit_header_dhcpv6_server and related header editing API functions.\",\n  \"Subtask 4\": \"Subscribe to StreamBlockStats statistics view using the subscribe_result API function.\",\n  \"Subtask 5\": \"Configure traffic transmission parameters for StreamTemplate_1 using edit_port_load_profile API to set burst mode with specific packet count.\",\n  \"Subtask 6\": \"Start traffic transmission using the start_stream API function.\",\n  \"Subtask 7\": \"Wait until traffic transmission completes using the wait_stream_state API function.\",\n  \"Subtask 8\": \"Wait for 3 seconds to ensure statistics collection completes.\",\n  \"Subtask 9\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API function.\",\n  \"Subtask 10\": \"Verify transmitted packet count (TxStreamFrames) equals received packet count (RxStreamFrames) for StreamTemplate_1.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of flow statistics from the test instrument\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a traffic stream, StreamTemplate_1, on port Port_1;\n                   Step 3: Modify the DHCPv6 Server header content in traffic stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Transmit all traffic and wait for a period;\n                   Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:  \tTester-003\n\nBugs   \t    :  \tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Server'])\n\n    # 修改dhcpv6 server头部\n    header = edit_header_dhcpv6_server(Stream=stream, Level=0,\n                              MessageType=2,\n                              TransId=2,\n                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='clientIdOption',\n                                     Duid='01',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Duid'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='serverIdOption',\n                                     DuidType=2,\n                                     HardwareType=2,\n                                     LinkAddress='00:00:00:00:00:02',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['LinkAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='ianaOption',\n                                     Iaid='00000003',\n                                     T1=3,\n                                     T2=3,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Iaid'],\n                  Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_address(Stream=stream, Index=2,\n                                                Type=5, Length=5, Ipv6Address='2020::1',\n                                                PreferredLifetime=1, ValidLifetime=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=ia_option['Ipv6Address'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='requestOption',\n                                     Value='04',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='elapsedTimeOption',\n                                     ElapseTime=5,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['ElapseTime'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='serverUnicastOption',\n                                     ServerAddress='2022::1',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['ServerAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='statusCodeOption',\n                                     StatusCode=7,\n                                     StatusMsg='0000000007',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['StatusMsg'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='rapidCommitOption',\n                                     Length=8,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Length'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='interfaceIdOption',\n                                     InterfaceId='0000000009',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['InterfaceId'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reconfigureAcceptOption',\n                                     Type=10,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Type'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='iapdOption',\n                                     Iaid='00000011',\n                                     T1=11,\n                                     T2=11,\n                                     IaOption=1,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Iaid'],\n    #               Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_prefix(Stream=stream, Index=10,\n                                                            Type=5, Length=5, Ipv6Address='2020::1',\n                                                            PreferredLifetime=1, ValidLifetime=1, PrefixLength=128)\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=ia_option['Ipv6Address'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Value='12',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='13',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Server'],\n                                             FieldName='dhcpv6Server_1.messageType',\n                                             Value=2,\n                                             MaxValue=2,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/llc.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的llc头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Verify the accuracy of traffic statistics sent by the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports: Port_1, Port_2;\n                    Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                    Test Step 3: Modify the LLC header content of traffic stream StreamTemplate_1;\n                    Test Step 4: Subscribe to StreamBlockStats statistics;\n                    Test Step 5: Send all traffic streams and wait for a period;\n                    Test Step 6: Stop all traffic streams and check StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, received and sent packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-002\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp', 'logicLinkControl'])\n\n    # 修改802.3头部\n    attr = edit_header_llc(Stream=stream, Level=0, Dsap='FF')\n    edit_modifier(Stream=stream, Attribute=attr['Dsap'],\n                  Type='Increment', Count=10, HeaderType='logicLinkControl')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using the provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream named StreamTemplate_1 on Port_1.\",\n  \"Subtask 4\": \"Edit StreamTemplate_1 parameters to set frame length type to 'AUTO'.\",\n  \"Subtask 5\": \"Create Ethernet II, IPv4, UDP, and LLC headers for StreamTemplate_1.\",\n  \"Subtask 6\": \"Modify LLC header of StreamTemplate_1 by setting Dsap field to 'FF'.\",\n  \"Subtask 7\": \"Add increment modifier to Dsap field in LLC header with count=10.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 9\": \"Configure Port_1 to transmit in BURST mode with burst count=100.\",\n  \"Subtask 10\": \"Start transmission of all traffic streams.\",\n  \"Subtask 11\": \"Wait until all traffic streams stop transmitting.\",\n  \"Subtask 12\": \"Wait 3 seconds after stream stop to ensure accurate statistics collection.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats results for StreamTemplate_1.\",\n  \"Subtask 14\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 15\": \"Verify both TxStreamFrames and RxStreamFrames equal the configured burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Verify the accuracy of traffic statistics sent by the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports: Port_1, Port_2;\n                    Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                    Test Step 3: Modify the LLC header content of traffic stream StreamTemplate_1;\n                    Test Step 4: Subscribe to StreamBlockStats statistics;\n                    Test Step 5: Send all traffic streams and wait for a period;\n                    Test Step 6: Stop all traffic streams and check StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, received and sent packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-002\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp', 'logicLinkControl'])\n\n    # 修改802.3头部\n    attr = edit_header_llc(Stream=stream, Level=0, Dsap='FF')\n    edit_modifier(Stream=stream, Attribute=attr['Dsap'],\n                  Type='Increment', Count=10, HeaderType='logicLinkControl')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Destination.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Destination头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify that the test instrument correctly counts transmitted IPv6 packets\n\nStep: Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n      Test Step 2: Modify the IPv6 Destination header of traffic StreamTemplate_1;\n      Test Step 3: Configure filtered packet capture;\n      Test Step 4: Subscribe to StreamBlockStats;\n      Test Step 5: Set port transmission mode to Burst;\n      Test Step 6: Transmit all traffic and wait for a period;\n      Test Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: Transmitted and received packets for StreamTemplate_1 in Step 6 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6destinationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_destination(Stream=stream,\n                                        Length=10,\n                                        OptionHeaders=['bierv6'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr['Length'],\n                  Type='Increment', Count=10, Step=2)\n    attr_bier = edit_header_ipv6_destination_option(Stream=stream, Option='bierv6',\n                                                    Optiontype=20,\n                                                    BierbitString=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr_bier['Optiontype'],\n                  Type='Increment', Count=10, Step=2)\n    attr_bit_string = edit_header_ipv6_destination_bier_bit_string(Stream=stream,\n                                                                   BitString='11001100110011001100110011001100')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr_bit_string['BitString'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester for the specified product (DarYu) using init_tester API.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using reserve_port API with provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv6, and ipv6destinationheader using create_stream_header API.\",\n  \"Subtask 5\": \"Modify IPv6 Destination header length field and configure increment modifier (Step=2, Count=10) using edit_header_ipv6_destination and edit_modifier APIs.\",\n  \"Subtask 6\": \"Modify IPv6 Destination BIERv6 option type field and configure increment modifier (Step=2, Count=10) using edit_header_ipv6_destination_option and edit_modifier APIs.\",\n  \"Subtask 7\": \"Modify IPv6 Destination BIER bit string field and configure increment modifier (Step=2, Count=10) using edit_header_ipv6_destination_bier_bit_string and edit_modifier APIs.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats view using subscribe_result API.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode to Burst with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for 10 seconds to allow traffic flow.\",\n  \"Subtask 12\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats using get_streamblock_statistic API for the created stream.\",\n  \"Subtask 14\": \"Verify TxStreamFrames equal RxStreamFrames in the retrieved statistics.\",\n  \"Subtask 15\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify that the test instrument correctly counts transmitted IPv6 packets\n\nStep: Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n      Test Step 2: Modify the IPv6 Destination header of traffic StreamTemplate_1;\n      Test Step 3: Configure filtered packet capture;\n      Test Step 4: Subscribe to StreamBlockStats;\n      Test Step 5: Set port transmission mode to Burst;\n      Test Step 6: Transmit all traffic and wait for a period;\n      Test Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: Transmitted and received packets for StreamTemplate_1 in Step 6 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6destinationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_destination(Stream=stream,\n                                        Length=10,\n                                        OptionHeaders=['bierv6'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr['Length'],\n                  Type='Increment', Count=10, Step=2)\n    attr_bier = edit_header_ipv6_destination_option(Stream=stream, Option='bierv6',\n                                                    Optiontype=20,\n                                                    BierbitString=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr_bier['Optiontype'],\n                  Type='Increment', Count=10, Step=2)\n    attr_bit_string = edit_header_ipv6_destination_bier_bit_string(Stream=stream,\n                                                                   BitString='11001100110011001100110011001100')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr_bit_string['BitString'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahMacInMac.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Verify the test instrument's traffic transmission statistics accuracy\n\nStep          : Step 1: Reserve two loopback ports: Port_1 and Port_2;\n               Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n               Step 3: Modify the 802.1ah header content of traffic stream StreamTemplate_1;\n               Step 4: Subscribe to StreamBlockStats statistics;\n               Step 5: Transmit all traffic and wait for a duration;\n               Step 6: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['mac-in-mac', 'ipv4'])\n\n    # 修改Encapsulated Mac-in-Mac头部\n    attr = edit_header_8021ah_MacInMac(Stream=stream, Level=0,\n                                       DestMacAdd='22:00:00:00:00:00',\n                                       SourceMacAdd='22:11:11:11:11:11')\n    edit_modifier(Stream=stream, Attribute=attr['DestMacAdd'],\n                  Type='Increment', Count=10, HeaderType='mac-in-mac')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform.\",\n  \"Subtask 2\": \"Reserve two test ports designated as Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream named StreamTemplate_1 on Port_1.\",\n  \"Subtask 4\": \"Configure StreamTemplate_1 with mac-in-mac and ipv4 headers.\",\n  \"Subtask 5\": \"Modify the 802.1ah header of StreamTemplate_1: set destination MAC to '22:00:00:00:00:00' and source MAC to '22:11:11:11:11:11'.\",\n  \"Subtask 6\": \"Apply increment modifier to destination MAC address field with step value 10.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics collection.\",\n  \"Subtask 8\": \"Configure Port_1 transmit mode as burst with burst count set to 100.\",\n  \"Subtask 9\": \"Start traffic transmission for StreamTemplate_1.\",\n  \"Subtask 10\": \"Wait until traffic transmission completes and then wait 3 seconds for statistics stabilization.\",\n  \"Subtask 11\": \"Retrieve StreamBlockStats results for StreamTemplate_1.\",\n  \"Subtask 12\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames) for StreamTemplate_1.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Verify the test instrument's traffic transmission statistics accuracy\n\nStep          : Step 1: Reserve two loopback ports: Port_1 and Port_2;\n               Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n               Step 3: Modify the 802.1ah header content of traffic stream StreamTemplate_1;\n               Step 4: Subscribe to StreamBlockStats statistics;\n               Step 5: Transmit all traffic and wait for a duration;\n               Step 6: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['mac-in-mac', 'ipv4'])\n\n    # 修改Encapsulated Mac-in-Mac头部\n    attr = edit_header_8021ah_MacInMac(Stream=stream, Level=0,\n                                       DestMacAdd='22:00:00:00:00:00',\n                                       SourceMacAdd='22:11:11:11:11:11')\n    edit_modifier(Stream=stream, Attribute=attr['DestMacAdd'],\n                  Type='Increment', Count=10, HeaderType='mac-in-mac')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ripv2.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发Ripv2报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的Ripv2头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify that the test instrument correctly counts sent/received Ripv2 packets  \n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;  \n      Test Step 2: Modify Ripv2 header content in traffic StreamTemplate_1;  \n      Test Step 3: Configure filtered packet capture;  \n      Test Step 4: Subscribe to StreamBlockStats;  \n      Test Step 5: Set port transmission mode to burst;  \n      Test Step 6: Send all traffic and wait;  \n      Test Step 7: Stop all traffic and check StreamBlockStats;  \n\nCriteria: Expected Result 1: In Step 6, transmitted/received packets for StreamTemplate_1 are equal;  \n\nCreated by: Tester-001  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripv2']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripv2(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripv2', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripv2_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripv2_entry(Stream=stream, Level=0, Index=0, Ipaddr='192.168.0.11', SubnetMask='192.168.1.11', NextHop='192.168.2.11', Afi=1, RouteTag=1)\n    edit_header_ripv2_entry(Stream=stream, Level=0, Index=1, Ipaddr='192.168.0.12', SubnetMask='192.168.1.12', NextHop='192.168.2.12', Afi=2, RouteTag=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform for product 'DarYu'.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations for loopback testing.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv4, and Ripv2.\",\n  \"Subtask 5\": \"Modify Ripv2 header fields: set Command=2, Version=1, Reserved=2 at Level 0.\",\n  \"Subtask 6\": \"Apply increment modifier to Ripv2 Reserved field with count=3.\",\n  \"Subtask 7\": \"Insert two Ripv2 entries into the stream.\",\n  \"Subtask 8\": \"Edit first Ripv2 entry: set Ipaddr='192.168.0.11', SubnetMask='192.168.1.11', NextHop='192.168.2.11', Afi=1, RouteTag=1.\",\n  \"Subtask 9\": \"Edit second Ripv2 entry: set Ipaddr='192.168.0.12', SubnetMask='192.168.1.12', NextHop='192.168.2.12', Afi=2, RouteTag=2.\",\n  \"Subtask 10\": \"Create first PDU capture pattern on second port: match Ripv2 Reserved field at Level 2 with value=1 and max=2.\",\n  \"Subtask 11\": \"Create second PDU capture pattern on second port: match Ripv2 Version field at Level 2 with value=1 and max=1.\",\n  \"Subtask 12\": \"Configure packet capture filter on second port using logical AND of both PDU patterns.\",\n  \"Subtask 13\": \"Subscribe to StreamBlockStats view for statistics collection.\",\n  \"Subtask 14\": \"Set port transmission mode to BURST with burst count=100 on traffic source port.\",\n  \"Subtask 15\": \"Save test configuration to specified file path.\",\n  \"Subtask 16\": \"Start packet capture on second port.\",\n  \"Subtask 17\": \"Transmit traffic stream from first port.\",\n  \"Subtask 18\": \"Wait 10 seconds during traffic transmission.\",\n  \"Subtask 19\": \"Stop traffic transmission.\",\n  \"Subtask 20\": \"Stop packet capture.\",\n  \"Subtask 21\": \"Download captured packets from second port to local storage.\",\n  \"Subtask 22\": \"Retrieve StreamBlockStats for the traffic stream.\",\n  \"Subtask 23\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 24\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify that the test instrument correctly counts sent/received Ripv2 packets  \n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;  \n      Test Step 2: Modify Ripv2 header content in traffic StreamTemplate_1;  \n      Test Step 3: Configure filtered packet capture;  \n      Test Step 4: Subscribe to StreamBlockStats;  \n      Test Step 5: Set port transmission mode to burst;  \n      Test Step 6: Send all traffic and wait;  \n      Test Step 7: Stop all traffic and check StreamBlockStats;  \n\nCriteria: Expected Result 1: In Step 6, transmitted/received packets for StreamTemplate_1 are equal;  \n\nCreated by: Tester-001  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripv2']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripv2(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripv2', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripv2_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripv2_entry(Stream=stream, Level=0, Index=0, Ipaddr='192.168.0.11', SubnetMask='192.168.1.11', NextHop='192.168.2.11', Afi=1, RouteTag=1)\n    edit_header_ripv2_entry(Stream=stream, Level=0, Index=1, Ipaddr='192.168.0.12', SubnetMask='192.168.1.12', NextHop='192.168.2.12', Afi=2, RouteTag=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/HsrTag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的hsr tag头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Verify the accuracy of test instrument traffic statistics  \n\nStep:  \n1. Reserve two loopback ports: Port_1, Port_2  \n2. Create traffic stream StreamTemplate_1 on Port_1  \n3. Modify HSR tag header content of StreamTemplate_1  \n4. Subscribe to StreamBlockStats  \n5. Transmit all traffic and wait for a period  \n6. Stop all traffic and check StreamBlockStats  \n\nCriteria:  \n1. Received and transmitted packets of StreamTemplate_1 must match in Step 6  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['hsrtag', 'ipv4'])\n\n    # 修改hsr头部\n    attr = edit_header_hsr_tag(Stream=stream, Level=0,\n                            LsduSize=4095)\n    edit_modifier(Stream=stream, Attribute=attr['LsduSize'],\n                  Type='Increment', Count=10, HeaderType='hsrtag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with the specified product using init_tester API.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_UP and Port_Down) using reserve_port API with provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API.\",\n  \"Subtask 4\": \"Create stream headers including HSR tag and IPv4 using create_stream_header API.\",\n  \"Subtask 5\": \"Edit HSR tag header by setting LsduSize to 4095 using edit_header_hsr_tag API.\",\n  \"Subtask 6\": \"Configure modifier for LsduSize field with increment type and count of 10 using edit_modifier API.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats and PortStats using subscribe_result API.\",\n  \"Subtask 8\": \"Configure port load profile for Port_UP with burst transmit mode and burst count of 100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 12\": \"Wait additional 3 seconds to ensure accurate statistics collection.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 14\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both equal burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Verify the accuracy of test instrument traffic statistics  \n\nStep:  \n1. Reserve two loopback ports: Port_1, Port_2  \n2. Create traffic stream StreamTemplate_1 on Port_1  \n3. Modify HSR tag header content of StreamTemplate_1  \n4. Subscribe to StreamBlockStats  \n5. Transmit all traffic and wait for a period  \n6. Stop all traffic and check StreamBlockStats  \n\nCriteria:  \n1. Received and transmitted packets of StreamTemplate_1 must match in Step 6  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['hsrtag', 'ipv4'])\n\n    # 修改hsr头部\n    attr = edit_header_hsr_tag(Stream=stream, Level=0,\n                            LsduSize=4095)\n    edit_modifier(Stream=stream, Attribute=attr['LsduSize'],\n                  Type='Increment', Count=10, HeaderType='hsrtag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Encapsulation.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Encapsulation头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective\t:\tTest Objective: Verify that the test instrument correctly counts transmitted IPv6 packets\n\nStep\t\t:\tTest Step 1: Reserve two loopback ports: Port_1 and Port_2;\n\t\t\t\tTest Step 2: Modify the IPv6 Encapsulation header content of traffic stream StreamTemplate_1;\n\t\t\t\tTest Step 3: Configure filtered packet capture;\n\t\t\t\tTest Step 4: Subscribe to StreamBlockStats statistics;\n\t\t\t\tTest Step 5: Set port transmission mode to burst mode;\n\t\t\t\tTest Step 6: Transmit all traffic and wait for a period of time;\n\t\t\t\tTest Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria\t:\tExpected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by\t:\tTester-002\n\nBugs\t\t:\tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6encapsulationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_encapsulation(Stream=stream, Spi=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6encapsulationheader', Attribute=attr['Spi'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with product specification 'DarYu' using the init_tester API.\",\n  \"Subtask 2\": \"Reserve two physical ports at specified locations using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Build stream headers with EthernetII, IPv6, and IPv6 Encapsulation Header layers using create_stream_header API.\",\n  \"Subtask 5\": \"Set base value of Security Parameters Index (SPI) field in IPv6 Encapsulation Header to 10.\",\n  \"Subtask 6\": \"Configure increment modifier for SPI field with step size 2 and packet count 10 using edit_modifier API.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 8\": \"Configure port transmission mode as burst with burst count 100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Save current test configuration to specified file path using save_case API.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Maintain traffic flow for 10 seconds to allow packet transmission and reception.\",\n  \"Subtask 12\": \"Stop all traffic transmission using stop_stream API.\",\n  \"Subtask 13\": \"Wait 3 seconds for statistics stabilization after traffic stop.\",\n  \"Subtask 14\": \"Retrieve StreamBlock statistics for the created stream using get_streamblock_statistic API.\",\n  \"Subtask 15\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) in statistics.\",\n  \"Subtask 16\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective\t:\tTest Objective: Verify that the test instrument correctly counts transmitted IPv6 packets\n\nStep\t\t:\tTest Step 1: Reserve two loopback ports: Port_1 and Port_2;\n\t\t\t\tTest Step 2: Modify the IPv6 Encapsulation header content of traffic stream StreamTemplate_1;\n\t\t\t\tTest Step 3: Configure filtered packet capture;\n\t\t\t\tTest Step 4: Subscribe to StreamBlockStats statistics;\n\t\t\t\tTest Step 5: Set port transmission mode to burst mode;\n\t\t\t\tTest Step 6: Transmit all traffic and wait for a period of time;\n\t\t\t\tTest Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria\t:\tExpected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by\t:\tTester-002\n\nBugs\t\t:\tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6encapsulationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_encapsulation(Stream=stream, Spi=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6encapsulationheader', Attribute=attr['Spi'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Vlan.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发vlan报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的vlan头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify that the test instrument correctly counts transmitted VLAN packets\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Modify the VLAN header content of traffic stream StreamTemplate_1;;\n                   Test Step 3: Configure filtered packet capture;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set port transmission mode to burst;\n                   Test Step 6: Transmit all traffic and wait for a period;\n                   Test Step 7: Stop all traffic and check StreamBlockStats statistics;;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-004\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'vlan']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改vlan头部\n    attribute_dict = edit_header_vlan(Stream=stream, Level=0, ID=100, Priority=5, CFI=0)\n    # vlan头部目字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['ID'],\n                  Type='Increment', StreamType='InterModifier',\n                  Count=10, Step=2)\n    # vlan头部目字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['Priority'],\n                  Type='List',\n                  List=[2, 4, 6, 3])\n    # vlan头部目字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['CFI'],\n                  Type='Random',\n                  Range=1)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.cfi',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.id',\n                                               Value='100',\n                                               MaxValue='100')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.priority',\n                                               Value='5',\n                                               MaxValue='5')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (default 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports at provided locations (default '//10.0.11.191/1/5' and '//10.0.11.191/1/6').\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Create stream headers for EthernetII and VLAN protocols.\",\n  \"Subtask 5\": \"Modify VLAN header at level 0: set ID=100, Priority=5, CFI=0.\",\n  \"Subtask 6\": \"Apply increment modifier to VLAN ID field: start=100, step=2, count=10.\",\n  \"Subtask 7\": \"Apply list modifier to VLAN Priority field: values=[2,4,6,3].\",\n  \"Subtask 8\": \"Apply random modifier to VLAN CFI field: range=0-1.\",\n  \"Subtask 9\": \"Create capture PDU patterns on second port for: VLAN CFI=1, VLAN ID=100, VLAN Priority=5.\",\n  \"Subtask 10\": \"Configure capture filter on second port using logical AND of all PDU patterns.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 12\": \"Set transmission mode to burst with burst count=100 on first port.\",\n  \"Subtask 13\": \"Save test configuration to specified file path.\",\n  \"Subtask 14\": \"Start packet capture on second port.\",\n  \"Subtask 15\": \"Start traffic transmission.\",\n  \"Subtask 16\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 17\": \"Stop traffic transmission.\",\n  \"Subtask 18\": \"Stop packet capture.\",\n  \"Subtask 19\": \"Download captured packets from second port (optional debug step).\",\n  \"Subtask 20\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 21\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 22\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify that the test instrument correctly counts transmitted VLAN packets\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Modify the VLAN header content of traffic stream StreamTemplate_1;;\n                   Test Step 3: Configure filtered packet capture;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set port transmission mode to burst;\n                   Test Step 6: Transmit all traffic and wait for a period;\n                   Test Step 7: Stop all traffic and check StreamBlockStats statistics;;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-004\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'vlan']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改vlan头部\n    attribute_dict = edit_header_vlan(Stream=stream, Level=0, ID=100, Priority=5, CFI=0)\n    # vlan头部目字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['ID'],\n                  Type='Increment', StreamType='InterModifier',\n                  Count=10, Step=2)\n    # vlan头部目字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['Priority'],\n                  Type='List',\n                  List=[2, 4, 6, 3])\n    # vlan头部目字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['CFI'],\n                  Type='Random',\n                  Range=1)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.cfi',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.id',\n                                               Value='100',\n                                               MaxValue='100')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.priority',\n                                               Value='5',\n                                               MaxValue='5')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/goose.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Goose头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test purpose: Verify the test instrument's traffic statistics accuracy  \n\nStep:  \n1. Reserve two loopback ports: Port_1 and Port_2.  \n2. Create a traffic stream StreamTemplate_1 on Port_1.  \n3. Modify the Goose header content of StreamTemplate_1.  \n4. Subscribe to StreamBlockStats.  \n5. Transmit all traffic and wait for a period.  \n6. Stop all traffic and check StreamBlockStats.  \n\nCriteria:  \n1. Expected result: In step 6, StreamTemplate_1's transmitted and received packets are equal.  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetII', 'goose'])\n\n    # 修改Goose头部\n    attr = edit_header_goose(Stream=stream, Level=0,\n                             Apdu='102030405060')\n    edit_modifier(Stream=stream, Attribute=attr['Apdu'],\n                  Type='Increment', Count=10, HeaderType='goose')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using 'init_tester' API with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports using 'reserve_port' API, assigning them as Port_UP (sender) and Port_Down (receiver).\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using 'add_stream' API.\",\n  \"Subtask 4\": \"Configure stream parameters with 'edit_stream' API to set frame length type to 'AUTO'.\",\n  \"Subtask 5\": \"Create Ethernet II and Goose headers for the stream using 'create_stream_header' API.\",\n  \"Subtask 6\": \"Modify Goose header's Apdu field to specific value and configure increment modifier using 'edit_modifier' API.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats and PortStats using 'subscribe_result' API.\",\n  \"Subtask 8\": \"Configure Port_UP's load profile with 'edit_port_load_profile' API for burst mode transmission (100 packets).\",\n  \"Subtask 9\": \"Save test configuration to file using 'save_case' API.\",\n  \"Subtask 10\": \"Start traffic transmission using 'start_stream' API.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete using 'wait_stream_state' API.\",\n  \"Subtask 12\": \"Wait 3 seconds for statistics stabilization after traffic stops.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats using 'get_streamblock_statistic' API for the created stream.\",\n  \"Subtask 14\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both match configured burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test purpose: Verify the test instrument's traffic statistics accuracy  \n\nStep:  \n1. Reserve two loopback ports: Port_1 and Port_2.  \n2. Create a traffic stream StreamTemplate_1 on Port_1.  \n3. Modify the Goose header content of StreamTemplate_1.  \n4. Subscribe to StreamBlockStats.  \n5. Transmit all traffic and wait for a period.  \n6. Stop all traffic and check StreamBlockStats.  \n\nCriteria:  \n1. Expected result: In step 6, StreamTemplate_1's transmitted and received packets are equal.  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetII', 'goose'])\n\n    # 修改Goose头部\n    attr = edit_header_goose(Stream=stream, Level=0,\n                             Apdu='102030405060')\n    edit_modifier(Stream=stream, Attribute=attr['Apdu'],\n                  Type='Increment', Count=10, HeaderType='goose')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Udp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发udp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的udp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Purpose: Verify the test instrument accurately counts transmitted UDP packets\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2\n      Step 2: Modify UDP header content of traffic stream StreamTemplate_1\n      Step 3: Configure filtered packet capture\n      Step 4: Subscribe to StreamBlockStats\n      Step 5: Set port transmission mode to burst\n      Step 6: Transmit all traffic streams and wait\n      Step 7: Stop all traffic and check StreamBlockStats\n\nCriteria: Expected Result 1: Packets sent/received for StreamTemplate_1 are equal during Step 6\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ipv4', 'udp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改vlan头部\n    header = edit_header_udp(Stream=stream, Level=0,\n                             SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Level=0, HeaderType='udp',\n                  Attribute=header['SourcePort'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='udp_1.destPort',\n                                               Value='2000', MaxValue='2000')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_udp:修改测试仪表流量模板中UDP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports (Port_1 and Port_2) for testing.\",\n  \"Subtask 2\": \"Create a traffic stream on Port_1 with fixed length 256 bytes.\",\n  \"Subtask 3\": \"Configure stream headers for Ethernet II, IPv4, and UDP protocols.\",\n  \"Subtask 4\": \"Edit UDP header of the stream to set source port=1000 and destination port=2000.\",\n  \"Subtask 5\": \"Apply increment modifier to UDP source port field with step=2 and count=10.\",\n  \"Subtask 6\": \"Create capture PDU pattern on Port_2 filtering UDP packets with destination port=2000.\",\n  \"Subtask 7\": \"Set capture filter on Port_2 using the created PDU pattern.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistic view.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode as burst with burst count=100 packets.\",\n  \"Subtask 10\": \"Start packet capture on Port_2.\",\n  \"Subtask 11\": \"Initiate traffic transmission from Port_1.\",\n  \"Subtask 12\": \"Wait 10 seconds during traffic transmission and capture.\",\n  \"Subtask 13\": \"Stop traffic transmission from Port_1.\",\n  \"Subtask 14\": \"Stop packet capture on Port_2.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 16\": \"Verify transmitted frame count equals received frame count for the UDP stream.\",\n  \"Subtask 17\": \"Release reserved ports Port_1 and Port_2.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Purpose: Verify the test instrument accurately counts transmitted UDP packets\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2\n      Step 2: Modify UDP header content of traffic stream StreamTemplate_1\n      Step 3: Configure filtered packet capture\n      Step 4: Subscribe to StreamBlockStats\n      Step 5: Set port transmission mode to burst\n      Step 6: Transmit all traffic streams and wait\n      Step 7: Stop all traffic and check StreamBlockStats\n\nCriteria: Expected Result 1: Packets sent/received for StreamTemplate_1 are equal during Step 6\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ipv4', 'udp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改vlan头部\n    header = edit_header_udp(Stream=stream, Level=0,\n                             SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Level=0, HeaderType='udp',\n                  Attribute=header['SourcePort'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='udp_1.destPort',\n                                               Value='2000', MaxValue='2000')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_udp:修改测试仪表流量模板中UDP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6MLDv2Query.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv2 query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv2 query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify that the test instrument accurately counts sent ICMPv6 MLDv2 query packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test Step 2: Modify ICMPv6 MLDv2 query header content in traffic StreamTemplate_1;\n      Test Step 3: Configure filter for packet capture;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Set port transmission mode to burst;\n      Test Step 6: Transmit all traffic and wait for a period;\n      Test Step 7: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, sent and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv2query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2 query头部\n    header = edit_header_icmpv6_mldv2_query(Stream=stream, Level=0,\n                                            Code='2', Reserved='10',\n                                            GroupAddress='FF1E::1', Qrv='111',\n                                            SourceAddressList=['2001::1', '2002::2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2query', Attribute=header['SourceAddressList: 2002::2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.Qrv',\n                                               Value='111',\n                                               MaxValue='111')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_mldv2_query:修改测试仪表流量模板中Icmpv6 Mldv2 Query报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with product specification 'DarYu'.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) at specified locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv6, and MLDv2 Query.\",\n  \"Subtask 5\": \"Modify MLDv2 Query header parameters: Code=2, Reserved=10, GroupAddress='FF1E::1', Qrv=111, SourceAddressList=['2001::1','2002::2'].\",\n  \"Subtask 6\": \"Apply increment modifier to SourceAddressList field with count=10.\",\n  \"Subtask 7\": \"Create PDU patterns on Port_2 for capture filtering: MLDv2 Query Code=2, Reserved=10, Qrv=111.\",\n  \"Subtask 8\": \"Configure capture filter on Port_2 using logical AND combination of PDU patterns.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Set Port_1 transmission mode to BURST with burst count=100.\",\n  \"Subtask 11\": \"Start packet capture on Port_2.\",\n  \"Subtask 12\": \"Initiate traffic transmission from Port_1.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission and capture.\",\n  \"Subtask 14\": \"Stop traffic transmission on Port_1.\",\n  \"Subtask 15\": \"Stop packet capture on Port_2.\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats results for transmitted and received frame counts.\",\n  \"Subtask 17\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 18\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify that the test instrument accurately counts sent ICMPv6 MLDv2 query packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test Step 2: Modify ICMPv6 MLDv2 query header content in traffic StreamTemplate_1;\n      Test Step 3: Configure filter for packet capture;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Set port transmission mode to burst;\n      Test Step 6: Transmit all traffic and wait for a period;\n      Test Step 7: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, sent and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv2query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2 query头部\n    header = edit_header_icmpv6_mldv2_query(Stream=stream, Level=0,\n                                            Code='2', Reserved='10',\n                                            GroupAddress='FF1E::1', Qrv='111',\n                                            SourceAddressList=['2001::1', '2002::2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2query', Attribute=header['SourceAddressList: 2002::2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.Qrv',\n                                               Value='111',\n                                               MaxValue='111')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_mldv2_query:修改测试仪表流量模板中Icmpv6 Mldv2 Query报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2LinkStateUpdate.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发OSPFv2 Link State Update Instance报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的OSPFv2 Link State Update Instance头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Verify that the test instrument accurately counts transmitted OSPFv2 Link State Update Instance packets\n\nStep         :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Test Step 2: Modify the OSPFv2 Link State Update Instance header of traffic stream StreamTemplate_1;\n                Test Step 3: Configure filtered packet capture;\n                Test Step 4: Subscribe to StreamBlockStats;\n                Test Step 5: Set port transmission mode to burst;\n                Test Step 6: Transmit all traffic and wait for a period;\n                Test Step 7: Stop all traffic and examine StreamBlockStats;\n\nCriteria     :   Expected Result 1: In step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstateupdate']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2头部\n    header = edit_header_ospfv2_update(Stream=stream, Level=0,\n                                       RouterID='2.2.2.2', AuthType='MD5')\n\n    router_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Router',\n                                               RouterLsaReserved1=10,\n                                               LsaAge=20,\n                                               Reserved7=1,\n                                               Reserved7Router=0,\n                                               )\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['RouterLsaReserved1'],\n    #               Type='Increment',\n    #               Count=10, Step=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['LsaAge'],\n    #               Type='Increment',\n    #               Count=10, Step=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['Reserved7'],\n    #               Type='Increment',\n    #               Count=2, Step=1)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['Reserved7Router'],\n    #               Type='Increment',\n    #               Count=2, Step=1)\n\n    router_lsa_link = edit_header_ospfv2_update_route_lsa_link(Stream=stream,\n                                                               LinkId='3.3.3.3')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=router_lsa_link['LinkId'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    router_lsa_link_metric = edit_header_ospfv2_update_route_link_tos_metric(Stream=stream,\n                                                                             RouterLsaMetricReserved=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=router_lsa_link_metric['RouterLsaMetricReserved'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    network_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Network', Index=1,\n                                                LsType=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=network_lsa['LsType'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    network_attached_router = edit_header_ospfv2_update_network_attached_route(Stream=stream, LsaIndex=1,\n                                                                               RouterID='4.4.4.4')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=network_attached_router['RouterID'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    summary_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Summary', Index=2,\n                                                AdvertisingRouter='5.5.5.5')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=summary_lsa['AdvertisingRouter'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    summary_tos_metric = edit_header_ospfv2_update_tos_metric(Stream=stream, Type='Summary', LsaIndex=2,\n                                                              MetricReserved=20)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=summary_tos_metric['MetricReserved'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='ospfv2LinkStateUpdate_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_update:修改测试仪表流量模板中OSPFv2 Link State Update报文头部内容",
      "edit_header_ospfv2_update_lsa:修改测试仪表流量模板中OSPFv2 Update报文中Lsa头部内容.",
      "edit_header_ospfv2_update_route_link_tos_metric:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容",
      "edit_header_ospfv2_update_route_lsa_link:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容",
      "edit_header_ospfv2_update_tos_metric:修改测试仪表流量模板中OSPFv2 Update报文中Summary、 SummaryAsbr或AsExternal Lsa头部Tos Metric内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu'.\",\n  \"Subtask 2\": \"Reserve two ports using specified locations.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Create stream headers: EthernetII, IPv4, and OSPFv2 Link State Update.\",\n  \"Subtask 5\": \"Edit OSPFv2 Link State Update header: set router ID to '2.2.2.2' and authentication type to 'MD5'.\",\n  \"Subtask 6\": \"Edit Router LSA: set RouterLsaReserved1=10, LsaAge=20, Reserved7=1, Reserved7Router=0.\",\n  \"Subtask 7\": \"Set increment modifier on Router LSA LinkId field: start '3.3.3.3', count=10, step=2.\",\n  \"Subtask 8\": \"Set increment modifier on Router LSA MetricReserved field: start=10, count=10, step=2.\",\n  \"Subtask 9\": \"Edit Network LSA: set Type='Network', Index=1, LsType=10, then set increment modifier on LsType field with count=10, step=2.\",\n  \"Subtask 10\": \"Edit Network Attached Router: set LsaIndex=1, RouterID='4.4.4.4', then set increment modifier on RouterID field with count=10, step=2.\",\n  \"Subtask 11\": \"Edit Summary LSA: set Type='Summary', Index=2, AdvertisingRouter='5.5.5.5', then set increment modifier on AdvertisingRouter field with count=10, step=2.\",\n  \"Subtask 12\": \"Edit Summary TOS Metric: set MetricReserved=20, then set increment modifier on MetricReserved field with count=10, step=2.\",\n  \"Subtask 13\": \"Create capture PDU pattern on second port: filter by OSPFv2 routerID='2.2.2.2'.\",\n  \"Subtask 14\": \"Apply capture filter expression to second port using created PDU pattern.\",\n  \"Subtask 15\": \"Subscribe to StreamBlockStats view.\",\n  \"Subtask 16\": \"Configure first port transmission mode: set to BURST with burst count=100.\",\n  \"Subtask 17\": \"Save test configuration to file.\",\n  \"Subtask 18\": \"Start packet capture on second port.\",\n  \"Subtask 19\": \"Start traffic stream transmission on first port.\",\n  \"Subtask 20\": \"Wait for 10 seconds during transmission.\",\n  \"Subtask 21\": \"Stop traffic stream transmission.\",\n  \"Subtask 22\": \"Stop packet capture.\",\n  \"Subtask 23\": \"Download captured packets from second port.\",\n  \"Subtask 24\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 25\": \"Verify transmitted frames equal received frames (TxStreamFrames == RxStreamFrames).\",\n  \"Subtask 26\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Verify that the test instrument accurately counts transmitted OSPFv2 Link State Update Instance packets\n\nStep         :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Test Step 2: Modify the OSPFv2 Link State Update Instance header of traffic stream StreamTemplate_1;\n                Test Step 3: Configure filtered packet capture;\n                Test Step 4: Subscribe to StreamBlockStats;\n                Test Step 5: Set port transmission mode to burst;\n                Test Step 6: Transmit all traffic and wait for a period;\n                Test Step 7: Stop all traffic and examine StreamBlockStats;\n\nCriteria     :   Expected Result 1: In step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstateupdate']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2头部\n    header = edit_header_ospfv2_update(Stream=stream, Level=0,\n                                       RouterID='2.2.2.2', AuthType='MD5')\n\n    router_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Router',\n                                               RouterLsaReserved1=10,\n                                               LsaAge=20,\n                                               Reserved7=1,\n                                               Reserved7Router=0,\n                                               )\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['RouterLsaReserved1'],\n    #               Type='Increment',\n    #               Count=10, Step=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['LsaAge'],\n    #               Type='Increment',\n    #               Count=10, Step=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['Reserved7'],\n    #               Type='Increment',\n    #               Count=2, Step=1)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['Reserved7Router'],\n    #               Type='Increment',\n    #               Count=2, Step=1)\n\n    router_lsa_link = edit_header_ospfv2_update_route_lsa_link(Stream=stream,\n                                                               LinkId='3.3.3.3')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=router_lsa_link['LinkId'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    router_lsa_link_metric = edit_header_ospfv2_update_route_link_tos_metric(Stream=stream,\n                                                                             RouterLsaMetricReserved=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=router_lsa_link_metric['RouterLsaMetricReserved'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    network_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Network', Index=1,\n                                                LsType=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=network_lsa['LsType'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    network_attached_router = edit_header_ospfv2_update_network_attached_route(Stream=stream, LsaIndex=1,\n                                                                               RouterID='4.4.4.4')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=network_attached_router['RouterID'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    summary_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Summary', Index=2,\n                                                AdvertisingRouter='5.5.5.5')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=summary_lsa['AdvertisingRouter'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    summary_tos_metric = edit_header_ospfv2_update_tos_metric(Stream=stream, Type='Summary', LsaIndex=2,\n                                                              MetricReserved=20)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=summary_tos_metric['MetricReserved'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='ospfv2LinkStateUpdate_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_update:修改测试仪表流量模板中OSPFv2 Link State Update报文头部内容;\nedit_header_ospfv2_update_lsa:修改测试仪表流量模板中OSPFv2 Update报文中Lsa头部内容.;\nedit_header_ospfv2_update_route_link_tos_metric:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容;\nedit_header_ospfv2_update_route_lsa_link:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容;\nedit_header_ospfv2_update_tos_metric:修改测试仪表流量模板中OSPFv2 Update报文中Summary、 SummaryAsbr或AsExternal Lsa头部Tos Metric内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/MstpConfig.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的mstp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify the test instrument accurately counts traffic statistics\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a stream, StreamTemplate_1, on port Port_1;\n      Step 3: Modify the MSTP header content of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats;\n      Step 5: Transmit all streams and wait for a period;\n      Step 6: Stop all streams and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, packets received and sent for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'logicLinkControl', 'cfg'])\n\n    # 修改mstp头部\n    attr = edit_header_mstp_config(Stream=stream, Level=0,\n                                   RootBridgeSystemID='22:11:11:11:11:11',\n                                   MstInstances=1)\n    edit_modifier(Stream=stream, Attribute=attr['RootBridgeSystemID'],\n                  Type='Increment', Count=10, HeaderType='cfg')\n    attr_ins = edit_header_mstp_config_mst_instance(Stream=stream,\n                                                    RemainingHops=255)\n    edit_modifier(Stream=stream, Attribute=attr_ins['RemainingHops'],\n                  Type='Increment', Count=10, HeaderType='cfg')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using the specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using provided locations.\",\n  \"Subtask 3\": \"Create a stream (StreamTemplate_1) on Port_1.\",\n  \"Subtask 4\": \"Edit the stream to set frame length type to 'AUTO'.\",\n  \"Subtask 5\": \"Create stream headers for ethernetii, logicLinkControl, and cfg protocols.\",\n  \"Subtask 6\": \"Modify MSTP header configuration: set Level=0, RootBridgeSystemID='22:11:11:11:11:11', and MstInstances=1.\",\n  \"Subtask 7\": \"Configure increment modifier for RootBridgeSystemID attribute (Increment by 10 for 10 counts).\",\n  \"Subtask 8\": \"Modify MSTP instance header configuration: set RemainingHops=255.\",\n  \"Subtask 9\": \"Configure increment modifier for RemainingHops attribute (Increment by 10 for 10 counts).\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 11\": \"Configure port load profile for Port_1: set TransmitMode='BURST' and BurstCount=100.\",\n  \"Subtask 12\": \"Save the test configuration to a file.\",\n  \"Subtask 13\": \"Start stream transmission.\",\n  \"Subtask 14\": \"Wait until all streams stop transmitting.\",\n  \"Subtask 15\": \"Wait 3 seconds after stream stop to ensure accurate statistics collection.\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats results for StreamTemplate_1.\",\n  \"Subtask 17\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both equal the burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify the test instrument accurately counts traffic statistics\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a stream, StreamTemplate_1, on port Port_1;\n      Step 3: Modify the MSTP header content of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats;\n      Step 5: Transmit all streams and wait for a period;\n      Step 6: Stop all streams and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, packets received and sent for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'logicLinkControl', 'cfg'])\n\n    # 修改mstp头部\n    attr = edit_header_mstp_config(Stream=stream, Level=0,\n                                   RootBridgeSystemID='22:11:11:11:11:11',\n                                   MstInstances=1)\n    edit_modifier(Stream=stream, Attribute=attr['RootBridgeSystemID'],\n                  Type='Increment', Count=10, HeaderType='cfg')\n    attr_ins = edit_header_mstp_config_mst_instance(Stream=stream,\n                                                    RemainingHops=255)\n    edit_modifier(Stream=stream, Attribute=attr_ins['RemainingHops'],\n                  Type='Increment', Count=10, HeaderType='cfg')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl1psnpHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    : Verify the accuracy of traffic statistics from the test instrument\n\nStep        : Step 1: Reserve two loopback ports, Port_1 and Port_2;\n             Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n             Step 3: Modify the ISIS header content of StreamTemplate_1;\n             Step 4: Subscribe to StreamBlockStats statistics;\n             Step 5: Transmit all traffic and wait for a duration;\n             Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    : Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by  : Tester-002\n\nBugs        : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1psnpHeader'])\n\n    header = edit_header_isis_psnp(Stream=stream,\n                                   LengthIndicator=10,\n                                   CsnpDataTlvOptionHeader=['isIsLspEntries', 'authentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=header['LengthIndicator'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries',\n                                      Length=10,\n                                      LspEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=tlv['Length'],\n                  Type='Increment', Count=10)\n\n    entry = edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=entry['RemainTime'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1psnpHeader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports (Port_1 and Port_2) using reserve_port API with specified locations.\",\n  \"Subtask 2\": \"Create traffic stream StreamTemplate_1 on Port_1 using add_stream API.\",\n  \"Subtask 3\": \"Create stream headers for StreamTemplate_1 with EthernetII and l1psnpHeader using create_stream_header API.\",\n  \"Subtask 4\": \"Modify ISIS PSNP header in StreamTemplate_1: set LengthIndicator=10 and configure increment modifier using edit_header_isis_psnp and edit_modifier APIs.\",\n  \"Subtask 5\": \"Modify ISIS TLV header in StreamTemplate_1: set Option='IsIsLspEntries', Length=10 and configure increment modifier using edit_header_isis_tlv_header and edit_modifier APIs.\",\n  \"Subtask 6\": \"Modify ISIS LSP entry in StreamTemplate_1: set RemainTime=10 and configure increment modifier using edit_header_isis_lsp_entry and edit_modifier APIs.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics using subscribe_result API with type 'StreamBlockStats'.\",\n  \"Subtask 8\": \"Configure Port_1 transmit mode as burst with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Start traffic transmission using start_stream API and wait for completion using wait_stream_state API.\",\n  \"Subtask 10\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API and verify TxStreamFrames equals RxStreamFrames.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    : Verify the accuracy of traffic statistics from the test instrument\n\nStep        : Step 1: Reserve two loopback ports, Port_1 and Port_2;\n             Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n             Step 3: Modify the ISIS header content of StreamTemplate_1;\n             Step 4: Subscribe to StreamBlockStats statistics;\n             Step 5: Transmit all traffic and wait for a duration;\n             Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    : Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by  : Tester-002\n\nBugs        : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1psnpHeader'])\n\n    header = edit_header_isis_psnp(Stream=stream,\n                                   LengthIndicator=10,\n                                   CsnpDataTlvOptionHeader=['isIsLspEntries', 'authentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=header['LengthIndicator'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries',\n                                      Length=10,\n                                      LspEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=tlv['Length'],\n                  Type='Increment', Count=10)\n\n    entry = edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=entry['RemainTime'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1psnpHeader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Gtpv1.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发gtpv1报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的gtpv1头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Purpose: Verify the test instrument correctly counts GTPv1 packets sent\n\nStep          : Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Step 2: Modify GTPv1 header content in traffic stream StreamTemplate_1;\n               Step 3: Configure filtered packet capture;\n               Step 4: Subscribe to StreamBlockStats counters;\n               Step 5: Set port transmission mode to burst;\n               Step 6: Transmit all traffic streams and wait;\n               Step 7: Stop all traffic and check StreamBlockStats data;\n\nCriteria      : Expected Result 1: Packets sent/received for StreamTemplate_1 match in Step 6;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TCP', 'gtpv1', 'gtpv1opt', 'gtpv1ext']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改gtp头部\n    gtp = edit_header_gtpv1(Stream=stream, Teid=10)\n    opt = edit_header_gtpv1_optional(Stream=stream, Sequence=20)\n    optext = edit_header_gtpv1_optional_extension(Stream=stream, NPDUNumber=30)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1', Attribute=gtp['Teid'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1opt', Attribute=opt['Sequence'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1ext', Attribute=optext['NPDUNumber'],\n                  Type='Increment', Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='gtpv1_1.version',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (default 'DarYu' or command-line input).\",\n  \"Subtask 2\": \"Reserve two ports based on provided locations (default or command-line input).\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Create stream headers: EthernetII, IPv4, TCP, GTPv1, GTPv1 optional, and GTPv1 extension.\",\n  \"Subtask 5\": \"Edit GTPv1 header fields: set initial TEID=10, Sequence=20, and NPDU Number=30.\",\n  \"Subtask 6\": \"Configure modifiers for GTPv1 fields: increment TEID by 2 for 10 counts, Sequence by 2 for 10 counts, NPDU Number by 2 for 10 counts.\",\n  \"Subtask 7\": \"Create capture filter on second port: GTPv1 packets with version=1.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats counter view.\",\n  \"Subtask 9\": \"Configure first port's transmission mode: burst mode with count=100 packets.\",\n  \"Subtask 10\": \"Save test configuration to file.\",\n  \"Subtask 11\": \"Start packet capture on second port.\",\n  \"Subtask 12\": \"Start traffic transmission on first port.\",\n  \"Subtask 13\": \"Wait 10 seconds during transmission.\",\n  \"Subtask 14\": \"Stop traffic transmission.\",\n  \"Subtask 15\": \"Stop packet capture.\",\n  \"Subtask 16\": \"Download captured packets from second port to local directory.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats counters for the traffic stream.\",\n  \"Subtask 18\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 19\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Purpose: Verify the test instrument correctly counts GTPv1 packets sent\n\nStep          : Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Step 2: Modify GTPv1 header content in traffic stream StreamTemplate_1;\n               Step 3: Configure filtered packet capture;\n               Step 4: Subscribe to StreamBlockStats counters;\n               Step 5: Set port transmission mode to burst;\n               Step 6: Transmit all traffic streams and wait;\n               Step 7: Stop all traffic and check StreamBlockStats data;\n\nCriteria      : Expected Result 1: Packets sent/received for StreamTemplate_1 match in Step 6;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TCP', 'gtpv1', 'gtpv1opt', 'gtpv1ext']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改gtp头部\n    gtp = edit_header_gtpv1(Stream=stream, Teid=10)\n    opt = edit_header_gtpv1_optional(Stream=stream, Sequence=20)\n    optext = edit_header_gtpv1_optional_extension(Stream=stream, NPDUNumber=30)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1', Attribute=gtp['Teid'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1opt', Attribute=opt['Sequence'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1ext', Attribute=optext['NPDUNumber'],\n                  Type='Increment', Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='gtpv1_1.version',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2UpdateRouteLsa.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 link state update报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的ospfv2 link state update头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify that the test instrument correctly counts OSPFv2 Link State Update packets sent\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the OSPFv2 Link State Update header content in traffic stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: For traffic stream StreamTemplate_1 in Step 6, transmitted and received packet counts are equal;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n\n    stream = add_stream(Ports=Port_UP, FixedLength=256)\n\n    # 修改流量报文头部\n\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'ospfv2linkstateupdate'])\n\n    # 修改ospfv2 link state update头部，添加一个Router LSA\n\n    LsaHeaders = ['Router']\n    edit_header_ospfv2_update(Stream=stream, Level=0,\n                              RouterID='10.1.1.2',\n                              AreaID='0.0.0.2',\n                              AuthValue2=1,\n                              LsaHeaders=LsaHeaders,\n                              )\n\n    # 修改ospfv2 link state update头部，Router LSA内容，并添加4个Lsa Link即RouterLsaLinkCount=4\n\n    edit_header_ospfv2_update_lsa(Stream=stream, Level=0,\n                                  Index=0,\n                                  Type='Router',\n                                  LinkStateId='10.1.0.1',\n                                  AdvertisingRouter='10.1.0.2',\n                                  RouterLsaLinkCount=4,\n                                  )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第一个RouterLsaLinkCount内容即Index=0\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=0,\n                                             LinkId='10.1.0.0',\n                                             LinkData='255.255.255.255',\n                                             RouterLsaLinkType=3,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第二个RouterLsaLinkCount内容即Index=1\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=1,\n                                             LinkId='10.2.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=2,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第三个RouterLsaLinkCount内容即Index=2\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=2,\n                                             LinkId='10.3.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=4,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第四个RouterLsaLinkCount内容即Index=3\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=3,\n                                             LinkId='10.4.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=1,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 订阅StreamBlockStats统计视图\n\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n\n    start_capture()\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_capture()\n\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(stream, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 释放端口资源\n\n    result = release_port(Locations=locations)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_update:修改测试仪表流量模板中OSPFv2 Link State Update报文头部内容",
      "edit_header_ospfv2_update_lsa:修改测试仪表流量模板中OSPFv2 Update报文中Lsa头部内容.",
      "edit_header_ospfv2_update_route_lsa_link:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using 'init_tester' API with specified product parameter.\",\n  \"Subtask 2\": \"Reserve two ports using 'reserve_port' API with provided locations, assigning them to Port_1 (sending port) and Port_2 (receiving port).\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 using 'add_stream' API with fixed length of 256 bytes, assigning it to stream variable.\",\n  \"Subtask 4\": \"Configure stream headers for EthernetII, IPv4, and OSPFv2 Link State Update using 'create_stream_header' API.\",\n  \"Subtask 5\": \"Modify OSPFv2 Link State Update header using 'edit_header_ospfv2_update' API with parameters: RouterID='10.1.1.2', AreaID='0.0.0.2', AuthValue2=1, and LSA type 'Router'.\",\n  \"Subtask 6\": \"Edit Router LSA header using 'edit_header_ospfv2_update_lsa' API with parameters: LinkStateId='10.1.0.1', AdvertisingRouter='10.1.0.2', RouterLsaLinkCount=4.\",\n  \"Subtask 7\": \"Configure first Router LSA link (index 0) using 'edit_header_ospfv2_update_route_lsa_link' API with parameters: LinkId='10.1.0.0', LinkData='255.255.255.255', RouterLsaLinkType=3.\",\n  \"Subtask 8\": \"Configure second Router LSA link (index 1) using 'edit_header_ospfv2_update_route_lsa_link' API with parameters: LinkId='10.2.0.0', LinkData='255.255.0.0', RouterLsaLinkType=2.\",\n  \"Subtask 9\": \"Configure third Router LSA link (index 2) using 'edit_header_ospfv2_update_route_lsa_link' API with parameters: LinkId='10.3.0.0', LinkData='255.255.0.0', RouterLsaLinkType=4.\",\n  \"Subtask 10\": \"Configure fourth Router LSA link (index 3) using 'edit_header_ospfv2_update_route_lsa_link' API with parameters: LinkId='10.4.0.0', LinkData='255.255.0.0', RouterLsaLinkType=1.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics using 'subscribe_result' API.\",\n  \"Subtask 12\": \"Start packet capture on both ports using 'start_capture' API.\",\n  \"Subtask 13\": \"Transmit traffic stream using 'start_stream' API.\",\n  \"Subtask 14\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission using 'stop_stream' API.\",\n  \"Subtask 16\": \"Stop packet capture using 'stop_capture' API.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats using 'get_streamblock_statistic' API for the created stream.\",\n  \"Subtask 18\": \"Verify transmitted packet count (TxStreamFrames) equals received packet count (RxStreamFrames); if not equal, mark test as failed.\",\n  \"Subtask 19\": \"Download captured packets from Port_2 using 'download_packages' API with specified directory and filename.\",\n  \"Subtask 20\": \"Release reserved ports using 'release_port' API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify that the test instrument correctly counts OSPFv2 Link State Update packets sent\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the OSPFv2 Link State Update header content in traffic stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: For traffic stream StreamTemplate_1 in Step 6, transmitted and received packet counts are equal;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n\n    stream = add_stream(Ports=Port_UP, FixedLength=256)\n\n    # 修改流量报文头部\n\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'ospfv2linkstateupdate'])\n\n    # 修改ospfv2 link state update头部，添加一个Router LSA\n\n    LsaHeaders = ['Router']\n    edit_header_ospfv2_update(Stream=stream, Level=0,\n                              RouterID='10.1.1.2',\n                              AreaID='0.0.0.2',\n                              AuthValue2=1,\n                              LsaHeaders=LsaHeaders,\n                              )\n\n    # 修改ospfv2 link state update头部，Router LSA内容，并添加4个Lsa Link即RouterLsaLinkCount=4\n\n    edit_header_ospfv2_update_lsa(Stream=stream, Level=0,\n                                  Index=0,\n                                  Type='Router',\n                                  LinkStateId='10.1.0.1',\n                                  AdvertisingRouter='10.1.0.2',\n                                  RouterLsaLinkCount=4,\n                                  )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第一个RouterLsaLinkCount内容即Index=0\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=0,\n                                             LinkId='10.1.0.0',\n                                             LinkData='255.255.255.255',\n                                             RouterLsaLinkType=3,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第二个RouterLsaLinkCount内容即Index=1\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=1,\n                                             LinkId='10.2.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=2,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第三个RouterLsaLinkCount内容即Index=2\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=2,\n                                             LinkId='10.3.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=4,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第四个RouterLsaLinkCount内容即Index=3\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=3,\n                                             LinkId='10.4.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=1,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 订阅StreamBlockStats统计视图\n\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n\n    start_capture()\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_capture()\n\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(stream, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 释放端口资源\n\n    result = release_port(Locations=locations)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_update:修改测试仪表流量模板中OSPFv2 Link State Update报文头部内容;\nedit_header_ospfv2_update_lsa:修改测试仪表流量模板中OSPFv2 Update报文中Lsa头部内容.;\nedit_header_ospfv2_update_route_lsa_link:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2TPv3DataOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Data Over Udp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test objective: Verify the accuracy of the test instrument's traffic statistics\n\nStep: Test step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Test step 3: Modify the L2TPv3 Data Over UDP header content of stream StreamTemplate_1;\n      Test step 4: Subscribe to StreamBlockStats statistics;\n      Test step 5: Transmit all traffic and wait for a period;\n      Test step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-003\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp'])\n\n    # 修改icmpv4 echo reply头部\n    edit_header_l2tpv3_data_over_udp(Stream=stream, Level=0,\n                                     Type=1,\n                                     Reserved1='00000000001',\n                                     Version=1,\n                                     Reserved2=1,\n                                     SessionId=1,\n                                     Cookie4Byte='00000001',\n                                     L2specificsublayer={'xbit': 1, 'sbit': 1, 'xbits': '000001', 'sequence': 1}, )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp'],\n                                             FieldName='l2tpv3DataOverUdp_1.sessionId',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two test instrument ports: Port_1 as the transmitting port and Port_2 as the receiving port for loopback testing.\",\n  \"Subtask 2\": \"Create a traffic stream (StreamTemplate_1) on Port_1 with a fixed frame length of 512 bytes.\",\n  \"Subtask 3\": \"Construct the stream header for StreamTemplate_1 with protocol layers: Ethernet II, IPv4, UDP, and L2TPv3 Data over UDP.\",\n  \"Subtask 4\": \"Modify the L2TPv3 Data over UDP header parameters: set Type=1, Reserved1='00000000001', Version=1, Reserved2=1, SessionId=1, Cookie4Byte='00000001', and L2-specific sublayer with xbit=1, sbit=1, xbits='000001', sequence=1.\",\n  \"Subtask 5\": \"Subscribe to StreamBlockStats statistics view for performance monitoring.\",\n  \"Subtask 6\": \"Configure Port_1 transmission mode as BURST with burst count set to 100 packets.\",\n  \"Subtask 7\": \"Start traffic transmission from Port_1 and simultaneously begin packet capture on Port_2.\",\n  \"Subtask 8\": \"Wait for traffic transmission to complete and then pause for 3 seconds to stabilize statistics collection.\",\n  \"Subtask 9\": \"Stop packet capture on Port_2 after traffic transmission ends.\",\n  \"Subtask 10\": \"Retrieve StreamBlockStats statistics for StreamTemplate_1 to obtain transmitted (TxStreamFrames) and received (RxStreamFrames) packet counts.\",\n  \"Subtask 11\": \"Verify that TxStreamFrames equals RxStreamFrames and both match the configured burst count of 100 packets.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test objective: Verify the accuracy of the test instrument's traffic statistics\n\nStep: Test step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Test step 3: Modify the L2TPv3 Data Over UDP header content of stream StreamTemplate_1;\n      Test step 4: Subscribe to StreamBlockStats statistics;\n      Test step 5: Transmit all traffic and wait for a period;\n      Test step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-003\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp'])\n\n    # 修改icmpv4 echo reply头部\n    edit_header_l2tpv3_data_over_udp(Stream=stream, Level=0,\n                                     Type=1,\n                                     Reserved1='00000000001',\n                                     Version=1,\n                                     Reserved2=1,\n                                     SessionId=1,\n                                     Cookie4Byte='00000001',\n                                     L2specificsublayer={'xbit': 1, 'sbit': 1, 'xbits': '000001', 'sequence': 1}, )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp'],\n                                             FieldName='l2tpv3DataOverUdp_1.sessionId',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv2Report.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发igmpv2 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的igmpv2 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   : Verify that the test instrument correctly counts transmitted IGMPv2 report packets\nStep        : Step 1: Reserve two loopback ports: Port_1 and Port_2;\n             : Step 2: Modify the IGMPv2 report header content of traffic StreamTemplate_1;\n             : Step 3: Configure filtered packet capture;\n             : Step 4: Subscribe to StreamBlockStats statistics;\n             : Step 5: Set port transmission mode to burst;\n             : Step 6: Send all traffic and wait for a period;\n             : Step 7: Stop all traffic and check StreamBlockStats statistics;\nCriteria    : Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\nCreated by  : Tester-004\nBugs        : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv2']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv2_report(Stream=stream, Level=0, Type=99, MaxResponseTime='255', Checksum='ffff',\n                              GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.GroupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv2_report:修改测试仪表流量模板中IGMPv2 Report报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu' using the init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations using reserve_port API, assigning them as Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Build stream headers with EthernetII, IPv4, and IGMPv2 layers using create_stream_header API.\",\n  \"Subtask 5\": \"Modify IGMPv2 report header parameters: Type=99, MaxResponseTime='255', Checksum='ffff', GroupAddress='10.1.1.1' using edit_header_igmpv2_report API.\",\n  \"Subtask 6\": \"Create three PDU patterns on Port_2 for capture filtering: match igmpv2_1.type=99, igmpv2_1.Checksum='ffff', and igmpv2_1.GroupAddress='10.1.1.1' using create_capture_pdu_pattern API.\",\n  \"Subtask 7\": \"Configure packet capture filter on Port_2 with logical AND expression combining the three PDU patterns using edit_capture_filter API.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode as burst with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Start packet capture on Port_2 using start_capture API.\",\n  \"Subtask 11\": \"Transmit traffic from Port_1 using start_stream API.\",\n  \"Subtask 12\": \"Wait 10 seconds for traffic transmission and capture.\",\n  \"Subtask 13\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 14\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats using get_streamblock_statistic API and verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 16\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   : Verify that the test instrument correctly counts transmitted IGMPv2 report packets\nStep        : Step 1: Reserve two loopback ports: Port_1 and Port_2;\n             : Step 2: Modify the IGMPv2 report header content of traffic StreamTemplate_1;\n             : Step 3: Configure filtered packet capture;\n             : Step 4: Subscribe to StreamBlockStats statistics;\n             : Step 5: Set port transmission mode to burst;\n             : Step 6: Send all traffic and wait for a period;\n             : Step 7: Stop all traffic and check StreamBlockStats statistics;\nCriteria    : Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\nCreated by  : Tester-004\nBugs        : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv2']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv2_report(Stream=stream, Level=0, Type=99, MaxResponseTime='255', Checksum='ffff',\n                              GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.GroupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv2_report:修改测试仪表流量模板中IGMPv2 Report报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/IPv6.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective      :   Test Objective: Verify the accuracy of IPv6 packet statistics transmitted by the test instrument\n\nStep           :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Modify the IPv6 header content of traffic StreamTemplate_1;\n                   Test Step 3: Configure packet capture filtering;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Set port transmission mode to burst packet;\n                   Test Step 6: Transmit all traffic and wait for a period;\n                   Test Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria       :   Expected Result 1: In Step 6, transmitted and received packets of StreamTemplate_1 are equal;\n\nCreated by     :   Tester-004\n\nBugs           :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6fragmentheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ipv6头部\n    attribute_dict = edit_header_ipv6(Stream=stream, Level=0, HopLimit=20,\n                                      Source='2022::2', Destination='2020::2', Gateway='2022::1')\n    # ipv6头部HopLimit字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['HopLimit'],\n                  Type='Increment', Count=10, Step=2)\n    # ipv6头部Source字段添加List跳变\n#    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['Source'],\n#                  Type='List', List=['2022::2', '2022::5', '2022::3'])\n    # ipv6头部Destination的Length字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['Destination'],\n                  Type='Random', Range='2020::10')\n    # ipv6 fragment\n    attr = edit_header_ipv6_fragment(Stream=stream, NextHeader=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6fragmentheader', Attribute=attr['NextHeader'],\n                  Type='Increment', Count=10, Step=2)\n\n    # 配置过滤抓包\n    # 使用Level和Attribute参数添加pdu_pattern\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            Level=1,\n    #                                            Attribute=attribute_dict['HopLimit'],\n    #                                            Value=20, MaxValue=22)\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            Level=1,\n    #                                            Attribute=attribute_dict['Source'],\n    #                                            Value='2022::2', MaxValue='2022::2')\n    # 使用FieldName参数添加pdu_pattern\n    # pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ipv6_1.destination',\n    #                                            Value='2020::2', MaxValue='2020::2')\n    # edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv6:修改测试仪表流量模板中IPv6报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports Port_1 and Port_2 using reserve_port API with specified locations.\",\n  \"Subtask 2\": \"Create a traffic stream on Port_1 using add_stream API with fixed length of 256 bytes.\",\n  \"Subtask 3\": \"Configure stream headers for EthernetII, IPv6, and ipv6fragmentheader using create_stream_header API.\",\n  \"Subtask 4\": \"Modify IPv6 header fields (HopLimit, Source, Destination) using edit_header_ipv6 API.\",\n  \"Subtask 5\": \"Apply increment modifier to IPv6 HopLimit field using edit_modifier API with Count=10 and Step=2.\",\n  \"Subtask 6\": \"Apply random modifier to IPv6 Destination field using edit_modifier API with Range='2020::10'.\",\n  \"Subtask 7\": \"Apply increment modifier to ipv6fragmentheader NextHeader field using edit_modifier API.\",\n  \"Subtask 8\": \"Configure packet capture filtering on Port_2 by creating PDU patterns and setting filter expression (commented in code but required by intent).\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 10\": \"Set Port_1 transmission mode to burst with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 11\": \"Save test configuration using save_case API.\",\n  \"Subtask 12\": \"Start packet capture on Port_2 using start_capture API.\",\n  \"Subtask 13\": \"Transmit traffic from Port_1 using start_stream API.\",\n  \"Subtask 14\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 16\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 17\": \"Download captured packets from Port_2 using download_packages API.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats using get_streamblock_statistic API and verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 19\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective      :   Test Objective: Verify the accuracy of IPv6 packet statistics transmitted by the test instrument\n\nStep           :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Modify the IPv6 header content of traffic StreamTemplate_1;\n                   Test Step 3: Configure packet capture filtering;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Set port transmission mode to burst packet;\n                   Test Step 6: Transmit all traffic and wait for a period;\n                   Test Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria       :   Expected Result 1: In Step 6, transmitted and received packets of StreamTemplate_1 are equal;\n\nCreated by     :   Tester-004\n\nBugs           :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6fragmentheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ipv6头部\n    attribute_dict = edit_header_ipv6(Stream=stream, Level=0, HopLimit=20,\n                                      Source='2022::2', Destination='2020::2', Gateway='2022::1')\n    # ipv6头部HopLimit字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['HopLimit'],\n                  Type='Increment', Count=10, Step=2)\n    # ipv6头部Source字段添加List跳变\n#    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['Source'],\n#                  Type='List', List=['2022::2', '2022::5', '2022::3'])\n    # ipv6头部Destination的Length字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['Destination'],\n                  Type='Random', Range='2020::10')\n    # ipv6 fragment\n    attr = edit_header_ipv6_fragment(Stream=stream, NextHeader=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6fragmentheader', Attribute=attr['NextHeader'],\n                  Type='Increment', Count=10, Step=2)\n\n    # 配置过滤抓包\n    # 使用Level和Attribute参数添加pdu_pattern\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            Level=1,\n    #                                            Attribute=attribute_dict['HopLimit'],\n    #                                            Value=20, MaxValue=22)\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            Level=1,\n    #                                            Attribute=attribute_dict['Source'],\n    #                                            Value='2022::2', MaxValue='2022::2')\n    # 使用FieldName参数添加pdu_pattern\n    # pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ipv6_1.destination',\n    #                                            Value='2020::2', MaxValue='2020::2')\n    # edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv6:修改测试仪表流量模板中IPv6报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Mpls.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发mpls报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的mpls头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Objective: Verify the test instrument's accurate MPLS packet statistics\n\nStep        :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Step 2: Modify the MPLS header content of traffic StreamTemplate_1;\n                Step 3: Configure packet capture filtering;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Set port transmission mode to burst packet;\n                Step 6: Transmit all traffic and wait for a period;\n                Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria    :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by  :   Tester-004\n\nBugs        :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Log=True)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'mpls']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改mpls头部\n    attribute_dict = edit_header_mpls(Stream=stream, Level=0, Label=32, Exp='001', TTL=200)\n    # mpls头部Label字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['Label'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # mpls头部目Exp字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['Exp'],\n                  Type='List',\n                  List=['001', '011', '110'])\n    # mpls头部目TTL字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['TTL'],\n                  Type='Random',\n                  Range=1000)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mpls_1.label',\n                                               Value='32', MaxValue='32')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mpls_1.ttl',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_mpls:修改测试仪表流量模板中MPLS报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product and enable logging using init_tester.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations using reserve_port.\",\n  \"Subtask 3\": \"Create a stream on the first reserved port with fixed length of 256 bytes using add_stream.\",\n  \"Subtask 4\": \"Create stream headers of type EthernetII and MPLS using create_stream_header.\",\n  \"Subtask 5\": \"Modify MPLS header at level 0 to set Label=32, Exp='001', TTL=200 using edit_header_mpls.\",\n  \"Subtask 6\": \"Configure increment modifier for MPLS Label field with count=10 and step=2 using edit_modifier.\",\n  \"Subtask 7\": \"Configure list modifier for MPLS Exp field with values ['001','011','110'] using edit_modifier.\",\n  \"Subtask 8\": \"Configure random modifier for MPLS TTL field within range 1000 using edit_modifier.\",\n  \"Subtask 9\": \"Create PDU pattern for MPLS label=32 on second port using create_capture_pdu_pattern.\",\n  \"Subtask 10\": \"Create PDU pattern for MPLS TTL=200 on second port using create_capture_pdu_pattern.\",\n  \"Subtask 11\": \"Set capture filter on second port using logical AND of both PDU patterns via edit_capture_filter.\",\n  \"Subtask 12\": \"Subscribe to StreamBlockStats statistics using subscribe_result.\",\n  \"Subtask 13\": \"Set first port's transmission mode to BURST with burst count=100 using edit_port_load_profile.\",\n  \"Subtask 14\": \"Save test configuration to file using save_case.\",\n  \"Subtask 15\": \"Start packet capture on second port using start_capture.\",\n  \"Subtask 16\": \"Start stream transmission using start_stream.\",\n  \"Subtask 17\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 18\": \"Stop stream transmission using stop_stream.\",\n  \"Subtask 19\": \"Stop packet capture using stop_capture.\",\n  \"Subtask 20\": \"Wait 3 seconds for capture finalization.\",\n  \"Subtask 21\": \"Download captured packets from second port to specified directory using download_packages.\",\n  \"Subtask 22\": \"Retrieve StreamBlockStats for the stream using get_streamblock_statistic.\",\n  \"Subtask 23\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 24\": \"Release reserved ports using release_port.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Objective: Verify the test instrument's accurate MPLS packet statistics\n\nStep        :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Step 2: Modify the MPLS header content of traffic StreamTemplate_1;\n                Step 3: Configure packet capture filtering;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Set port transmission mode to burst packet;\n                Step 6: Transmit all traffic and wait for a period;\n                Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria    :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by  :   Tester-004\n\nBugs        :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Log=True)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'mpls']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改mpls头部\n    attribute_dict = edit_header_mpls(Stream=stream, Level=0, Label=32, Exp='001', TTL=200)\n    # mpls头部Label字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['Label'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # mpls头部目Exp字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['Exp'],\n                  Type='List',\n                  List=['001', '011', '110'])\n    # mpls头部目TTL字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['TTL'],\n                  Type='Random',\n                  Range=1000)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mpls_1.label',\n                                               Value='32', MaxValue='32')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mpls_1.ttl',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_mpls:修改测试仪表流量模板中MPLS报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ancp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的ANCP头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test objective: Verify accurate traffic statistics generation by the test instrument  \n\nStep:  \n1. Reserve two loopback ports: Port_1 and Port_2  \n2. Create traffic stream StreamTemplate_1 on Port_1  \n3. Modify ANCP header content of StreamTemplate_1  \n4. Subscribe to StreamBlockStats  \n5. Transmit all traffic and wait  \n6. Stop all traffic and check StreamBlockStats  \n\nCriteria:  \nExpected result 1: Received and transmitted packets for StreamTemplate_1 are equal in Step 6  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['portManagement'])\n\n    # 修改ancp头部\n    attr = edit_header_ancp(Stream=stream, Level=0,\n                            Version=20,\n                            AccessLineIdentifyingTlvs=1,\n                            TestingRelatedTlvs=1,\n                            StatusInfoTlvs=1)\n    edit_modifier(Stream=stream, Attribute=attr['Version'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    access_attr = edit_header_ancp_access_line_identifying_tlv(Stream=stream,\n                                                               Value='102030')\n    edit_modifier(Stream=stream, Attribute=access_attr['Value'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    testing_attr = edit_header_ancp_testing_related_tlv(Stream=stream,\n                                                        Value1='405060')\n    edit_modifier(Stream=stream, Attribute=testing_attr['Value1'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    edit_header_ancp_status_info_tlv(Stream=stream,\n                                     OptionalSubTLV=1)\n    optinal_attr = edit_header_ancp_status_info_tlv_optional_sub_tlv(Stream=stream,\n                                                                     Data='708090')\n    edit_modifier(Stream=stream, Attribute=optinal_attr['Data'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with specified product configuration (default 'DarYu' or from command line argument).\",\n  \"Subtask 2\": \"Reserve two ports using provided locations (default '//10.0.11.191/1/5' and '//10.0.11.191/1/6' or command line arguments) and assign them as Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API.\",\n  \"Subtask 4\": \"Create stream header of type 'portManagement' for the traffic stream using create_stream_header API.\",\n  \"Subtask 5\": \"Edit ANCP header version to 20 and set required TLV flags (AccessLineIdentifyingTlvs, TestingRelatedTlvs, StatusInfoTlvs) at level 0 using edit_header_ancp API.\",\n  \"Subtask 6\": \"Apply increment modifier to ANCP version field with count=10 and type='Increment' using edit_modifier API.\",\n  \"Subtask 7\": \"Edit ANCP Access Line Identifying TLV value to '102030' and apply increment modifier with count=10 using edit_header_ancp_access_line_identifying_tlv and edit_modifier APIs.\",\n  \"Subtask 8\": \"Edit ANCP Testing Related TLV value to '405060' and apply increment modifier with count=10 using edit_header_ancp_testing_related_tlv and edit_modifier APIs.\",\n  \"Subtask 9\": \"Edit ANCP Status Info TLV to enable OptionalSubTLV and set its data to '708090', then apply increment modifier with count=10 using edit_header_ancp_status_info_tlv, edit_header_ancp_status_info_tlv_optional_sub_tlv and edit_modifier APIs.\",\n  \"Subtask 10\": \"Subscribe to PortStats and StreamBlockStats statistics views using subscribe_result API.\",\n  \"Subtask 11\": \"Configure port load profile for Port_UP with TransmitMode='BURST' and BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 12\": \"Save test configuration to file path derived from current script name and location using save_case API.\",\n  \"Subtask 13\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 14\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 15\": \"Wait 3 seconds after traffic stops to ensure accurate statistics collection.\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API and extract TxStreamFrames and RxStreamFrames values.\",\n  \"Subtask 17\": \"Verify TxStreamFrames equals RxStreamFrames and both equal the configured BurstCount (100), setting verdict to 'fail' if mismatch occurs.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test objective: Verify accurate traffic statistics generation by the test instrument  \n\nStep:  \n1. Reserve two loopback ports: Port_1 and Port_2  \n2. Create traffic stream StreamTemplate_1 on Port_1  \n3. Modify ANCP header content of StreamTemplate_1  \n4. Subscribe to StreamBlockStats  \n5. Transmit all traffic and wait  \n6. Stop all traffic and check StreamBlockStats  \n\nCriteria:  \nExpected result 1: Received and transmitted packets for StreamTemplate_1 are equal in Step 6  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['portManagement'])\n\n    # 修改ancp头部\n    attr = edit_header_ancp(Stream=stream, Level=0,\n                            Version=20,\n                            AccessLineIdentifyingTlvs=1,\n                            TestingRelatedTlvs=1,\n                            StatusInfoTlvs=1)\n    edit_modifier(Stream=stream, Attribute=attr['Version'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    access_attr = edit_header_ancp_access_line_identifying_tlv(Stream=stream,\n                                                               Value='102030')\n    edit_modifier(Stream=stream, Attribute=access_attr['Value'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    testing_attr = edit_header_ancp_testing_related_tlv(Stream=stream,\n                                                        Value1='405060')\n    edit_modifier(Stream=stream, Attribute=testing_attr['Value1'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    edit_header_ancp_status_info_tlv(Stream=stream,\n                                     OptionalSubTLV=1)\n    optinal_attr = edit_header_ancp_status_info_tlv_optional_sub_tlv(Stream=stream,\n                                                                     Data='708090')\n    edit_modifier(Stream=stream, Attribute=optinal_attr['Data'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/LldpEnd.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的lldp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Purpose: Verify that the test instrument's traffic transmission statistics are correct\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the LLDP header content of traffic stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Transmit all traffic and wait for a period;\n                   Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-002\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv', 'ttltlv', 'endtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_end_tlv(Stream=stream, Level=0, Length=10)\n    edit_modifier(Stream=stream, Attribute=attr['Length'],\n                  Type='Increment', Count=10, HeaderType='endtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product (e.g., 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_UP and Port_Down) using reserve_port API with provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API.\",\n  \"Subtask 4\": \"Edit the stream parameters to set frame length type to 'AUTO' using edit_stream API.\",\n  \"Subtask 5\": \"Create stream headers including Ethernet II, Port ID TLV, TTL TLV, and End TLV using create_stream_header API.\",\n  \"Subtask 6\": \"Modify the End TLV header's length field by setting initial value to 10 and applying increment modifier with count 10 using edit_modifier API.\",\n  \"Subtask 7\": \"Subscribe to PortStats and StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 8\": \"Configure port load profile for Port_UP to burst mode with burst count 100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Save the current configuration to a file using save_case API.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 12\": \"Wait 3 seconds after traffic stops to ensure statistics collection.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 14\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames) and both equal the burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Purpose: Verify that the test instrument's traffic transmission statistics are correct\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the LLDP header content of traffic stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Transmit all traffic and wait for a period;\n                   Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-002\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv', 'ttltlv', 'endtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_end_tlv(Stream=stream, Level=0, Length=10)\n    edit_modifier(Stream=stream, Attribute=attr['Length'],\n                  Type='Increment', Count=10, HeaderType='endtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/LinkModifier.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv4报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv4头部内容;;\n                   测试步骤3: 设置link Modifer;\n\n Criteria    \t:   预期结果1: 配置无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   : Test Purpose: Verify that the test instrument correctly counts transmitted IPv4 packets\n\nStep        : Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\n             Test Step 2: Modify the IPv4 header content of traffic stream template StreamTemplate_1;\n             Test Step 3: Set the link modifier\n\nCriteria    : Expected Result 1: Configuration without abnormalities\n\nCreated by  : Tester-001\n\nBugs        : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port1, port2 = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=port1, FixedLength=256)\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n    # 修改ipv4头部\n    HeaderOption = ['Security', 'RouterAlert']\n    attribute_dict = edit_header_ipv4(Stream=stream, Level=0, TTL=200, Source='10.1.1.2', Destination='20.1.1.2',\n                                      Flags=111, HeaderOption=HeaderOption)\n    # ipv4头部Source字段添加Increment跳变\n    modifier_1 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=10, Step=2)\n\n    modifier_2 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=20, Step=2)\n\n    modifier_3 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Destination'],\n                               Type='Increment', Count=10, Step=2)\n\n    modifier_4 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Destination'],\n                               Type='Increment', Count=20, Step=2)\n    # 设置流量link modifer\n    link_modifier = [[modifier_1, modifier_2, modifier_3], [modifier_2, modifier_3, modifier_4], [modifier_3, modifier_4]]\n    edit_modifier_link(Stream=stream, Link=link_modifier)\n\n    # 保存配置\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 释放端口资源\n    release_port(locations)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using the init_tester API with the specified product platform.\",\n  \"Subtask 2\": \"Reserve two physical ports (Port_1 and Port_2) using reserve_port API based on provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Configure the stream headers to include EthernetII and IPv4 layers using create_stream_header API.\",\n  \"Subtask 5\": \"Modify IPv4 header parameters: set TTL=200, Source='10.1.1.2', Destination='20.1.1.2', Flags=111, and HeaderOptions=['Security','RouterAlert'] using edit_header_ipv4 API.\",\n  \"Subtask 6\": \"Create modifier_1 for IPv4 Source field: Increment type with Count=10 and Step=2 using edit_modifier API.\",\n  \"Subtask 7\": \"Create modifier_2 for IPv4 Source field: Increment type with Count=20 and Step=2 using edit_modifier API.\",\n  \"Subtask 8\": \"Create modifier_3 for IPv4 Destination field: Increment type with Count=10 and Step=2 using edit_modifier API.\",\n  \"Subtask 9\": \"Create modifier_4 for IPv4 Destination field: Increment type with Count=20 and Step=2 using edit_modifier API.\",\n  \"Subtask 10\": \"Configure link modifier relationships: [[modifier_1, modifier_2, modifier_3], [modifier_2, modifier_3, modifier_4], [modifier_3, modifier_4]] using edit_modifier_link API.\",\n  \"Subtask 11\": \"Save the complete test configuration to an .xcfg file using save_case API.\",\n  \"Subtask 12\": \"Release all reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   : Test Purpose: Verify that the test instrument correctly counts transmitted IPv4 packets\n\nStep        : Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\n             Test Step 2: Modify the IPv4 header content of traffic stream template StreamTemplate_1;\n             Test Step 3: Set the link modifier\n\nCriteria    : Expected Result 1: Configuration without abnormalities\n\nCreated by  : Tester-001\n\nBugs        : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port1, port2 = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=port1, FixedLength=256)\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n    # 修改ipv4头部\n    HeaderOption = ['Security', 'RouterAlert']\n    attribute_dict = edit_header_ipv4(Stream=stream, Level=0, TTL=200, Source='10.1.1.2', Destination='20.1.1.2',\n                                      Flags=111, HeaderOption=HeaderOption)\n    # ipv4头部Source字段添加Increment跳变\n    modifier_1 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=10, Step=2)\n\n    modifier_2 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=20, Step=2)\n\n    modifier_3 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Destination'],\n                               Type='Increment', Count=10, Step=2)\n\n    modifier_4 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Destination'],\n                               Type='Increment', Count=20, Step=2)\n    # 设置流量link modifer\n    link_modifier = [[modifier_1, modifier_2, modifier_3], [modifier_2, modifier_3, modifier_4], [modifier_3, modifier_4]]\n    edit_modifier_link(Stream=stream, Link=link_modifier)\n\n    # 保存配置\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 释放端口资源\n    release_port(locations)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Tcp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发tcp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的tcp头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Purpose: Verify the accuracy of TCP packet statistics transmitted by the test instrument.\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test Step 2: Modify the TCP header content of traffic StreamTemplate_1;\n      Test Step 3: Configure filter-based packet capture;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Set port transmission mode to burst packet;\n      Test Step 6: Transmit all traffic streams and wait for a period;\n      Test Step 7: Stop all traffic and examine StreamBlockStats information;\n\nCriteria: Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ipv4', 'tcp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改vlan头部\n    header = edit_header_tcp(Stream=stream, Level=0,\n                             SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Level=0, HeaderType='tcp',\n                  Attribute=header['SourcePort'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='tcp_1.destPort',\n                                               Value='2000', MaxValue='2000')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_tcp:修改测试仪表流量模板中TCP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports at the provided locations, assigning them to Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Create stream headers for the traffic stream with types: EthernetII, IPv4, TCP.\",\n  \"Subtask 5\": \"Edit TCP header of the traffic stream: set source port to 1000 and destination port to 2000 at level 0.\",\n  \"Subtask 6\": \"Configure modifier for TCP source port field: increment by step 2 for 10 counts.\",\n  \"Subtask 7\": \"On Port_2, create capture PDU pattern matching TCP destination port 2000 with header types EthernetII/IPv4/TCP.\",\n  \"Subtask 8\": \"Set capture filter on Port_2 using the created PDU pattern expression.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Configure Port_1 transmission mode to BURST with burst count 100.\",\n  \"Subtask 11\": \"Save current configuration to a file.\",\n  \"Subtask 12\": \"Start packet capture on Port_2.\",\n  \"Subtask 13\": \"Start traffic transmission on Port_1.\",\n  \"Subtask 14\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission on Port_1.\",\n  \"Subtask 16\": \"Stop packet capture on Port_2.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats for the traffic stream and verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 18\": \"Release all reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Purpose: Verify the accuracy of TCP packet statistics transmitted by the test instrument.\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test Step 2: Modify the TCP header content of traffic StreamTemplate_1;\n      Test Step 3: Configure filter-based packet capture;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Set port transmission mode to burst packet;\n      Test Step 6: Transmit all traffic streams and wait for a period;\n      Test Step 7: Stop all traffic and examine StreamBlockStats information;\n\nCriteria: Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ipv4', 'tcp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改vlan头部\n    header = edit_header_tcp(Stream=stream, Level=0,\n                             SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Level=0, HeaderType='tcp',\n                  Attribute=header['SourcePort'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='tcp_1.destPort',\n                                               Value='2000', MaxValue='2000')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_tcp:修改测试仪表流量模板中TCP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv3_DataOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 data over udp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 data over udp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify that the test instrument correctly counts L2TPv3 data over UDP packets\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\nStep 2: Modify the L2TPv3 data over UDP header content in traffic StreamTemplate_1;;\nStep 3: Configure filtered packet capture;\nStep 4: Subscribe to StreamBlockStats statistics;;\nStep 5: Set the port transmission mode to burst packets;\nStep 6: Send all traffic and wait for a period of time;\nStep 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In step 6, the traffic StreamTemplate_1 should have equal send and receive packets;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改l2tpv3DataOverUdp头部\n    header = edit_header_l2tpv3_data_over_udp(Stream=stream, Level=0, SessionId='1', Cookie8Byte='0000000000000001',\n                                     L2specificsublayer=1)\n    # 修改l2tpv3 data over udp头部选项\n    header_option = edit_header_l2tpv3_data_sublayer(Stream=stream, Type='L2specificsublayer', Xbit=1, Sbit=1, Sequence=10)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverUdp', Attribute=header_option['Sequence'],\n                  Type='Increment', Count=10)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverUdp', Attribute=header['Cookie8Byte'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3DataOverUdp_1.sessionId',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports using provided locations for Port_1 and Port_2.\",\n  \"Subtask 3\": \"Add a traffic stream on Port_1 with fixed frame length of 512 bytes.\",\n  \"Subtask 4\": \"Create stream headers: EthernetII, IPv4, UDP, and L2TPv3 data over UDP.\",\n  \"Subtask 5\": \"Edit L2TPv3 data over UDP header: set SessionId=1, Cookie8Byte='0000000000000001', enable L2 specific sublayer.\",\n  \"Subtask 6\": \"Edit L2TPv3 data sublayer: set Xbit=1, Sbit=1, Sequence=10.\",\n  \"Subtask 7\": \"Configure modifier for L2TPv3 Sequence field: increment by 1 for 10 packets.\",\n  \"Subtask 8\": \"Configure modifier for L2TPv3 Cookie8Byte field: increment by 1 for 10 packets.\",\n  \"Subtask 9\": \"Create PDU capture pattern on Port_2: filter L2TPv3 sessionId=1 with specified headers.\",\n  \"Subtask 10\": \"Apply capture filter expression to Port_2 using created PDU pattern.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 12\": \"Configure Port_1 transmission mode: burst mode with burst count=100.\",\n  \"Subtask 13\": \"Save test configuration to file.\",\n  \"Subtask 14\": \"Start packet capture on Port_2.\",\n  \"Subtask 15\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 16\": \"Wait 10 seconds during traffic transmission.\",\n  \"Subtask 17\": \"Stop traffic transmission.\",\n  \"Subtask 18\": \"Stop packet capture on Port_2.\",\n  \"Subtask 19\": \"Download captured packets from Port_2 to specified directory.\",\n  \"Subtask 20\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 21\": \"Verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 22\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify that the test instrument correctly counts L2TPv3 data over UDP packets\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\nStep 2: Modify the L2TPv3 data over UDP header content in traffic StreamTemplate_1;;\nStep 3: Configure filtered packet capture;\nStep 4: Subscribe to StreamBlockStats statistics;;\nStep 5: Set the port transmission mode to burst packets;\nStep 6: Send all traffic and wait for a period of time;\nStep 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In step 6, the traffic StreamTemplate_1 should have equal send and receive packets;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改l2tpv3DataOverUdp头部\n    header = edit_header_l2tpv3_data_over_udp(Stream=stream, Level=0, SessionId='1', Cookie8Byte='0000000000000001',\n                                     L2specificsublayer=1)\n    # 修改l2tpv3 data over udp头部选项\n    header_option = edit_header_l2tpv3_data_sublayer(Stream=stream, Type='L2specificsublayer', Xbit=1, Sbit=1, Sequence=10)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverUdp', Attribute=header_option['Sequence'],\n                  Type='Increment', Count=10)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverUdp', Attribute=header['Cookie8Byte'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3DataOverUdp_1.sessionId',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/ControlWord.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Control Word头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Purpose: Verify correct traffic statistics on the test instrument\n\nStep         :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                 Step 2: Create traffic stream StreamTemplate_1 on Port_1;\n                 Step 3: Modify the Control Word header of StreamTemplate_1;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Transmit all traffic and wait for a period;\n                 Step 6: Stop all traffic and check StreamBlockStats;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['cw', 'ethernetii', 'ipv4'])\n\n    # 修改Control Word头部\n    attr = edit_header_control_word(Stream=stream, Level=0,\n                                    Sn='65535')\n    edit_modifier(Stream=stream, Attribute=attr['Sn'],\n                  Type='Increment', Count=10, HeaderType='cw')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (default 'DarYu') to prepare the test environment.\",\n  \"Subtask 2\": \"Reserve two loopback ports using provided locations (e.g., '//10.0.11.191/1/5' and '//10.0.11.191/1/6') and assign them as Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 using the add_stream API function.\",\n  \"Subtask 4\": \"Create stream headers for the traffic stream including Control Word, Ethernet II, and IPv4 using create_stream_header API.\",\n  \"Subtask 5\": \"Modify the Control Word header by setting Sequence Number (Sn) to 65535 and configure an increment modifier for Sn field (increment by 1 for 10 packets).\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats using subscribe_result API to enable statistics collection.\",\n  \"Subtask 7\": \"Configure Port_1's load profile to burst mode with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 8\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 9\": \"Wait for traffic transmission to complete using wait_stream_state API, then wait 3 seconds for statistics stabilization.\",\n  \"Subtask 10\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API and record TxStreamFrames and RxStreamFrames values.\",\n  \"Subtask 11\": \"Verify TxStreamFrames equals RxStreamFrames to validate correct traffic statistics.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Purpose: Verify correct traffic statistics on the test instrument\n\nStep         :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                 Step 2: Create traffic stream StreamTemplate_1 on Port_1;\n                 Step 3: Modify the Control Word header of StreamTemplate_1;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Transmit all traffic and wait for a period;\n                 Step 6: Stop all traffic and check StreamBlockStats;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['cw', 'ethernetii', 'ipv4'])\n\n    # 修改Control Word头部\n    attr = edit_header_control_word(Stream=stream, Level=0,\n                                    Sn='65535')\n    edit_modifier(Stream=stream, Attribute=attr['Sn'],\n                  Type='Increment', Count=10, HeaderType='cw')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ethernet8023.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.3头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Verify the accuracy of traffic statistics from the test instrument  \n\nStep:  \nStep 1: Reserve two loopback ports, Port_1 and Port_2;  \nStep 2: Create a traffic stream StreamTemplate_1 on port Port_1;  \nStep 3: Modify the 802.3 header of stream StreamTemplate_1;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Send all traffic and wait for a period of time;  \nStep 6: Stop all traffic and check StreamBlockStats statistics;  \n\nCriteria:  \nExpected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['8023'])\n\n    # 修改802.3头部\n    attr = edit_header_8023(Stream=stream, Level=0,\n                            Oui='102030')\n    edit_modifier(Stream=stream, Attribute=attr['Oui'],\n                  Type='Increment', Count=10, HeaderType='8023')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (e.g., 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports using reserve_port API with provided locations.\",\n  \"Subtask 3\": \"Create traffic stream on upstream port using add_stream API.\",\n  \"Subtask 4\": \"Edit stream parameters to set frame length type to 'AUTO' using edit_stream API.\",\n  \"Subtask 5\": \"Create 802.3 header for the stream using create_stream_header API.\",\n  \"Subtask 6\": \"Modify 802.3 header Oui field to '102030' at level 0 using edit_header_8023 API.\",\n  \"Subtask 7\": \"Configure modifier for Oui field with increment type and count=10 using edit_modifier API.\",\n  \"Subtask 8\": \"Set port load profile to burst mode with burst count=100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats and PortStats using subscribe_result API.\",\n  \"Subtask 11\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 12\": \"Wait for traffic to stop automatically after burst transmission using wait_stream_state API.\",\n  \"Subtask 13\": \"Wait 3 seconds after traffic stops to ensure accurate statistics collection.\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats using get_streamblock_statistic API for the created stream.\",\n  \"Subtask 15\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both equal burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Verify the accuracy of traffic statistics from the test instrument  \n\nStep:  \nStep 1: Reserve two loopback ports, Port_1 and Port_2;  \nStep 2: Create a traffic stream StreamTemplate_1 on port Port_1;  \nStep 3: Modify the 802.3 header of stream StreamTemplate_1;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Send all traffic and wait for a period of time;  \nStep 6: Stop all traffic and check StreamBlockStats statistics;  \n\nCriteria:  \nExpected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['8023'])\n\n    # 修改802.3头部\n    attr = edit_header_8023(Stream=stream, Level=0,\n                            Oui='102030')\n    edit_modifier(Stream=stream, Attribute=attr['Oui'],\n                  Type='Increment', Count=10, HeaderType='8023')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl1csnpHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: To verify the accuracy of traffic transmission statistics on the test instrument.  \n\nStep:  \nStep 1: Reserve two loopback ports, Port_1 and Port_2;  \nStep 2: Create a traffic stream StreamTemplate_1 on port Port_1;  \nStep 3: Modify the IS-IS header content of traffic stream StreamTemplate_1;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Transmit all traffic and wait for a duration;  \nStep 6: Stop all traffic and examine StreamBlockStats statistics;  \n\nCriteria:  \nExpected result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1csnpheader'])\n\n    header = edit_header_isis_csnp(Stream=stream,\n                                   Version=1,\n                                   LspId='10203040506070',\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=header['LspId'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries',\n                                      TlvCode=10,\n                                      LspEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n\n    lsp = edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1,\n                                     RemainTime=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=lsp['RemainTime'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using their physical locations.\",\n  \"Subtask 3\": \"Create a traffic stream (StreamTemplate_1) on Port_1 with EthernetII and IS-IS L1 CSNP headers.\",\n  \"Subtask 4\": \"Modify the IS-IS CSNP header of StreamTemplate_1 by setting version, LSP ID, and CSNP data TLV options.\",\n  \"Subtask 5\": \"Apply increment modifiers to specific IS-IS header fields (version, LSP ID, TLV code, and remain time) with defined increment counts.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats and PortStats statistics views.\",\n  \"Subtask 7\": \"Configure Port_1's transmission mode as burst with a specified packet count (e.g., 100 packets).\",\n  \"Subtask 8\": \"Start traffic transmission on all streams and simultaneously begin packet capture.\",\n  \"Subtask 9\": \"Wait until traffic transmission completes and stop packet capture.\",\n  \"Subtask 10\": \"Retrieve StreamBlockStats statistics for StreamTemplate_1 and capture information from Port_2.\",\n  \"Subtask 11\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and match the configured burst count.\",\n  \"Subtask 12\": \"Check captured packet count matches transmitted burst count and downloaded packets.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: To verify the accuracy of traffic transmission statistics on the test instrument.  \n\nStep:  \nStep 1: Reserve two loopback ports, Port_1 and Port_2;  \nStep 2: Create a traffic stream StreamTemplate_1 on port Port_1;  \nStep 3: Modify the IS-IS header content of traffic stream StreamTemplate_1;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Transmit all traffic and wait for a duration;  \nStep 6: Stop all traffic and examine StreamBlockStats statistics;  \n\nCriteria:  \nExpected result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1csnpheader'])\n\n    header = edit_header_isis_csnp(Stream=stream,\n                                   Version=1,\n                                   LspId='10203040506070',\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=header['LspId'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries',\n                                      TlvCode=10,\n                                      LspEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n\n    lsp = edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1,\n                                     RemainTime=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=lsp['RemainTime'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6MLDv1Done.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv1 done报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv1 done头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Purpose: Verify that the test instrument accurately counts sent ICMPv6 MLDv1 Done packets\n\nStep         :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                 Step 2: Modify the ICMPv6 MLDv1 Done header in traffic stream StreamTemplate_1;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Send all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats;\n\nCriteria     :   Expected Result 1: In Step 6, sent and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv1done']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # icmpv6 mldv1done头部\n    edit_header_icmpv6_mldv1_done(Stream=stream, Level=0,\n                          Type='132',MaxRespDelay='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.maxRespDelay',\n                                               Value='10', MaxValue='10')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.type',\n                                               Value='132',\n                                               MaxValue='132')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_mldv1_done:修改测试仪表流量模板中Icmpv6 Mldv1 Done报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with specified product type (DarYu or provided argument).\",\n  \"Subtask 2\": \"Reserve two ports using provided locations (default or command-line arguments).\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers with EthernetII, IPv6, and MLDv1 Done protocol layers.\",\n  \"Subtask 5\": \"Modify ICMPv6 MLDv1 Done header parameters: Type=132, MaxRespDelay=10, MulticastAddress='FF1E::1'.\",\n  \"Subtask 6\": \"Create three PDU patterns on the second port for MLDv1 Done header fields: maxRespDelay=10, multicastAddress='FF1E::1', type=132.\",\n  \"Subtask 7\": \"Apply packet capture filter using logical AND combination of the three PDU patterns.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 9\": \"Configure port transmission mode as burst with burst count set to 100 packets.\",\n  \"Subtask 10\": \"Save test configuration to specified file path.\",\n  \"Subtask 11\": \"Start packet capture on the second port.\",\n  \"Subtask 12\": \"Initiate traffic transmission from the first port.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission and capture.\",\n  \"Subtask 14\": \"Stop traffic transmission.\",\n  \"Subtask 15\": \"Stop packet capture.\",\n  \"Subtask 16\": \"Wait 3 seconds for packet processing completion.\",\n  \"Subtask 17\": \"Download captured packets from second port to local directory.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats results for transmitted and received frame counts.\",\n  \"Subtask 19\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames).\",\n  \"Subtask 20\": \"Release both reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Purpose: Verify that the test instrument accurately counts sent ICMPv6 MLDv1 Done packets\n\nStep         :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                 Step 2: Modify the ICMPv6 MLDv1 Done header in traffic stream StreamTemplate_1;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Send all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats;\n\nCriteria     :   Expected Result 1: In Step 6, sent and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv1done']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # icmpv6 mldv1done头部\n    edit_header_icmpv6_mldv1_done(Stream=stream, Level=0,\n                          Type='132',MaxRespDelay='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.maxRespDelay',\n                                               Value='10', MaxValue='10')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.type',\n                                               Value='132',\n                                               MaxValue='132')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_mldv1_done:修改测试仪表流量模板中Icmpv6 Mldv1 Done报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2DatabaseDescription.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 database description报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ospfv2 database description头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Objective: To verify the test instrument correctly counts transmitted and received OSPFv2 Database Description packets\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Modify the OSPFv2 Database Description header content in traffic stream StreamTemplate_1;;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats statistics;;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Transmit all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2databasedescription']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 database description头部\n    header = edit_header_ospfv2_dd(Stream=stream, Level=0,\n                                   PacketOptionsReserved7=1,\n                                   RouterID='2.2.2.2', AuthType='SimplePassword',\n                                   AuthValue1=123, AuthValue2=456,\n                                   PacketOptionsDcBit=1, DdOptionsReserved3=1,\n                                   SequenceNumber=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['RouterID'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['PacketOptionsReserved7'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['AuthValue1'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['DdOptionsReserved3'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    lsa = edit_header_ospfv2_lsa(Stream=stream, HeaderType='Ospfv2DatabaseDescription',\n                                 LsaAge=10, Reserved7=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=lsa['LsaAge'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=lsa['Reserved7'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.ddOptions.dcBit',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.ospfHeader.authSelect.hdrAuthSelectNone.authValue2',\n                                               Value='456',\n                                               MaxValue='456')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.sequenceNumber',\n                                               Value='10',\n                                               MaxValue='10')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_dd:修改测试仪表流量模板中OSPFv2 Database Description报文头部内容",
      "edit_header_ospfv2_lsa:修改测试仪表流量模板中OSPFv2报文中Lsa头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at given locations using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers as EthernetII, IPv4, and OSPFv2 Database Description using create_stream_header API.\",\n  \"Subtask 5\": \"Edit OSPFv2 Database Description header fields (RouterID, AuthType, PacketOptions, etc.) using edit_header_ospfv2_dd API.\",\n  \"Subtask 6\": \"Configure increment modifiers for RouterID, PacketOptionsReserved7, AuthValue1, and DdOptionsReserved3 fields in OSPFv2 header using edit_modifier API.\",\n  \"Subtask 7\": \"Edit OSPFv2 LSA header fields (LsaAge, Reserved7) within Database Description using edit_header_ospfv2_lsa API.\",\n  \"Subtask 8\": \"Configure increment modifiers for LsaAge and Reserved7 fields in OSPFv2 LSA header using edit_modifier API.\",\n  \"Subtask 9\": \"Create three PDU patterns for capture filtering on the second port targeting dcBit=1, authValue2=456, and sequenceNumber=10 using create_capture_pdu_pattern API.\",\n  \"Subtask 10\": \"Set capture filter expression combining all three PDU patterns with logical AND on the second port using edit_capture_filter API.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 12\": \"Configure port transmission mode as burst with count=100 using edit_port_load_profile API.\",\n  \"Subtask 13\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 14\": \"Start packet capture on the second port using start_capture API.\",\n  \"Subtask 15\": \"Begin traffic transmission using start_stream API.\",\n  \"Subtask 16\": \"Wait 10 seconds for traffic transmission and capture.\",\n  \"Subtask 17\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 18\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 19\": \"Wait 3 seconds for capture processing.\",\n  \"Subtask 20\": \"Download captured packets from the second port using download_packages API.\",\n  \"Subtask 21\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 22\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 23\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Objective: To verify the test instrument correctly counts transmitted and received OSPFv2 Database Description packets\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Modify the OSPFv2 Database Description header content in traffic stream StreamTemplate_1;;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats statistics;;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Transmit all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2databasedescription']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 database description头部\n    header = edit_header_ospfv2_dd(Stream=stream, Level=0,\n                                   PacketOptionsReserved7=1,\n                                   RouterID='2.2.2.2', AuthType='SimplePassword',\n                                   AuthValue1=123, AuthValue2=456,\n                                   PacketOptionsDcBit=1, DdOptionsReserved3=1,\n                                   SequenceNumber=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['RouterID'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['PacketOptionsReserved7'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['AuthValue1'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['DdOptionsReserved3'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    lsa = edit_header_ospfv2_lsa(Stream=stream, HeaderType='Ospfv2DatabaseDescription',\n                                 LsaAge=10, Reserved7=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=lsa['LsaAge'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=lsa['Reserved7'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.ddOptions.dcBit',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.ospfHeader.authSelect.hdrAuthSelectNone.authValue2',\n                                               Value='456',\n                                               MaxValue='456')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.sequenceNumber',\n                                               Value='10',\n                                               MaxValue='10')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_dd:修改测试仪表流量模板中OSPFv2 Database Description报文头部内容;\nedit_header_ospfv2_lsa:修改测试仪表流量模板中OSPFv2报文中Lsa头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2TPv2Control.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv2 Control头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify the correctness of flow statistics transmitted by the test instrument\n\nStep: Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n      Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Test Step 3: Modify the L2TPv2 Control header content of traffic stream StreamTemplate_1;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Transmit all traffic and wait for a period;\n      Test Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-003\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control'])\n\n    # 修改l2tpv2 control头部\n    edit_header_l2tpv2_control(Stream=stream, Level=0,\n                               Type=1,\n                               Reserved1=11,\n                               Ns=5,\n                               Nr=6,\n                               )\n\n    # 修改l2tpv2 control头部，添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='protocolVersion',\n                                      Ver=1,\n                                      Rev=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='framingCapabilities',\n                                      Abit=1,\n                                      Sbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='bearerCapabilities',\n                                      Abit=1,\n                                      Dbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='firmwareRevision',\n                                      FirmwareRevision=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='assignedTunnelId',\n                                      TunnelId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='assignedSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='response',\n                                      ResponseValue='00000000000000000000000000000001',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='minimumBps',\n                                      MinimumBps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='maximumBps',\n                                      MaximumBps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='bearerType',\n                                      Abit=1,\n                                      Dbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='framingType',\n                                      Abit=1,\n                                      Sbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='txConnectSpeed',\n                                      Bps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='rxConnectSpeed',\n                                      HighBPS=1,\n                                      LowBPS=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=19,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=20,\n                                      Types='proxyAuthenType',\n                                      AuthenType=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=21,\n                                      Types='proxyAuthenId',\n                                      AuthenId=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control'],\n                                             FieldName='l2tpv2Control_1.ns',\n                                             Value=5,\n                                             MaxValue=5,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream named StreamTemplate_1 on Port_1 using add_stream API with frame length set to AUTO.\",\n  \"Subtask 4\": \"Create stream headers for StreamTemplate_1 including EthernetII, IPv4, UDP, and L2TPv2Control using create_stream_header API.\",\n  \"Subtask 5\": \"Modify L2TPv2 Control header of StreamTemplate_1 to set Type=1, Reserved1=11, Ns=5, Nr=6 and add multiple header options with specific attributes.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 7\": \"Configure Port_1 transmit mode as BURST with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 8\": \"Start traffic transmission using start_stream API and wait for completion using wait_stream_state API.\",\n  \"Subtask 9\": \"Wait 3 seconds after traffic stops to ensure accurate statistics collection.\",\n  \"Subtask 10\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API.\",\n  \"Subtask 11\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both equal 100.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify the correctness of flow statistics transmitted by the test instrument\n\nStep: Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n      Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Test Step 3: Modify the L2TPv2 Control header content of traffic stream StreamTemplate_1;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Transmit all traffic and wait for a period;\n      Test Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-003\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control'])\n\n    # 修改l2tpv2 control头部\n    edit_header_l2tpv2_control(Stream=stream, Level=0,\n                               Type=1,\n                               Reserved1=11,\n                               Ns=5,\n                               Nr=6,\n                               )\n\n    # 修改l2tpv2 control头部，添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='protocolVersion',\n                                      Ver=1,\n                                      Rev=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='framingCapabilities',\n                                      Abit=1,\n                                      Sbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='bearerCapabilities',\n                                      Abit=1,\n                                      Dbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='firmwareRevision',\n                                      FirmwareRevision=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='assignedTunnelId',\n                                      TunnelId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='assignedSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='response',\n                                      ResponseValue='00000000000000000000000000000001',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='minimumBps',\n                                      MinimumBps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='maximumBps',\n                                      MaximumBps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='bearerType',\n                                      Abit=1,\n                                      Dbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='framingType',\n                                      Abit=1,\n                                      Sbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='txConnectSpeed',\n                                      Bps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='rxConnectSpeed',\n                                      HighBPS=1,\n                                      LowBPS=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=19,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=20,\n                                      Types='proxyAuthenType',\n                                      AuthenType=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=21,\n                                      Types='proxyAuthenId',\n                                      AuthenId=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control'],\n                                             FieldName='l2tpv2Control_1.ns',\n                                             Value=5,\n                                             MaxValue=5,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4TimeStampRequest.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 time stamp request报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 time stamp request头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Purpose: Verify that the test instrument correctly counts the statistics of ICMPv4 timestamp request packets sent\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Modify the header content of the ICMPv4 timestamp request in traffic StreamTemplate_1;;\n                   Test Step 3: Configure filtered packet capture;;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set the port transmission mode to burst mode;;\n                   Test Step 6: Send all traffic, wait for a period of time;;\n                   Test Step 7: Stop all traffic, view StreamBlockStats statistical information;;\n\nCriteria    \t:   Expected Result 1: In step 6, the traffic StreamTemplate_1 has equal send and receive packets;\n\nCreated by   \t:  \tTester-004\n\nBugs   \t    :  \tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimestampRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改TimestampRequest头部\n    edit_header_icmp_time_stamp_request(Stream=stream, Level=0,\n                          Identifier='100', SequenceNumber='200',\n                          OriginateTimestamp='111', ReceiveTimestamp='222', TransmitTimestamp='333')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampRequest_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampRequest_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_time_stamp_request:修改测试仪表流量模板中Icmp Time Stamp Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform and reserve two ports (Port_1 and Port_2) using specified locations.\",\n  \"Subtask 2\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes and configure headers: EthernetII, IPv4, and ICMPv4 Timestamp Request.\",\n  \"Subtask 3\": \"Modify ICMPv4 Timestamp Request header fields: set Identifier=100, SequenceNumber=200, OriginateTimestamp=111, ReceiveTimestamp=222, TransmitTimestamp=333.\",\n  \"Subtask 4\": \"Configure filtered packet capture on Port_2 by creating two PDU patterns: one matching ICMPv4 Identifier=100 and another matching SequenceNumber=200, then set capture filter as logical AND of both patterns.\",\n  \"Subtask 5\": \"Subscribe to StreamBlockStats statistics view for performance monitoring.\",\n  \"Subtask 6\": \"Configure Port_1 transmission mode as burst mode with burst count set to 100.\",\n  \"Subtask 7\": \"Start packet capture on Port_2, initiate traffic transmission from Port_1, maintain active state for 10 seconds, then stop traffic transmission and packet capture.\",\n  \"Subtask 8\": \"Retrieve StreamBlockStats for the created stream and verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 9\": \"Release reserved ports and cleanup resources.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Purpose: Verify that the test instrument correctly counts the statistics of ICMPv4 timestamp request packets sent\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Modify the header content of the ICMPv4 timestamp request in traffic StreamTemplate_1;;\n                   Test Step 3: Configure filtered packet capture;;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set the port transmission mode to burst mode;;\n                   Test Step 6: Send all traffic, wait for a period of time;;\n                   Test Step 7: Stop all traffic, view StreamBlockStats statistical information;;\n\nCriteria    \t:   Expected Result 1: In step 6, the traffic StreamTemplate_1 has equal send and receive packets;\n\nCreated by   \t:  \tTester-004\n\nBugs   \t    :  \tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimestampRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改TimestampRequest头部\n    edit_header_icmp_time_stamp_request(Stream=stream, Level=0,\n                          Identifier='100', SequenceNumber='200',\n                          OriginateTimestamp='111', ReceiveTimestamp='222', TransmitTimestamp='333')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampRequest_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampRequest_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_time_stamp_request:修改测试仪表流量模板中Icmp Time Stamp Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl2psnpHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Verify the accuracy of traffic statistics sent by the test instrument\n\nStep         :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                Step 3: Modify the IS-IS header content of traffic stream StreamTemplate_1;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Send all traffic and wait for a period;\n                Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2psnpHeader'])\n\n    header = edit_header_isis_psnp(Stream=stream,\n                                   SourceId='102030405060',\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2psnpHeader', Attribute=header['SourceId'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsLspEntries', LspEntries=2)\n\n    edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l2psnpHeader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using init_tester API with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using reserve_port API with provided location information.\",\n  \"Subtask 3\": \"Create traffic stream on Port_1 using add_stream API and build header structure with create_stream_header API specifying EthernetII and l2psnpHeader types.\",\n  \"Subtask 4\": \"Modify IS-IS PSNP header using edit_header_isis_psnp API to set SourceId='102030405060' and CsnpDataTlvOptionHeader=['IsIsLspEntries','AuthentionInfo'].\",\n  \"Subtask 5\": \"Configure modifier for SourceId field using edit_modifier API with increment type and count=10.\",\n  \"Subtask 6\": \"Edit TLV header using edit_header_isis_tlv_header API to set LspEntries=2.\",\n  \"Subtask 7\": \"Modify LSP entry using edit_header_isis_lsp_entry API to set RemainTime=10 for TlvIndex=0 and LspIndex=1.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 9\": \"Configure port load profile using edit_port_load_profile API to set burst mode with BurstCount=100.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Monitor traffic state using wait_stream_state API until transmission completes.\",\n  \"Subtask 12\": \"Wait 3 seconds after traffic stops to ensure statistics collection.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats using get_streamblock_statistic API for the created stream.\",\n  \"Subtask 14\": \"Verify TxStreamFrames equals RxStreamFrames and both equal the configured BurstCount (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Verify the accuracy of traffic statistics sent by the test instrument\n\nStep         :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                Step 3: Modify the IS-IS header content of traffic stream StreamTemplate_1;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Send all traffic and wait for a period;\n                Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2psnpHeader'])\n\n    header = edit_header_isis_psnp(Stream=stream,\n                                   SourceId='102030405060',\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2psnpHeader', Attribute=header['SourceId'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsLspEntries', LspEntries=2)\n\n    edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l2psnpHeader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisp2phelloHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective      :   Test Objective: Verify the accuracy of flow statistics on the test instrument\n\nStep           :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the ISIS header content of stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats;\n                   Step 5: Transmit all streams and wait for a period;\n                   Step 6: Stop all streams and check StreamBlockStats statistics;\n\nCriteria       :   Expected Result 1: In Step 6, the transmitted and received packet counts for stream StreamTemplate_1 are equal;\n\nCreated by     :   Tester-002\n\nBugs           :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'p2phelloheader'])\n\n    header = edit_header_isis_p2p_hello(Stream=stream,\n                                        PDUType=10,\n                                        IsIsTlv=['AreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                 'IpInterfaceAddress', 'P2pAdjacencyState', 'RestartSignal',\n                                                 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='p2phelloheader', Attribute=header['PDUType'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AreaAddress', AreaAddressEntries=1)\n    edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, NlPIDEntriesField=2)\n    edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='p2pAdjacencyState', Index=5,\n                                **{'adjacencyStateInitializing.extendLocalCircuitId':'10203040'})\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容",
      "edit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two ports (Port_1 and Port_2) on the tester using the reserve_port API with specified locations.\",\n  \"Subtask 2\": \"Create a stream (StreamTemplate_1) on Port_1 using the add_stream API.\",\n  \"Subtask 3\": \"Modify the ISIS P2P Hello header of StreamTemplate_1 using edit_header_isis_p2p_hello API, setting PDUType=10 and including specified TLVs.\",\n  \"Subtask 4\": \"Configure increment modifiers for the ISIS header fields using edit_modifier API with Type='Increment' and Count=10.\",\n  \"Subtask 5\": \"Edit specific ISIS TLV headers (AreaAddress, Padding, AuthenticationInfo, etc.) using edit_header_isis_tlv_header and related entry APIs.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats and PortStats views using subscribe_result API.\",\n  \"Subtask 7\": \"Configure Port_1's load profile to burst mode with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 8\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 9\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 10\": \"Wait 3 seconds for statistics stabilization after traffic stops.\",\n  \"Subtask 11\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API.\",\n  \"Subtask 12\": \"Verify TxStreamFrames equals RxStreamFrames and both equal the configured BurstCount (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective      :   Test Objective: Verify the accuracy of flow statistics on the test instrument\n\nStep           :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the ISIS header content of stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats;\n                   Step 5: Transmit all streams and wait for a period;\n                   Step 6: Stop all streams and check StreamBlockStats statistics;\n\nCriteria       :   Expected Result 1: In Step 6, the transmitted and received packet counts for stream StreamTemplate_1 are equal;\n\nCreated by     :   Tester-002\n\nBugs           :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'p2phelloheader'])\n\n    header = edit_header_isis_p2p_hello(Stream=stream,\n                                        PDUType=10,\n                                        IsIsTlv=['AreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                 'IpInterfaceAddress', 'P2pAdjacencyState', 'RestartSignal',\n                                                 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='p2phelloheader', Attribute=header['PDUType'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AreaAddress', AreaAddressEntries=1)\n    edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, NlPIDEntriesField=2)\n    edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='p2pAdjacencyState', Index=5,\n                                **{'adjacencyStateInitializing.extendLocalCircuitId':'10203040'})\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容;\nedit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2HelloInstance.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 hello报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ospfv2 hello头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Objective: Verify that the test instrument correctly counts transmitted OSPFv2 Hello packets\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Modify the OSPFv2 Hello header content in traffic stream StreamTemplate_1;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Transmit all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2hello']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 hello头部\n    header = edit_header_ospfv2_hello(Stream=stream, Level=0,\n                                      RouterID='2.2.2.2', AuthType='MD5',\n                                      NetworkMask='255.255.255.0',\n                                      Neighbors=['1.1.1.1', '2.2.2.2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2hello',\n                  Attribute=header['NetworkMask'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2hello',\n                  Attribute=header['Neighbors: 2.2.2.2'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.networkMask',\n                                               Value='255.255.255.0', MaxValue='255.255.255.0')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.ospfHeader.routerID',\n                                               Value='2.2.2.2',\n                                               MaxValue='2.2.2.2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.routerDeadInterval',\n                                               Value='50',\n                                               MaxValue='50')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_hello:修改测试仪表流量模板中OSPFv2 Hello报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for the specified product (DarYu).\",\n  \"Subtask 2\": \"Reserve two ports at the given locations for testing.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length.\",\n  \"Subtask 4\": \"Configure the stream headers to include EthernetII, IPv4, and OSPFv2 Hello protocols.\",\n  \"Subtask 5\": \"Modify the OSPFv2 Hello header with specific parameters: RouterID='2.2.2.2', AuthType='MD5', NetworkMask='255.255.255.0', Neighbors=['1.1.1.1', '2.2.2.2'].\",\n  \"Subtask 6\": \"Apply increment modifiers to the OSPFv2 Hello NetworkMask field with count=10 and step=2.\",\n  \"Subtask 7\": \"Apply increment modifiers to the OSPFv2 Hello Neighbors field with count=10 and step=2.\",\n  \"Subtask 8\": \"Create three PDU patterns for capture filtering on the second port targeting specific OSPFv2 fields: NetworkMask='255.255.255.0', RouterID='2.2.2.2', RouterDeadInterval='50'.\",\n  \"Subtask 9\": \"Configure packet capture filter on the second port using logical AND combination of the three PDU patterns.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 11\": \"Configure the first port's transmission mode to burst with burst count=100.\",\n  \"Subtask 12\": \"Save test configuration to file.\",\n  \"Subtask 13\": \"Start packet capture on the second port.\",\n  \"Subtask 14\": \"Start traffic transmission on the first port.\",\n  \"Subtask 15\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 16\": \"Stop traffic transmission.\",\n  \"Subtask 17\": \"Stop packet capture.\",\n  \"Subtask 18\": \"Download captured packets from the second port to local storage.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats results for the created stream.\",\n  \"Subtask 20\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 21\": \"Release all reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Objective: Verify that the test instrument correctly counts transmitted OSPFv2 Hello packets\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Modify the OSPFv2 Hello header content in traffic stream StreamTemplate_1;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Transmit all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2hello']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 hello头部\n    header = edit_header_ospfv2_hello(Stream=stream, Level=0,\n                                      RouterID='2.2.2.2', AuthType='MD5',\n                                      NetworkMask='255.255.255.0',\n                                      Neighbors=['1.1.1.1', '2.2.2.2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2hello',\n                  Attribute=header['NetworkMask'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2hello',\n                  Attribute=header['Neighbors: 2.2.2.2'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.networkMask',\n                                               Value='255.255.255.0', MaxValue='255.255.255.0')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.ospfHeader.routerID',\n                                               Value='2.2.2.2',\n                                               MaxValue='2.2.2.2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.routerDeadInterval',\n                                               Value='50',\n                                               MaxValue='50')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_hello:修改测试仪表流量模板中OSPFv2 Hello报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl1lspHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective    :   Test Objective: Verify the accuracy of traffic statistics from the test instrument\n\nStep        :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Test Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n                Test Step 3: Modify the ISIS header content of stream StreamTemplate_1;\n                Test Step 4: Subscribe to StreamBlockStats;\n                Test Step 5: Transmit all traffic and wait for a period;\n                Test Step 6: Stop all traffic and check StreamBlockStats information;\n\nCriteria    :   Expected Result 1: Packets sent and received for stream StreamTemplate_1 are equal in Step 6;\n\nCreated by  :   Tester-002\n\nBugs        :   None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, )\n    edit_stream(Stream=stream, FrameLengthType='Auto')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1lspheader'])\n\n    header = edit_header_isis_lsp(Stream=stream, \n                                  InterRoutingProtocolDiscriminator=10,\n                                  PDULength=20,\n                                  LspisIsTlvOptionSet=['IsIsAreaAddress', 'IsIsReachability', 'ExtendedReachability',\n                                    'IsIsIpInterReachability', 'IsIsProtocolsSupported', 'IsIsIPExternalReachability',\n                                    'IpInterfaceAddress', 'Ipv6InterfaceAddress', 'IsIsIpv6Reachability'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=header['InterRoutingProtocolDiscriminator'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=header['PDULength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsAreaAddress', \n                                      TlvCode=10,\n                                      AreaAddressEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n    entry = edit_header_isis_area_address_entry(Stream=stream, TlvLength=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=entry['TlvLength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsReachability', Index=1,\n                                      VirtualFlag=10,\n                                      MetricEntries=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=tlv['VirtualFlag'],\n                  Type='Increment', Count=10)\n    entry = edit_header_isis_metric_entry(Stream=stream, TlvIndex=1, EntryIndex=1, DefaultMetric=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=entry['DefaultMetric'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ExtendedReachability', Index=2,\n                                IisNeighborSubTlv=['AdGroupSubtlv', 'Ipv4InterfaceAddressSubtlv', 'Ipv4NeighborAddressSubtlv',\n                                      'MaxLinkBandwidthSubtlv', 'ReservableLinkBandwidthSubtlv', 'UnReservedBandwidthSubtlv',\n                                      'InterfaceIpv6Subtlv', 'NeigbhorIpv6Subtlv'])\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='AdGroupSubtlv', TlvIndex=2, SubTlvIndex=0, tlvCode=20)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4InterfaceAddressSubtlv', TlvIndex=2, SubTlvIndex=1, Ipv4InterfaceAddressValue='1.1.1.1')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4NeighborAddressSubtlv', TlvIndex=2, SubTlvIndex=2, Ipv4NeighborAddressValue='2.2.2.2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='MaxLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=3, MaxBandwidthValue=30)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='ReservableLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=4, ReservableLinkBandwidthValue=40)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='UnReservedBandwidthSubtlv', TlvIndex=2, SubTlvIndex=5, ResBandwidth0Value=50)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='InterfaceIpv6Subtlv', TlvIndex=2, SubTlvIndex=6, InterfaceIpv6Value='2022::2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='NeigbhorIpv6Subtlv', TlvIndex=2, SubTlvIndex=7, Neighboripv6Value='2033::3')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsIpInterReachability', Index=3, InternalmetricEntries=1)\n    edit_header_isis_internal_metric_entry(Stream=stream, TlvIndex=3, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IpInterfaceAddress', Index=6, Ipv4InterfaceAddress=['1.1.1.1', '2.2.2.2'])\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Ipv6InterfaceAddress', Index=7, Ipv6InterfaceAddress=['2022::2', '2033::3'])\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    # start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容",
      "edit_header_isis_internal_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容",
      "edit_header_isis_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容",
      "edit_header_isis_sub_tlv:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Sub Tlv内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester API with specified product platform.\",\n  \"Subtask 2\": \"Reserve two ports (Port_UP and Port_Down) using reserve_port API with provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API and configure frame length type with edit_stream API.\",\n  \"Subtask 4\": \"Build ISIS header structure using create_stream_header API with EthernetII and l1lspheader.\",\n  \"Subtask 5\": \"Modify ISIS LSP header fields (InterRoutingProtocolDiscriminator, PDULength) using edit_header_isis_lsp API and configure increment modifiers with edit_modifier API.\",\n  \"Subtask 6\": \"Configure ISIS Area Address TLV using edit_header_isis_tlv_header API, set modifiers for TlvCode and TlvLength fields.\",\n  \"Subtask 7\": \"Configure ISIS Reachability TLV using edit_header_isis_tlv_header API, set modifiers for VirtualFlag and DefaultMetric fields.\",\n  \"Subtask 8\": \"Configure Extended Reachability TLV with specific sub-TLVs (AdGroupSubtlv, Ipv4InterfaceAddressSubtlv, etc.) using edit_header_isis_sub_tlv API.\",\n  \"Subtask 9\": \"Configure ISIS IP Reachability, IP Interface Address, and IPv6 Interface Address TLVs using edit_header_isis_tlv_header API.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats and PortStats views using subscribe_result API.\",\n  \"Subtask 11\": \"Configure port load profile with burst mode and burst count (100) using edit_port_load_profile API.\",\n  \"Subtask 12\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 13\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 14\": \"Wait for traffic transmission completion using wait_stream_state API and pause for 3 seconds.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 16\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both match burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective    :   Test Objective: Verify the accuracy of traffic statistics from the test instrument\n\nStep        :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Test Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n                Test Step 3: Modify the ISIS header content of stream StreamTemplate_1;\n                Test Step 4: Subscribe to StreamBlockStats;\n                Test Step 5: Transmit all traffic and wait for a period;\n                Test Step 6: Stop all traffic and check StreamBlockStats information;\n\nCriteria    :   Expected Result 1: Packets sent and received for stream StreamTemplate_1 are equal in Step 6;\n\nCreated by  :   Tester-002\n\nBugs        :   None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, )\n    edit_stream(Stream=stream, FrameLengthType='Auto')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1lspheader'])\n\n    header = edit_header_isis_lsp(Stream=stream, \n                                  InterRoutingProtocolDiscriminator=10,\n                                  PDULength=20,\n                                  LspisIsTlvOptionSet=['IsIsAreaAddress', 'IsIsReachability', 'ExtendedReachability',\n                                    'IsIsIpInterReachability', 'IsIsProtocolsSupported', 'IsIsIPExternalReachability',\n                                    'IpInterfaceAddress', 'Ipv6InterfaceAddress', 'IsIsIpv6Reachability'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=header['InterRoutingProtocolDiscriminator'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=header['PDULength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsAreaAddress', \n                                      TlvCode=10,\n                                      AreaAddressEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n    entry = edit_header_isis_area_address_entry(Stream=stream, TlvLength=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=entry['TlvLength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsReachability', Index=1,\n                                      VirtualFlag=10,\n                                      MetricEntries=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=tlv['VirtualFlag'],\n                  Type='Increment', Count=10)\n    entry = edit_header_isis_metric_entry(Stream=stream, TlvIndex=1, EntryIndex=1, DefaultMetric=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=entry['DefaultMetric'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ExtendedReachability', Index=2,\n                                IisNeighborSubTlv=['AdGroupSubtlv', 'Ipv4InterfaceAddressSubtlv', 'Ipv4NeighborAddressSubtlv',\n                                      'MaxLinkBandwidthSubtlv', 'ReservableLinkBandwidthSubtlv', 'UnReservedBandwidthSubtlv',\n                                      'InterfaceIpv6Subtlv', 'NeigbhorIpv6Subtlv'])\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='AdGroupSubtlv', TlvIndex=2, SubTlvIndex=0, tlvCode=20)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4InterfaceAddressSubtlv', TlvIndex=2, SubTlvIndex=1, Ipv4InterfaceAddressValue='1.1.1.1')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4NeighborAddressSubtlv', TlvIndex=2, SubTlvIndex=2, Ipv4NeighborAddressValue='2.2.2.2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='MaxLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=3, MaxBandwidthValue=30)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='ReservableLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=4, ReservableLinkBandwidthValue=40)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='UnReservedBandwidthSubtlv', TlvIndex=2, SubTlvIndex=5, ResBandwidth0Value=50)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='InterfaceIpv6Subtlv', TlvIndex=2, SubTlvIndex=6, InterfaceIpv6Value='2022::2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='NeigbhorIpv6Subtlv', TlvIndex=2, SubTlvIndex=7, Neighboripv6Value='2033::3')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsIpInterReachability', Index=3, InternalmetricEntries=1)\n    edit_header_isis_internal_metric_entry(Stream=stream, TlvIndex=3, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IpInterfaceAddress', Index=6, Ipv4InterfaceAddress=['1.1.1.1', '2.2.2.2'])\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Ipv6InterfaceAddress', Index=7, Ipv6InterfaceAddress=['2022::2', '2033::3'])\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    # start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容;\nedit_header_isis_internal_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容;\nedit_header_isis_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容;\nedit_header_isis_sub_tlv:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Sub Tlv内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/LoadProfile/EditLoadProfile_BaseOnPort_DarYu.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Port负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约4个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Port,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================",
    "intent_en": "Objective: To verify that the test instrument's load mode configuration \"Base On Port\" is successfully set.  \n\nStep 1: Reserve 4 offline ports;  \nStep 2: Set port load mode to \"Base On Port\" and configure all type parameters for the load;  \n\nCriteria: Expected Result 1: The port load configuration in Step 2 is successfully set;  \n\nCreated by: Tester-001  \n\nBugs:",
    "code": "from TesterLibrary.base import *\n\n\nProduct = 'DarYu'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'daryu':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Port, （端口负载：15, 负载单位：Percent(%)） 传输模式：Continuous, （突发报文数：10, 突发间隔：100, 突发间隔单位: ns）\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='PORT_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               BurstSize=10,\n                               InterFrameGap=100,\n                               InterFrameGapUnit='NS',\n                               Rate=15,\n                               Unit='PERCENT',)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Port （端口负载：20, 负载单位：Inter Frame Gap(ns)）, 传输模式：Burst, （突发报文数：15, 突发间隔：110, 突发间隔单位: us , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='PORT_BASE',\n                               Rate=20,\n                               Unit='NS',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=110,\n                               InterFrameGapUnit='US',\n                               BurstCount=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Port, （端口负载：25, 负载单位：Inter Frame Gap(byte)） 传输模式：Time, （突发报文数：20, 突发间隔：120, 突发间隔单位: ms, 发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='PORT_BASE',\n                               Rate=25,\n                               Unit='INTER_FRAME_GAP_BYTE',\n                               TransmitMode=\"TIME\",\n                               BurstSize=15,\n                               InterFrameGap=120,\n                               InterFrameGapUnit='MS',\n                               Seconds=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Port, （端口负载：30, 负载单位：Frames per Second） 传输模式：Step, （突发报文数：25, 突发间隔：130, 突发间隔单位: sec, 发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='PORT_BASE',\n                               Rate=30,\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               BurstSize=20,\n                               InterFrameGap=130,\n                               InterFrameGapUnit='SEC',\n                               Frames=20)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve 4 offline ports at locations ['//10.0.11.191/1/1', '//10.0.11.191/1/2', '//10.0.11.191/1/3', '//10.0.11.191/1/4'] using reserve_port API.\",\n  \"Subtask 3\": \"Set port 1 load mode to 'PORT_BASE' with parameters: TransmitMode='CONTINUOUS', BurstSize=10, InterFrameGap=100, InterFrameGapUnit='NS', Rate=15, Unit='PERCENT' using edit_port_load_profile API.\",\n  \"Subtask 4\": \"Set port 2 load mode to 'PORT_BASE' with parameters: TransmitMode='BURST', BurstSize=15, InterFrameGap=110, InterFrameGapUnit='US', Rate=20, Unit='NS', BurstCount=10 using edit_port_load_profile API.\",\n  \"Subtask 5\": \"Set port 3 load mode to 'PORT_BASE' with parameters: TransmitMode='TIME', BurstSize=15, InterFrameGap=120, InterFrameGapUnit='MS', Rate=25, Unit='INTER_FRAME_GAP_BYTE', Seconds=15 using edit_port_load_profile API.\",\n  \"Subtask 6\": \"Set port 4 load mode to 'PORT_BASE' with parameters: TransmitMode='STEP', BurstSize=20, InterFrameGap=130, InterFrameGapUnit='SEC', Rate=30, Unit='FRAME_PER_SEC', Frames=20 using edit_port_load_profile API.\",\n  \"Subtask 7\": \"Save the configuration to file using save_case API with path derived from current script location.\",\n  \"Subtask 8\": \"Verify all port load configurations were set successfully by checking no exceptions occurred during configuration steps.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: To verify that the test instrument's load mode configuration \"Base On Port\" is successfully set.  \n\nStep 1: Reserve 4 offline ports;  \nStep 2: Set port load mode to \"Base On Port\" and configure all type parameters for the load;  \n\nCriteria: Expected Result 1: The port load configuration in Step 2 is successfully set;  \n\nCreated by: Tester-001  \n\nBugs:\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\n\nProduct = 'DarYu'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'daryu':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Port, （端口负载：15, 负载单位：Percent(%)） 传输模式：Continuous, （突发报文数：10, 突发间隔：100, 突发间隔单位: ns）\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='PORT_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               BurstSize=10,\n                               InterFrameGap=100,\n                               InterFrameGapUnit='NS',\n                               Rate=15,\n                               Unit='PERCENT',)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Port （端口负载：20, 负载单位：Inter Frame Gap(ns)）, 传输模式：Burst, （突发报文数：15, 突发间隔：110, 突发间隔单位: us , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='PORT_BASE',\n                               Rate=20,\n                               Unit='NS',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=110,\n                               InterFrameGapUnit='US',\n                               BurstCount=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Port, （端口负载：25, 负载单位：Inter Frame Gap(byte)） 传输模式：Time, （突发报文数：20, 突发间隔：120, 突发间隔单位: ms, 发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='PORT_BASE',\n                               Rate=25,\n                               Unit='INTER_FRAME_GAP_BYTE',\n                               TransmitMode=\"TIME\",\n                               BurstSize=15,\n                               InterFrameGap=120,\n                               InterFrameGapUnit='MS',\n                               Seconds=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Port, （端口负载：30, 负载单位：Frames per Second） 传输模式：Step, （突发报文数：25, 突发间隔：130, 突发间隔单位: sec, 发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='PORT_BASE',\n                               Rate=30,\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               BurstSize=20,\n                               InterFrameGap=130,\n                               InterFrameGapUnit='SEC',\n                               Frames=20)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/LoadProfile/EditLoadProfile_BaseOnStream_DarYu.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Stream负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约4个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Stream,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Check that the test instrument's load mode is set to Base On Stream and the load configuration is successfully applied.\n\nStep: Step 1: Reserve 4 offline ports;\n      Step 2: Set port load mode to Base On Stream and configure all load parameter types;\n\nCriteria: Expected result 1: Port load configuration in step 2 is successfully set;\n\nCreated by: Tester-001\n\nBugs: \n=================================================================================",
    "code": "from TesterLibrary.base import *\n\n\nProduct = 'DarYu'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'daryu':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Stream,  传输模式：Continuous, （突发报文数：10, 突发间隔：100, 突发间隔单位: ns）\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               BurstSize=10,\n                               InterFrameGap=100,\n                               InterFrameGapUnit='NS')\n        # 创建流量\n        stream = add_stream(Ports=Ports[0], FixedLength=256)\n        # 负载单位：Percent(%) 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='PERCENT', Rate=5)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Stream, 传输模式：Burst, （（突发报文数：15, 突发间隔：110, 突发间隔单位: us , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=110,\n                               InterFrameGapUnit='US',\n                               BurstCount=10)\n        # 创建流量\n        stream = add_stream(Ports=Ports[1], FixedLength=256)\n        # 负载单位：Frames per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='FRAME_PER_SEC', Rate=10)\n        \n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Stream, 传输模式：Time, （突发报文数：20, 突发间隔：120, 突发间隔单位: ms, 发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"TIME\",\n                               BurstSize=15,\n                               InterFrameGap=120,\n                               InterFrameGapUnit='MS',\n                               Seconds=15)\n        # 创建流量\n        stream = add_stream(Ports=Ports[2], FixedLength=256)\n        # 负载单位：Byte per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='BYTE_PER_SEC', Rate=15)\n        \n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Stream, 传输模式：Step, （突发报文数：25, 突发间隔：130, 突发间隔单位: sec, 发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"STEP\",\n                               BurstSize=20,\n                               InterFrameGap=130,\n                               InterFrameGapUnit='SEC',\n                               Frames=20)\n        # 创建流量\n        stream = add_stream(Ports=Ports[3], FixedLength=256)\n        # 负载单位：Line Bits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='LINEBIT_PER_SEC', Rate=20)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "add_stream:测试仪表创建流量"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with product type 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve 4 offline ports at specified locations using reserve_port API.\",\n  \"Subtask 3\": \"For port 1: Set load mode to Base On Stream (STREAM_BASE) with Continuous transmit mode (BurstSize=10, InterFrameGap=100ns) using edit_port_load_profile API.\",\n  \"Subtask 4\": \"For port 1: Create traffic stream with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 5\": \"For port 1: Configure stream load profile with PERCENT unit and 5% rate using edit_stream_load_profile API.\",\n  \"Subtask 6\": \"For port 2: Set load mode to Base On Stream (STREAM_BASE) with Burst transmit mode (BurstSize=15, InterFrameGap=110us, BurstCount=10) using edit_port_load_profile API.\",\n  \"Subtask 7\": \"For port 2: Create traffic stream with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 8\": \"For port 2: Configure stream load profile with FRAME_PER_SEC unit and 10 fps rate using edit_stream_load_profile API.\",\n  \"Subtask 9\": \"For port 3: Set load mode to Base On Stream (STREAM_BASE) with Time transmit mode (BurstSize=15, InterFrameGap=120ms, Seconds=15) using edit_port_load_profile API.\",\n  \"Subtask 10\": \"For port 3: Create traffic stream with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 11\": \"For port 3: Configure stream load profile with BYTE_PER_SEC unit and 15 Bps rate using edit_stream_load_profile API.\",\n  \"Subtask 12\": \"For port 4: Set load mode to Base On Stream (STREAM_BASE) with Step transmit mode (BurstSize=20, InterFrameGap=130sec, Frames=20) using edit_port_load_profile API.\",\n  \"Subtask 13\": \"For port 4: Create traffic stream with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 14\": \"For port 4: Configure stream load profile with LINEBIT_PER_SEC unit and 20 bps rate using edit_stream_load_profile API.\",\n  \"Subtask 15\": \"Save the complete configuration to .xcfg file using save_case API.\",\n  \"Subtask 16\": \"Verify all port load configurations were successfully applied without errors (implicit through exception handling).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Check that the test instrument's load mode is set to Base On Stream and the load configuration is successfully applied.\n\nStep: Step 1: Reserve 4 offline ports;\n      Step 2: Set port load mode to Base On Stream and configure all load parameter types;\n\nCriteria: Expected result 1: Port load configuration in step 2 is successfully set;\n\nCreated by: Tester-001\n\nBugs: \n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\n\nProduct = 'DarYu'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'daryu':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Stream,  传输模式：Continuous, （突发报文数：10, 突发间隔：100, 突发间隔单位: ns）\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               BurstSize=10,\n                               InterFrameGap=100,\n                               InterFrameGapUnit='NS')\n        # 创建流量\n        stream = add_stream(Ports=Ports[0], FixedLength=256)\n        # 负载单位：Percent(%) 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='PERCENT', Rate=5)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Stream, 传输模式：Burst, （（突发报文数：15, 突发间隔：110, 突发间隔单位: us , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=110,\n                               InterFrameGapUnit='US',\n                               BurstCount=10)\n        # 创建流量\n        stream = add_stream(Ports=Ports[1], FixedLength=256)\n        # 负载单位：Frames per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='FRAME_PER_SEC', Rate=10)\n        \n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Stream, 传输模式：Time, （突发报文数：20, 突发间隔：120, 突发间隔单位: ms, 发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"TIME\",\n                               BurstSize=15,\n                               InterFrameGap=120,\n                               InterFrameGapUnit='MS',\n                               Seconds=15)\n        # 创建流量\n        stream = add_stream(Ports=Ports[2], FixedLength=256)\n        # 负载单位：Byte per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='BYTE_PER_SEC', Rate=15)\n        \n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Stream, 传输模式：Step, （突发报文数：25, 突发间隔：130, 突发间隔单位: sec, 发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"STEP\",\n                               BurstSize=20,\n                               InterFrameGap=130,\n                               InterFrameGapUnit='SEC',\n                               Frames=20)\n        # 创建流量\n        stream = add_stream(Ports=Ports[3], FixedLength=256)\n        # 负载单位：Line Bits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='LINEBIT_PER_SEC', Rate=20)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nadd_stream:测试仪表创建流量\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv3_ControlOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 control over udp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 control over udp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Objective: Verify that the test instrument correctly counts transmitted and received packets for L2TPv3 control over UDP\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Modify the L2TPv3 control over UDP header content of traffic stream StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Transmit all traffic and wait for a period;\nTest Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3ControlOverUdp头部\n    header = edit_header_l2tpv3_control_over_udp(Stream=stream, Level=0, Type=1, SequenceNumberNr=1, Length=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header['Length'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header['SequenceNumberNr'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv3ControlOverUdp头部选项\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=0, Types='generalTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=1, Types='messageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=2, Types='resultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=3, Types='tieBreaker', TieBreakerValue='0000000000000001')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['TieBreakerValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=4, Types='receiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=5, Types='callSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=6, Types='physicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=7, Types='circuitError', AlignmentOverruns='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['AlignmentOverruns'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=8, Types='routeId', RouteId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['RouteId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=9, Types='assignedConnection', ConnectionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['ConnectionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=10, Types='localSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=11, Types='remoteSessionId',  SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=12, Types='assignedCookie', Cookie8Byte='1020304050607080')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['Cookie8Byte'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=13, Types='pwType', PwType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['PwType'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=14, Types='l2SpecificSub', L2SpecificSublayer='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['L2SpecificSublayer'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=15, Types='dataSequencing', DataSequencing='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['DataSequencing'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=16, Types='txConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=17, Types='rxConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=18, Types='circuitStatus', Nbit='1',Abit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['Abit'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3ControlOverUdp_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with product specification 'DarYu'.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations for testing.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length of 512 bytes.\",\n  \"Subtask 4\": \"Configure the stream header with protocol stack: EthernetII, IPv4, UDP, L2TPv3 control over UDP.\",\n  \"Subtask 5\": \"Edit the main L2TPv3 control header fields (Type, SequenceNumberNr, Length) and configure increment modifiers for Length and SequenceNumberNr fields with count=10.\",\n  \"Subtask 6\": \"Edit 18 L2TPv3 control options (generalTLV, messageType, resultCode, etc.) and configure increment modifiers for AttributeValue, MessageType, ErrorCode, and TieBreakerValue fields with count=10.\",\n  \"Subtask 7\": \"Create a PDU pattern on the second port to filter L2TPv3 control packets where type field equals 1.\",\n  \"Subtask 8\": \"Apply the PDU pattern as a capture filter on the second port.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Configure the first port's transmission mode to burst with burst count=100.\",\n  \"Subtask 11\": \"Save the test configuration to a file.\",\n  \"Subtask 12\": \"Start packet capture on the second port.\",\n  \"Subtask 13\": \"Start traffic transmission from the first port.\",\n  \"Subtask 14\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission from the first port.\",\n  \"Subtask 16\": \"Stop packet capture on the second port.\",\n  \"Subtask 17\": \"Download captured packets from the second port to a specified directory.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats results for the created stream.\",\n  \"Subtask 19\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 20\": \"Release the reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Objective: Verify that the test instrument correctly counts transmitted and received packets for L2TPv3 control over UDP\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Modify the L2TPv3 control over UDP header content of traffic stream StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Transmit all traffic and wait for a period;\nTest Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3ControlOverUdp头部\n    header = edit_header_l2tpv3_control_over_udp(Stream=stream, Level=0, Type=1, SequenceNumberNr=1, Length=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header['Length'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header['SequenceNumberNr'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv3ControlOverUdp头部选项\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=0, Types='generalTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=1, Types='messageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=2, Types='resultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=3, Types='tieBreaker', TieBreakerValue='0000000000000001')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['TieBreakerValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=4, Types='receiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=5, Types='callSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=6, Types='physicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=7, Types='circuitError', AlignmentOverruns='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['AlignmentOverruns'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=8, Types='routeId', RouteId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['RouteId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=9, Types='assignedConnection', ConnectionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['ConnectionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=10, Types='localSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=11, Types='remoteSessionId',  SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=12, Types='assignedCookie', Cookie8Byte='1020304050607080')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['Cookie8Byte'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=13, Types='pwType', PwType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['PwType'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=14, Types='l2SpecificSub', L2SpecificSublayer='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['L2SpecificSublayer'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=15, Types='dataSequencing', DataSequencing='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['DataSequencing'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=16, Types='txConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=17, Types='rxConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=18, Types='circuitStatus', Nbit='1',Abit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['Abit'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3ControlOverUdp_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/LoadProfile/EditLoadProfile_BaseOnPort_BigTao.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Port负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约6个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Port,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    : Check that the load mode of the testing instrument is set to Base On Port and the load configuration is set successfully.\n\nStep         : Step 1: Reserve 6 offline ports;\n              Step 2: Set the port load mode to Base On Port and configure all type parameters of the load configuration;\n\nCriteria     : Expected Result 1: In Step 2, the port load configuration is set successfully;\n\nCreated by   : Tester-001\n\nBugs         :\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\n\nProduct = 'BigTao'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n    '//10.0.11.191/1/5',\n    '//10.0.11.191/1/6',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'bigtao':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Port, （端口负载：15, 负载单位：Percent(%)） 传输模式：Continuous,\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='PORT_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=15,\n                               Unit='PERCENT')\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Port （端口负载：20, 负载单位：Inter Frame Gap(ns)）, 传输模式：Burst, （突发报文数：15, 突发间隔：2, 突发间隔单位: ms , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='PORT_BASE',\n                               Rate=20,\n                               Unit='NS',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=2,\n                               InterFrameGapUnit='MS',\n                               BurstCount=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Port, （端口负载：25, 负载单位：Inter Frame Gap(byte)） 传输模式：Time, （发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='PORT_BASE',\n                               Rate=25,\n                               Unit='INTER_FRAME_GAP_BYTE',\n                               TransmitMode=\"TIME\",\n                               Seconds=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Port, （端口负载：30, 负载单位：Frames per Second） 传输模式：Step, （发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='PORT_BASE',\n                               Rate=30,\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               Frames=20)\n\n        # =============== *设置模式5* ===============\n        # 负载模式：Base On Port, （端口负载：35, 负载单位：Byte per Second） 传输模式：On Stream, 流传输模式：Continuous\n        edit_port_load_profile(Ports=Ports[4],\n                               LoadProfileType='PORT_BASE',\n                               Rate=35,\n                               Unit='BYTE_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[4], FixedLength=256)\n        edit_stream_load_profile(Streams=stream, StreamTransmitMode='CONTINUOUS')\n\n        # =============== *设置模式6* ===============\n        # 负载模式：Base On Port, （端口负载：40, 负载单位：Data Bits per Second） 传输模式：On Stream, 流传输模式：Burst （突发间隔单位：MS, 突发次数：3, 突发间隔：4, 突发数量：10）\n        edit_port_load_profile(Ports=Ports[5],\n                               LoadProfileType='PORT_BASE',\n                               Rate=40,\n                               Unit='DATABIT_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[5], FixedLength=256)\n        edit_stream_load_profile(Streams=stream, StreamTransmitMode='BURST', BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "add_stream:测试仪表创建流量"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the testing instrument for product 'BigTao' using init_tester API.\",\n  \"Subtask 2\": \"Reserve 6 offline ports at specified locations using reserve_port API with Debug=True.\",\n  \"Subtask 3\": \"Configure port 1 load profile: set LoadProfileType='PORT_BASE', TransmitMode='CONTINUOUS', Rate=15, Unit='PERCENT' using edit_port_load_profile.\",\n  \"Subtask 4\": \"Configure port 2 load profile: set LoadProfileType='PORT_BASE', TransmitMode='BURST', Rate=20, Unit='NS' with BurstSize=15, InterFrameGap=2, InterFrameGapUnit='MS', BurstCount=10 using edit_port_load_profile.\",\n  \"Subtask 5\": \"Configure port 3 load profile: set LoadProfileType='PORT_BASE', TransmitMode='TIME', Rate=25, Unit='INTER_FRAME_GAP_BYTE' with Seconds=15 using edit_port_load_profile.\",\n  \"Subtask 6\": \"Configure port 4 load profile: set LoadProfileType='PORT_BASE', TransmitMode='STEP', Rate=30, Unit='FRAME_PER_SEC' with Frames=20 using edit_port_load_profile.\",\n  \"Subtask 7\": \"Configure port 5 load profile: set LoadProfileType='PORT_BASE', TransmitMode='ONSTREAM', Rate=35, Unit='BYTE_PER_SEC' using edit_port_load_profile. Then create stream with add_stream and set StreamTransmitMode='CONTINUOUS' using edit_stream_load_profile.\",\n  \"Subtask 8\": \"Configure port 6 load profile: set LoadProfileType='PORT_BASE', TransmitMode='ONSTREAM', Rate=40, Unit='DATABIT_PER_SEC' using edit_port_load_profile. Then create stream with add_stream and set StreamTransmitMode='BURST' with BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10 using edit_stream_load_profile.\",\n  \"Subtask 9\": \"Save the configuration to specified file path using save_case API.\",\n  \"Subtask 10\": \"Verify all port load configurations were applied successfully by confirming no exceptions occurred during configuration steps and final verdict is 'pass'.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    : Check that the load mode of the testing instrument is set to Base On Port and the load configuration is set successfully.\n\nStep         : Step 1: Reserve 6 offline ports;\n              Step 2: Set the port load mode to Base On Port and configure all type parameters of the load configuration;\n\nCriteria     : Expected Result 1: In Step 2, the port load configuration is set successfully;\n\nCreated by   : Tester-001\n\nBugs         :\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\n\nProduct = 'BigTao'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n    '//10.0.11.191/1/5',\n    '//10.0.11.191/1/6',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'bigtao':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Port, （端口负载：15, 负载单位：Percent(%)） 传输模式：Continuous,\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='PORT_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=15,\n                               Unit='PERCENT')\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Port （端口负载：20, 负载单位：Inter Frame Gap(ns)）, 传输模式：Burst, （突发报文数：15, 突发间隔：2, 突发间隔单位: ms , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='PORT_BASE',\n                               Rate=20,\n                               Unit='NS',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=2,\n                               InterFrameGapUnit='MS',\n                               BurstCount=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Port, （端口负载：25, 负载单位：Inter Frame Gap(byte)） 传输模式：Time, （发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='PORT_BASE',\n                               Rate=25,\n                               Unit='INTER_FRAME_GAP_BYTE',\n                               TransmitMode=\"TIME\",\n                               Seconds=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Port, （端口负载：30, 负载单位：Frames per Second） 传输模式：Step, （发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='PORT_BASE',\n                               Rate=30,\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               Frames=20)\n\n        # =============== *设置模式5* ===============\n        # 负载模式：Base On Port, （端口负载：35, 负载单位：Byte per Second） 传输模式：On Stream, 流传输模式：Continuous\n        edit_port_load_profile(Ports=Ports[4],\n                               LoadProfileType='PORT_BASE',\n                               Rate=35,\n                               Unit='BYTE_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[4], FixedLength=256)\n        edit_stream_load_profile(Streams=stream, StreamTransmitMode='CONTINUOUS')\n\n        # =============== *设置模式6* ===============\n        # 负载模式：Base On Port, （端口负载：40, 负载单位：Data Bits per Second） 传输模式：On Stream, 流传输模式：Burst （突发间隔单位：MS, 突发次数：3, 突发间隔：4, 突发数量：10）\n        edit_port_load_profile(Ports=Ports[5],\n                               LoadProfileType='PORT_BASE',\n                               Rate=40,\n                               Unit='DATABIT_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[5], FixedLength=256)\n        edit_stream_load_profile(Streams=stream, StreamTransmitMode='BURST', BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nadd_stream:测试仪表创建流量\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ripv1.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发Ripv1报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的Ripv1头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify that the test instrument correctly counts RIP version 1 packets sent.\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Modify the RIP version 1 header content of traffic stream StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set the port transmission mode to burst packets;\nTest Step 6: Send all traffic and wait for a period of time;\nTest Step 7: Stop all traffic and view the StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, the sent and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-001\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripv1']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripv1(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripv1', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripv1_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripv1_entry(Stream=stream, Level=0, Index=0, Ipaddr='192.168.0.11', Afi=1, Reserved=1, Reserved1=1, Reserved2=1, Metric=1)\n    edit_header_ripv1_entry(Stream=stream, Level=0, Index=1, Ipaddr='192.168.0.12', Afi=2, Reserved=2, Reserved1=2, Reserved2=2, Metric=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for product 'DarYu'.\",\n  \"Subtask 2\": \"Reserve two ports using specified locations for Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed length 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv4, and Ripv1.\",\n  \"Subtask 5\": \"Edit Ripv1 header at level 0: set Command=2, Version=1, Reserved=2.\",\n  \"Subtask 6\": \"Apply increment modifier to Ripv1 Reserved field with count=3.\",\n  \"Subtask 7\": \"Insert two Ripv1 entries into the stream.\",\n  \"Subtask 8\": \"Edit first Ripv1 entry (index 0): set IP=192.168.0.11, Afi=1, Metric=1.\",\n  \"Subtask 9\": \"Edit second Ripv1 entry (index 1): set IP=192.168.0.12, Afi=2, Metric=2.\",\n  \"Subtask 10\": \"Create first PDU capture pattern on Port_2: match Ripv1 Reserved field between 1-2.\",\n  \"Subtask 11\": \"Create second PDU capture pattern on Port_2: match Ripv1 Version field fixed at 1.\",\n  \"Subtask 12\": \"Configure capture filter on Port_2 using logical AND of both PDU patterns.\",\n  \"Subtask 13\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 14\": \"Set Port_1 transmission mode to burst with burst count=100.\",\n  \"Subtask 15\": \"Save test configuration to specified file path.\",\n  \"Subtask 16\": \"Start packet capture on Port_2.\",\n  \"Subtask 17\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 18\": \"Wait 10 seconds during traffic transmission and capture.\",\n  \"Subtask 19\": \"Stop traffic transmission.\",\n  \"Subtask 20\": \"Stop packet capture.\",\n  \"Subtask 21\": \"Wait 3 seconds for capture processing.\",\n  \"Subtask 22\": \"Download captured packets from Port_2 to local storage.\",\n  \"Subtask 23\": \"Retrieve StreamBlockStats for the traffic stream.\",\n  \"Subtask 24\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 25\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify that the test instrument correctly counts RIP version 1 packets sent.\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Modify the RIP version 1 header content of traffic stream StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set the port transmission mode to burst packets;\nTest Step 6: Send all traffic and wait for a period of time;\nTest Step 7: Stop all traffic and view the StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, the sent and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-001\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripv1']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripv1(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripv1', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripv1_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripv1_entry(Stream=stream, Level=0, Index=0, Ipaddr='192.168.0.11', Afi=1, Reserved=1, Reserved1=1, Reserved2=1, Metric=1)\n    edit_header_ripv1_entry(Stream=stream, Level=0, Index=1, Ipaddr='192.168.0.12', Afi=2, Reserved=2, Reserved1=2, Reserved2=2, Metric=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_6/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.6 地址缓存能力\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2889 中规定，将交换机三个端口与测试仪连接，分别为端口 1（测试端口），端口 2（学习端口），端口 3（监视端口），见图 5；\n                   测试步骤2: 测试方法采用 RFC2889 标准测试方法。\n\n Criteria    \t:   预期结果1: 技术要求二层交换机不低于 4k；三层交换机不低于 16k。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective\t:   Objective: 6.4.6 Address Caching Capability\n\nStep\t\t\t:\tTest Step 1: According to RFC 2889, connect three ports of the switch to the tester, designated as Port 1 (test port), Port 2 (learning port), and Port 3 (monitoring port), as illustrated in Figure 5;\n                Test Step 2: The test method employs the RFC 2889 standard test procedure.\n\nCriteria    \t:   Expected Result 1: Technical requirements specify Layer 2 switches must support at least 4k entries, while Layer 3 switches must support at least 16k entries.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressCachingCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    # 提供学习的地址数和地址学习速率\n    edit_benchmark_address_learning_capacity(Config=Config,\n                                             MinAddressCount=cfg['arg']['learning_capacity']['default']['min_address_count']['default'],\n                                             MaxAddressCount=cfg['arg']['learning_capacity']['default']['max_address_count']['default'],\n                                             InitAddressCount=cfg['arg']['learning_capacity']['default']['init_address_count']['default'],\n                                             Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                             AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                             LearningRate=cfg['arg']['learning_capacity']['default']['learning_rate']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_address_learning_capacity:编辑RFC2889测试套件地址容量测试项参数",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester API based on provided RTSM IP or default settings.\",\n  \"Subtask 2\": \"Reserve three ports (Port1 as test port, Port2 as learning port, Port3 as monitoring port) using reserve_port API with specified locations.\",\n  \"Subtask 3\": \"Configure port parameters using edit_port API if not in debug mode, including force settings and wait for port status using wait_port_state API.\",\n  \"Subtask 4\": \"Create RFC2889 benchmark for addressCachingCapacity test item using create_benchmark API.\",\n  \"Subtask 5\": \"Assign reserved ports to benchmark roles (test port, learning port, monitoring port) using relate_benchmark_ports API.\",\n  \"Subtask 6\": \"Create Ethernet interfaces on test port and learning port using create_interface API.\",\n  \"Subtask 7\": \"Configure MAC addresses for created interfaces using edit_interface API with addresses from configuration.\",\n  \"Subtask 8\": \"Retrieve Ethernet layer objects from interfaces using get_layer_from_interfaces API for stream creation.\",\n  \"Subtask 9\": \"Create unidirectional traffic streams from test port to learning port with monitoring port using create_benchmark_streams API.\",\n  \"Subtask 10\": \"Configure latency settings (FIFO type, delay before/after) using edit_benchmark_latency API.\",\n  \"Subtask 11\": \"Set test duration parameters (number of trials) using edit_benchmark_duration API.\",\n  \"Subtask 12\": \"Configure custom frame size using edit_benchmark_frame API.\",\n  \"Subtask 13\": \"Configure address learning parameters (min/max/init address count, resolution, aging time, learning rate) using edit_benchmark_address_learning_capacity API.\",\n  \"Subtask 14\": \"Generate test script using expand_benchmark API.\",\n  \"Subtask 15\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 16\": \"Execute benchmark test using run_benchmark API with analyzer setting and timeout.\",\n  \"Subtask 17\": \"Retrieve and format test results using get_benchmark_result API.\",\n  \"Subtask 18\": \"Verify address caching capacity meets requirements: ≥4k entries for L2 switches or ≥16k entries for L3 switches.\",\n  \"Subtask 19\": \"Release reserved ports using release_port API.\",\n  \"Subtask 20\": \"Shutdown tester processes and perform cleanup using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective\t:   Objective: 6.4.6 Address Caching Capability\n\nStep\t\t\t:\tTest Step 1: According to RFC 2889, connect three ports of the switch to the tester, designated as Port 1 (test port), Port 2 (learning port), and Port 3 (monitoring port), as illustrated in Figure 5;\n                Test Step 2: The test method employs the RFC 2889 standard test procedure.\n\nCriteria    \t:   Expected Result 1: Technical requirements specify Layer 2 switches must support at least 4k entries, while Layer 3 switches must support at least 16k entries.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressCachingCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    # 提供学习的地址数和地址学习速率\n    edit_benchmark_address_learning_capacity(Config=Config,\n                                             MinAddressCount=cfg['arg']['learning_capacity']['default']['min_address_count']['default'],\n                                             MaxAddressCount=cfg['arg']['learning_capacity']['default']['max_address_count']['default'],\n                                             InitAddressCount=cfg['arg']['learning_capacity']['default']['init_address_count']['default'],\n                                             Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                             AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                             LearningRate=cfg['arg']['learning_capacity']['default']['learning_rate']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_address_learning_capacity:编辑RFC2889测试套件地址容量测试项参数;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_9/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.5.9 生成树协议\n\n Step\t\t\t:\t测试步骤1: 将4台交换机按照图9连接，级联口均采用100M光口；\n                   测试步骤2: 整个组网设备间运行标准生成树协议，配置各设备的生成树参数，\n                   测试步骤3: 观察设备能否根据配置的参数修剪环路，完成生成树\n                   测试步骤4: 阻断开设备目前的生成树链路，观察设备是否可自动完成网络拓扑重构；\n                   测试步骤5: 启用所有交换机的RSTP功能\n                   测试步骤6: 将交换机如图9连接；\n                   测试步骤7: 用SmartBits 在任意两台交换机之间加载95Mbps数据流量；\n                   测试步骤8: 拔插环网中的任一链路，查看网络是否可以正常收敛\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: 6.5.9 Spanning Tree Protocol\n\nStep\t\t\t:\tTest Step 1: Connect four switches as shown in Figure 9, using 100M optical ports for all cascade interfaces;\n                   Test Step 2: Run the standard Spanning Tree Protocol among all networking devices, configuring spanning tree parameters for each device;\n                   Test Step 3: Observe whether devices can prune loops according to configured parameters and complete spanning tree formation;\n                   Test Step 4: Block the current spanning tree link and observe whether devices automatically reconstruct the network topology;\n                   Test Step 5: Enable RSTP functionality on all switches;\n                   Test Step 6: Connect the switches as shown in Figure 9;\n                   Test Step 7: Use SmartBits to load 95Mbps data traffic between any two switches;\n                   Test Step 8: Unplug and replug any link in the ring network, verifying whether normal network convergence occurs.\n\nCriteria    \t:   Expected Result 1:\n\nCreated by   \t:   Tester-006\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95,)\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插链路\n        time.sleep(30)\n\n        # 查看收敛时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxFCSErr = Result['RxFCSErr']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=True)\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Connect four switches in a ring topology using 100M optical ports for all inter-switch links as specified in Figure 9.\",\n  \"Subtask 2\": \"Configure standard Spanning Tree Protocol (STP) parameters on all switches, including bridge priority, port costs, and STP timers.\",\n  \"Subtask 3\": \"Verify STP convergence by checking that switches successfully prune loops and establish a loop-free topology with designated root/blocked ports.\",\n  \"Subtask 4\": \"Manually block the current active STP forwarding link by disabling the corresponding switch port.\",\n  \"Subtask 5\": \"Observe and validate that switches automatically reconverge the topology by activating alternate paths within STP timers.\",\n  \"Subtask 6\": \"Enable Rapid Spanning Tree Protocol (RSTP) on all switches and ensure configuration consistency across devices.\",\n  \"Subtask 7\": \"Configure tester ports to generate 95Mbps bidirectional traffic between two switches using SmartBits, setting frame size to 64 bytes and continuous transmission mode.\",\n  \"Subtask 8\": \"Start traffic transmission and monitor baseline traffic statistics for stability before topology change.\",\n  \"Subtask 9\": \"Physically disconnect and reconnect a ring network link while traffic is running to simulate topology change.\",\n  \"Subtask 10\": \"Measure network convergence time by monitoring traffic interruption duration during link disruption using StreamBlock statistics.\",\n  \"Subtask 11\": \"Verify successful RSTP reconvergence by confirming traffic resumes to baseline levels (Tx/Rx frame counts match) after link restoration.\",\n  \"Subtask 12\": \"Validate no frame errors (e.g., RxFCSErr) occurred during convergence event to confirm data integrity.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: 6.5.9 Spanning Tree Protocol\n\nStep\t\t\t:\tTest Step 1: Connect four switches as shown in Figure 9, using 100M optical ports for all cascade interfaces;\n                   Test Step 2: Run the standard Spanning Tree Protocol among all networking devices, configuring spanning tree parameters for each device;\n                   Test Step 3: Observe whether devices can prune loops according to configured parameters and complete spanning tree formation;\n                   Test Step 4: Block the current spanning tree link and observe whether devices automatically reconstruct the network topology;\n                   Test Step 5: Enable RSTP functionality on all switches;\n                   Test Step 6: Connect the switches as shown in Figure 9;\n                   Test Step 7: Use SmartBits to load 95Mbps data traffic between any two switches;\n                   Test Step 8: Unplug and replug any link in the ring network, verifying whether normal network convergence occurs.\n\nCriteria    \t:   Expected Result 1:\n\nCreated by   \t:   Tester-006\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95,)\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插链路\n        time.sleep(30)\n\n        # 查看收敛时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxFCSErr = Result['RxFCSErr']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=True)\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_7/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.7 地址学习速率\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2889 中规定，将交换机三个端口与测试仪连接，分别为端口 1（测试端口），端口 2（学习端口），端口 3（监视端口），见图 5；\n                   测试步骤2: 测试方法采用 RFC2889 标准测试方法。\n\n Criteria    \t:   预期结果1: 技术要求应不低于 1000 帧/s。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   6.4.7 Address Learning Rate\n\nStep\t\t\t:\tStep 1: According to RFC 2889, connect three ports of the switch to the tester: Port 1 (test port), Port 2 (learning port), Port 3 (monitor port), as shown in Figure 5;\n                    Step 2: The test method adopts the standard test method of RFC 2889.\n\nCriteria    \t:   Expected Result 1: The technical requirement shall be no less than 1000 frames/s.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressLearningRate'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n\n    # 地址学习速率和地址数量\n    edit_benchmark_address_learning_rate(Config=Config,\n                                         MinRateCount=cfg['arg']['learning_capacity']['default']['min_rate_count']['default'],\n                                         MaxRateCount=cfg['arg']['learning_capacity']['default']['max_rate_count']['default'],\n                                         InitRateCount=cfg['arg']['learning_capacity']['default']['init_rate_count']['default'],\n                                         Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                         AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                         AddressCount=cfg['arg']['learning_capacity']['default']['address_count']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_address_learning_rate:编辑RFC2889测试套件地址容量测试项参数",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester using init_tester API, using RTSM IP if provided in testbed configuration.\",\n  \"Subtask 2\": \"Reserve three test ports (Port 1 as test port, Port 2 as learning port, Port 3 as monitor port) using reserve_port API with locations from configuration.\",\n  \"Subtask 3\": \"Edit port parameters using edit_port API according to testbed configuration and wait for port status using wait_port_state if required.\",\n  \"Subtask 4\": \"Create RFC2889 benchmark for addressLearningRate test item using create_benchmark API.\",\n  \"Subtask 5\": \"Assign reserved ports to benchmark roles (test port, learning port, monitor port) using relate_benchmark_ports API.\",\n  \"Subtask 6\": \"Create Ethernet interfaces on test port and learning port using create_interface API.\",\n  \"Subtask 7\": \"Configure MAC addresses for both interfaces using edit_interface API with addresses from configuration.\",\n  \"Subtask 8\": \"Retrieve Ethernet layer objects from interfaces using get_layer_from_interfaces API.\",\n  \"Subtask 9\": \"Create benchmark traffic streams between test port and learning port using create_benchmark_streams API, specifying monitor port and unidirectional traffic.\",\n  \"Subtask 10\": \"Configure latency settings (FIFO mode, 2s delay before, 10s delay after) using edit_benchmark_latency API.\",\n  \"Subtask 11\": \"Set test duration to 1 trial using edit_benchmark_duration API.\",\n  \"Subtask 12\": \"Configure custom frame size using edit_benchmark_frame API as specified in configuration.\",\n  \"Subtask 13\": \"Configure address learning rate parameters (min/max/init rate count, resolution, aging time, address count) using edit_benchmark_address_learning_rate API with values from configuration.\",\n  \"Subtask 14\": \"Generate test script by expanding benchmark configuration using expand_benchmark API.\",\n  \"Subtask 15\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 16\": \"Execute benchmark test using run_benchmark API with 3600s timeout.\",\n  \"Subtask 17\": \"Retrieve test results in dataframe format using get_benchmark_result API for RFC2889 test type.\",\n  \"Subtask 18\": \"Verify address learning rate result meets criterion: no less than 1000 frames/s.\",\n  \"Subtask 19\": \"Release all reserved ports using release_port API.\",\n  \"Subtask 20\": \"Shutdown tester using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   6.4.7 Address Learning Rate\n\nStep\t\t\t:\tStep 1: According to RFC 2889, connect three ports of the switch to the tester: Port 1 (test port), Port 2 (learning port), Port 3 (monitor port), as shown in Figure 5;\n                    Step 2: The test method adopts the standard test method of RFC 2889.\n\nCriteria    \t:   Expected Result 1: The technical requirement shall be no less than 1000 frames/s.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressLearningRate'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n\n    # 地址学习速率和地址数量\n    edit_benchmark_address_learning_rate(Config=Config,\n                                         MinRateCount=cfg['arg']['learning_capacity']['default']['min_rate_count']['default'],\n                                         MaxRateCount=cfg['arg']['learning_capacity']['default']['max_rate_count']['default'],\n                                         InitRateCount=cfg['arg']['learning_capacity']['default']['init_rate_count']['default'],\n                                         Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                         AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                         AddressCount=cfg['arg']['learning_capacity']['default']['address_count']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_address_learning_rate:编辑RFC2889测试套件地址容量测试项参数;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/LoadProfile/EditLoadProfile_BaseOnStream_BigTao.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Stream负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约6个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Stream,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   To verify that the test instrument's load mode is successfully configured as Base On Stream load configuration\n\nStep         :   Test Step 1: Reserve 6 offline ports;\n                 Test Step 2: Set port load mode to Base On Stream and configure all parameter types for the load configuration;\n\nCriteria     :   Expected Result 1: The port load configuration in Step 2 is successfully set;\n\nCreated by   :   Tester-001\n\nBugs         :\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\n\nProduct = 'BigTao'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n    '//10.0.11.191/1/5',\n    '//10.0.11.191/1/6',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'bigtao':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Continuous,\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               LoadMode='FRAME_PER_SEC')\n        # 创建流量\n        stream = add_stream(Ports=Ports[0], FixedLength=256)\n        # 负载单位：Percent(%) 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='PERCENT', Rate=5)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Stream （调速模式：Byte per Second）, 传输模式：Burst, （突发报文数：15, 突发间隔：2, 突发间隔单位: ms , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='BYTE_PER_SEC',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=2,\n                               InterFrameGapUnit='MS',\n                               BurstCount=10)\n        # 创建流量\n        stream = add_stream(Ports=Ports[1], FixedLength=256)\n        # 负载单位：Frames per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='FRAME_PER_SEC', Rate=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Time, （发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"TIME\",\n                               Seconds=99)\n        # 创建流量\n        stream = add_stream(Ports=Ports[2], FixedLength=256)\n        # 负载单位：Byte per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='BYTE_PER_SEC', Rate=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Step, （发送帧数：15）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               Frames=110)\n        # 创建流量\n        stream = add_stream(Ports=Ports[3], FixedLength=256)\n        # 负载单位：Line Bits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='LINEBIT_PER_SEC', Rate=20)\n\n        # =============== *设置模式5* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：On Stream, 流传输模式：Continuous\n        edit_port_load_profile(Ports=Ports[4],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[4], FixedLength=256)\n        # 负载单位：Line KBits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='KLINEBIT_PER_SEC', Rate=25)\n\n        # =============== *设置模式6* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：On Stream, 流传输模式：Burst （突发间隔单位：MS, 突发次数：3, 突发间隔：4, 突发数量：10）\n        edit_port_load_profile(Ports=Ports[5],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[5], FixedLength=256)\n        # 负载单位：Line KBits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='MLINEBIT_PER_SEC', Rate=30, StreamTransmitMode='BURST', BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "add_stream:测试仪表创建流量"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'BigTao' using init_tester API.\",\n  \"Subtask 2\": \"Reserve 6 ports at specified locations using reserve_port API with Debug mode enabled.\",\n  \"Subtask 3\": \"Configure port 1: Set load profile to STREAM_BASE with TransmitMode=CONTINUOUS and LoadMode=FRAME_PER_SEC using edit_port_load_profile API.\",\n  \"Subtask 4\": \"Create a stream on port 1 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 5\": \"Configure stream on port 1: Set load unit to PERCENT with rate 5 using edit_stream_load_profile API.\",\n  \"Subtask 6\": \"Configure port 2: Set load profile to STREAM_BASE with LoadMode=BYTE_PER_SEC, TransmitMode=BURST, BurstSize=15, InterFrameGap=2ms, and BurstCount=10 using edit_port_load_profile API.\",\n  \"Subtask 7\": \"Create a stream on port 2 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 8\": \"Configure stream on port 2: Set load unit to FRAME_PER_SEC with rate 10 using edit_stream_load_profile API.\",\n  \"Subtask 9\": \"Configure port 3: Set load profile to STREAM_BASE with LoadMode=FRAME_PER_SEC, TransmitMode=TIME, and Duration=99 seconds using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Create a stream on port 3 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 11\": \"Configure stream on port 3: Set load unit to BYTE_PER_SEC with rate 15 using edit_stream_load_profile API.\",\n  \"Subtask 12\": \"Configure port 4: Set load profile to STREAM_BASE with LoadMode=FRAME_PER_SEC, TransmitMode=STEP, and Frames=110 using edit_port_load_profile API.\",\n  \"Subtask 13\": \"Create a stream on port 4 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 14\": \"Configure stream on port 4: Set load unit to LINEBIT_PER_SEC with rate 20 using edit_stream_load_profile API.\",\n  \"Subtask 15\": \"Configure port 5: Set load profile to STREAM_BASE with LoadMode=FRAME_PER_SEC and TransmitMode=ONSTREAM using edit_port_load_profile API.\",\n  \"Subtask 16\": \"Create a stream on port 5 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 17\": \"Configure stream on port 5: Set load unit to KLINEBIT_PER_SEC with rate 25 using edit_stream_load_profile API.\",\n  \"Subtask 18\": \"Configure port 6: Set load profile to STREAM_BASE with LoadMode=FRAME_PER_SEC and TransmitMode=ONSTREAM using edit_port_load_profile API.\",\n  \"Subtask 19\": \"Create a stream on port 6 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 20\": \"Configure stream on port 6: Set load unit to MLINEBIT_PER_SEC with rate 30, StreamTransmitMode=BURST, BurstGap=4ms, BurstCount=3, and FramePerBurst=10 using edit_stream_load_profile API.\",\n  \"Subtask 21\": \"Save the test configuration to file using save_case API.\",\n  \"Subtask 22\": \"Verify all port load configurations completed successfully by checking for absence of runtime exceptions.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   To verify that the test instrument's load mode is successfully configured as Base On Stream load configuration\n\nStep         :   Test Step 1: Reserve 6 offline ports;\n                 Test Step 2: Set port load mode to Base On Stream and configure all parameter types for the load configuration;\n\nCriteria     :   Expected Result 1: The port load configuration in Step 2 is successfully set;\n\nCreated by   :   Tester-001\n\nBugs         :\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\n\nProduct = 'BigTao'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n    '//10.0.11.191/1/5',\n    '//10.0.11.191/1/6',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'bigtao':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Continuous,\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               LoadMode='FRAME_PER_SEC')\n        # 创建流量\n        stream = add_stream(Ports=Ports[0], FixedLength=256)\n        # 负载单位：Percent(%) 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='PERCENT', Rate=5)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Stream （调速模式：Byte per Second）, 传输模式：Burst, （突发报文数：15, 突发间隔：2, 突发间隔单位: ms , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='BYTE_PER_SEC',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=2,\n                               InterFrameGapUnit='MS',\n                               BurstCount=10)\n        # 创建流量\n        stream = add_stream(Ports=Ports[1], FixedLength=256)\n        # 负载单位：Frames per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='FRAME_PER_SEC', Rate=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Time, （发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"TIME\",\n                               Seconds=99)\n        # 创建流量\n        stream = add_stream(Ports=Ports[2], FixedLength=256)\n        # 负载单位：Byte per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='BYTE_PER_SEC', Rate=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Step, （发送帧数：15）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               Frames=110)\n        # 创建流量\n        stream = add_stream(Ports=Ports[3], FixedLength=256)\n        # 负载单位：Line Bits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='LINEBIT_PER_SEC', Rate=20)\n\n        # =============== *设置模式5* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：On Stream, 流传输模式：Continuous\n        edit_port_load_profile(Ports=Ports[4],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[4], FixedLength=256)\n        # 负载单位：Line KBits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='KLINEBIT_PER_SEC', Rate=25)\n\n        # =============== *设置模式6* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：On Stream, 流传输模式：Burst （突发间隔单位：MS, 突发次数：3, 突发间隔：4, 突发数量：10）\n        edit_port_load_profile(Ports=Ports[5],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[5], FixedLength=256)\n        # 负载单位：Line KBits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='MLINEBIT_PER_SEC', Rate=30, StreamTransmitMode='BURST', BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nadd_stream:测试仪表创建流量\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_6/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.6 IGMP-Snooping 组播: 二层交换机应支持 IGMP-Snooping 组播功能\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示，交换机端口为同一VLAN 内的UNTAGGED 端口；\n                   测试步骤2: 端口1 向端口2 发送1 个组的组播流量\n                   测试步骤3: 在被测交换机上禁用IGMP Snooping 功能，观察端口2 流量接收情况；\n                   测试步骤4: 在被测交换机上启用IGMP Snooping 功能，观察端口2 流量接收情况；\n                   测试步骤5: 端口2 使用IGMP 协议V2 加入组播组，观察端口2 流量接收情况；\n                   测试步骤6: 端口2 发送离开组请求，观察端口2 流量接收情况。\n\n Criteria    \t:   预期结果1: 步骤2）在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量；\n                   预期结果2: 步骤3）在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量；\n                   预期结果3: 步骤4）端口2 发送组加入请求后，可接收组播流量；\n                   预期结果4: 步骤5）端口2 发送离开组请求后，不能接收组播流量。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "Objective: 6.5.6 IGMP-Snooping Multicast: The Layer 2 switch should support IGMP-Snooping multicast function.\n\nStep 1: Connect the traffic generator to the switch as shown in Figure 4, with switch ports configured as UNTAGGED ports within the same VLAN.\nStep 2: Port 1 sends multicast traffic for one group to Port 2.\nStep 3: Disable IGMP Snooping function on the switch under test, and observe traffic reception on Port 2.\nStep 4: Enable IGMP Snooping function on the switch under test, and observe traffic reception on Port 2.\nStep 5: Port 2 joins the multicast group using IGMP protocol V2, and observe traffic reception on Port 2.\nStep 6: Port 2 sends a leave group request, and observe traffic reception on Port 2.\n\nCriterion 1: In step 2), when IGMP Snooping is disabled on the switch under test, all ports should receive multicast traffic.\nCriterion 2: In step 3), when IGMP Snooping is enabled on the switch under test, non-multicast client ports should not receive multicast traffic.\nCriterion 3: In step 4), after Port 2 sends a join group request, it should receive multicast traffic.\nCriterion 4: In step 5), after Port 2 sends a leave group request, it should not receive multicast traffic.\n\nCreated by: Tester-008\n\nTags: function",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port_1, port_2 = ports\n    # 创建接口\n    interface_1 = create_interface(Port=port_1,Layers=['eth', 'ipv4'])\n    interface_2 = create_interface(Port=port_2,Layers=['eth', 'ipv4'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_2, Version='IGMPV2')\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interface_2)\n\n    # 创建全局组播组\n    multicast_group = create_multicast_group(Start='225.0.1.2',Count=1)\n\n    # 创建组播协议和组播组绑定关系对象\n    memberships = create_memberships(Session=igmp)\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP绑定流\n    src_point = get_layer_from_interfaces(Interfaces=interface_1)\n\n    stream = add_stream(Type='binding', SrcPoints=src_point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        # 获取流量统计结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'RxLossStreamFrames',\n                                                                    'RealtimeLossRate'])\n        if  Result['RxStreamFrames'] > 0  and Result['RxLossStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，没有所有端口都接收到组播流量', step=5, result=False)\n\n        # 被测设备使能igmp snooping\n        cmd_cfg = '_'.join('DeviceA_Step3'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        # 清空统计计数\n        clear_result()\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        printf(message='step3：端口1向端口2发送1个组的组播流量, 在被测交换机上启用IGMP Snooping 功能')\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=False)\n\n        igmp_send_report(Sessions=igmp)\n        time.sleep(3)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=False)\n\n        igmp_send_leave(Sessions=igmp)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if Result['TxStreamFrames'] != Result['RxStreamFrames'] and Result['RxStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "create_igmp:创建IGMP协议会话对象",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize tester and reserve ports using init_tester and reserve_port APIs based on testbed configuration.\",\n  \"Subtask 2\": \"Configure switch ports as UNTAGGED in the same VLAN per test topology (DUT configuration step).\",\n  \"Subtask 3\": \"Create Ethernet and IPv4 interfaces on Port 1 and Port 2 using create_interface API.\",\n  \"Subtask 4\": \"Create IGMPv2 session on Port 2 using create_igmp API.\",\n  \"Subtask 5\": \"Bind IGMP session to Port 2 interface using select_interface API.\",\n  \"Subtask 6\": \"Create multicast group (start=225.0.1.2, count=1) using create_multicast_group API.\",\n  \"Subtask 7\": \"Create memberships object for IGMP session using create_memberships API.\",\n  \"Subtask 8\": \"Bind multicast group to IGMP session memberships using binding_multicast_group API.\",\n  \"Subtask 9\": \"Get layer objects from Port 1 interface using get_layer_from_interfaces API.\",\n  \"Subtask 10\": \"Create multicast traffic stream from Port 1 to multicast group using add_stream API.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats view using subscribe_result API.\",\n  \"Subtask 12\": \"Disable IGMP Snooping on switch under test (DUT configuration step).\",\n  \"Subtask 13\": \"Clear statistics, start traffic stream for 10 seconds using start_stream, then stop stream using stop_stream.\",\n  \"Subtask 14\": \"Verify Port 2 receives multicast traffic (RxStreamFrames > 0 and RxLossStreamFrames = 0) using get_streamblock_statistic API.\",\n  \"Subtask 15\": \"Enable IGMP Snooping on switch under test (DUT configuration step).\",\n  \"Subtask 16\": \"Start IGMP protocol using start_protocol API and wait for stable state using wait_igmp_state API.\",\n  \"Subtask 17\": \"Clear statistics, start traffic stream for 10 seconds, then stop stream.\",\n  \"Subtask 18\": \"Verify Port 2 does not receive multicast traffic (RxStreamFrames = 0) using get_streamblock_statistic API.\",\n  \"Subtask 19\": \"Send IGMP join report from Port 2 using IGMP session.\",\n  \"Subtask 20\": \"Clear statistics, start traffic stream for 10 seconds, then stop stream.\",\n  \"Subtask 21\": \"Verify Port 2 receives multicast traffic (RxStreamFrames = TxStreamFrames) using get_streamblock_statistic API.\",\n  \"Subtask 22\": \"Send IGMP leave request from Port 2 using IGMP session.\",\n  \"Subtask 23\": \"Clear statistics, start traffic stream for 10 seconds, then stop stream.\",\n  \"Subtask 24\": \"Verify Port 2 does not receive multicast traffic (RxStreamFrames = 0) using get_streamblock_statistic API.\",\n  \"Subtask 25\": \"Release tester ports using release_port API and perform cleanup.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: 6.5.6 IGMP-Snooping Multicast: The Layer 2 switch should support IGMP-Snooping multicast function.\n\nStep 1: Connect the traffic generator to the switch as shown in Figure 4, with switch ports configured as UNTAGGED ports within the same VLAN.\nStep 2: Port 1 sends multicast traffic for one group to Port 2.\nStep 3: Disable IGMP Snooping function on the switch under test, and observe traffic reception on Port 2.\nStep 4: Enable IGMP Snooping function on the switch under test, and observe traffic reception on Port 2.\nStep 5: Port 2 joins the multicast group using IGMP protocol V2, and observe traffic reception on Port 2.\nStep 6: Port 2 sends a leave group request, and observe traffic reception on Port 2.\n\nCriterion 1: In step 2), when IGMP Snooping is disabled on the switch under test, all ports should receive multicast traffic.\nCriterion 2: In step 3), when IGMP Snooping is enabled on the switch under test, non-multicast client ports should not receive multicast traffic.\nCriterion 3: In step 4), after Port 2 sends a join group request, it should receive multicast traffic.\nCriterion 4: In step 5), after Port 2 sends a leave group request, it should not receive multicast traffic.\n\nCreated by: Tester-008\n\nTags: function\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port_1, port_2 = ports\n    # 创建接口\n    interface_1 = create_interface(Port=port_1,Layers=['eth', 'ipv4'])\n    interface_2 = create_interface(Port=port_2,Layers=['eth', 'ipv4'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_2, Version='IGMPV2')\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interface_2)\n\n    # 创建全局组播组\n    multicast_group = create_multicast_group(Start='225.0.1.2',Count=1)\n\n    # 创建组播协议和组播组绑定关系对象\n    memberships = create_memberships(Session=igmp)\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP绑定流\n    src_point = get_layer_from_interfaces(Interfaces=interface_1)\n\n    stream = add_stream(Type='binding', SrcPoints=src_point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        # 获取流量统计结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'RxLossStreamFrames',\n                                                                    'RealtimeLossRate'])\n        if  Result['RxStreamFrames'] > 0  and Result['RxLossStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，没有所有端口都接收到组播流量', step=5, result=False)\n\n        # 被测设备使能igmp snooping\n        cmd_cfg = '_'.join('DeviceA_Step3'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        # 清空统计计数\n        clear_result()\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        printf(message='step3：端口1向端口2发送1个组的组播流量, 在被测交换机上启用IGMP Snooping 功能')\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=False)\n\n        igmp_send_report(Sessions=igmp)\n        time.sleep(3)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=False)\n\n        igmp_send_leave(Sessions=igmp)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if Result['TxStreamFrames'] != Result['RxStreamFrames'] and Result['RxStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\ncreate_igmp:创建IGMP协议会话对象;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_3/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  6.7.3动态主机配置协议（DHCP）\n\n Step\t\t\t:\t测试步骤1: ：按图10搭建测试环境\n                   测试步骤2: DUT port1 地址为192.168.1.1/24，DUT 上开启 DHCP 服务，设置为DHCP服务器，配置地址池192.168.1.2~192.168.1.254；\n                   测试步骤3: tester port1 作为 DHCP 客户端，发送DHCP请求\n                   测试步骤4: 观察客户端能否接收到正确的地址配置\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: 6.7.3 Dynamic Host Configuration Protocol (DHCP)  \n\nStep:  \nStep 1: Set up the test environment according to Figure 10  \nStep 2: Configure DUT port1 with address 192.168.1.1/24. Enable DHCP service on DUT as DHCP server, configuring address pool 192.168.1.2~192.168.1.254  \nStep 3: Set tester port1 as DHCP client to send DHCP request  \nStep 4: Observe whether the client receives correct address configuration  \n\nCriteria:  \nExpected Result 1: The client receives correct address configuration  \n\nCreated by: Tester-006  \n\nBugs: None",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    # 创建DHCPv4协议会话\n    client = create_dhcp_client(Port=port_up)\n\n    # DHCPv4协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_up)\n\n    # # 获取DHCP Server地址池\n    # configDict = get_configs(Configs='Dhcpv4AddressPool')\n    # dhcpv4AddressPool = list(configDict.values())[0]\n    # edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='192.168.1.2', PrefixLength=19, PoolAddressCount=253)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n        start_protocol()\n        # dhcp_bind(Sessions=client)\n        # 等待DHCP协议协议会话状态正确\n        result = wait_dhcp_client_state(Sessions=client)\n\n        if result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is Bound', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is not Bound', step=4, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "create_dhcp_client:创建DHCPv4客户端协议会话对象",
      "wait_dhcp_client_state:等待DHCP协议会话达到指定状态"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester system and reserve required ports based on test configuration.\",\n  \"Subtask 2\": \"Configure DUT port1 with IP address 192.168.1.1/24 and enable DHCP server with address pool 192.168.1.2-192.168.1.254.\",\n  \"Subtask 3\": \"On tester port1, create a network interface and configure it for DHCP client operation without static IP assignment.\",\n  \"Subtask 4\": \"Create DHCPv4 client session on tester port1 and bind it to the created interface.\",\n  \"Subtask 5\": \"Start DHCP protocol operation and wait for client session to reach BOUND state.\",\n  \"Subtask 6\": \"Verify DHCP client received IP address within configured pool (192.168.1.2-192.168.1.254) and confirm correct network configuration.\",\n  \"Subtask 7\": \"Release reserved ports and shut down tester system after test completion.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: 6.7.3 Dynamic Host Configuration Protocol (DHCP)  \n\nStep:  \nStep 1: Set up the test environment according to Figure 10  \nStep 2: Configure DUT port1 with address 192.168.1.1/24. Enable DHCP service on DUT as DHCP server, configuring address pool 192.168.1.2~192.168.1.254  \nStep 3: Set tester port1 as DHCP client to send DHCP request  \nStep 4: Observe whether the client receives correct address configuration  \n\nCriteria:  \nExpected Result 1: The client receives correct address configuration  \n\nCreated by: Tester-006  \n\nBugs: None\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    # 创建DHCPv4协议会话\n    client = create_dhcp_client(Port=port_up)\n\n    # DHCPv4协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_up)\n\n    # # 获取DHCP Server地址池\n    # configDict = get_configs(Configs='Dhcpv4AddressPool')\n    # dhcpv4AddressPool = list(configDict.values())[0]\n    # edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='192.168.1.2', PrefixLength=19, PoolAddressCount=253)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n        start_protocol()\n        # dhcp_bind(Sessions=client)\n        # 等待DHCP协议协议会话状态正确\n        result = wait_dhcp_client_state(Sessions=client)\n\n        if result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is Bound', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is not Bound', step=4, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\ncreate_dhcp_client:创建DHCPv4客户端协议会话对象;\nwait_dhcp_client_state:等待DHCP协议会话达到指定状态\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_3/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.3 队头阻塞测试\n\n Step\t\t\t:\t测试步骤1: 按图7，从交换机任意选取4 个端口与测试仪相连接，分别定为端口A、端口B、端口C 和端口D；\n                   测试步骤2: 网络测试仪、交换机均关闭流控，12 发送100%流量，32 发送50%流量，34 发送50%流量；\n                    1) 口建立untag流量 连接交换机端口 access vlan 100,\n                    2) 口连接交换机trunk vlan 100,200\n                    3) 口建立vlan 200,vlan4094流量 连接交换机trunk vlan 200,4094\n                    4) 口连接交换机access vlan 4094\n                   测试步骤3: 记录端口D 是否有丢包。\n\n Criteria    \t:   预期结果1: 记录端口D 是否有丢包。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective     : Objective: 6.5.3 Head-of-Line Blocking Test\n\nStep          : Step 1: As per Figure 7, arbitrarily select 4 ports from the switch and connect them to the tester, designated as Port A, Port B, Port C, and Port D respectively;\n               Step 2: Disable flow control on both the network tester and the switch. Send 100% traffic from 1→2, 50% traffic from 3→2, and 50% traffic from 3→4;\n               1) Port 1: Establish untagged traffic and connect to the switch port in access mode for VLAN 100;\n               2) Port 2: Connect to the switch trunk port allowing VLANs 100 and 200;\n               3) Port 3: Establish traffic for VLAN 200 and VLAN 4094, and connect to the switch trunk port allowing VLANs 200 and 4094;\n               4) Port 4: Connect to the switch port in access mode for VLAN 4094;\n               Step 3: Record whether there is packet loss on Port D.\n\nCriteria      : Expected Result 1: Record whether there is packet loss on Port D.\n\nCreated by    : Tester-008\n\nTags          : function\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=100, Seconds=30)\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 绑定流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4', 'tcp'])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 绑定流量\n    edit_port_load_profile(Ports=port3, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    #edit_port_load_profile(Ports=port3, Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan200_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 50)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan4094_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=4094)\n    edit_stream_load_profile(Streams=stream, Rate=50)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        stream1=get_streams(Ports=port1)\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n        stream_object = get_streams(Ports=port3)\n        for stream in stream_object:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=3, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=3, result=True)\n\n        stream = stream_object[1]\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames}),端口D丢包',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),端口D未丢包',\n                step=4, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester using the init_tester API function.\",\n  \"Subtask 2\": \"Reserve four test ports designated as Port1, Port2, Port3, Port4 using reserve_port API and assign MAC addresses to each port.\",\n  \"Subtask 3\": \"Import switch configuration topology using NTO actions_import to set Port1 as access mode VLAN100, Port2 as trunk mode allowing VLAN100/200, Port3 as trunk mode allowing VLAN200/4094, and Port4 as access mode VLAN4094.\",\n  \"Subtask 4\": \"Disable flow control by configuring test port parameters using edit_port API according to testbed specifications.\",\n  \"Subtask 5\": \"Configure Port1 load profile: set transmit mode to TIME, rate to 100%, duration to 30 seconds using edit_port_load_profile API.\",\n  \"Subtask 6\": \"Create untagged VLAN100 traffic stream on Port1: add stream, set frame length to 128 bytes, build Ethernet/VLAN/IPv4/TCP headers, and configure source/destination MAC addresses using add_stream, edit_stream, create_stream_header, and edit_header_ethernet APIs.\",\n  \"Subtask 7\": \"Configure Port3 load profile: set type to STREAM_BASE, transmit mode to TIME, duration to 30 seconds using edit_port_load_profile API.\",\n  \"Subtask 8\": \"Create VLAN200 traffic stream on Port3: add stream, set frame length to 128 bytes, build headers, configure MAC addresses, set VLAN ID to 200, and set rate to 50% using add_stream, edit_stream, create_stream_header, edit_header_ethernet, edit_header_vlan, and edit_stream_load_profile APIs.\",\n  \"Subtask 9\": \"Create VLAN4094 traffic stream on Port3: add stream, set frame length to 128 bytes, build headers, configure MAC addresses, set VLAN ID to 4094, and set rate to 50% using add_stream, edit_stream, create_stream_header, edit_header_ethernet, edit_header_vlan, and edit_stream_load_profile APIs.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats view using subscribe_result API for traffic monitoring.\",\n  \"Subtask 11\": \"Save test configuration using save_case API.\",\n  \"Subtask 12\": \"Start Layer 2 address learning using start_l2_learning API and wait 5 seconds.\",\n  \"Subtask 13\": \"Start traffic transmission on all ports simultaneously using start_stream API.\",\n  \"Subtask 14\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 15\": \"Verify transmitted frame counts for all streams are non-zero using get_streamblock_statistic API.\",\n  \"Subtask 16\": \"Retrieve transmitted (TxStreamFrames) and received (RxStreamFrames) frame counts for VLAN4094 stream (Port3 to Port4) using get_streamblock_statistic API.\",\n  \"Subtask 17\": \"Compare TxStreamFrames and RxStreamFrames for VLAN4094 stream to detect packet loss on Port4.\",\n  \"Subtask 18\": \"Record test result indicating presence/absence of packet loss on Port4 based on frame count comparison.\",\n  \"Subtask 19\": \"Clear statistical results using clear_result API.\",\n  \"Subtask 20\": \"Release reserved ports using release_port API.\",\n  \"Subtask 21\": \"Shutdown tester using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective     : Objective: 6.5.3 Head-of-Line Blocking Test\n\nStep          : Step 1: As per Figure 7, arbitrarily select 4 ports from the switch and connect them to the tester, designated as Port A, Port B, Port C, and Port D respectively;\n               Step 2: Disable flow control on both the network tester and the switch. Send 100% traffic from 1→2, 50% traffic from 3→2, and 50% traffic from 3→4;\n               1) Port 1: Establish untagged traffic and connect to the switch port in access mode for VLAN 100;\n               2) Port 2: Connect to the switch trunk port allowing VLANs 100 and 200;\n               3) Port 3: Establish traffic for VLAN 200 and VLAN 4094, and connect to the switch trunk port allowing VLANs 200 and 4094;\n               4) Port 4: Connect to the switch port in access mode for VLAN 4094;\n               Step 3: Record whether there is packet loss on Port D.\n\nCriteria      : Expected Result 1: Record whether there is packet loss on Port D.\n\nCreated by    : Tester-008\n\nTags          : function\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=100, Seconds=30)\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 绑定流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4', 'tcp'])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 绑定流量\n    edit_port_load_profile(Ports=port3, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    #edit_port_load_profile(Ports=port3, Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan200_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 50)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan4094_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=4094)\n    edit_stream_load_profile(Streams=stream, Rate=50)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        stream1=get_streams(Ports=port1)\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n        stream_object = get_streams(Ports=port3)\n        for stream in stream_object:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=3, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=3, result=True)\n\n        stream = stream_object[1]\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames}),端口D丢包',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),端口D未丢包',\n                step=4, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_1/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.1IP 广播功能\n\n Step\t\t\t:\t测试步骤1: ：1.按图10搭建测试环境；\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为 192.168.2.100/24；\n                   测试步骤3: DUT port1 地址为 192.168.1.1/24，port2 地址为 192.168.2.1/24；port1和port2 均开启直接广播支持；\n                   测试步骤4: tester port1 发送目的地址为255.255.255.255的数据包；\n                   测试步骤5: tester port1 发送目的地址为192.168.2.255的数据包；\n                   测试步骤6: DUT port2 配置192.168.3.0 路由；\n                   测试步骤7: tester port1 发送目的地址为192.168.3.255的数据包；\n                   测试步骤8: 记录步骤4、5、7中tester port2是否收到广播包。\n\n Criteria    \t:   预期结果1: 1.有限广播不能转发。2.三层交换机必须将网络前缀直接广播作为有效\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: 6.7.1 IP Broadcast Function Test  \nStep:  \n1. Set up test environment according to Figure 10.  \n2. Tester port1 address: 192.168.1.100/24, port2 address: 192.168.2.100/24.  \n3. DUT port1 address: 192.168.1.1/24, port2 address: 192.168.2.1/24; enable directed broadcast support on both port1 and port2.  \n4. Tester port1 sends packet with destination address 255.255.255.255.  \n5. Tester port1 sends packet with destination address 192.168.2.255.  \n6. Configure route 192.168.3.0 on DUT port2.  \n7. Tester port1 sends packet with destination address 192.168.3.255.  \n8. Record whether tester port2 receives broadcast packets in steps 4, 5, and 7.  \n\nCriteria:  \n1. Limited broadcast (255.255.255.255) must not be forwarded.  \n2. Layer 3 switch must treat directed broadcast to network prefix as valid.  \n\nCreated by: Tester-006  \nBugs: None",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        TransmitMode=\"CONTINUOUS\",\n    #                        Frames=100,\n    #                        Unit='FRAME_PER_SEC')\n    # edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['255.255.255.255', '192.168.2.255', '192.168.3.255']\n\n    # 创建广播流量\n    # edit_port_load_profile(Ports=port1,LoadProfileType='PORT_BASE',Rate=30,Unit='FRAME_PER_SEC',TransmitMode=\"STEP\",Frames=20)\n    # tester port1 发送目的地址为255.255.255.255的数据包\n    stream = add_stream(Ports=port1, Names=f'step4')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168\n    # .2.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step5')\n\n    edit_stream(Stream=stream, FixedLength=64, )\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168.3.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[2],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_port_load_profile(Ports=port1, LoadProfileType='STREAM_BASE', TransmitMode='TIME', Seconds=30)\n\n    # 订阅统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        streams = get_streams(Ports=port1)\n        start_stream(Type='stream', Objects=streams[0])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[0],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 未收到广播包',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 收到广播包',\n                step=3, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[1])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[1],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=4, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[2])\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[2],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=5, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l3_learning:启动测试仪表流量三层ARP ND学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester and reserve ports according to testbed configuration.\",\n  \"Subtask 2\": \"Configure tester port parameters including force, debug, and wait_for_status_up settings.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both tester ports with specified MAC and IP addresses: port1 at 192.168.1.100/24 (gateway 192.168.1.1), port2 at 192.168.2.100/24 (gateway 192.168.2.1).\",\n  \"Subtask 4\": \"Configure DUT ports: set port1 to 192.168.1.1/24 and port2 to 192.168.2.1/24, enabling directed broadcast support on both ports.\",\n  \"Subtask 5\": \"Set port load profiles for continuous transmission at 100 frames per second.\",\n  \"Subtask 6\": \"Create first test stream on port1 with destination IP 255.255.255.255 (limited broadcast), fixed length 64 bytes.\",\n  \"Subtask 7\": \"Create second test stream on port1 with destination IP 192.168.2.255 (directed broadcast), fixed length 64 bytes.\",\n  \"Subtask 8\": \"Configure DUT to add route for network 192.168.3.0 on port2.\",\n  \"Subtask 9\": \"Create third test stream on port1 with destination IP 192.168.3.255 (directed broadcast), fixed length 64 bytes.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats view for result collection.\",\n  \"Subtask 11\": \"Save test configuration to file.\",\n  \"Subtask 12\": \"For first stream (limited broadcast): start L3 learning, clear statistics, transmit traffic, then verify port2 received 0 packets (no forwarding).\",\n  \"Subtask 13\": \"For second stream (directed broadcast): start L3 learning, clear statistics, transmit traffic, then verify port2 received packets (successful forwarding).\",\n  \"Subtask 14\": \"For third stream (routed directed broadcast): start L3 learning, clear statistics, transmit traffic, then verify port2 received packets (successful forwarding).\",\n  \"Subtask 15\": \"Release tester ports and shutdown tester after test completion.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: 6.7.1 IP Broadcast Function Test  \nStep:  \n1. Set up test environment according to Figure 10.  \n2. Tester port1 address: 192.168.1.100/24, port2 address: 192.168.2.100/24.  \n3. DUT port1 address: 192.168.1.1/24, port2 address: 192.168.2.1/24; enable directed broadcast support on both port1 and port2.  \n4. Tester port1 sends packet with destination address 255.255.255.255.  \n5. Tester port1 sends packet with destination address 192.168.2.255.  \n6. Configure route 192.168.3.0 on DUT port2.  \n7. Tester port1 sends packet with destination address 192.168.3.255.  \n8. Record whether tester port2 receives broadcast packets in steps 4, 5, and 7.  \n\nCriteria:  \n1. Limited broadcast (255.255.255.255) must not be forwarded.  \n2. Layer 3 switch must treat directed broadcast to network prefix as valid.  \n\nCreated by: Tester-006  \nBugs: None\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        TransmitMode=\"CONTINUOUS\",\n    #                        Frames=100,\n    #                        Unit='FRAME_PER_SEC')\n    # edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['255.255.255.255', '192.168.2.255', '192.168.3.255']\n\n    # 创建广播流量\n    # edit_port_load_profile(Ports=port1,LoadProfileType='PORT_BASE',Rate=30,Unit='FRAME_PER_SEC',TransmitMode=\"STEP\",Frames=20)\n    # tester port1 发送目的地址为255.255.255.255的数据包\n    stream = add_stream(Ports=port1, Names=f'step4')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168\n    # .2.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step5')\n\n    edit_stream(Stream=stream, FixedLength=64, )\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168.3.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[2],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_port_load_profile(Ports=port1, LoadProfileType='STREAM_BASE', TransmitMode='TIME', Seconds=30)\n\n    # 订阅统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        streams = get_streams(Ports=port1)\n        start_stream(Type='stream', Objects=streams[0])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[0],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 未收到广播包',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 收到广播包',\n                step=3, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[1])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[1],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=4, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[2])\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[2],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=5, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l3_learning:启动测试仪表流量三层ARP ND学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_6_1/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.6.1 三层转发速率\n\n Step\t\t\t:\t测试步骤1: 按拓扑图搭建测试环境；\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为192.168.2.100/24；\n                   测试步骤3: DUT port1 地址为 192.168.1.1/24，port2 地址为 192.168.2.1/24；\n                   测试步骤4: 测试仪从端口以最大负荷，不同帧长度（64、128、256、512、1024、1518byte）发送数据，测试时间为 30 秒。\n\n Criteria    \t:   预期结果1: 记录转发速率。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   6.6.1 Layer 3 Forwarding Rate\n\nStep\t\t\t:\tStep 1: Set up the test environment according to the topology diagram;\n                   Step 2: Set tester port1 address to 192.168.1.100/24 and port2 address to 192.168.2.100/24;\n                   Step 3: Set DUT port1 address to 192.168.1.1/24 and port2 address to 192.168.2.1/24;\n                   Step 4: The tester sends data from the ports at maximum load with different frame sizes (64, 128, 256, 512, 1024, 1518 bytes) for a test duration of 30 seconds.\n\nCriteria    \t:   Expected result 1: Record the forwarding rate.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['seconds']['default'])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 初始化一个空的DataFrame来存储所有数据\n        printf(message='Test start')\n        all_data = pd.DataFrame()\n        for frame_size in cfg['arg']['stream']['default']['frame_size']['default']:\n            # 修改帧长\n            for s in streams:\n                s.edit(FixedLength=frame_size)\n            # 发送流量\n            start_stream()\n            time.sleep(3)\n            df = get_streamblock_statistic()\n            wait_stream_state(TimeOut=cfg['arg']['load_profile']['default']['seconds']['default'] + 3)\n            time.sleep(3)\n            result = get_streamblock_statistic()\n            # 使用 concat 拼接 DataFrame\n            df = pd.concat([df, result])\n            # 重置索引\n            df = df.reset_index(drop=True)\n            # 添加一列帧长，全部值为当前循环的frame_length，并命名为'frame_length'\n            # 注意：这里我们假设原始DataFrame中没有名为'frame_length'的列，或者即使有，我们也想要覆盖它\n            df['FrameSize'] = frame_size\n            # 但是，由于我们想要将'frame_length'放在第二列，我们需要重新排列列\n            # 首先获取当前列名列表\n            columns = df.columns.tolist()\n            # 如果'FrameSize'已经在列表中，移除它以便我们可以重新插入到正确的位置\n            if 'FrameSize' in columns:\n                columns.remove('FrameSize')\n            # 将'frame_length'插入到第二列的位置（索引为1）\n            columns.insert(1, 'FrameSize')\n            # 重新排序DataFrame的列\n            df = df.reindex(columns=columns)\n            # 将当前循环的数据追加到所有数据的DataFrame中\n            all_data = pd.concat([all_data, df])\n            # 重置all_data的索引，虽然这不是严格必要的，但可以保持索引的连续性\n            all_data = all_data.reset_index(drop=True)\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(all_data, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(all_data)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester system using init_tester API.\",\n  \"Subtask 2\": \"Reserve tester ports using reserve_port API according to test topology.\",\n  \"Subtask 3\": \"Set up DUT port configurations: port1 to 192.168.1.1/24 and port2 to 192.168.2.1/24 (handled by setup function).\",\n  \"Subtask 4\": \"Create IPv4 interfaces on reserved ports using create_interface API.\",\n  \"Subtask 5\": \"Configure tester interface parameters: port1 to 192.168.1.100/24 (gateway 192.168.1.1) and port2 to 192.168.2.100/24 (gateway 192.168.2.1) using edit_interface API.\",\n  \"Subtask 6\": \"Retrieve IPv4 layer objects from interfaces using get_layer_from_interfaces API.\",\n  \"Subtask 7\": \"Create bidirectional traffic streams between port1 and port2 IPv4 layers using add_stream API.\",\n  \"Subtask 8\": \"Configure load profile: maximum load (100%), PERCENT unit, TIME mode, 30-second duration using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Subscribe to PortStats and StreamBlockStats views using subscribe_result API.\",\n  \"Subtask 10\": \"Save test configuration using save_case API.\",\n  \"Subtask 11\": \"For each frame size in [64, 128, 256, 512, 1024, 1518] bytes: modify stream frame length and start traffic using start_stream API.\",\n  \"Subtask 12\": \"Run traffic for 30 seconds, wait for completion using wait_stream_state API.\",\n  \"Subtask 13\": \"Capture and record forwarding rate statistics using get_streamblock_statistic API after each test iteration.\",\n  \"Subtask 14\": \"Release tester ports using release_port API after all test iterations.\",\n  \"Subtask 15\": \"Shutdown tester system using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   6.6.1 Layer 3 Forwarding Rate\n\nStep\t\t\t:\tStep 1: Set up the test environment according to the topology diagram;\n                   Step 2: Set tester port1 address to 192.168.1.100/24 and port2 address to 192.168.2.100/24;\n                   Step 3: Set DUT port1 address to 192.168.1.1/24 and port2 address to 192.168.2.1/24;\n                   Step 4: The tester sends data from the ports at maximum load with different frame sizes (64, 128, 256, 512, 1024, 1518 bytes) for a test duration of 30 seconds.\n\nCriteria    \t:   Expected result 1: Record the forwarding rate.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['seconds']['default'])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 初始化一个空的DataFrame来存储所有数据\n        printf(message='Test start')\n        all_data = pd.DataFrame()\n        for frame_size in cfg['arg']['stream']['default']['frame_size']['default']:\n            # 修改帧长\n            for s in streams:\n                s.edit(FixedLength=frame_size)\n            # 发送流量\n            start_stream()\n            time.sleep(3)\n            df = get_streamblock_statistic()\n            wait_stream_state(TimeOut=cfg['arg']['load_profile']['default']['seconds']['default'] + 3)\n            time.sleep(3)\n            result = get_streamblock_statistic()\n            # 使用 concat 拼接 DataFrame\n            df = pd.concat([df, result])\n            # 重置索引\n            df = df.reset_index(drop=True)\n            # 添加一列帧长，全部值为当前循环的frame_length，并命名为'frame_length'\n            # 注意：这里我们假设原始DataFrame中没有名为'frame_length'的列，或者即使有，我们也想要覆盖它\n            df['FrameSize'] = frame_size\n            # 但是，由于我们想要将'frame_length'放在第二列，我们需要重新排列列\n            # 首先获取当前列名列表\n            columns = df.columns.tolist()\n            # 如果'FrameSize'已经在列表中，移除它以便我们可以重新插入到正确的位置\n            if 'FrameSize' in columns:\n                columns.remove('FrameSize')\n            # 将'frame_length'插入到第二列的位置（索引为1）\n            columns.insert(1, 'FrameSize')\n            # 重新排序DataFrame的列\n            df = df.reindex(columns=columns)\n            # 将当前循环的数据追加到所有数据的DataFrame中\n            all_data = pd.concat([all_data, df])\n            # 重置all_data的索引，虽然这不是严格必要的，但可以保持索引的连续性\n            all_data = all_data.reset_index(drop=True)\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(all_data, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(all_data)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_8_1/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.8.1错误帧过滤功能\n\n Step\t\t\t:\t测试步骤1: ：按图4，任选交换机两个端口作为测试端口；\n                   测试步骤2: 端口1向端口2发送CRC校验错误帧，观察接收情况；\n                   测试步骤3: 端口1向端口2发送源MAC地址错误帧，观察接收情况\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    : Purpose: 6.8.1 Error Frame Filtering Function\n\nStep        : Test Step 1: According to Figure 4, select any two ports of the switch as test ports.\n              Test Step 2: Port 1 sends a CRC error frame to Port 2; observe reception status.\n              Test Step 3: Port 1 sends a source MAC address error frame to Port 2; observe reception status.\n\nCriteria     : Expected Result 1:\n\nCreated by   : Tester-006\n\nBugs         : None\n=================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100,\n                           GenerateError='CRC')\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=False)\n\n        clear_result()\n        edit_port_load_profile(Ports=port1,\n                               LoadProfileType='PORT_BASE',\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=100,\n                               GenerateError='NO_ERROR')\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames == RxStreamFrames and  RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester system and reserve two specified ports from the testbed configuration.\",\n  \"Subtask 2\": \"Create network interfaces on both reserved ports with IPv4 layers and configure MAC/IPv4 addresses according to test parameters.\",\n  \"Subtask 3\": \"Configure port1's load profile to generate CRC errors with continuous transmission at 100 frames/sec.\",\n  \"Subtask 4\": \"Create stream1 on port1 with valid source MAC address, destination MAC address, and fixed 64-byte frame length.\",\n  \"Subtask 5\": \"Create stream2 on port1 with invalid source MAC address (00:00:00:00:00:00), same destination MAC, and fixed 64-byte frame length.\",\n  \"Subtask 6\": \"Subscribe to PortStats and StreamBlockStats views for result monitoring.\",\n  \"Subtask 7\": \"Start L2 learning process and transmit stream1 (CRC error frames) for 10 seconds.\",\n  \"Subtask 8\": \"Retrieve stream1 statistics and verify that TxStreamFrames > 0 while RxStreamFrames = 0.\",\n  \"Subtask 9\": \"Reconfigure port1's load profile to disable error generation (NO_ERROR setting).\",\n  \"Subtask 10\": \"Start L2 learning process and transmit stream2 (source MAC error frames) for 10 seconds.\",\n  \"Subtask 11\": \"Retrieve stream2 statistics and verify that TxStreamFrames = RxStreamFrames > 0.\",\n  \"Subtask 12\": \"Release reserved ports and shutdown tester system.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    : Purpose: 6.8.1 Error Frame Filtering Function\n\nStep        : Test Step 1: According to Figure 4, select any two ports of the switch as test ports.\n              Test Step 2: Port 1 sends a CRC error frame to Port 2; observe reception status.\n              Test Step 3: Port 1 sends a source MAC address error frame to Port 2; observe reception status.\n\nCriteria     : Expected Result 1:\n\nCreated by   : Tester-006\n\nBugs         : None\n=================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100,\n                           GenerateError='CRC')\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=False)\n\n        clear_result()\n        edit_port_load_profile(Ports=port1,\n                               LoadProfileType='PORT_BASE',\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=100,\n                               GenerateError='NO_ERROR')\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames == RxStreamFrames and  RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_5/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.5 多链路聚合: 链路聚合时不应丢失数据\n\n Step\t\t\t:\t测试步骤1: 按图8 建立测试环境；\n                   测试步骤2: 将交换机1 的2 个端口和交换机2 的2 个端口对应连接。将交换机1 的 2个端口配置为一个静态聚合端口，交换机2 的2 个端口配置为一个静态聚合端口；\n                   测试步骤3: 由测试仪1、3 端口分别向2、4 端口发送数据流，负载率为100%；\n                   测试步骤4: 在测试仪的2、4 端口观察流量的接收情况，应无丢包；\n                   测试步骤5: 断开交换机1 和交换机2 间的1 条链路，观察流量的接收情况，应各丢 50%；\n                   测试步骤6: 停掉3 向4 的数据流，观察1 向2 的数据流的接收情况，应无丢包。\n\n Criteria    \t:   预期结果1: 记录端口4 接收到的数据帧数量，判断镜像功能是否设置成功。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "Objective: Test Purpose: 6.5.5 Multi-Link Aggregation: No data loss should occur during link aggregation.\n\nStep: Test Step 1: Establish the test environment according to Figure 8;  \nTest Step 2: Connect two ports of Switch 1 to two ports of Switch 2 respectively. Configure the two ports of Switch 1 as one static aggregation port, and the two ports of Switch 2 as one static aggregation port;  \nTest Step 3: Send data streams from ports 1 and 3 of the tester to ports 2 and 4 respectively at 100% load rate;  \nTest Step 4: Observe traffic reception at ports 2 and 4 of the tester—no packet loss should occur;  \nTest Step 5: Disconnect one link between Switch 1 and Switch 2—observe traffic reception, 50% packet loss should occur on each;  \nTest Step 6: Stop the data stream from port 3 to port 4—observe reception of the data stream from port 1 to port 2—no packet loss should occur.\n\nCriteria: Expected Result 1: Record the number of data frames received at port 4 to determine whether the mirroring function is successfully configured.\n\nCreated by: Tester-008\n\nTags: function",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    # 端口1创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream1 = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream1, FixedLength=128)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 端口3创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream2 = add_stream(Ports=port3, Names=f'{port3.Name}_100%')\n    edit_stream(Stream=stream2, FixedLength=128)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取流量结果\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step4：get  stream statistic')\n        # 获取流量1统计结果\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames'] and Result2['TxStreamFrames']==Result2['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames']*2 and Result2['TxStreamFrames']==Result2['RxStreamFrames']*2:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        # 停止3口流量\n        stop_stream(Type='stream',Objects=stream2)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result1['TxStreamFrames'] == Result1['RxStreamFrames']  and Result2['TxStreamFrames'] == Result2[\n            'RxStreamFrames'] :\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester and reserve ports 1, 2, 3, and 4 according to testbed configuration.\",\n  \"Subtask 2\": \"Configure all reserved ports with required parameters (transmit mode, rate) using edit_port_load_profile.\",\n  \"Subtask 3\": \"Create stream on port 1 with Ethernet header (source MAC 00:00:00:13:40:21, destination MAC 00:00:01:13:40:20), fixed length 128 bytes.\",\n  \"Subtask 4\": \"Create stream on port 3 with Ethernet header (source MAC 00:00:00:13:40:22, destination MAC 00:00:01:13:40:21), fixed length 128 bytes.\",\n  \"Subtask 5\": \"Subscribe to StreamBlockStats view for traffic monitoring.\",\n  \"Subtask 6\": \"Start L2 learning process and wait 5 seconds for MAC address learning.\",\n  \"Subtask 7\": \"Clear existing statistics, start both streams (port1→port2 and port3→port4) at 100% load rate.\",\n  \"Subtask 8\": \"Wait for streams to complete, then verify no packet loss by comparing TxStreamFrames and RxStreamFrames for both streams.\",\n  \"Subtask 9\": \"Clear statistics again, restart both streams to simulate link disconnection scenario.\",\n  \"Subtask 10\": \"After streams complete, verify 50% packet loss by checking TxStreamFrames = 2 * RxStreamFrames for both streams.\",\n  \"Subtask 11\": \"Clear statistics, stop port3→port4 stream while keeping port1→port2 stream active.\",\n  \"Subtask 12\": \"Verify no packet loss on port1→port2 stream by comparing TxStreamFrames and RxStreamFrames.\",\n  \"Subtask 13\": \"Release all reserved ports and shutdown tester after test completion.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: 6.5.5 Multi-Link Aggregation: No data loss should occur during link aggregation.\n\nStep: Test Step 1: Establish the test environment according to Figure 8;  \nTest Step 2: Connect two ports of Switch 1 to two ports of Switch 2 respectively. Configure the two ports of Switch 1 as one static aggregation port, and the two ports of Switch 2 as one static aggregation port;  \nTest Step 3: Send data streams from ports 1 and 3 of the tester to ports 2 and 4 respectively at 100% load rate;  \nTest Step 4: Observe traffic reception at ports 2 and 4 of the tester—no packet loss should occur;  \nTest Step 5: Disconnect one link between Switch 1 and Switch 2—observe traffic reception, 50% packet loss should occur on each;  \nTest Step 6: Stop the data stream from port 3 to port 4—observe reception of the data stream from port 1 to port 2—no packet loss should occur.\n\nCriteria: Expected Result 1: Record the number of data frames received at port 4 to determine whether the mirroring function is successfully configured.\n\nCreated by: Tester-008\n\nTags: function\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    # 端口1创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream1 = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream1, FixedLength=128)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 端口3创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream2 = add_stream(Ports=port3, Names=f'{port3.Name}_100%')\n    edit_stream(Stream=stream2, FixedLength=128)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取流量结果\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step4：get  stream statistic')\n        # 获取流量1统计结果\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames'] and Result2['TxStreamFrames']==Result2['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames']*2 and Result2['TxStreamFrames']==Result2['RxStreamFrames']*2:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        # 停止3口流量\n        stop_stream(Type='stream',Objects=stream2)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result1['TxStreamFrames'] == Result1['RxStreamFrames']  and Result2['TxStreamFrames'] == Result2[\n            'RxStreamFrames'] :\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_7/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.7 网络风暴抑制: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示；\n                   测试步骤2: 测试帧长设为64，端口负载为满负载，测试时间30s；\n                   测试步骤3: 交换机分别开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能；\n                   测试步骤4: 使用默认抑制值或者设置抑制值为1M；\n                   测试步骤5: 端口1 向端口2 发送3 条数据流，分别为Stream1（广播帧）、Stream2（广播帧）、Stream3（IPv4 帧），端口2 向端口1 发送2 条数据流，分别为Stream1（组播帧）、Stream2（未知单播帧）；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断网络风暴抑制功能是否设置成功；\n                   测试步骤7: 根据帧丢失率，计算网络风暴抑制比偏差。\n\n Criteria    \t:   预期结果1: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启；\n                   预期结果2: 网络风暴实际抑制值不应超过抑制设定值的110%。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective     : Test Objective : 6.5.7 Network Storm Control: Shall support broadcast, multicast, and unknown unicast storm control functions. Broadcast storm control is enabled by default.\n\nStep          : Test Step 1: Connect traffic generator to switch as shown in Figure 4;\n                Test Step 2: Set frame length to 64 bytes, port load to 100%, test duration 30s;\n                Test Step 3: Enable broadcast, multicast, and unknown unicast storm control functions on the switch;\n                Test Step 4: Use default suppression value or set suppression value to 1M;\n                Test Step 5: Port 1 sends 3 streams to Port 2: Stream1 (broadcast frames), Stream2 (broadcast frames), Stream3 (IPv4 frames). Port 2 sends 2 streams to Port 1: Stream1 (multicast frames), Stream2 (unknown unicast frames);\n                Test Step 6: Record frame loss rate for each stream to verify storm control configuration;\n                Test Step 7: Calculate storm control ratio deviation based on frame loss rate.\n\nCriteria      : Expected Result 1: Shall support broadcast, multicast, and unknown unicast storm control functions. Broadcast storm control is enabled by default;\n                Expected Result 2: Actual suppression value shall not exceed 110% of configured suppression value.\n\nCreated by    : Tester-008\n\nTags          : Function\n=================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        expected_value = 0.1 * 1.1\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 3 * 2\n\n            if round(prss, 2) < expected_value:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 2\n            if round(prss, 2) < expected_value:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester and reserve ports as specified in the testbed configuration.\",\n  \"Subtask 2\": \"Set frame length to 64 bytes, port load to 100%, and test duration to 30 seconds for all test ports.\",\n  \"Subtask 3\": \"Enable broadcast, multicast, and unknown unicast storm control on the switch with suppression value set to 1Mbps.\",\n  \"Subtask 4\": \"Create three streams on port1: Stream1 (broadcast frames), Stream2 (broadcast frames), Stream3 (IPv4 frames) with specified source/destination MAC addresses.\",\n  \"Subtask 5\": \"Create two streams on port2: Stream1 (multicast frames), Stream2 (unknown unicast frames) with specified source/destination MAC addresses.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats view for traffic statistics collection.\",\n  \"Subtask 7\": \"Start traffic transmission from port1 and wait for completion.\",\n  \"Subtask 8\": \"For each stream on port1: retrieve transmitted/received frame counts, calculate frame loss rate, and verify broadcast streams show suppression within 110% threshold while IPv4 stream forwards without loss.\",\n  \"Subtask 9\": \"Clear statistics and start traffic transmission from port2.\",\n  \"Subtask 10\": \"For each stream on port2: retrieve transmitted/received frame counts, calculate frame loss rate, and verify multicast/unknown unicast streams show suppression within 110% threshold.\",\n  \"Subtask 11\": \"Calculate storm control ratio deviation based on frame loss rates for all suppressed streams.\",\n  \"Subtask 12\": \"Release all reserved ports and perform cleanup operations.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective     : Test Objective : 6.5.7 Network Storm Control: Shall support broadcast, multicast, and unknown unicast storm control functions. Broadcast storm control is enabled by default.\n\nStep          : Test Step 1: Connect traffic generator to switch as shown in Figure 4;\n                Test Step 2: Set frame length to 64 bytes, port load to 100%, test duration 30s;\n                Test Step 3: Enable broadcast, multicast, and unknown unicast storm control functions on the switch;\n                Test Step 4: Use default suppression value or set suppression value to 1M;\n                Test Step 5: Port 1 sends 3 streams to Port 2: Stream1 (broadcast frames), Stream2 (broadcast frames), Stream3 (IPv4 frames). Port 2 sends 2 streams to Port 1: Stream1 (multicast frames), Stream2 (unknown unicast frames);\n                Test Step 6: Record frame loss rate for each stream to verify storm control configuration;\n                Test Step 7: Calculate storm control ratio deviation based on frame loss rate.\n\nCriteria      : Expected Result 1: Shall support broadcast, multicast, and unknown unicast storm control functions. Broadcast storm control is enabled by default;\n                Expected Result 2: Actual suppression value shall not exceed 110% of configured suppression value.\n\nCreated by    : Tester-008\n\nTags          : Function\n=================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        expected_value = 0.1 * 1.1\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 3 * 2\n\n            if round(prss, 2) < expected_value:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 2\n            if round(prss, 2) < expected_value:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_8/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.8 网络风暴抑制: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示；\n                   测试步骤2: 测试帧长设为64，端口负载为满负载，测试时间30s；\n                   测试步骤3: 交换机分别开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能；\n                   测试步骤4: 设置抑制值为1M+粒度；\n                   测试步骤5: 端口1 向端口2 发送3 条数据流，分别为Stream1（广播帧）、Stream2（广播帧）、Stream3（IPv4 帧），端口2 向端口1 发送2 条数据流，分别为Stream1（组播帧）、Stream2（未知单播帧）；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断网络风暴抑制功能是否设置成功；\n                   测试步骤7: 根据帧丢失率，计算网络风暴抑制比偏差。\n\n Criteria    \t:   预期结果1: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启；\n                   预期结果2: 网络风暴实际抑制值不应超过抑制设定值的110%。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective     : 6.5.8 Network Storm Suppression: Must support broadcast storm suppression, multicast storm suppression, and unknown unicast storm suppression functions. The broadcast storm suppression function is enabled by default.\n\nStep          : Step 1: Connect the traffic generator to the switch as shown in Figure 4;\n               Step 2: Set test frame length to 64, port load to full load, and test duration to 30 seconds;\n               Step 3: Enable broadcast storm suppression, multicast storm suppression, and unknown unicast storm suppression functions on the switch;\n               Step 4: Set suppression value to 1M+ granularity;\n               Step 5: Port 1 sends three data streams to Port 2: Stream1 (broadcast frame), Stream2 (broadcast frame), Stream3 (IPv4 frame). Port 2 sends two data streams to Port 1: Stream1 (multicast frame), Stream2 (unknown unicast frame);\n               Step 6: Record frame loss rates for each data stream and determine if network storm suppression is successfully configured;\n               Step 7: Calculate network storm suppression ratio deviation based on frame loss rates.\n\nCriteria      : Expected Result 1: Must support broadcast storm suppression, multicast storm suppression, and unknown unicast storm suppression functions. The broadcast storm suppression function is enabled by default;\n               Expected Result 2: Actual network storm suppression value must not exceed 110% of the configured suppression value.\n\nCreated by    : Tester-008\n\nTags          : function\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester and reserve ports according to the testbed configuration.\",\n  \"Subtask 2\": \"Configure switch settings: enable broadcast storm suppression (default), multicast storm suppression, and unknown unicast storm suppression with 1M+ granularity suppression value.\",\n  \"Subtask 3\": \"Set test parameters: frame length to 64 bytes, port load to 100%, and test duration to 30 seconds using edit_port_load_profile.\",\n  \"Subtask 4\": \"Create three streams on Port 1: Stream1 (broadcast frames), Stream2 (broadcast frames), Stream3 (IPv4 frames) with specified MAC addresses using add_stream, edit_stream, create_stream_header, and edit_header_ethernet.\",\n  \"Subtask 5\": \"Create two streams on Port 2: Stream1 (multicast frames), Stream2 (unknown unicast frames) with specified MAC addresses using add_stream, edit_stream, create_stream_header, and edit_header_ethernet.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats view using subscribe_result and save test configuration with save_case.\",\n  \"Subtask 7\": \"Start all streams on Port 1 using start_stream, wait for transmission completion with wait_stream_state, then collect frame loss statistics using get_streamblock_statistic.\",\n  \"Subtask 8\": \"Verify broadcast streams (Stream1-2) show >99% frame loss indicating successful suppression, and IPv4 stream (Stream3) shows 0% frame loss indicating normal forwarding.\",\n  \"Subtask 9\": \"Clear statistics using clear_result.\",\n  \"Subtask 10\": \"Start all streams on Port 2 using start_stream, wait for transmission completion with wait_stream_state, then collect frame loss statistics using get_streamblock_statistic.\",\n  \"Subtask 11\": \"Verify multicast and unknown unicast streams (Port2 Stream1-2) show >99% frame loss indicating successful suppression.\",\n  \"Subtask 12\": \"Calculate actual suppression value from received frame rates and verify deviation does not exceed 110% of configured 1M+ suppression value.\",\n  \"Subtask 13\": \"Release reserved ports using release_port and shut down tester.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective     : 6.5.8 Network Storm Suppression: Must support broadcast storm suppression, multicast storm suppression, and unknown unicast storm suppression functions. The broadcast storm suppression function is enabled by default.\n\nStep          : Step 1: Connect the traffic generator to the switch as shown in Figure 4;\n               Step 2: Set test frame length to 64, port load to full load, and test duration to 30 seconds;\n               Step 3: Enable broadcast storm suppression, multicast storm suppression, and unknown unicast storm suppression functions on the switch;\n               Step 4: Set suppression value to 1M+ granularity;\n               Step 5: Port 1 sends three data streams to Port 2: Stream1 (broadcast frame), Stream2 (broadcast frame), Stream3 (IPv4 frame). Port 2 sends two data streams to Port 1: Stream1 (multicast frame), Stream2 (unknown unicast frame);\n               Step 6: Record frame loss rates for each data stream and determine if network storm suppression is successfully configured;\n               Step 7: Calculate network storm suppression ratio deviation based on frame loss rates.\n\nCriteria      : Expected Result 1: Must support broadcast storm suppression, multicast storm suppression, and unknown unicast storm suppression functions. The broadcast storm suppression function is enabled by default;\n               Expected Result 2: Actual network storm suppression value must not exceed 110% of the configured suppression value.\n\nCreated by    : Tester-008\n\nTags          : function\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_4/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.4 端口镜像:支持单端口镜像和多端口镜像，镜像端口在不丢失数据的前提下应保证系统要求的转发速率。\n\n Step\t\t\t:\t测试步骤1: 测试帧长度为 64 字节，测试时间不小于 30s；\n                   测试步骤2: 测试配置图如图 7 所示，交换机端口 4 设置成镜像端口，端口 1 和端口 3设置成被镜像端口，镜像方式为输入和输出同时镜像；\n                   测试步骤3: 端口 1 向端口 2 双向发送数据，端口 2 和端口 3 双向发送数据，负载率分别为 25%；\n\n Criteria    \t:   预期结果1: 记录端口 4 接收到的数据帧数量，判断镜像功能是否设置成功。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective      :   Test Purpose : 6.5.4 Port Mirroring: Supports single-port and multi-port mirroring. The mirror port shall maintain the system-required forwarding rate without packet loss.\n\nStep           :   Test Step 1: Frame length = 64 bytes, test duration ≥ 30s;\n                   Test Step 2: Test configuration as per Figure 7. Switch Port 4 configured as mirror port, Ports 1 and 3 as mirrored ports with bidirectional mirroring (input/output);\n                   Test Step 3: Port 1 ↔ Port 2 bidirectional transmission, Port 2 ↔ Port 3 bidirectional transmission, each at 25% load rate.\n\nCriteria       :   Expected Result 1: Record frame count received at Port 4 to verify mirroring configuration success.\n\nCreated by     :   Tester-008\n\nTags           :   function\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_25%')\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=25, Seconds=30)\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 流量\n    edit_port_load_profile(Ports=port2, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan200_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 25)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan100_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_stream_load_profile(Streams=stream, Rate= 25)\n\n    # 端口3创建绑定1-》2 绑定流量\n    edit_port_load_profile(Ports=port3, TransmitMode='TIME', Rate=25, Seconds=30)\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        #清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        result = get_port_statistic(StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port1_Result = get_port_statistic(Port=port1, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port3_Result = get_port_statistic(Port=port3, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port4_Result = get_port_statistic(Port=port4, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        MirrotFrames = Port1_Result['TxStreamFrames']+Port1_Result['RxSignatureStreamFrames']+Port3_Result['TxStreamFrames']+Port3_Result['RxSignatureStreamFrames']\n        RX_Result=Port4_Result['RxSignatureStreamFrames']\n        if MirrotFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is not equal to 0',\n                step=3, result=True)\n\n        if  MirrotFrames == RX_Result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is not equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_port_statistic:获取测试仪表端口统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using init_tester API.\",\n  \"Subtask 2\": \"Reserve ports 1, 2, 3, and 4 using reserve_port API with locations from configuration.\",\n  \"Subtask 3\": \"Configure switch settings: Set port 4 as mirror port, ports 1 and 3 as mirrored ports with bidirectional mirroring (input/output).\",\n  \"Subtask 4\": \"Edit port parameters (speed/duplex) per testbed configuration using edit_port API.\",\n  \"Subtask 5\": \"Create traffic streams: On port 1, add untagged TCP stream to port 2 with 64-byte frames and 25% load rate.\",\n  \"Subtask 6\": \"Create traffic streams: On port 2, add two VLAN-tagged TCP streams (VLAN 200 and VLAN 100) to port 3 with 64-byte frames and 25% load rate each.\",\n  \"Subtask 7\": \"Create traffic streams: On port 3, add untagged TCP stream to port 2 with 64-byte frames and 25% load rate.\",\n  \"Subtask 8\": \"Set all streams to 30-second duration using edit_stream_load_profile API.\",\n  \"Subtask 9\": \"Configure Ethernet headers for all streams with appropriate source/destination MAC addresses using edit_header_ethernet API.\",\n  \"Subtask 10\": \"Subscribe to PortStats view using subscribe_result API for statistics collection.\",\n  \"Subtask 11\": \"Start Layer 2 learning using start_l2_learning API and wait 5 seconds for MAC address stabilization.\",\n  \"Subtask 12\": \"Clear all port statistics using clear_result API.\",\n  \"Subtask 13\": \"Start all traffic streams simultaneously using start_stream API.\",\n  \"Subtask 14\": \"Wait for test duration completion (≥30 seconds) and verify streams stop using wait_stream_state API.\",\n  \"Subtask 15\": \"Collect port statistics: Get TxStreamFrames and RxSignatureStreamFrames for port 1 using get_port_statistic API.\",\n  \"Subtask 16\": \"Collect port statistics: Get TxStreamFrames and RxSignatureStreamFrames for port 3 using get_port_statistic API.\",\n  \"Subtask 17\": \"Collect port statistics: Get RxSignatureStreamFrames for mirror port 4 using get_port_statistic API.\",\n  \"Subtask 18\": \"Calculate total mirrored frames: Sum of (port 1 Tx + port 1 Rx + port 3 Tx + port 3 Rx) frames.\",\n  \"Subtask 19\": \"Verify mirroring success: Confirm port 4 received frames equal calculated total mirrored frames.\",\n  \"Subtask 20\": \"Release all reserved ports using release_port API.\",\n  \"Subtask 21\": \"Shutdown test instrument using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective      :   Test Purpose : 6.5.4 Port Mirroring: Supports single-port and multi-port mirroring. The mirror port shall maintain the system-required forwarding rate without packet loss.\n\nStep           :   Test Step 1: Frame length = 64 bytes, test duration ≥ 30s;\n                   Test Step 2: Test configuration as per Figure 7. Switch Port 4 configured as mirror port, Ports 1 and 3 as mirrored ports with bidirectional mirroring (input/output);\n                   Test Step 3: Port 1 ↔ Port 2 bidirectional transmission, Port 2 ↔ Port 3 bidirectional transmission, each at 25% load rate.\n\nCriteria       :   Expected Result 1: Record frame count received at Port 4 to verify mirroring configuration success.\n\nCreated by     :   Tester-008\n\nTags           :   function\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_25%')\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=25, Seconds=30)\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 流量\n    edit_port_load_profile(Ports=port2, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan200_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 25)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan100_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_stream_load_profile(Streams=stream, Rate= 25)\n\n    # 端口3创建绑定1-》2 绑定流量\n    edit_port_load_profile(Ports=port3, TransmitMode='TIME', Rate=25, Seconds=30)\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        #清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        result = get_port_statistic(StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port1_Result = get_port_statistic(Port=port1, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port3_Result = get_port_statistic(Port=port3, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port4_Result = get_port_statistic(Port=port4, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        MirrotFrames = Port1_Result['TxStreamFrames']+Port1_Result['RxSignatureStreamFrames']+Port3_Result['TxStreamFrames']+Port3_Result['RxSignatureStreamFrames']\n        RX_Result=Port4_Result['RxSignatureStreamFrames']\n        if MirrotFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is not equal to 0',\n                step=3, result=True)\n\n        if  MirrotFrames == RX_Result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is not equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_port_statistic:获取测试仪表端口统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_6/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  开放式最短路径优先路由协议（OSPF)\n\n Step\t\t\t:\t测试步骤1: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24；\n                   测试步骤2: DUT port1 IP地址为192.168.1.1/24，port2为 192.168.2.1/24；\n                   测试步骤3: 在DUT上配置OSPFv2路由协议；\n                   测试步骤4: 测试仪tester使用port1、port2建立OSPF路由器，在port1插入一些LSA，并使port1和DUT的port1达到FULL状态，port2和DUT的port2达到FULL状态，观察port2是否能得到port1的LSA。\n\n Criteria    \t:   预期结果1: ospf建立成功，可以收到lsa\n =================================================================================",
    "intent_en": "Objective: Open Shortest Path First routing protocol (OSPF)  \n\nStep 1: Tester port1 IP address is 192.168.1.100/24, port2 is 192.168.2.100/24;  \nStep 2: DUT port1 IP address is 192.168.1.1/24, port2 is 192.168.2.1/24;  \nStep 3: Configure OSPFv2 routing protocol on the DUT;  \nStep 4: The tester uses port1 and port2 to establish OSPF routers, injects LSAs on port1, ensures port1 and DUT's port1 reach FULL state, and port2 and DUT's port2 reach FULL state. Observe whether port2 receives the LSAs from port1.  \n\nCriteria 1: OSPF establishes successfully and LSAs are received.",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    #创建ospf协议\n    session_1 = create_ospf(Port=port_up, Priority=1)\n    session_2 = create_ospf(Port=port_down, Priority=2)\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    # OSPFv2协议会话1创建Summary Lsa\n    summary_lsa = create_ospf_summary_lsa(Session=session_1)\n\n    # OSPFv2协议会话2创建External Lsa\n    external_lsa = create_ospf_external_lsa(Session=session_2)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=summary_lsa)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        advertise_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n\n        # 发送流量\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        withdraw_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n        stop_protocol()\n        time.sleep(3)\n\n        # 获取OSPFv2会话1统计\n        import pandas\n        result = get_ospf_statistic()\n        print(result)\n        if not isinstance(result, pandas.DataFrame):\n            verdict = 'fail'\n\n        result = get_ospf_statistic(Session=session_1)\n        print(result)\n        TxSummaryLsa = result['TxSummaryLsa']\n        RxAsExternalLsa = result['RxAsExternalLsa']\n        print('TxSummaryLsa: {}'.format(TxSummaryLsa))\n        print('RxAsExternalLsa: {}'.format(RxAsExternalLsa))\n\n        # 获取OSPFv2会话2统计\n        result = get_ospf_statistic(Session=session_2)\n        print(result)\n        RxSummaryLsa = result['RxSummaryLsa']\n        TxAsExternalLsa = result['TxAsExternalLsa']\n        print('RxSummaryLsa: {}'.format(RxSummaryLsa))\n        print('TxAsExternalLsa: {}'.format(TxAsExternalLsa))\n\n        # 获取流量1统计\n        result = get_streamblock_statistic(Stream=streams[0])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name,TxStreamFrames,RxStreamFrames)\n\n        # 获取流量2统计\n\n        result = get_streamblock_statistic(Stream=streams[1])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name,TxStreamFrames,RxStreamFrames)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_ospf_lsa:通告 OSPFv2 协议会话 lsa",
      "create_ospf:创建OSPFv2协议会话对象",
      "create_ospf_external_lsa:创建OSPFv2 External LSA对象",
      "create_ospf_summary_lsa:创建OSPFv2 Summary LSA对象",
      "get_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象",
      "get_ospf_statistic:获取OSPFv2协议会话统计结果",
      "wait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态",
      "withdraw_ospf_lsa:撤销OSPFv2协议会话lsa",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester and reserve ports for both tester interfaces (port1 and port2) using reserve_port API.\",\n  \"Subtask 2\": \"Configure port parameters for both reserved ports using edit_port API as per testbed specifications.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both tester ports (port1 and port2) using create_interface API with specified IP addresses: 192.168.1.100/24 for port1 and 192.168.2.100/24 for port2.\",\n  \"Subtask 4\": \"Set MAC addresses and IPv4 gateways for both interfaces using edit_interface API, with gateways pointing to DUT ports (192.168.1.1 for port1 interface, 192.168.2.1 for port2 interface).\",\n  \"Subtask 5\": \"Create OSPFv2 sessions on both tester ports using create_ospf API with specified priorities (1 for port1, 2 for port2).\",\n  \"Subtask 6\": \"Bind the OSPFv2 sessions to their respective interfaces using select_interface API.\",\n  \"Subtask 7\": \"Create Summary LSA on port1's OSPF session using create_ospf_summary_lsa API.\",\n  \"Subtask 8\": \"Start OSPF protocol on both ports using start_protocol API.\",\n  \"Subtask 9\": \"Wait until both OSPF sessions reach FULL adjacency state with DUT ports using wait_ospf_adjacency_state API.\",\n  \"Subtask 10\": \"Advertise the created Summary LSA on port1 using advertise_ospf_lsa API.\",\n  \"Subtask 11\": \"Retrieve OSPF statistics for port2's session using get_ospf_statistic API and verify receipt of Summary LSA by checking RxSummaryLsa count.\",\n  \"Subtask 12\": \"Stop OSPF protocol using stop_protocol API and release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Open Shortest Path First routing protocol (OSPF)  \n\nStep 1: Tester port1 IP address is 192.168.1.100/24, port2 is 192.168.2.100/24;  \nStep 2: DUT port1 IP address is 192.168.1.1/24, port2 is 192.168.2.1/24;  \nStep 3: Configure OSPFv2 routing protocol on the DUT;  \nStep 4: The tester uses port1 and port2 to establish OSPF routers, injects LSAs on port1, ensures port1 and DUT's port1 reach FULL state, and port2 and DUT's port2 reach FULL state. Observe whether port2 receives the LSAs from port1.  \n\nCriteria 1: OSPF establishes successfully and LSAs are received.\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    #创建ospf协议\n    session_1 = create_ospf(Port=port_up, Priority=1)\n    session_2 = create_ospf(Port=port_down, Priority=2)\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    # OSPFv2协议会话1创建Summary Lsa\n    summary_lsa = create_ospf_summary_lsa(Session=session_1)\n\n    # OSPFv2协议会话2创建External Lsa\n    external_lsa = create_ospf_external_lsa(Session=session_2)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=summary_lsa)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        advertise_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n\n        # 发送流量\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        withdraw_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n        stop_protocol()\n        time.sleep(3)\n\n        # 获取OSPFv2会话1统计\n        import pandas\n        result = get_ospf_statistic()\n        print(result)\n        if not isinstance(result, pandas.DataFrame):\n            verdict = 'fail'\n\n        result = get_ospf_statistic(Session=session_1)\n        print(result)\n        TxSummaryLsa = result['TxSummaryLsa']\n        RxAsExternalLsa = result['RxAsExternalLsa']\n        print('TxSummaryLsa: {}'.format(TxSummaryLsa))\n        print('RxAsExternalLsa: {}'.format(RxAsExternalLsa))\n\n        # 获取OSPFv2会话2统计\n        result = get_ospf_statistic(Session=session_2)\n        print(result)\n        RxSummaryLsa = result['RxSummaryLsa']\n        TxAsExternalLsa = result['TxAsExternalLsa']\n        print('RxSummaryLsa: {}'.format(RxSummaryLsa))\n        print('TxAsExternalLsa: {}'.format(TxAsExternalLsa))\n\n        # 获取流量1统计\n        result = get_streamblock_statistic(Stream=streams[0])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name,TxStreamFrames,RxStreamFrames)\n\n        # 获取流量2统计\n\n        result = get_streamblock_statistic(Stream=streams[1])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name,TxStreamFrames,RxStreamFrames)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_ospf_lsa:通告 OSPFv2 协议会话 lsa;\ncreate_ospf:创建OSPFv2协议会话对象;\ncreate_ospf_external_lsa:创建OSPFv2 External LSA对象;\ncreate_ospf_summary_lsa:创建OSPFv2 Summary LSA对象;\nget_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象;\nget_ospf_statistic:获取OSPFv2协议会话统计结果;\nwait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态;\nwithdraw_ospf_lsa:撤销OSPFv2协议会话lsa;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_4/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  6.7.4静态路由\n\n Step\t\t\t:\t测试步骤1: ：按图搭建测试环境\n                   测试步骤2: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24\n                   测试步骤3:  DUT1 port1 IP地址为192.168.1.1/24，port2 为1.1.1.1/24；\n                   测试步骤4:  DUT2 port2 IP地址为192.168.2.1/24，port1 为1.1.1.2/24；\n                   测试步骤5: 在DUT1、DUT2上配置tester port1和port2之间的静态路由；\n                   测试步骤6: 测试仪tester使用port1、port2发送双向数据流，检验连通性\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: 6.7.4 Static Routing  \n\nStep:  \nTest Step 1: Set up the test environment according to the diagram  \nTest Step 2: Configure tester port1 IP address as 192.168.1.100/24 and port2 as 192.168.2.100/24  \nTest Step 3: Configure DUT1 port1 IP address as 192.168.1.1/24 and port2 as 1.1.1.1/24  \nTest Step 4: Configure DUT2 port2 IP address as 192.168.2.1/24 and port1 as 1.1.1.2/24  \nTest Step 5: Configure static routing between tester port1 and port2 on DUT1 and DUT2  \nTest Step 6: The tester uses port1 and port2 to send bidirectional traffic to verify connectivity  \n\nCriteria:  \nExpected Result 1: The client can receive the correct address configuration  \n\nCreated by: Tester-006  \n\nBugs: None",
    "code": "import time\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    sip_address_list = ['192.168.1.100','192.168.2.100']\n    dip_address_list = ['192.168.3.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'stream1_2')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0])\n\n    stream = add_stream(Ports=port_down, Names=f'stream2_1')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[1], Destination=dip_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        if RxStreamFrames == TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is avaliable',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is not avaliable',\n                step=6, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using init_tester API.\",\n  \"Subtask 2\": \"Reserve test ports based on configuration using reserve_port API.\",\n  \"Subtask 3\": \"Edit port parameters (if required) and wait for port status using edit_port and wait_port_state APIs.\",\n  \"Subtask 4\": \"Create IPv4 interfaces on both test ports using create_interface API.\",\n  \"Subtask 5\": \"Configure MAC addresses for both interfaces using edit_interface API on Ethernet layer.\",\n  \"Subtask 6\": \"Configure IPv4 addresses and gateways for both interfaces: port1 as 192.168.1.100/24 (gateway 192.168.1.1), port2 as 192.168.2.100/24 (gateway 192.168.2.1) using edit_interface API on IPv4 layer.\",\n  \"Subtask 7\": \"Set port load profile parameters: TransmitMode=TIME, Rate=100%, Duration=30 seconds using edit_port_load_profile API.\",\n  \"Subtask 8\": \"Create stream from port1 to destination 192.168.2.100: add_stream, create_stream_header (Ethernet+IPv4), and set IPv4 source=192.168.1.100, destination=192.168.2.100 using edit_header_ipv4.\",\n  \"Subtask 9\": \"Create stream from port2 to destination 192.168.1.100: add_stream, create_stream_header (Ethernet+IPv4), and set IPv4 source=192.168.2.100, destination=192.168.1.100 using edit_header_ipv4.\",\n  \"Subtask 10\": \"Subscribe to PortStats and StreamBlockStats views using subscribe_result API.\",\n  \"Subtask 11\": \"Save test configuration using save_case API.\",\n  \"Subtask 12\": \"Start bidirectional traffic transmission on both ports using start_stream API.\",\n  \"Subtask 13\": \"Wait for stream transmission completion using wait_stream_state API.\",\n  \"Subtask 14\": \"Retrieve and verify stream statistics: check TxStreamFrames > 0 using get_streamblock_statistic API.\",\n  \"Subtask 15\": \"Validate bidirectional connectivity: confirm RxStreamFrames match TxStreamFrames for both streams using get_streamblock_statistic API.\",\n  \"Subtask 16\": \"Clear statistical results using clear_result API.\",\n  \"Subtask 17\": \"Release reserved ports using release_port API.\",\n  \"Subtask 18\": \"Shutdown test instrument using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: 6.7.4 Static Routing  \n\nStep:  \nTest Step 1: Set up the test environment according to the diagram  \nTest Step 2: Configure tester port1 IP address as 192.168.1.100/24 and port2 as 192.168.2.100/24  \nTest Step 3: Configure DUT1 port1 IP address as 192.168.1.1/24 and port2 as 1.1.1.1/24  \nTest Step 4: Configure DUT2 port2 IP address as 192.168.2.1/24 and port1 as 1.1.1.2/24  \nTest Step 5: Configure static routing between tester port1 and port2 on DUT1 and DUT2  \nTest Step 6: The tester uses port1 and port2 to send bidirectional traffic to verify connectivity  \n\nCriteria:  \nExpected Result 1: The client can receive the correct address configuration  \n\nCreated by: Tester-006  \n\nBugs: None\n- Code Snippet: \n  ```python\n  import time\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    sip_address_list = ['192.168.1.100','192.168.2.100']\n    dip_address_list = ['192.168.3.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'stream1_2')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0])\n\n    stream = add_stream(Ports=port_down, Names=f'stream2_1')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[1], Destination=dip_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        if RxStreamFrames == TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is avaliable',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is not avaliable',\n                step=6, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_1/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.1 虚拟局域网 VLAN 功能\n\n Step\t\t\t:\t测试步骤1: 测试帧长度为 128 字节，测试时间为 30；\n                   测试步骤2: 任意选取 3 个端口与测试仪相连接，测试配置图如图 6 所示；\n                   测试步骤3: 在测试仪端口 3 上构造 7 个数据流；\n                   测试步骤4: 交换机端口均设置为 untagged，端口 A 设置为 VLAN100，端口 B 设置为 VLAN4094，端口 C 设置为 TRUNK 口、VLAN1，其他端口默认设；\n                   测试步骤5: 网络测试仪端口 3 向端口 1、端口 2 分别以 10%负载发送数；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断 VLAN 是否划分成功；\n                   测试步骤7: 在测试仪端口 1、端口 2 上构造以上 7 个数据；\n                   测试步骤8: 端口 1、端口 2 分别向端口 3 以 10%负载发送数据；\n                   测试步骤9: 记录不同数据流的帧丢失率，判断 VLAN TRUNK 是否成功。\n\n Criteria    \t:   预期结果1: 测试仪发送到交换机的数据流，若 VLAN ID 不同，则交换机丢弃该数据流（入口不透传）或转发至相应 VLAN 端口（入口透传）；若相同则转发至相同 VLAN 的端口。广播风暴仅可在 VLAN 内广播。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   6.5.1 Virtual Local Area Network (VLAN) Functionality\n\nStep\t\t\t:\tStep 1: Set test frame length to 128 bytes, test duration to 30 seconds;\n                   Step 2: Arbitrarily select 3 ports to connect to the tester; test configuration diagram shown in Figure 6;\n                   Step 3: Construct 7 data streams on tester port 3;\n                   Step 4: Set all switch ports to untagged; configure port A as VLAN100, port B as VLAN4094, port C as TRUNK port (VLAN1); other ports retain default settings;\n                   Step 5: Tester port 3 sends data to port 1 and port 2 at 10% load respectively;\n                   Step 6: Record frame loss rates for different data streams to determine VLAN segmentation success;\n                   Step 7: Construct the aforementioned 7 data streams on tester port 1 and port 2;\n                   Step 8: Port 1 and port 2 send data to port 3 at 10% load respectively;\n                   Step 9: Record frame loss rates for different data streams to determine VLAN TRUNK success.\n\nCriteria    \t:   Expected Result 1: For data streams sent from tester to switch:\n                   - If VLAN IDs differ, switch discards stream (non-pass-through ingress) or forwards to corresponding VLAN port (pass-through ingress);\n                   - If VLAN IDs match, forwards to ports in same VLAN.\n                   Broadcast storms are confined within the VLAN.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   function\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n\n    # 端口1创建流量\n    mac_address_list = ['00:02:00:00:00:01', '00:02:00:00:00:02', '00:02:00:00:00:03']\n    vlan_id_list = [100, 4094, 1]\n\n    # interfaces_1 = create_interface(Port=ports[0], Layers=['eth', 'vlan'])\n    # interfaces_2 = create_interface(Port=ports[1], Layers=['eth', 'vlan'])\n    # interfaces_3 = create_interface(Port=ports[2], Layers=['eth', 'vlan'])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[2])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[2])\n\n    streams = {}\n    # 端口创建7条流量\n    number = -1\n    for port in ports:\n        number += 1\n        test_mac_address = mac_address_list.copy()\n        source_mac = test_mac_address.pop(number)\n        # 数据流 1：无 VID 标识 IPv4 报文\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 2：VID 为 100 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 3：VID 为 4094 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 4：无 VID 标识的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n        # 数据流 5：VID 为 100 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 6：VID 为 4094 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 7：广播报文，无 VID 标识；\n        stream_port1_VID_100 = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Broadcast')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream_port1_VID_100, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream_port1_VID_100, SourceMacAdd=source_mac,\n                                      DestMacAdd='ff:ff:ff:ff:ff:ff')\n        streams.update({stream[0].Name: stream})\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 步骤5：端口3发流量测试\n        printf(message='step5：port3 start stream')\n        start_stream(Type='port', Objects=ports[2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step6：get port3 stream statistic')\n        # 获取端口3下所有流量统计结果\n        streams_obj = get_streams(ports[2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=6, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=6, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0', step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0', step=6,\n                        result=False)\n            if 'VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_1':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n            if 'VID_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n        clear_result()\n        # 步骤8：端口1，2发流量测试\n        printf(message='step8：port1,port2 start stream')\n        start_stream(Type='port', Objects=ports[:2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，3口收到报文\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=9, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=9, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}))',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=9, result=False)\n            if 'Port_1_VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_3':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            if 'Port_2_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            else:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0,RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0',\n                        step=9, result=True)\n\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester and reserve 3 test ports according to the test configuration diagram.\",\n  \"Subtask 2\": \"Set frame length to 128 bytes and test duration to 30 seconds for all test ports using port load profile configuration.\",\n  \"Subtask 3\": \"Configure the switch ports: set all ports to untagged mode, assign port A to VLAN100, port B to VLAN4094, and port C as TRUNK port (VLAN1).\",\n  \"Subtask 4\": \"Create 7 data streams on tester port 3 with specified characteristics: no VLAN/IPv4, VLAN100/IPv4, VLAN4094/IPv4, no VLAN/multicast, VLAN100/multicast, VLAN4094/multicast, no VLAN/broadcast.\",\n  \"Subtask 5\": \"Start transmission of all streams from port 3 to ports 1 and 2 at 10% load rate.\",\n  \"Subtask 6\": \"Collect and analyze frame loss statistics for each stream on ports 1 and 2 to verify VLAN segmentation behavior: confirm non-matching VLANs are discarded/forwarded correctly and broadcast storms are contained within VLAN.\",\n  \"Subtask 7\": \"Create identical 7 data streams on tester ports 1 and 2 with the same stream characteristics.\",\n  \"Subtask 8\": \"Start transmission of all streams from ports 1 and 2 to port 3 at 10% load rate.\",\n  \"Subtask 9\": \"Collect and analyze frame loss statistics for each stream on port 3 to verify VLAN TRUNK functionality: confirm proper forwarding behavior between VLAN ports.\",\n  \"Subtask 10\": \"Release all reserved test ports and shut down the tester after completing measurements.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   6.5.1 Virtual Local Area Network (VLAN) Functionality\n\nStep\t\t\t:\tStep 1: Set test frame length to 128 bytes, test duration to 30 seconds;\n                   Step 2: Arbitrarily select 3 ports to connect to the tester; test configuration diagram shown in Figure 6;\n                   Step 3: Construct 7 data streams on tester port 3;\n                   Step 4: Set all switch ports to untagged; configure port A as VLAN100, port B as VLAN4094, port C as TRUNK port (VLAN1); other ports retain default settings;\n                   Step 5: Tester port 3 sends data to port 1 and port 2 at 10% load respectively;\n                   Step 6: Record frame loss rates for different data streams to determine VLAN segmentation success;\n                   Step 7: Construct the aforementioned 7 data streams on tester port 1 and port 2;\n                   Step 8: Port 1 and port 2 send data to port 3 at 10% load respectively;\n                   Step 9: Record frame loss rates for different data streams to determine VLAN TRUNK success.\n\nCriteria    \t:   Expected Result 1: For data streams sent from tester to switch:\n                   - If VLAN IDs differ, switch discards stream (non-pass-through ingress) or forwards to corresponding VLAN port (pass-through ingress);\n                   - If VLAN IDs match, forwards to ports in same VLAN.\n                   Broadcast storms are confined within the VLAN.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   function\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n\n    # 端口1创建流量\n    mac_address_list = ['00:02:00:00:00:01', '00:02:00:00:00:02', '00:02:00:00:00:03']\n    vlan_id_list = [100, 4094, 1]\n\n    # interfaces_1 = create_interface(Port=ports[0], Layers=['eth', 'vlan'])\n    # interfaces_2 = create_interface(Port=ports[1], Layers=['eth', 'vlan'])\n    # interfaces_3 = create_interface(Port=ports[2], Layers=['eth', 'vlan'])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[2])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[2])\n\n    streams = {}\n    # 端口创建7条流量\n    number = -1\n    for port in ports:\n        number += 1\n        test_mac_address = mac_address_list.copy()\n        source_mac = test_mac_address.pop(number)\n        # 数据流 1：无 VID 标识 IPv4 报文\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 2：VID 为 100 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 3：VID 为 4094 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 4：无 VID 标识的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n        # 数据流 5：VID 为 100 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 6：VID 为 4094 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 7：广播报文，无 VID 标识；\n        stream_port1_VID_100 = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Broadcast')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream_port1_VID_100, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream_port1_VID_100, SourceMacAdd=source_mac,\n                                      DestMacAdd='ff:ff:ff:ff:ff:ff')\n        streams.update({stream[0].Name: stream})\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 步骤5：端口3发流量测试\n        printf(message='step5：port3 start stream')\n        start_stream(Type='port', Objects=ports[2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step6：get port3 stream statistic')\n        # 获取端口3下所有流量统计结果\n        streams_obj = get_streams(ports[2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=6, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=6, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0', step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0', step=6,\n                        result=False)\n            if 'VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_1':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n            if 'VID_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n        clear_result()\n        # 步骤8：端口1，2发流量测试\n        printf(message='step8：port1,port2 start stream')\n        start_stream(Type='port', Objects=ports[:2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，3口收到报文\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=9, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=9, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}))',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=9, result=False)\n            if 'Port_1_VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_3':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            if 'Port_2_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            else:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0,RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0',\n                        step=9, result=True)\n\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_3/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.3 端口吞吐量\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2544 中规定，将交换机任意两个同类型端口与测试仪相连接，见图 3；\n                   测试步骤2: 配置流量发生器：测试帧长度分别为（64、65、256、1024、1518）字节；\n                   测试步骤3: 测试时间为 60s。\n\n Criteria    \t:   预期结果1: 技术要求吞吐量为100%。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective     : Objective: 6.4.3 Port Throughput\n\nStep          : Test Step 1: According to RFC 2544, connect any two ports of the same type on the switch to the tester, as shown in Figure 3;\n                Test Step 2: Configure the traffic generator: test frame lengths are (64, 65, 256, 1024, 1518) bytes;\n                Test Step 3: Test duration is 60 seconds.\n\nCriteria      : Expected Result 1: The technical requirement for throughput is 100%.\n\nCreated by    : Tester-001\n\nTags          : performance\n=================================================================================",
    "code": "import sys\nimport os\nimport time\n\nstart_time=time.time()\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_search(Config=Config, Mode='binary', Init=cfg['arg']['search']['default']['init']['default'],\n                          Lower=cfg['arg']['search']['default']['lower']['default'], Upper=cfg['arg']['search']['default']['upper']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester API to prepare the testing environment.\",\n  \"Subtask 2\": \"Reserve two test ports using reserve_port API based on testbed configuration locations.\",\n  \"Subtask 3\": \"Configure reserved ports' parameters using edit_port API with testbed settings.\",\n  \"Subtask 4\": \"Wait for ports to reach operational state using wait_port_state API.\",\n  \"Subtask 5\": \"Create Ethernet interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 6\": \"Configure source and destination MAC addresses for interfaces using edit_interface API.\",\n  \"Subtask 7\": \"Retrieve Ethernet layer objects from interfaces using get_layer_from_interfaces API.\",\n  \"Subtask 8\": \"Create bidirectional traffic stream between Ethernet layers using add_stream API.\",\n  \"Subtask 9\": \"Create RFC2544 throughput benchmark suite using create_benchmark API.\",\n  \"Subtask 10\": \"Assign reserved ports to benchmark suite using relate_benchmark_ports API.\",\n  \"Subtask 11\": \"Configure benchmark to use pre-created traffic stream using benchmark_stream_use_exist API.\",\n  \"Subtask 12\": \"Set benchmark MAC learning to occur once before test using edit_benchmark_learning API.\",\n  \"Subtask 13\": \"Configure test duration to 60 seconds using edit_benchmark_duration API.\",\n  \"Subtask 14\": \"Set frame sizes to (64, 65, 256, 1024, 1518) bytes using edit_benchmark_frame API.\",\n  \"Subtask 15\": \"Configure binary search parameters for throughput test using edit_benchmark_search API.\",\n  \"Subtask 16\": \"Generate benchmark configuration using expand_benchmark API.\",\n  \"Subtask 17\": \"Save test configuration using save_case API.\",\n  \"Subtask 18\": \"Execute benchmark test using run_benchmark API with 3600s timeout.\",\n  \"Subtask 19\": \"Retrieve throughput results using get_benchmark_result API.\",\n  \"Subtask 20\": \"Verify throughput results meet 100% requirement for all frame sizes.\",\n  \"Subtask 21\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective     : Objective: 6.4.3 Port Throughput\n\nStep          : Test Step 1: According to RFC 2544, connect any two ports of the same type on the switch to the tester, as shown in Figure 3;\n                Test Step 2: Configure the traffic generator: test frame lengths are (64, 65, 256, 1024, 1518) bytes;\n                Test Step 3: Test duration is 60 seconds.\n\nCriteria      : Expected Result 1: The technical requirement for throughput is 100%.\n\nCreated by    : Tester-001\n\nTags          : performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\nimport time\n\nstart_time=time.time()\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_search(Config=Config, Mode='binary', Init=cfg['arg']['search']['default']['init']['default'],\n                          Lower=cfg['arg']['search']['default']['lower']['default'], Upper=cfg['arg']['search']['default']['upper']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_4/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.4 存储转发时延\n\n Step\t\t\t:\t测试步骤1: 按照图 4，将交换机任意两个同类型端口与测试仪相连接；\n                   测试步骤2: 两个端口同时以相应负载互相发送数据，测试帧长度分别为（64、65、256、1024、1518）字节，测试时间为 60s；负载率设置为：重载 95%，轻载10%；\n                   测试步骤3: 记录不同帧长的平均存储转发时延。\n\n Criteria    \t:   预期结果1: 技术要求平均时延应小于10µs。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   Test Objective: 6.4.4 Store-and-Forward Delay\n\nStep\t\t\t:\tTest Step 1: According to Figure 4, connect any two same-type ports of the switch to the tester;\n                    Test Step 2: Both ports simultaneously send data to each other with corresponding loads. Test frame lengths are (64, 65, 256, 1024, 1518) bytes, with a test duration of 60 seconds. Load rates set to: heavy load 95%, light load 10%;\n                    Test Step 3: Record the average store-and-forward delay for different frame lengths.\n\nCriteria    \t:   Expected Result 1: The technical requirement specifies that the average delay must be less than 10µs.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================",
    "code": "import sys\nimport os\nimport time\n\nstart_time=time.time()\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        print(\"111\",testbed['tester']['rtsm']['ip'])\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    print(\"port_up\",port_up)\n    print(\"port_down\", port_down)\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    for k, v in testbed['tester'].items():\n        edit_port_kwargs = {}\n        if k in edit_port_params:\n            edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    print(\"interfaces_up\", interfaces_up)\n    print(\"interfaces_down\", interfaces_down)\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['latency'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using the init_tester API to establish communication with the test equipment.\",\n  \"Subtask 2\": \"Reserve two same-type test ports using reserve_port API based on configuration parameters.\",\n  \"Subtask 3\": \"Configure port parameters using edit_port API with settings from the testbed configuration.\",\n  \"Subtask 4\": \"Create Ethernet interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 5\": \"Set MAC addresses for both interfaces using edit_interface API as per configuration specifications.\",\n  \"Subtask 6\": \"Create bidirectional traffic streams between the interfaces using add_stream API with Bidirection=True.\",\n  \"Subtask 7\": \"Create RFC2544 benchmark for latency measurement using create_benchmark API.\",\n  \"Subtask 8\": \"Assign reserved ports to the benchmark using relate_benchmark_ports API.\",\n  \"Subtask 9\": \"Configure benchmark to use existing streams using benchmark_stream_use_exist API.\",\n  \"Subtask 10\": \"Set benchmark address learning to 'once' with edit_benchmark_learning API.\",\n  \"Subtask 11\": \"Configure test duration to 60 seconds using edit_benchmark_duration API.\",\n  \"Subtask 12\": \"Set custom frame sizes [64, 65, 256, 1024, 1518] bytes using edit_benchmark_frame API.\",\n  \"Subtask 13\": \"Configure traffic loads [10%, 95%] using edit_benchmark_traffic_load_loop API with LoadMode='custom'.\",\n  \"Subtask 14\": \"Generate test configuration using expand_benchmark API.\",\n  \"Subtask 15\": \"Save test configuration using save_case API.\",\n  \"Subtask 16\": \"Execute benchmark test using run_benchmark API with 60-second duration.\",\n  \"Subtask 17\": \"Retrieve latency results using get_benchmark_result API with ReturnType='dataframe'.\",\n  \"Subtask 18\": \"Verify average store-and-forward delay is below 10µs for all frame sizes and loads.\",\n  \"Subtask 19\": \"Release test ports using release_port API.\",\n  \"Subtask 20\": \"Shutdown tester connection using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   Test Objective: 6.4.4 Store-and-Forward Delay\n\nStep\t\t\t:\tTest Step 1: According to Figure 4, connect any two same-type ports of the switch to the tester;\n                    Test Step 2: Both ports simultaneously send data to each other with corresponding loads. Test frame lengths are (64, 65, 256, 1024, 1518) bytes, with a test duration of 60 seconds. Load rates set to: heavy load 95%, light load 10%;\n                    Test Step 3: Record the average store-and-forward delay for different frame lengths.\n\nCriteria    \t:   Expected Result 1: The technical requirement specifies that the average delay must be less than 10µs.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\nimport time\n\nstart_time=time.time()\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        print(\"111\",testbed['tester']['rtsm']['ip'])\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    print(\"port_up\",port_up)\n    print(\"port_down\", port_down)\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    for k, v in testbed['tester'].items():\n        edit_port_kwargs = {}\n        if k in edit_port_params:\n            edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    print(\"interfaces_up\", interfaces_up)\n    print(\"interfaces_down\", interfaces_down)\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['latency'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_2/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  6.7.2互联网控制消息协议（ICMP）\n\n Step\t\t\t:\t测试步骤1: ：按图10搭建测试环境\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为192.168.2.100/24\n                   测试步骤3: DUT port1 地址为192.168.1.1/24，port2 地址为192.168.2.1/24\n                   测试步骤4: tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n                   测试步骤5: tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n                   测试步骤6: tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n                   测试步骤7: tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: 6.7.2 Internet Control Message Protocol (ICMP)\n\nStep: Test Step 1: Set up test environment according to Figure 10\n      Test Step 2: Tester Port1 address: 192.168.1.100/24, Port2 address: 192.168.2.100/24\n      Test Step 3: DUT Port1 address: 192.168.1.1/24, Port2 address: 192.168.2.1/24\n      Test Step 4: Send ping packet from Tester Port1 to 192.168.1.1, observe if correct response is received\n      Test Step 5: Send IP packet from Tester Port1 to 192.168.3.1, observe if correct response (Network Unreachable, Type 3, Code 0) is received\n      Test Step 6: Send IP packet with protocol number 100 from Tester Port1 to 192.168.1.1, observe if correct response (Protocol Unreachable, Type 3, Code 2) is received\n      Test Step 7: Send IP packet with protocol number 17 and port 100 from Tester Port1 to 192.168.1.1, observe if correct response (Port Unreachable, Type 3, Code 3) is received\n\nCriteria: Expected Result 1: Client can receive correct address configuration\n\nCreated by: Tester-006\n\nBugs: None\n=================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # edit_port_load_profile(Ports=port_up, TransmitMode='TIME', Rate=1, Seconds=30)\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['192.168.3.1 ','192.168.1.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'step5')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0], Gateway='192.168.1.1')\n\n    # step6 tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n    stream = add_stream(Ports=port_up, Names=f'step6')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=100, Gateway='192.168.1.1')\n\n    # step7 tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n    stream = add_stream(Ports=port_up, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=17, Gateway='192.168.1.1')\n    edit_header_udp(Stream=stream, SourcePort=100)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.1.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n\n        stream1, stream2, stream3 = get_streams(Ports=port_up)\n        # 端口1测试\n        net_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step5', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '0' and pkt.icmp.type == '3':\n                net_unreached_pkt.append(pkt)\n\n        if len(net_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到网络不可达报文，类型为 3，编码为 0',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到网络不可达报文',\n                step=5, result=False)\n\n        protocol_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '2' and pkt.icmp.type == '3':\n                protocol_unreached_pkt.append(pkt)\n        if len(protocol_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到协议不可达报文，类型为 3，编码为 2',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到协议不可达报文',\n                step=6, result=False)\n\n        port_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream3)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '3' and pkt.icmp.code == '3':\n                port_unreached_pkt.append(pkt)\n\n        if len(port_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到端口不可达报文，类型为 3，编码为 3',\n                step=7, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到端口不可达报文',\n                step=7, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "edit_header_udp:修改测试仪表流量模板中UDP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l3_learning:启动测试仪表流量三层ARP ND学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester system and reserve required testing ports based on configuration parameters.\",\n  \"Subtask 2\": \"Configure port parameters including force, debug, and wait-for-status-up settings, then wait for ports to reach operational state.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on tester ports with specified IP addresses (192.168.1.100/24) and gateways (192.168.1.1).\",\n  \"Subtask 4\": \"Configure port load profiles with continuous transmission mode at 100 frames per second.\",\n  \"Subtask 5\": \"Create and configure three test streams: Stream1 (destination 192.168.3.1), Stream2 (protocol 100 to 192.168.1.1), Stream3 (UDP port 100 to 192.168.1.1) with appropriate Ethernet/IPv4/UDP headers.\",\n  \"Subtask 6\": \"Save test configuration to case file and subscribe to port statistics monitoring.\",\n  \"Subtask 7\": \"Execute ICMP ping test from Tester Port1 to 192.168.1.1 and verify response reception.\",\n  \"Subtask 8\": \"For Stream1: Start Layer3 learning, capture traffic, transmit stream to 192.168.3.1, then analyze captured packets for ICMP Network Unreachable (Type=3, Code=0).\",\n  \"Subtask 9\": \"For Stream2: Start Layer3 learning, capture traffic, transmit stream with protocol 100 to 192.168.1.1, then analyze captured packets for ICMP Protocol Unreachable (Type=3, Code=2).\",\n  \"Subtask 10\": \"For Stream3: Start Layer3 learning, capture traffic, transmit UDP stream to port 100 at 192.168.1.1, then analyze captured packets for ICMP Port Unreachable (Type=3, Code=3).\",\n  \"Subtask 11\": \"Release reserved ports and perform test environment teardown after completion.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: 6.7.2 Internet Control Message Protocol (ICMP)\n\nStep: Test Step 1: Set up test environment according to Figure 10\n      Test Step 2: Tester Port1 address: 192.168.1.100/24, Port2 address: 192.168.2.100/24\n      Test Step 3: DUT Port1 address: 192.168.1.1/24, Port2 address: 192.168.2.1/24\n      Test Step 4: Send ping packet from Tester Port1 to 192.168.1.1, observe if correct response is received\n      Test Step 5: Send IP packet from Tester Port1 to 192.168.3.1, observe if correct response (Network Unreachable, Type 3, Code 0) is received\n      Test Step 6: Send IP packet with protocol number 100 from Tester Port1 to 192.168.1.1, observe if correct response (Protocol Unreachable, Type 3, Code 2) is received\n      Test Step 7: Send IP packet with protocol number 17 and port 100 from Tester Port1 to 192.168.1.1, observe if correct response (Port Unreachable, Type 3, Code 3) is received\n\nCriteria: Expected Result 1: Client can receive correct address configuration\n\nCreated by: Tester-006\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # edit_port_load_profile(Ports=port_up, TransmitMode='TIME', Rate=1, Seconds=30)\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['192.168.3.1 ','192.168.1.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'step5')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0], Gateway='192.168.1.1')\n\n    # step6 tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n    stream = add_stream(Ports=port_up, Names=f'step6')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=100, Gateway='192.168.1.1')\n\n    # step7 tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n    stream = add_stream(Ports=port_up, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=17, Gateway='192.168.1.1')\n    edit_header_udp(Stream=stream, SourcePort=100)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.1.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n\n        stream1, stream2, stream3 = get_streams(Ports=port_up)\n        # 端口1测试\n        net_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step5', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '0' and pkt.icmp.type == '3':\n                net_unreached_pkt.append(pkt)\n\n        if len(net_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到网络不可达报文，类型为 3，编码为 0',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到网络不可达报文',\n                step=5, result=False)\n\n        protocol_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '2' and pkt.icmp.type == '3':\n                protocol_unreached_pkt.append(pkt)\n        if len(protocol_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到协议不可达报文，类型为 3，编码为 2',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到协议不可达报文',\n                step=6, result=False)\n\n        port_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream3)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '3' and pkt.icmp.code == '3':\n                port_unreached_pkt.append(pkt)\n\n        if len(port_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到端口不可达报文，类型为 3，编码为 3',\n                step=7, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到端口不可达报文',\n                step=7, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nedit_header_udp:修改测试仪表流量模板中UDP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l3_learning:启动测试仪表流量三层ARP ND学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_5/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.5 路由信息协议（RIP）\n\n Step\t\t\t:\t测试步骤1: 按图4，任选交换机两个端口作为测试端口；\n                   测试步骤2:  tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24;\n                   测试步骤3:  DUT1 port1 IP 地 址 为 192.168.1.1/24 ， port2 IP 地 址 为192.168.2.1/24\n                   测试步骤3:  在DUT上配置RIPv2路由协议；\n                   测试步骤3:   tester port1 从 UDP端口520向组播地址224.0.0.9的520 UDP端口发\n                               送地址簇为2，RIP条目为192.168.4.0/255.255.255.0/8 的RIPv2 应答报\n                               文，周期为1s，观察DUT的路由表变化，观察testerport2是否收到路由更新报文；\n                   测试步骤3:  停止发送步骤6的报文，tester port1 从UDP端口520向组播地址\n                               224.0.0.9 的 520 UDP 端 口 发 送 地 址 簇 为 2 ， RIP 条 目 为\n                               192.168.4.0/255.255.255.0/6 的 RIPv2 应答报文，周期为 1s，观察 DUT\n                               的路由表变化，观察tester port2是否收到路由更新报文；\n                   测试步骤3:   停止发送步骤7的报文，tester port1 从UDP端口520向组播地址\n                               224.0.0.9 的 520 UDP 端 口 发 送 地 址 簇 为 2 ， RIP 条 目 为\n                               192.168.4.0/255.255.255.0/10 的 RIPv2 应答报文，周期为 1s，观察 DUT\n                               的路由表变化，观察tester port2是否收到路由更新报文\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: 6.7.5 Routing Information Protocol (RIP)\n\nStep: Test Step 1: According to Figure 4, select any two ports of the switch as test ports;\nTest Step 2: Tester port1 IP address is 192.168.1.100/24, port2 is 192.168.2.100/24;\nTest Step 3: DUT1 port1 IP address is 192.168.1.1/24, port2 IP address is 192.168.2.1/24;\nTest Step 3: Configure the RIPv2 routing protocol on the DUT;\nTest Step 3: Tester port1 sends RIPv2 response packets from UDP port 520 to multicast address 224.0.0.9 UDP port 520, with address family 2 and RIP entry 192.168.4.0/255.255.255.0/8, at a period of 1s; observe DUT's routing table changes and whether tester port2 receives routing update packets;\nTest Step 3: Stop sending packets from Step 6; tester port1 sends RIPv2 response packets from UDP port 520 to multicast address 224.0.0.9 UDP port 520, with address family 2 and RIP entry 192.168.4.0/255.255.255.0/6, at a period of 1s; observe DUT's routing table changes and whether tester port2 receives routing update packets;\nTest Step 3: Stop sending packets from Step 7; tester port1 sends RIPv2 response packets from UDP port 520 to multicast address 224.0.0.9 UDP port 520, with address family 2 and RIP entry 192.168.4.0/255.255.255.0/10, at a period of 1s; observe DUT's routing table changes and whether tester port2 receives routing update packets;\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建RIP协议会话\n    session_1 = create_rip(Port=port_up)\n    session_2 = create_rip(Port=port_down)\n\n    # RIP协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    #创建流量\n    port1, port2 = ports\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n\n        route = create_rip_ipv4_route(Session=session_1, StartIpv4Prefix='192.168.4.0', Increment=8)\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 6\n        save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 10\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step8', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_rip:通告RIP协议路由",
      "create_rip:创建RIP协议会话对象",
      "create_rip_ipv4_route:创建RIP IPv4路由对象",
      "wait_rip_state:等待RIP协议会话达到指定状态",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester system and reserve two test ports as specified in the testbed configuration.\",\n  \"Subtask 2\": \"Configure tester port parameters including force, debug, and wait_for_status_up settings based on testbed specifications.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both reserved ports with MAC addresses, IP addresses (192.168.1.100/24 for port1, 192.168.2.100/24 for port2), and gateways (192.168.1.1 for port1, 192.168.2.1 for port2).\",\n  \"Subtask 4\": \"Create RIPv2 protocol sessions on both tester ports and bind each session to its respective interface.\",\n  \"Subtask 5\": \"Create an RIP IPv4 route object on port1's session with StartIpv4Prefix='192.168.4.0' and Increment=8.\",\n  \"Subtask 6\": \"Start RIP protocol on both sessions and wait until both sessions reach the established state.\",\n  \"Subtask 7\": \"Start packet capture on port2 to monitor routing update packets.\",\n  \"Subtask 8\": \"Advertise the RIP route from port1's session to multicast address 224.0.0.9 on UDP port 520.\",\n  \"Subtask 9\": \"Stop packet capture on port2 after 3 seconds of transmission.\",\n  \"Subtask 10\": \"Download captured packets from port2 and save as 'step6.pcap' for analysis.\",\n  \"Subtask 11\": \"Analyze captured packets to verify reception of RIPv2 update containing 192.168.4.0 route with metric 8 at port2.\",\n  \"Subtask 12\": \"Stop RIP protocol on both sessions.\",\n  \"Subtask 13\": \"Modify the RIP IPv4 route object on port1 to set Increment=6.\",\n  \"Subtask 14\": \"Restart RIP protocol on both sessions and wait for established state.\",\n  \"Subtask 15\": \"Start packet capture on port2 for metric 6 test iteration.\",\n  \"Subtask 16\": \"Re-advertise the modified RIP route from port1's session.\",\n  \"Subtask 17\": \"Stop packet capture on port2 after 3 seconds and save as 'step7.pcap'.\",\n  \"Subtask 18\": \"Verify reception of RIPv2 update with 192.168.4.0 route and metric 6 at port2.\",\n  \"Subtask 19\": \"Stop RIP protocol on both sessions.\",\n  \"Subtask 20\": \"Update RIP IPv4 route object on port1 to set Increment=10.\",\n  \"Subtask 21\": \"Restart RIP protocol on both sessions and wait for established state.\",\n  \"Subtask 22\": \"Start packet capture on port2 for metric 10 test iteration.\",\n  \"Subtask 23\": \"Advertise the updated RIP route from port1's session.\",\n  \"Subtask 24\": \"Stop packet capture on port2 after 3 seconds and save as 'step8.pcap'.\",\n  \"Subtask 25\": \"Verify reception of RIPv2 update with 192.168.4.0 route and metric 10 at port2.\",\n  \"Subtask 26\": \"Release reserved tester ports and shutdown tester system after completing all test iterations.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: 6.7.5 Routing Information Protocol (RIP)\n\nStep: Test Step 1: According to Figure 4, select any two ports of the switch as test ports;\nTest Step 2: Tester port1 IP address is 192.168.1.100/24, port2 is 192.168.2.100/24;\nTest Step 3: DUT1 port1 IP address is 192.168.1.1/24, port2 IP address is 192.168.2.1/24;\nTest Step 3: Configure the RIPv2 routing protocol on the DUT;\nTest Step 3: Tester port1 sends RIPv2 response packets from UDP port 520 to multicast address 224.0.0.9 UDP port 520, with address family 2 and RIP entry 192.168.4.0/255.255.255.0/8, at a period of 1s; observe DUT's routing table changes and whether tester port2 receives routing update packets;\nTest Step 3: Stop sending packets from Step 6; tester port1 sends RIPv2 response packets from UDP port 520 to multicast address 224.0.0.9 UDP port 520, with address family 2 and RIP entry 192.168.4.0/255.255.255.0/6, at a period of 1s; observe DUT's routing table changes and whether tester port2 receives routing update packets;\nTest Step 3: Stop sending packets from Step 7; tester port1 sends RIPv2 response packets from UDP port 520 to multicast address 224.0.0.9 UDP port 520, with address family 2 and RIP entry 192.168.4.0/255.255.255.0/10, at a period of 1s; observe DUT's routing table changes and whether tester port2 receives routing update packets;\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建RIP协议会话\n    session_1 = create_rip(Port=port_up)\n    session_2 = create_rip(Port=port_down)\n\n    # RIP协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    #创建流量\n    port1, port2 = ports\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n\n        route = create_rip_ipv4_route(Session=session_1, StartIpv4Prefix='192.168.4.0', Increment=8)\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 6\n        save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 10\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step8', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_rip:通告RIP协议路由;\ncreate_rip:创建RIP协议会话对象;\ncreate_rip_ipv4_route:创建RIP IPv4路由对象;\nwait_rip_state:等待RIP协议会话达到指定状态;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_5/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.5 帧丢失率\n\n Step\t\t\t:\t测试步骤1: 按照图 4，将交换机任意两个同类型端口与测试仪相连接；\n                   测试步骤2: 两个端口同时互相发送数据，测试帧长度分别为（64、65、256、1024、1518）字节，测试时间为 60s；负载率设置为 100%；\n                   测试步骤3: 记录不同帧长的丢包率。\n\n Criteria    \t:   预期结果1: 技术要求在端口转发速率达到 100%的情况下，丢包率应为0。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective     : Test Objective: 6.4.5 Frame Loss Rate\n\nStep          : Test Step 1: According to Figure 4, connect any two ports of the same type on the switch to the tester;\n                Test Step 2: Both ports simultaneously send data to each other. Test frame lengths are (64, 65, 256, 1024, 1518) bytes, test duration is 60s; load rate is set to 100%;\n                Test Step 3: Record the packet loss rate for different frame lengths.\n\nCriteria      : Expected Result 1: According to technical requirements, when port forwarding rate reaches 100%, packet loss rate should be 0.\n\nCreated by    : Tester-001\n\nTags          : performance\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['frameloss'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester API to prepare for network testing.\",\n  \"Subtask 2\": \"Reserve two test ports using reserve_port API based on configuration, ensuring they are of the same type as required for the frame loss test.\",\n  \"Subtask 3\": \"Edit port parameters using edit_port API if required, and wait for port status using wait_port_state API to confirm link readiness.\",\n  \"Subtask 4\": \"Create Ethernet interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 5\": \"Configure MAC addresses on both interfaces using edit_interface API according to test specifications.\",\n  \"Subtask 6\": \"Create bidirectional traffic streams between the interfaces using add_stream API with Type='binding' and Bidirection=True.\",\n  \"Subtask 7\": \"Create RFC2544 benchmark test suite for frame loss measurement using create_benchmark API with 'frameloss' item.\",\n  \"Subtask 8\": \"Assign reserved ports to the benchmark using relate_benchmark_ports API.\",\n  \"Subtask 9\": \"Configure benchmark to use existing traffic streams using benchmark_stream_use_exist API.\",\n  \"Subtask 10\": \"Set benchmark address learning to occur once using edit_benchmark_learning API.\",\n  \"Subtask 11\": \"Configure test duration to 60 seconds using edit_benchmark_duration API with Mode='second'.\",\n  \"Subtask 12\": \"Set frame sizes to (64, 65, 256, 1024, 1518) bytes using edit_benchmark_frame API with Type='custom'.\",\n  \"Subtask 13\": \"Configure traffic load to 100% using edit_benchmark_traffic_load_loop API with LoadMode='custom' and LoadCustom=100.\",\n  \"Subtask 14\": \"Generate benchmark configuration using expand_benchmark API.\",\n  \"Subtask 15\": \"Save test configuration using save_case API for reference.\",\n  \"Subtask 16\": \"Execute benchmark test using run_benchmark API with 3600s timeout.\",\n  \"Subtask 17\": \"Retrieve frame loss results for all frame sizes using get_benchmark_result API with ReturnType='dataframe'.\",\n  \"Subtask 18\": \"Validate that packet loss rate is 0% for all frame sizes at 100% load as per technical requirements.\",\n  \"Subtask 19\": \"Release reserved ports using release_port API after test completion.\",\n  \"Subtask 20\": \"Shutdown tester using shutdown_tester API to clean up resources.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective     : Test Objective: 6.4.5 Frame Loss Rate\n\nStep          : Test Step 1: According to Figure 4, connect any two ports of the same type on the switch to the tester;\n                Test Step 2: Both ports simultaneously send data to each other. Test frame lengths are (64, 65, 256, 1024, 1518) bytes, test duration is 60s; load rate is set to 100%;\n                Test Step 3: Record the packet loss rate for different frame lengths.\n\nCriteria      : Expected Result 1: According to technical requirements, when port forwarding rate reaches 100%, packet loss rate should be 0.\n\nCreated by    : Tester-001\n\nTags          : performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['frameloss'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/DHCPv4Client.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv4 Client头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of traffic statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Test Step 3: Modify the DHCPv4 Client header content of stream StreamTemplate_1;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Transmit all traffic and wait for a period;\n                   Test Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-003\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Client'])\n\n    # 修改dhcpv4 client头部\n    header = edit_header_dhcpv4_client(Stream=stream, Level=0,\n                                       MessageType=1,\n                                       HardwareType=1,\n                                       Hops=1,\n                                       Bootpflags='0001',\n                                       )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=0,\n                                              Types='serverId',\n                                              ReqAddr='1.1.1.1',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ReqAddr'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=1,\n                                              Types='message',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=2,\n                                              Types='leaseTime',\n                                              LeaseTime=1,\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['LeaseTime'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=3,\n                                              Types='endOfOptions',\n                                              Type='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Type'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=4,\n                                              Types='messageSize',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=5,\n                                              Types='clientIdHW',\n                                              IdType='01',\n                                              ClientHWA='00:00:00:00:00:01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ClientHWA'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=6,\n                                              Types='clientIdNoneHW',\n                                              IdType='01',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=7,\n                                              Types='hostName',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=8,\n                                              Types='paramReqList',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=9,\n                                              Types='reqAddr',\n                                              ReqAddr='1.1.1.1',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ReqAddr'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=10,\n                                              Types='optionOverload',\n                                              Overload=1,\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=11,\n                                              Types='customOption',\n                                              Overload='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=12,\n                                              Types='generalTLV',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=13,\n                                              Types='messageType',\n                                              Code=4,\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Code'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Client'],\n                                             FieldName='dhcpv4Client_1.hops',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester API with specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream (StreamTemplate_1) on Port_1 with fixed frame length using add_stream API.\",\n  \"Subtask 4\": \"Build stream header layers (EthernetII, IPv4, UDP, DHCPv4Client) for StreamTemplate_1 using create_stream_header API.\",\n  \"Subtask 5\": \"Modify main DHCPv4 Client header fields (MessageType, HardwareType, Hops, Bootpflags) using edit_header_dhcpv4_client API.\",\n  \"Subtask 6\": \"Add DHCPv4 option header (serverId type) and configure ReqAddr field using edit_header_dhcpv4_option API.\",\n  \"Subtask 7\": \"Apply increment modifier to DHCPv4 Client MessageType field with count=10 using edit_modifier API.\",\n  \"Subtask 8\": \"Set port transmission mode to BURST with burst count=100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for traffic completion using wait_stream_state API and pause 3 seconds for statistics stabilization.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API.\",\n  \"Subtask 13\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) in StreamBlockStats.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of traffic statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Test Step 3: Modify the DHCPv4 Client header content of stream StreamTemplate_1;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Transmit all traffic and wait for a period;\n                   Test Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-003\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Client'])\n\n    # 修改dhcpv4 client头部\n    header = edit_header_dhcpv4_client(Stream=stream, Level=0,\n                                       MessageType=1,\n                                       HardwareType=1,\n                                       Hops=1,\n                                       Bootpflags='0001',\n                                       )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=0,\n                                              Types='serverId',\n                                              ReqAddr='1.1.1.1',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ReqAddr'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=1,\n                                              Types='message',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=2,\n                                              Types='leaseTime',\n                                              LeaseTime=1,\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['LeaseTime'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=3,\n                                              Types='endOfOptions',\n                                              Type='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Type'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=4,\n                                              Types='messageSize',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=5,\n                                              Types='clientIdHW',\n                                              IdType='01',\n                                              ClientHWA='00:00:00:00:00:01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ClientHWA'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=6,\n                                              Types='clientIdNoneHW',\n                                              IdType='01',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=7,\n                                              Types='hostName',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=8,\n                                              Types='paramReqList',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=9,\n                                              Types='reqAddr',\n                                              ReqAddr='1.1.1.1',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ReqAddr'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=10,\n                                              Types='optionOverload',\n                                              Overload=1,\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=11,\n                                              Types='customOption',\n                                              Overload='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=12,\n                                              Types='generalTLV',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=13,\n                                              Types='messageType',\n                                              Code=4,\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Code'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Client'],\n                                             FieldName='dhcpv4Client_1.hops',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_6_2/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.6.2 路由表容量\n\n Step\t\t\t:\t测试步骤1: 按拓扑图搭建测试环境；\n                   测试步骤2: tester port1 IP 地址为 192.168.1.100/24，port2 为 192.168.2.100/24；\n                   测试步骤3: DUT port1 IP地址为192.168.1.1/24，port2 IP地址为192.168.2.1/24；\n                   测试步骤4: 配置 DUT 与 tester 在相同 Area 域，DUT 的接口 1、2 分别和 tester 建立 OSPF 邻居；\n                   测试步骤5: Tester 的接口 port1、port2 分别向 DUT 的接口 port1、port2 发布 Type类型的 LSA，总数为被测交换机路由表容量的规定值。\n\n Criteria    \t:   预期结果1: 查看并记录被测交换机的 OSPF 生成的路由表统计信息。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective       :   Test Objective: 6.6.2 Routing Table Capacity\n\nStep            :   Test Step 1: Set up the test environment according to the topology diagram;\n                Test Step 2: Tester port1 IP address is 192.168.1.100/24, port2 is 192.168.2.100/24;\n                Test Step 3: DUT port1 IP address is 192.168.1.1/24, port2 IP address is 192.168.2.1/24;\n                Test Step 4: Configure DUT and Tester in the same OSPF Area, establishing OSPF neighbors between DUT interfaces 1,2 and Tester respectively;\n                Test Step 5: Tester interfaces port1 and port2 advertise Type LSAs to DUT interfaces port1 and port2 respectively, with the total number matching the specified routing table capacity of the DUT switch.\n\nCriteria        :   Expected Result 1: Check and record the OSPF-generated routing table statistics of the DUT switch.\n\nCreated by      :   Tester-001\n\nTags            :   performance\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建OSPFv2协议会话\n    session_1 = create_ospf(Port=port_up, Priority=cfg['arg']['ospf']['default']['priority_session_up']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n    session_2 = create_ospf(Port=port_down, Priority=cfg['arg']['ospf']['default']['priority_session_down']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    route_count = int(cfg['arg']['ospf']['default']['advertise_count']['default'] / 2)\n    # OSPFv2协议会话创建External Lsa\n    external_lsa_1 = create_ospf_external_lsa(Session=session_1, RouteCount=route_count)\n    external_lsa_2 = create_ospf_external_lsa(Session=session_2, RouteCount=route_count)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=external_lsa_1)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa_2)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['rate']['default'])\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats', 'Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 启动协议\n        printf(message='Test start')\n        start_protocol()\n        time.sleep(3)\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        advertise_ospf_lsa(Lsa=[external_lsa_1, external_lsa_2])\n        time.sleep(cfg['arg']['ospf']['default']['advertise_wait']['default'])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 发送流量\n        printf(message='Stream test start')\n        start_stream()\n        time.sleep(3)\n        df = get_streamblock_statistic()\n        wait_stream_state(State='RUNNING')\n        time.sleep(3)\n        result = get_streamblock_statistic()\n        # 使用 concat 拼接 DataFrame\n        df = pd.concat([df, result])\n        # 重置索引\n        df = df.reset_index(drop=True)\n        printf(message='Test completed')\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        stop_protocol()\n        time.sleep(3)\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_ospf_lsa:通告 OSPFv2 协议会话 lsa",
      "create_ospf:创建OSPFv2协议会话对象",
      "create_ospf_external_lsa:创建OSPFv2 External LSA对象",
      "get_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象",
      "get_ospf_statistic:获取OSPFv2协议会话统计结果",
      "wait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize test equipment and reserve ports according to topology specifications.\",\n  \"Subtask 2\": \"Configure tester port1 interface with IP address 192.168.1.100/24 and gateway 192.168.1.1.\",\n  \"Subtask 3\": \"Configure tester port2 interface with IP address 192.168.2.100/24 and gateway 192.168.2.1.\",\n  \"Subtask 4\": \"Create OSPFv2 sessions on both tester ports with identical Area ID to establish neighbor relationships with DUT.\",\n  \"Subtask 5\": \"Bind OSPFv2 sessions to respective tester interfaces (port1 and port2).\",\n  \"Subtask 6\": \"Create OSPF external LSAs with total route count matching DUT's routing table capacity, equally distributed between both ports.\",\n  \"Subtask 7\": \"Start OSPF protocol and wait until neighbor adjacencies reach FULL state.\",\n  \"Subtask 8\": \"Advertise created OSPF LSAs from both tester ports to DUT.\",\n  \"Subtask 9\": \"Retrieve and record OSPF-generated routing table statistics from DUT switch.\",\n  \"Subtask 10\": \"Release reserved ports and clean up test environment.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective       :   Test Objective: 6.6.2 Routing Table Capacity\n\nStep            :   Test Step 1: Set up the test environment according to the topology diagram;\n                Test Step 2: Tester port1 IP address is 192.168.1.100/24, port2 is 192.168.2.100/24;\n                Test Step 3: DUT port1 IP address is 192.168.1.1/24, port2 IP address is 192.168.2.1/24;\n                Test Step 4: Configure DUT and Tester in the same OSPF Area, establishing OSPF neighbors between DUT interfaces 1,2 and Tester respectively;\n                Test Step 5: Tester interfaces port1 and port2 advertise Type LSAs to DUT interfaces port1 and port2 respectively, with the total number matching the specified routing table capacity of the DUT switch.\n\nCriteria        :   Expected Result 1: Check and record the OSPF-generated routing table statistics of the DUT switch.\n\nCreated by      :   Tester-001\n\nTags            :   performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建OSPFv2协议会话\n    session_1 = create_ospf(Port=port_up, Priority=cfg['arg']['ospf']['default']['priority_session_up']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n    session_2 = create_ospf(Port=port_down, Priority=cfg['arg']['ospf']['default']['priority_session_down']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    route_count = int(cfg['arg']['ospf']['default']['advertise_count']['default'] / 2)\n    # OSPFv2协议会话创建External Lsa\n    external_lsa_1 = create_ospf_external_lsa(Session=session_1, RouteCount=route_count)\n    external_lsa_2 = create_ospf_external_lsa(Session=session_2, RouteCount=route_count)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=external_lsa_1)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa_2)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['rate']['default'])\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats', 'Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 启动协议\n        printf(message='Test start')\n        start_protocol()\n        time.sleep(3)\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        advertise_ospf_lsa(Lsa=[external_lsa_1, external_lsa_2])\n        time.sleep(cfg['arg']['ospf']['default']['advertise_wait']['default'])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 发送流量\n        printf(message='Stream test start')\n        start_stream()\n        time.sleep(3)\n        df = get_streamblock_statistic()\n        wait_stream_state(State='RUNNING')\n        time.sleep(3)\n        result = get_streamblock_statistic()\n        # 使用 concat 拼接 DataFrame\n        df = pd.concat([df, result])\n        # 重置索引\n        df = df.reset_index(drop=True)\n        printf(message='Test completed')\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        stop_protocol()\n        time.sleep(3)\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_ospf_lsa:通告 OSPFv2 协议会话 lsa;\ncreate_ospf:创建OSPFv2协议会话对象;\ncreate_ospf_external_lsa:创建OSPFv2 External LSA对象;\nget_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象;\nget_ospf_statistic:获取OSPFv2协议会话统计结果;\nwait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_9/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.9 支持网关数\n\n Step\t\t\t:\t测试步骤1: 记录三层交换机配置网络层地址的方式（路由口配置方式或者VLANInterface 方式）。\n                   测试步骤2: 记录三层交换机可配置的网关数目\n                   测试步骤3: 按图10建立测试环境\n                   测试步骤4: tester port1 地 址 为 192.168.9.100/24 ， port2 地 址 为192.168.11.100/24；DUT port1\n                   和 port2 分别配置 192.168.9.0 网段和192.168.11.0 网段网关，抽样验证网关是否配置成功。\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: 6.7.9 Supported Number of Gateways\n\nStep: Test Step 1: Record the Layer 3 switch's network layer address configuration method (routed port configuration or VLAN Interface method).\nTest Step 2: Record the maximum number of configurable gateways on the Layer 3 switch.\nTest Step 3: Establish the test environment according to Figure 10.\nTest Step 4: Set tester port1 address to 192.168.9.100/24 and port2 address to 192.168.11.100/24; configure DUT port1 and port2 as gateways for the 192.168.9.0 and 192.168.11.0 network segments respectively, and verify gateway configuration success through sampling.\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.9.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n        ipv4_ping(Interface=interfaces_down, IpAddr='192.168.11.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Record the Layer 3 switch's network layer address configuration method (routed port or VLAN Interface) as specified in the test objective.\",\n  \"Subtask 2\": \"Record the maximum number of configurable gateways supported by the Layer 3 switch according to its specifications.\",\n  \"Subtask 3\": \"Establish the test environment per Figure 10 by initializing the tester and reserving required ports.\",\n  \"Subtask 4\": \"Configure DUT port1 as gateway for 192.168.9.0/24 segment and DUT port2 as gateway for 192.168.11.0/24 segment.\",\n  \"Subtask 5\": \"Set tester port1 IP address to 192.168.9.100/24 with gateway 192.168.9.1 using interface configuration.\",\n  \"Subtask 6\": \"Set tester port2 IP address to 192.168.11.100/24 with gateway 192.168.11.1 using interface configuration.\",\n  \"Subtask 7\": \"Verify gateway configuration by sending ICMP echo requests from tester port1 to DUT gateway 192.168.9.1.\",\n  \"Subtask 8\": \"Verify gateway configuration by sending ICMP echo requests from tester port2 to DUT gateway 192.168.11.1.\",\n  \"Subtask 9\": \"Check ICMP reply status for both test paths to confirm gateway functionality.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: 6.7.9 Supported Number of Gateways\n\nStep: Test Step 1: Record the Layer 3 switch's network layer address configuration method (routed port configuration or VLAN Interface method).\nTest Step 2: Record the maximum number of configurable gateways on the Layer 3 switch.\nTest Step 3: Establish the test environment according to Figure 10.\nTest Step 4: Set tester port1 address to 192.168.9.100/24 and port2 address to 192.168.11.100/24; configure DUT port1 and port2 as gateways for the 192.168.9.0 and 192.168.11.0 network segments respectively, and verify gateway configuration success through sampling.\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.9.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n        ipv4_ping(Interface=interfaces_down, IpAddr='192.168.11.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_2/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.2 优先级QoS\n\n Step\t\t\t:\t测试步骤1: 按图6，从交换机任意选取三个端口与测试仪相连接，分别定为端口1、端口2 和端口3，交换机配置为绝对优先级，交换机设置端口trunk模式保证不剥掉vlan1；\n                   测试步骤2: 端口1 和端口2 同时端口3 发送数据；\n                   测试步骤3: 在端口1 构造两条优先级分别为7 和5 的数据流，在端口2 构造两条优先级分别为3 和1 的数据流，vlan1 的优先级设置为7 和5，3 和1；\n                   测试步骤4: 测试帧长度为64 字节，测试时间30s，端口负荷设置为100%；\n                   测试步骤5: 记录不同数据流的帧丢失率，判断优先级是否设置成功。\n\n Criteria    \t:   预期结果1: 不同数据流的帧丢失率，与优先级设置一致。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective     : Test Objective: 6.5.2 Priority QoS\n\nStep          : Test Step 1: As shown in Figure 6, connect any three switch ports to the tester, designated as Port 1, Port 2, and Port 3. Configure the switch for absolute priority and set ports to trunk mode to prevent stripping VLAN 1.\n                Test Step 2: Transmit data simultaneously from Port 1 and Port 2 to Port 3.\n                Test Step 3: Construct two data streams with priorities 7 and 5 on Port 1, and two streams with priorities 3 and 1 on Port 2. Set VLAN 1 priorities to 7, 5, 3, and 1 respectively.\n                Test Step 4: Use 64-byte test frames, 30-second test duration, and 100% port load.\n                Test Step 5: Record frame loss rates for different data streams to verify priority configuration.\n\nCriteria      : Expected Result 1: Frame loss rates for different data streams align with priority settings.\n\nCreated by    : Tester-008\n\nTags          : function\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    port1,port2,port3=ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建流量\n    # 数据流 1：qos优先级为 7 的 IPv4 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_7')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    edit_header_vlan(Stream=stream, Priority=7)\n    # 数据流 2：qos优先级为 5 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_5')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, Priority=5)\n\n    # 端口2创建流量\n    # 数据流 1：qos优先级为 3 的 IPv4 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_3')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, Priority=3)\n    # 数据流 2：qos优先级为 1 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_1')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[3])\n    edit_header_vlan(Stream=stream, Priority=1)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(5)\n        # 检查统计结果\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxPortID'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            TxPortID = Result['TxPortID']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=5, result=True)\n            if RxStreamFrames != TxStreamFrames:\n                if TxPortID == port2.Name:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=5, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester API to prepare for testing.\",\n  \"Subtask 2\": \"Reserve three test ports (Port1, Port2, Port3) using reserve_port API based on configured locations.\",\n  \"Subtask 3\": \"Configure port parameters including force, debug, and wait settings using edit_port API.\",\n  \"Subtask 4\": \"Set load profile parameters: 100% port load, 30-second duration, and TIME transmit mode using edit_port_load_profile API.\",\n  \"Subtask 5\": \"Create stream on Port1 with VLAN priority 7: use add_stream to create, edit_stream to set 64-byte frames and Port3 as receiver, create_stream_header for EthernetII/VLAN/IPv4 headers, edit_header_ethernet for MAC addresses, and edit_header_vlan to set priority 7.\",\n  \"Subtask 6\": \"Create stream on Port1 with VLAN priority 5: repeat steps from Subtask 5 with priority 5 and distinct MAC addresses.\",\n  \"Subtask 7\": \"Create stream on Port2 with VLAN priority 3: repeat steps from Subtask 5 with priority 3 and distinct MAC addresses.\",\n  \"Subtask 8\": \"Create stream on Port2 with VLAN priority 1: repeat steps from Subtask 5 with priority 1 and distinct MAC addresses.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats view using subscribe_result API for statistics collection.\",\n  \"Subtask 10\": \"Save test case configuration using save_case API.\",\n  \"Subtask 11\": \"Start Layer 2 learning using start_l2_learning API to enable MAC address discovery.\",\n  \"Subtask 12\": \"Simultaneously transmit all streams from Port1 and Port2 using start_stream API.\",\n  \"Subtask 13\": \"Wait for stream transmission completion using wait_stream_state API.\",\n  \"Subtask 14\": \"For each stream on Port1 and Port2: retrieve TxStreamFrames and RxStreamFrames using get_streams and get_streamblock_statistic APIs.\",\n  \"Subtask 15\": \"Verify high-priority streams (Port1 priorities 7/5) show 0% frame loss (RxStreamFrames == TxStreamFrames) and low-priority streams (Port2 priorities 3/1) show frame loss (RxStreamFrames < TxStreamFrames).\",\n  \"Subtask 16\": \"Clear statistical results using clear_result API.\",\n  \"Subtask 17\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective     : Test Objective: 6.5.2 Priority QoS\n\nStep          : Test Step 1: As shown in Figure 6, connect any three switch ports to the tester, designated as Port 1, Port 2, and Port 3. Configure the switch for absolute priority and set ports to trunk mode to prevent stripping VLAN 1.\n                Test Step 2: Transmit data simultaneously from Port 1 and Port 2 to Port 3.\n                Test Step 3: Construct two data streams with priorities 7 and 5 on Port 1, and two streams with priorities 3 and 1 on Port 2. Set VLAN 1 priorities to 7, 5, 3, and 1 respectively.\n                Test Step 4: Use 64-byte test frames, 30-second test duration, and 100% port load.\n                Test Step 5: Record frame loss rates for different data streams to verify priority configuration.\n\nCriteria      : Expected Result 1: Frame loss rates for different data streams align with priority settings.\n\nCreated by    : Tester-008\n\nTags          : function\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    port1,port2,port3=ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建流量\n    # 数据流 1：qos优先级为 7 的 IPv4 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_7')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    edit_header_vlan(Stream=stream, Priority=7)\n    # 数据流 2：qos优先级为 5 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_5')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, Priority=5)\n\n    # 端口2创建流量\n    # 数据流 1：qos优先级为 3 的 IPv4 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_3')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, Priority=3)\n    # 数据流 2：qos优先级为 1 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_1')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[3])\n    edit_header_vlan(Stream=stream, Priority=1)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(5)\n        # 检查统计结果\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxPortID'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            TxPortID = Result['TxPortID']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=5, result=True)\n            if RxStreamFrames != TxStreamFrames:\n                if TxPortID == port2.Name:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=5, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_8/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :   6.7.8 互联网组管理协议（IGMP)\n\n Step\t\t\t:\t测试步骤1:  按图10建立测试环境；\n                   测试步骤2:  tester port1 地 址 为 192.168.1.100/24 ， port2 地 址 为192.168.2.100/24\n                   测试步骤3:  DUT port1 地址为192.168.1.1/24，port2 地址为192.168.2.1/24\n                   测试步骤4:   DUT 设置IGMPv2组播查询；\n                   测试步骤5:   tester 向port1 发目的地址为225.1.1.1，TTL=1的IGMPv2应答报文，其组地址域也为225.1.1.1，周期为1秒\n                   测试步骤6:   停止发送步骤5中的IGMPv2应答报文，观察交换机组播组成员变化；\n                   测试步骤7:    tester 向port1 发目的地址为225.1.1.1，TTL=1的IGMPv2应答报文，\n                               其组地址域也为225.1.1.1，周期为1秒，停止发送应答报文之后tester\n                               立刻向port1发目的地址为224.0.0.2，TTL=1的IGMPv2离开报文，其组地址域为225.1.1.1。观察交换机组播组成员变化\n                   测试步骤8:   停止发送步骤7中的报文；\n                   测试步骤9:   检查DUT配置，看是否支持IGMPv1、IGMPv2、IGMPv3\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective\t:\tTest Objective: 6.7.8 Internet Group Management Protocol (IGMP)\n\nStep\t\t:\tTest Step 1: Establish test environment according to Figure 10;\nTest Step 2: tester port1 address is 192.168.1.100/24, port2 address is 192.168.2.100/24\nTest Step 3: DUT port1 address is 192.168.1.1/24, port2 address is 192.168.2.1/24\nTest Step 4: DUT configures IGMPv2 multicast query;\nTest Step 5: tester sends to port1 an IGMPv2 report message with destination address 225.1.1.1, TTL=1, group address field also 225.1.1.1, period of 1 second\nTest Step 6: Stop sending the IGMPv2 report message from step 5, observe changes in switch multicast group members;\nTest Step 7: tester sends to port1 an IGMPv2 report message with destination address 225.1.1.1, TTL=1, group address field also 225.1.1.1, period of 1 second; after stopping the report message, tester immediately sends to port1 an IGMPv2 leave message with destination address 224.0.0.2, TTL=1, group address field 225.1.1.1. Observe changes in switch multicast group members;\nTest Step 8: Stop sending the messages from step 7;\nTest Step 9: Check DUT configuration to see if it supports IGMPv1, IGMPv2, IGMPv3\n\nCriteria\t:\tExpected Result 1:\n\nCreated by\t:\tTester-006\n\nBugs\t\t:\tNone\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_up, Version='IGMPV2')\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interfaces_up)\n\n    # 创建组播组\n    multicast_group = create_multicast_group(Start='225.1.1.1')\n\n    # IGMP协议会话创建组成员关系\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=port_down, Version='IGMPV2')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_down)\n\n    # 创建IGMP绑定流\n\n    # point = get_layer_from_interfaces(Interfaces=interfaces_down)\n    #\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints='224.0.0', Bidirection=False)\n\n\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        Rate=100,\n    #                        Unit='FRAME_PER_SEC',\n    #                        TransmitMode=\"STEP\",\n    #                        Frames=20)\n\n\n    #创建IGMPv2报文\n    # stream1 = add_stream(Ports=port_up, Names=f'igmpv2_report')\n    # edit_stream(Stream=stream1, FixedLength=128)\n    # create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4','igmpv2'])\n    # edit_header_ipv4(Stream=stream1, Source='192.168.1.100', Destination= '225.1.1.1', TTl=1)\n    #\n    # stream2 = add_stream(Ports=port_up, Names=f'igmpv2_query')\n    # edit_stream(Stream=stream2, FixedLength=128)\n    # create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4','igmpv2query'])\n    # edit_header_ipv4(Stream=stream2, Source='192.168.1.100', Destination= '224.0.0.2', TTl=1)\n\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        #停止协议\n        stop_protocol()\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_igmp:创建IGMP协议会话对象",
      "create_igmp_querier:创建IGMP Querier协议会话对象",
      "edit_igmp:编辑IGMP协议会话对象",
      "edit_igmp_querier:编辑IGMP Querier协议会话对象",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize test equipment and reserve necessary ports according to testbed configuration.\",\n  \"Subtask 2\": \"Configure tester interface parameters: set port1 IP to 192.168.1.100/24 and port2 IP to 192.168.2.100/24 using edit_interface API.\",\n  \"Subtask 3\": \"Execute DUT configuration commands: set port1 IP to 192.168.1.1/24, port2 IP to 192.168.2.1/24, and enable IGMPv2 multicast query functionality.\",\n  \"Subtask 4\": \"Create IGMPv2 host session on tester port1 with report interval of 1 second, binding multicast group 225.1.1.1 using create_igmp, create_multicast_group, create_memberships, and binding_multicast_group APIs.\",\n  \"Subtask 5\": \"Start IGMP protocol operation using start_protocol API and wait for session stabilization with wait_igmp_state API.\",\n  \"Subtask 6\": \"Stop IGMP protocol using stop_protocol API and verify DUT multicast group removal by querying DUT multicast group table.\",\n  \"Subtask 7\": \"Restart IGMP protocol to send reports, then immediately stop protocol and send IGMPv2 leave message (destined to 224.0.0.2 with group 225.1.1.1) using stream creation/transmission APIs.\",\n  \"Subtask 8\": \"Terminate all message transmissions from step 7 using protocol/stream control APIs.\",\n  \"Subtask 9\": \"Query DUT configuration to validate support for IGMPv1, IGMPv2, and IGMPv3 through DUT command execution.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective\t:\tTest Objective: 6.7.8 Internet Group Management Protocol (IGMP)\n\nStep\t\t:\tTest Step 1: Establish test environment according to Figure 10;\nTest Step 2: tester port1 address is 192.168.1.100/24, port2 address is 192.168.2.100/24\nTest Step 3: DUT port1 address is 192.168.1.1/24, port2 address is 192.168.2.1/24\nTest Step 4: DUT configures IGMPv2 multicast query;\nTest Step 5: tester sends to port1 an IGMPv2 report message with destination address 225.1.1.1, TTL=1, group address field also 225.1.1.1, period of 1 second\nTest Step 6: Stop sending the IGMPv2 report message from step 5, observe changes in switch multicast group members;\nTest Step 7: tester sends to port1 an IGMPv2 report message with destination address 225.1.1.1, TTL=1, group address field also 225.1.1.1, period of 1 second; after stopping the report message, tester immediately sends to port1 an IGMPv2 leave message with destination address 224.0.0.2, TTL=1, group address field 225.1.1.1. Observe changes in switch multicast group members;\nTest Step 8: Stop sending the messages from step 7;\nTest Step 9: Check DUT configuration to see if it supports IGMPv1, IGMPv2, IGMPv3\n\nCriteria\t:\tExpected Result 1:\n\nCreated by\t:\tTester-006\n\nBugs\t\t:\tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_up, Version='IGMPV2')\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interfaces_up)\n\n    # 创建组播组\n    multicast_group = create_multicast_group(Start='225.1.1.1')\n\n    # IGMP协议会话创建组成员关系\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=port_down, Version='IGMPV2')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_down)\n\n    # 创建IGMP绑定流\n\n    # point = get_layer_from_interfaces(Interfaces=interfaces_down)\n    #\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints='224.0.0', Bidirection=False)\n\n\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        Rate=100,\n    #                        Unit='FRAME_PER_SEC',\n    #                        TransmitMode=\"STEP\",\n    #                        Frames=20)\n\n\n    #创建IGMPv2报文\n    # stream1 = add_stream(Ports=port_up, Names=f'igmpv2_report')\n    # edit_stream(Stream=stream1, FixedLength=128)\n    # create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4','igmpv2'])\n    # edit_header_ipv4(Stream=stream1, Source='192.168.1.100', Destination= '225.1.1.1', TTl=1)\n    #\n    # stream2 = add_stream(Ports=port_up, Names=f'igmpv2_query')\n    # edit_stream(Stream=stream2, FixedLength=128)\n    # create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4','igmpv2query'])\n    # edit_header_ipv4(Stream=stream2, Source='192.168.1.100', Destination= '224.0.0.2', TTl=1)\n\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        #停止协议\n        stop_protocol()\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_igmp:创建IGMP协议会话对象;\ncreate_igmp_querier:创建IGMP Querier协议会话对象;\nedit_igmp:编辑IGMP协议会话对象;\nedit_igmp_querier:编辑IGMP Querier协议会话对象;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_10/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.5.10 环网倒换时间\n\n Step\t\t\t:\t测试步骤1: 将4台交换机按照图9连接，允许交换机启用私有环网协议；\n                   测试步骤2: 在整个试验过程中，端口1、端口2互发数据流，测试帧长度为64字节，测试时间为30s，负荷率分别为10%和95%；\n                   测试步骤3: 分别拔插A、B、C路径，测试环网恢复时间。环网倒换时间（ms）=帧丢失数/总发送帧数×测试时间（ms）。\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: 6.5.10 Ring Network Switching Time\n\nStep: Test Step 1: Connect four switches according to Figure 9, allowing switches to enable private ring network protocol;\n      Test Step 2: Throughout the test, have Port 1 and Port 2 send bidirectional traffic streams. Use 64-byte test frames with 30-second duration at 10% and 95% load rates respectively;\n      Test Step 3: Disconnect and reconnect paths A, B, and C separately to measure ring recovery time. Ring switching time (ms) = (Number of lost frames / Total transmitted frames) × Test duration (ms).\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None\n=================================================================================",
    "code": "from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=10,)\n    edit_port_load_profile(Ports=port2,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95, )\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插路径\n        time.sleep(30)\n\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time1 =( TxStreamFrames - RxStreamFrames)/TxStreamFrames * 3000\n        print(switch_time1)\n        stop_stream()\n\n        start_stream(Type='stream', Objects=stream2)\n        # 拔插路径\n        time.sleep(30)\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time2 = (TxStreamFrames - RxStreamFrames) / TxStreamFrames * 3000\n        print(switch_time2)\n        stop_stream()\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize tester and reserve ports for Port1 and Port2 using reserve_port API.\",\n  \"Subtask 2\": \"Configure load profiles: set Port1 to 10% load and Port2 to 95% load using edit_port_load_profile API.\",\n  \"Subtask 3\": \"Create two bidirectional traffic streams (Stream1 and Stream2) with 64-byte frames using add_stream API.\",\n  \"Subtask 4\": \"Configure Ethernet headers for both streams with specified MAC addresses using edit_header_ethernet API.\",\n  \"Subtask 5\": \"Subscribe to PortStats and StreamBlockStats views using subscribe_result API.\",\n  \"Subtask 6\": \"Start both streams simultaneously using start_stream API.\",\n  \"Subtask 7\": \"Simulate path disconnection (Path A) during traffic transmission (manual intervention step).\",\n  \"Subtask 8\": \"Maintain traffic for 30 seconds after disconnection.\",\n  \"Subtask 9\": \"Simulate path reconnection (Path A) after test duration (manual intervention step).\",\n  \"Subtask 10\": \"Stop both streams using stop_stream API.\",\n  \"Subtask 11\": \"Retrieve transmitted (TxStreamFrames) and received (RxStreamFrames) counts for both streams using get_streamblock_statistic API.\",\n  \"Subtask 12\": \"Calculate ring switching time using formula: (Tx - Rx)/Tx * 30000 ms for each stream.\",\n  \"Subtask 13\": \"Clear statistics using clear_result API.\",\n  \"Subtask 14\": \"Repeat steps 6-13 for Path B disconnection/reconnection.\",\n  \"Subtask 15\": \"Repeat steps 6-13 for Path C disconnection/reconnection.\",\n  \"Subtask 16\": \"Release all reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: 6.5.10 Ring Network Switching Time\n\nStep: Test Step 1: Connect four switches according to Figure 9, allowing switches to enable private ring network protocol;\n      Test Step 2: Throughout the test, have Port 1 and Port 2 send bidirectional traffic streams. Use 64-byte test frames with 30-second duration at 10% and 95% load rates respectively;\n      Test Step 3: Disconnect and reconnect paths A, B, and C separately to measure ring recovery time. Ring switching time (ms) = (Number of lost frames / Total transmitted frames) × Test duration (ms).\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=10,)\n    edit_port_load_profile(Ports=port2,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95, )\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插路径\n        time.sleep(30)\n\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time1 =( TxStreamFrames - RxStreamFrames)/TxStreamFrames * 3000\n        print(switch_time1)\n        stop_stream()\n\n        start_stream(Type='stream', Objects=stream2)\n        # 拔插路径\n        time.sleep(30)\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time2 = (TxStreamFrames - RxStreamFrames) / TxStreamFrames * 3000\n        print(switch_time2)\n        stop_stream()\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_7/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.7 虚拟路由冗余协议（VRRP）\n\n Step\t\t\t:\t测试步骤1:  按图12建立测试环境\n                   测试步骤2:  DUT1 和DUT4为二层接入交换机\n                   测试步骤3:  DUT2（主机）和DUT3（备机）组成双机冗余，两机之间可增加心跳线；\n                   测试步骤4:  tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24\n                   测试步骤5:   DUT2 port1 与DUT3 port1作为192.168.1.0网段网关，代表IP为192.168.1.1/24；\n                   测试步骤6:   DUT2 port2 与DUT3 port2作为192.168.2.0网段网关，代表IP为192.168.2.1/24；\n                   测试步骤7:   tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，\n                               网关设置为VRRP组的虚拟IP地址，查看并记录数据的接收\n                   测试步骤8:  断开交换机DUT1与VRRP主机的连接，查看并记录DUT2、DUT3上VRRP\n                               的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间；\n                               恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流；\n                   测试步骤9:   重复步骤7、8两次。\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: 6.7.7 Virtual Router Redundancy Protocol (VRRP)\n\nStep:\nTest Step 1: Establish the test environment as shown in Figure 12.\nTest Step 2: Configure DUT1 and DUT4 as Layer 2 access switches.\nTest Step 3: Configure DUT2 (Master) and DUT3 (Backup) for device redundancy; a heartbeat cable may be added between them.\nTest Step 4: Set tester port1 IP address to 192.168.1.100/24, port2 to 192.168.2.100/24.\nTest Step 5: Configure DUT2 port1 and DUT3 port1 as gateways for the 192.168.1.0 network segment, with virtual IP 192.168.1.1/24.\nTest Step 6: Configure DUT2 port2 and DUT3 port2 as gateways for the 192.168.2.0 network segment, with virtual IP 192.168.2.1/24.\nTest Step 7: Generate traffic from tester port1 to port2 with frame size 256 bytes at 10,000 frames/second. Set the gateway to the VRRP group's virtual IP address. Observe and record data reception.\nTest Step 8: Disconnect the link between switch DUT1 and the VRRP master device. Observe and record VRRP status on DUT2/DUT3 and data loss. Calculate VRRP convergence time based on packet loss count and transmission rate. Restore the switch link, observe VRRP status on DUT2/DUT3, and resend data traffic.\nTest Step 9: Repeat steps 7 and 8 twice.\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，10.1.1.111\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Frames=10000)\n\n    stream = add_stream(Ports=port_up, Names=f'stream1')\n    edit_stream(Stream=stream, FixedLength=256)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=cfg['arg']['interface']['default']['ipv4_up_address'],\n                     Destination=cfg['arg']['interface']['default']['ipv4_down_address'],Gateway ='10.1.1.111')\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        for i in range(2):\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n            start_stream()\n            # 断开交换机DUT1与VRRP主机的连接,，查看并记录DUT2、DUT3上VRRP的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            #VRRP的收敛时间\n            Convergence_time = (TxStreamFrames - RxStreamFrames)/TxStreamFrames\n            clear_result()\n            #恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Establish test environment by initializing tester equipment and reserving ports as per topology.\",\n  \"Subtask 2\": \"Configure DUT1 and DUT4 as Layer 2 access switches using device-specific commands.\",\n  \"Subtask 3\": \"Configure DUT2 as VRRP master and DUT3 as backup with heartbeat connection between them.\",\n  \"Subtask 4\": \"Set tester port1 IP address to 192.168.1.100/24 and port2 to 192.168.2.100/24 using interface configuration APIs.\",\n  \"Subtask 5\": \"Configure DUT2 port1 and DUT3 port1 as gateways for 192.168.1.0/24 network with virtual IP 192.168.1.1/24.\",\n  \"Subtask 6\": \"Configure DUT2 port2 and DUT3 port2 as gateways for 192.168.2.0/24 network with virtual IP 192.168.2.1/24.\",\n  \"Subtask 7\": \"Create traffic stream from tester port1 to port2 with frame size 256 bytes and rate of 10,000 frames/second, setting gateway to VRRP virtual IP.\",\n  \"Subtask 8\": \"Start traffic transmission, wait for stabilization, then stop stream and record baseline frame statistics (Tx and Rx).\",\n  \"Subtask 9\": \"Verify baseline traffic: confirm received frames equal transmitted frames with no loss.\",\n  \"Subtask 10\": \"Disconnect link between DUT1 and VRRP master device while traffic is running.\",\n  \"Subtask 11\": \"Monitor VRRP status changes on DUT2/DUT3 and record traffic loss statistics during failure event.\",\n  \"Subtask 12\": \"Calculate VRRP convergence time using formula: (Tx frames - Rx frames) / transmission rate (10,000 fps).\",\n  \"Subtask 13\": \"Restore DUT1-VRRP master link and observe VRRP status recovery on DUT2/DUT3.\",\n  \"Subtask 14\": \"Restart traffic stream and record post-recovery frame statistics.\",\n  \"Subtask 15\": \"Verify post-recovery traffic: confirm received frames equal transmitted frames after link restoration.\",\n  \"Subtask 16\": \"Clear all test statistics and repeat failure/recovery test cycle (Subtask 8 to 15) for two additional iterations.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: 6.7.7 Virtual Router Redundancy Protocol (VRRP)\n\nStep:\nTest Step 1: Establish the test environment as shown in Figure 12.\nTest Step 2: Configure DUT1 and DUT4 as Layer 2 access switches.\nTest Step 3: Configure DUT2 (Master) and DUT3 (Backup) for device redundancy; a heartbeat cable may be added between them.\nTest Step 4: Set tester port1 IP address to 192.168.1.100/24, port2 to 192.168.2.100/24.\nTest Step 5: Configure DUT2 port1 and DUT3 port1 as gateways for the 192.168.1.0 network segment, with virtual IP 192.168.1.1/24.\nTest Step 6: Configure DUT2 port2 and DUT3 port2 as gateways for the 192.168.2.0 network segment, with virtual IP 192.168.2.1/24.\nTest Step 7: Generate traffic from tester port1 to port2 with frame size 256 bytes at 10,000 frames/second. Set the gateway to the VRRP group's virtual IP address. Observe and record data reception.\nTest Step 8: Disconnect the link between switch DUT1 and the VRRP master device. Observe and record VRRP status on DUT2/DUT3 and data loss. Calculate VRRP convergence time based on packet loss count and transmission rate. Restore the switch link, observe VRRP status on DUT2/DUT3, and resend data traffic.\nTest Step 9: Repeat steps 7 and 8 twice.\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，10.1.1.111\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Frames=10000)\n\n    stream = add_stream(Ports=port_up, Names=f'stream1')\n    edit_stream(Stream=stream, FixedLength=256)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=cfg['arg']['interface']['default']['ipv4_up_address'],\n                     Destination=cfg['arg']['interface']['default']['ipv4_down_address'],Gateway ='10.1.1.111')\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        for i in range(2):\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n            start_stream()\n            # 断开交换机DUT1与VRRP主机的连接,，查看并记录DUT2、DUT3上VRRP的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            #VRRP的收敛时间\n            Convergence_time = (TxStreamFrames - RxStreamFrames)/TxStreamFrames\n            clear_result()\n            #恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  }
]
[
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_10/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.5.10 环网倒换时间\n\n Step\t\t\t:\t测试步骤1: 将4台交换机按照图9连接，允许交换机启用私有环网协议；\n                   测试步骤2: 在整个试验过程中，端口1、端口2互发数据流，测试帧长度为64字节，测试时间为30s，负荷率分别为10%和95%；\n                   测试步骤3: 分别拔插A、B、C路径，测试环网恢复时间。环网倒换时间（ms）=帧丢失数/总发送帧数×测试时间（ms）。\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=10,)\n    edit_port_load_profile(Ports=port2,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95, )\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插路径\n        time.sleep(30)\n\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time1 =( TxStreamFrames - RxStreamFrames)/TxStreamFrames * 3000\n        print(switch_time1)\n        stop_stream()\n\n        start_stream(Type='stream', Objects=stream2)\n        # 拔插路径\n        time.sleep(30)\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time2 = (TxStreamFrames - RxStreamFrames) / TxStreamFrames * 3000\n        print(switch_time2)\n        stop_stream()\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表。\",\n  \"子任务2\": \"预约测试仪表端口（端口1和端口2）。\",\n  \"子任务3\": \"配置端口参数，包括设置端口模式和等待端口状态。\",\n  \"子任务4\": \"编辑端口负载配置文件：设置端口1负荷率为10%（连续发送模式），端口2负荷率为95%（连续发送模式）。\",\n  \"子任务5\": \"在端口1上创建流量流（stream1），帧长度固定为64字节。\",\n  \"子任务6\": \"在端口2上创建流量流（stream2），帧长度固定为64字节。\",\n  \"子任务7\": \"修改两个流的Ethernet报文头部，指定源MAC地址和目的MAC地址。\",\n  \"子任务8\": \"订阅统计视图，包括端口统计和流模板块统计。\",\n  \"子任务9\": \"保存测试配置文件。\",\n  \"子任务10\": \"启动二层学习。\",\n  \"子任务11\": \"开始发送两个流量流（stream1和stream2）。\",\n  \"子任务12\": \"模拟拔插路径A。\",\n  \"子任务13\": \"等待30秒测试时间。\",\n  \"子任务14\": \"停止发送流量流。\",\n  \"子任务15\": \"获取流模板块统计结果，包括发送帧数和接收帧数。\",\n  \"子任务16\": \"计算环网倒换时间：帧丢失数 / 总发送帧数 × 30000毫秒，分别针对stream1和stream2。\",\n  \"子任务17\": \"清除统计结果。\",\n  \"子任务18\": \"开始发送两个流量流（stream1和stream2）。\",\n  \"子任务19\": \"模拟拔插路径B。\",\n  \"子任务20\": \"等待30秒测试时间。\",\n  \"子任务21\": \"停止发送流量流。\",\n  \"子任务22\": \"获取流模板块统计结果，包括发送帧数和接收帧数。\",\n  \"子任务23\": \"计算环网倒换时间：帧丢失数 / 总发送帧数 × 30000毫秒，分别针对stream1和stream2。\",\n  \"子任务24\": \"清除统计结果。\",\n  \"子任务25\": \"开始发送两个流量流（stream1和stream2）。\",\n  \"子任务26\": \"模拟拔插路径C。\",\n  \"子任务27\": \"等待30秒测试时间。\",\n  \"子任务28\": \"停止发送流量流。\",\n  \"子任务29\": \"获取流模板块统计结果，包括发送帧数和接收帧数。\",\n  \"子任务30\": \"计算环网倒换时间：帧丢失数 / 总发送帧数 × 30000毫秒，分别针对stream1和stream2。\",\n  \"子任务31\": \"释放测试仪表端口资源。\",\n  \"子任务32\": \"关闭测试仪表。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.5.10 环网倒换时间\n\n Step\t\t\t:\t测试步骤1: 将4台交换机按照图9连接，允许交换机启用私有环网协议；\n                   测试步骤2: 在整个试验过程中，端口1、端口2互发数据流，测试帧长度为64字节，测试时间为30s，负荷率分别为10%和95%；\n                   测试步骤3: 分别拔插A、B、C路径，测试环网恢复时间。环网倒换时间（ms）=帧丢失数/总发送帧数×测试时间（ms）。\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=10,)\n    edit_port_load_profile(Ports=port2,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95, )\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插路径\n        time.sleep(30)\n\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time1 =( TxStreamFrames - RxStreamFrames)/TxStreamFrames * 3000\n        print(switch_time1)\n        stop_stream()\n\n        start_stream(Type='stream', Objects=stream2)\n        # 拔插路径\n        time.sleep(30)\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time2 = (TxStreamFrames - RxStreamFrames) / TxStreamFrames * 3000\n        print(switch_time2)\n        stop_stream()\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_7/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.7 虚拟路由冗余协议（VRRP）\n\n Step\t\t\t:\t测试步骤1:  按图12建立测试环境\n                   测试步骤2:  DUT1 和DUT4为二层接入交换机\n                   测试步骤3:  DUT2（主机）和DUT3（备机）组成双机冗余，两机之间可增加心跳线；\n                   测试步骤4:  tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24\n                   测试步骤5:   DUT2 port1 与DUT3 port1作为192.168.1.0网段网关，代表IP为192.168.1.1/24；\n                   测试步骤6:   DUT2 port2 与DUT3 port2作为192.168.2.0网段网关，代表IP为192.168.2.1/24；\n                   测试步骤7:   tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，\n                               网关设置为VRRP组的虚拟IP地址，查看并记录数据的接收\n                   测试步骤8:  断开交换机DUT1与VRRP主机的连接，查看并记录DUT2、DUT3上VRRP\n                               的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间；\n                               恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流；\n                   测试步骤9:   重复步骤7、8两次。\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，10.1.1.111\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Frames=10000)\n\n    stream = add_stream(Ports=port_up, Names=f'stream1')\n    edit_stream(Stream=stream, FixedLength=256)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=cfg['arg']['interface']['default']['ipv4_up_address'],\n                     Destination=cfg['arg']['interface']['default']['ipv4_down_address'],Gateway ='10.1.1.111')\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        for i in range(2):\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n            start_stream()\n            # 断开交换机DUT1与VRRP主机的连接,，查看并记录DUT2、DUT3上VRRP的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            #VRRP的收敛时间\n            Convergence_time = (TxStreamFrames - RxStreamFrames)/TxStreamFrames\n            clear_result()\n            #恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并预约端口port1和port2\",\n  \"子任务2\": \"配置端口参数并等待端口状态就绪\",\n  \"子任务3\": \"在port1创建接口并配置MAC地址与IPv4地址(192.168.1.100/24)，网关设置为VRRP虚拟IP(192.168.1.1)\",\n  \"子任务4\": \"在port2创建接口并配置MAC地址与IPv4地址(192.168.2.100/24)，网关设置为VRRP虚拟IP(192.168.2.1)\",\n  \"子任务5\": \"配置端口负载参数：帧长256字节，速率10000帧/秒，连续发送模式\",\n  \"子任务6\": \"创建从port1到port2的流量流，设置IPv4头部参数：源IP(192.168.1.100)，目的IP(192.168.2.100)\",\n  \"子任务7\": \"订阅端口统计和流统计视图\",\n  \"子任务8\": \"执行首次流量测试：启动流量发送，等待5秒后停止，获取并验证接收帧数等于发送帧数\",\n  \"子任务9\": \"清除统计结果\",\n  \"子任务10\": \"断开DUT1与VRRP主机的连接（外部操作），启动流量发送并等待5秒\",\n  \"子任务11\": \"停止流量发送，获取流统计结果，计算VRRP收敛时间：(发送帧数-接收帧数)/发送速率\",\n  \"子任务12\": \"清除统计结果\",\n  \"子任务13\": \"恢复交换机链路（外部操作），启动流量发送并等待5秒后停止\",\n  \"子任务14\": \"获取流统计结果并验证接收帧数等于发送帧数\",\n  \"子任务15\": \"清除统计结果\",\n  \"子任务16\": \"重复执行子任务8至子任务15两次（共三次测试循环）\",\n  \"子任务17\": \"释放测试仪端口资源并关闭仪表\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.7.7 虚拟路由冗余协议（VRRP）\n\n Step\t\t\t:\t测试步骤1:  按图12建立测试环境\n                   测试步骤2:  DUT1 和DUT4为二层接入交换机\n                   测试步骤3:  DUT2（主机）和DUT3（备机）组成双机冗余，两机之间可增加心跳线；\n                   测试步骤4:  tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24\n                   测试步骤5:   DUT2 port1 与DUT3 port1作为192.168.1.0网段网关，代表IP为192.168.1.1/24；\n                   测试步骤6:   DUT2 port2 与DUT3 port2作为192.168.2.0网段网关，代表IP为192.168.2.1/24；\n                   测试步骤7:   tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，\n                               网关设置为VRRP组的虚拟IP地址，查看并记录数据的接收\n                   测试步骤8:  断开交换机DUT1与VRRP主机的连接，查看并记录DUT2、DUT3上VRRP\n                               的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间；\n                               恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流；\n                   测试步骤9:   重复步骤7、8两次。\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，10.1.1.111\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Frames=10000)\n\n    stream = add_stream(Ports=port_up, Names=f'stream1')\n    edit_stream(Stream=stream, FixedLength=256)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=cfg['arg']['interface']['default']['ipv4_up_address'],\n                     Destination=cfg['arg']['interface']['default']['ipv4_down_address'],Gateway ='10.1.1.111')\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        for i in range(2):\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n            start_stream()\n            # 断开交换机DUT1与VRRP主机的连接,，查看并记录DUT2、DUT3上VRRP的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            #VRRP的收敛时间\n            Convergence_time = (TxStreamFrames - RxStreamFrames)/TxStreamFrames\n            clear_result()\n            #恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_9/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.5.9 生成树协议\n\n Step\t\t\t:\t测试步骤1: 将4台交换机按照图9连接，级联口均采用100M光口；\n                   测试步骤2: 整个组网设备间运行标准生成树协议，配置各设备的生成树参数，\n                   测试步骤3: 观察设备能否根据配置的参数修剪环路，完成生成树\n                   测试步骤4: 阻断开设备目前的生成树链路，观察设备是否可自动完成网络拓扑重构；\n                   测试步骤5: 启用所有交换机的RSTP功能\n                   测试步骤6: 将交换机如图9连接；\n                   测试步骤7: 用SmartBits 在任意两台交换机之间加载95Mbps数据流量；\n                   测试步骤8: 拔插环网中的任一链路，查看网络是否可以正常收敛\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95,)\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插链路\n        time.sleep(30)\n\n        # 查看收敛时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxFCSErr = Result['RxFCSErr']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=True)\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"设置测试拓扑：按照图9连接4台交换机，级联口使用100M光口。\",\n  \"子任务2\": \"配置生成树协议：在组网设备上运行标准生成树协议，并设置生成树参数。\",\n  \"子任务3\": \"验证初始收敛：观察设备是否根据配置参数修剪环路，完成生成树拓扑。\",\n  \"子任务4\": \"模拟链路故障：阻断开当前生成树链路。\",\n  \"子任务5\": \"验证故障恢复：观察设备是否自动完成网络拓扑重构，确保收敛。\",\n  \"子任务6\": \"启用RSTP功能：在所有交换机上启用快速生成树协议（RSTP）。\",\n  \"子任务7\": \"重新设置拓扑：将交换机按照图9重新连接，确保级联口为100M光口。\",\n  \"子任务8\": \"配置流量负载：使用测试仪表在任意两台交换机之间加载95Mbps数据流量，帧长度为64字节。\",\n  \"子任务9\": \"模拟链路事件：拔插环网中的任一链路。\",\n  \"子任务10\": \"验证收敛性能：通过流量统计检查网络是否正常收敛，预期结果包括TxStreamFrames与RxStreamFrames一致且无丢包。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.5.9 生成树协议\n\n Step\t\t\t:\t测试步骤1: 将4台交换机按照图9连接，级联口均采用100M光口；\n                   测试步骤2: 整个组网设备间运行标准生成树协议，配置各设备的生成树参数，\n                   测试步骤3: 观察设备能否根据配置的参数修剪环路，完成生成树\n                   测试步骤4: 阻断开设备目前的生成树链路，观察设备是否可自动完成网络拓扑重构；\n                   测试步骤5: 启用所有交换机的RSTP功能\n                   测试步骤6: 将交换机如图9连接；\n                   测试步骤7: 用SmartBits 在任意两台交换机之间加载95Mbps数据流量；\n                   测试步骤8: 拔插环网中的任一链路，查看网络是否可以正常收敛\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95,)\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插链路\n        time.sleep(30)\n\n        # 查看收敛时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxFCSErr = Result['RxFCSErr']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=True)\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_6/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.6 地址缓存能力\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2889 中规定，将交换机三个端口与测试仪连接，分别为端口 1（测试端口），端口 2（学习端口），端口 3（监视端口），见图 5；\n                   测试步骤2: 测试方法采用 RFC2889 标准测试方法。\n\n Criteria    \t:   预期结果1: 技术要求二层交换机不低于 4k；三层交换机不低于 16k。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressCachingCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    # 提供学习的地址数和地址学习速率\n    edit_benchmark_address_learning_capacity(Config=Config,\n                                             MinAddressCount=cfg['arg']['learning_capacity']['default']['min_address_count']['default'],\n                                             MaxAddressCount=cfg['arg']['learning_capacity']['default']['max_address_count']['default'],\n                                             InitAddressCount=cfg['arg']['learning_capacity']['default']['init_address_count']['default'],\n                                             Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                             AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                             LearningRate=cfg['arg']['learning_capacity']['default']['learning_rate']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_address_learning_capacity:编辑RFC2889测试套件地址容量测试项参数",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试仪的控制连接。\",\n  \"子任务2\": \"预约测试仪的三个端口：端口1作为测试端口，端口2作为学习端口，端口3作为监视端口。\",\n  \"子任务3\": \"修改测试仪表端口参数（如速率、双工模式等）以匹配被测设备配置。\",\n  \"子任务4\": \"等待所有预约端口链路状态变为UP，确保物理连接正常。\",\n  \"子任务5\": \"创建RFC2889测试套件，选择地址缓存容量（addressCachingCapacity）测试项。\",\n  \"子任务6\": \"关联测试套件与三个端口：测试端口作为源端口，学习端口作为目的端口，监视端口作为监控端口。\",\n  \"子任务7\": \"在测试端口和学习端口分别创建以太网接口。\",\n  \"子任务8\": \"配置测试端口和学习端口接口的MAC地址。\",\n  \"子任务9\": \"创建测试流量流：从测试端口到学习端口的单向以太网流量，并启用监视端口监控。\",\n  \"子任务10\": \"配置测试套件延迟参数：延迟类型为FIFO，延迟前2秒，延迟后10秒。\",\n  \"子任务11\": \"设置测试套件试验次数为1次。\",\n  \"子任务12\": \"配置测试帧长度为指定值（根据测试需求）。\",\n  \"子任务13\": \"配置地址缓存容量参数：最小地址数、最大地址数、初始地址数、分辨率、老化时间和学习速率。\",\n  \"子任务14\": \"生成测试套件的智能执行脚本。\",\n  \"子任务15\": \"保存测试配置文件。\",\n  \"子任务16\": \"执行测试套件，运行地址缓存容量测试。\",\n  \"子任务17\": \"从测试结果中获取地址缓存容量值。\",\n  \"子任务18\": \"验证测试结果：若被测设备为二层交换机，地址缓存容量≥4096；若为三层交换机，≥16384。\",\n  \"子任务19\": \"释放所有测试仪表端口资源。\",\n  \"子任务20\": \"关闭测试仪表连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.6 地址缓存能力\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2889 中规定，将交换机三个端口与测试仪连接，分别为端口 1（测试端口），端口 2（学习端口），端口 3（监视端口），见图 5；\n                   测试步骤2: 测试方法采用 RFC2889 标准测试方法。\n\n Criteria    \t:   预期结果1: 技术要求二层交换机不低于 4k；三层交换机不低于 16k。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressCachingCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    # 提供学习的地址数和地址学习速率\n    edit_benchmark_address_learning_capacity(Config=Config,\n                                             MinAddressCount=cfg['arg']['learning_capacity']['default']['min_address_count']['default'],\n                                             MaxAddressCount=cfg['arg']['learning_capacity']['default']['max_address_count']['default'],\n                                             InitAddressCount=cfg['arg']['learning_capacity']['default']['init_address_count']['default'],\n                                             Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                             AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                             LearningRate=cfg['arg']['learning_capacity']['default']['learning_rate']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_address_learning_capacity:编辑RFC2889测试套件地址容量测试项参数;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_7/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.7 地址学习速率\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2889 中规定，将交换机三个端口与测试仪连接，分别为端口 1（测试端口），端口 2（学习端口），端口 3（监视端口），见图 5；\n                   测试步骤2: 测试方法采用 RFC2889 标准测试方法。\n\n Criteria    \t:   预期结果1: 技术要求应不低于 1000 帧/s。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressLearningRate'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n\n    # 地址学习速率和地址数量\n    edit_benchmark_address_learning_rate(Config=Config,\n                                         MinRateCount=cfg['arg']['learning_capacity']['default']['min_rate_count']['default'],\n                                         MaxRateCount=cfg['arg']['learning_capacity']['default']['max_rate_count']['default'],\n                                         InitRateCount=cfg['arg']['learning_capacity']['default']['init_rate_count']['default'],\n                                         Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                         AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                         AddressCount=cfg['arg']['learning_capacity']['default']['address_count']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_address_learning_rate:编辑RFC2889测试套件地址容量测试项参数",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试仪的控制连接。\",\n  \"子任务2\": \"预约测试仪表三个端口：端口1作为测试端口，端口2作为学习端口，端口3作为监视端口。\",\n  \"子任务3\": \"配置测试端口和学习端口的链路参数（如速率、双工模式等）。\",\n  \"子任务4\": \"创建RFC2889测试套件，选择地址学习速率(addressLearningRate)测试项。\",\n  \"子任务5\": \"关联测试套件使用的三个端口：测试端口对应端口1，学习端口对应端口2，监视端口对应端口3。\",\n  \"子任务6\": \"在测试端口和学习端口上分别创建以太网接口。\",\n  \"子任务7\": \"配置测试端口接口的源MAC地址和学习端口接口的目的MAC地址。\",\n  \"子任务8\": \"创建测试流量：从测试端口发往学习端口的单向流量，监视端口用于监控。\",\n  \"子任务9\": \"配置测试时延参数：设置流量开始前延迟2秒，结束后延迟10秒。\",\n  \"子任务10\": \"设置测试次数为1次。\",\n  \"子任务11\": \"配置测试帧长为指定长度（根据配置参数）。\",\n  \"子任务12\": \"配置地址学习速率参数：最小速率、最大速率、初始速率、分辨率、老化时间和地址数量（根据配置参数）。\",\n  \"子任务13\": \"生成测试套件智能脚本。\",\n  \"子任务14\": \"保存测试配置文件。\",\n  \"子任务15\": \"执行RFC2889测试套件，设置超时时间为3600秒。\",\n  \"子任务16\": \"从测试结果中获取地址学习速率数据。\",\n  \"子任务17\": \"验证地址学习速率是否不低于1000帧/秒。\",\n  \"子任务18\": \"释放测试仪表端口资源。\",\n  \"子任务19\": \"关闭测试仪表连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.7 地址学习速率\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2889 中规定，将交换机三个端口与测试仪连接，分别为端口 1（测试端口），端口 2（学习端口），端口 3（监视端口），见图 5；\n                   测试步骤2: 测试方法采用 RFC2889 标准测试方法。\n\n Criteria    \t:   预期结果1: 技术要求应不低于 1000 帧/s。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressLearningRate'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n\n    # 地址学习速率和地址数量\n    edit_benchmark_address_learning_rate(Config=Config,\n                                         MinRateCount=cfg['arg']['learning_capacity']['default']['min_rate_count']['default'],\n                                         MaxRateCount=cfg['arg']['learning_capacity']['default']['max_rate_count']['default'],\n                                         InitRateCount=cfg['arg']['learning_capacity']['default']['init_rate_count']['default'],\n                                         Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                         AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                         AddressCount=cfg['arg']['learning_capacity']['default']['address_count']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_address_learning_rate:编辑RFC2889测试套件地址容量测试项参数;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_6/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.6 IGMP-Snooping 组播: 二层交换机应支持 IGMP-Snooping 组播功能\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示，交换机端口为同一VLAN 内的UNTAGGED 端口；\n                   测试步骤2: 端口1 向端口2 发送1 个组的组播流量\n                   测试步骤3: 在被测交换机上禁用IGMP Snooping 功能，观察端口2 流量接收情况；\n                   测试步骤4: 在被测交换机上启用IGMP Snooping 功能，观察端口2 流量接收情况；\n                   测试步骤5: 端口2 使用IGMP 协议V2 加入组播组，观察端口2 流量接收情况；\n                   测试步骤6: 端口2 发送离开组请求，观察端口2 流量接收情况。\n\n Criteria    \t:   预期结果1: 步骤2）在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量；\n                   预期结果2: 步骤3）在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量；\n                   预期结果3: 步骤4）端口2 发送组加入请求后，可接收组播流量；\n                   预期结果4: 步骤5）端口2 发送离开组请求后，不能接收组播流量。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port_1, port_2 = ports\n    # 创建接口\n    interface_1 = create_interface(Port=port_1,Layers=['eth', 'ipv4'])\n    interface_2 = create_interface(Port=port_2,Layers=['eth', 'ipv4'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_2, Version='IGMPV2')\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interface_2)\n\n    # 创建全局组播组\n    multicast_group = create_multicast_group(Start='225.0.1.2',Count=1)\n\n    # 创建组播协议和组播组绑定关系对象\n    memberships = create_memberships(Session=igmp)\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP绑定流\n    src_point = get_layer_from_interfaces(Interfaces=interface_1)\n\n    stream = add_stream(Type='binding', SrcPoints=src_point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        # 获取流量统计结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'RxLossStreamFrames',\n                                                                    'RealtimeLossRate'])\n        if  Result['RxStreamFrames'] > 0  and Result['RxLossStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，没有所有端口都接收到组播流量', step=5, result=False)\n\n        # 被测设备使能igmp snooping\n        cmd_cfg = '_'.join('DeviceA_Step3'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        # 清空统计计数\n        clear_result()\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        printf(message='step3：端口1向端口2发送1个组的组播流量, 在被测交换机上启用IGMP Snooping 功能')\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=False)\n\n        igmp_send_report(Sessions=igmp)\n        time.sleep(3)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=False)\n\n        igmp_send_leave(Sessions=igmp)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if Result['TxStreamFrames'] != Result['RxStreamFrames'] and Result['RxStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "create_igmp:创建IGMP协议会话对象",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，预约端口资源，配置端口参数（reserve_port, init_tester, edit_port）\",\n  \"子任务2\": \"在端口1和端口2上创建以太网/IPv4接口（create_interface）\",\n  \"子任务3\": \"在端口2创建IGMPv2协议会话并绑定接口（create_igmp, select_interface）\",\n  \"子任务4\": \"创建组播组(225.0.1.2)和成员关系对象（create_multicast_group, create_memberships）\",\n  \"子任务5\": \"绑定组播组到IGMP会话（binding_multicast_group）\",\n  \"子任务6\": \"创建端口1到组播组的流量流（get_layer_from_interfaces, add_stream）\",\n  \"子任务7\": \"在被测交换机禁用IGMP Snooping功能（设备配置操作）\",\n  \"子任务8\": \"发送流量并验证：所有端口均接收组播流量（start_stream, stop_stream, get_streamblock_statistic，预期RxStreamFrames>0且RxLossStreamFrames=0）\",\n  \"子任务9\": \"在被测交换机启用IGMP Snooping功能（设备配置操作）\",\n  \"子任务10\": \"启动IGMP协议并等待稳定状态（start_protocol, wait_igmp_state）\",\n  \"子任务11\": \"发送流量并验证：非成员端口不接收组播流量（start_stream, stop_stream, get_streamblock_statistic，预期RxStreamFrames=0）\",\n  \"子任务12\": \"从端口2发送IGMP加入组报告（igmp_send_report）\",\n  \"子任务13\": \"发送流量并验证：成员端口接收组播流量（start_stream, stop_stream, get_streamblock_statistic，预期TxStreamFrames==RxStreamFrames）\",\n  \"子任务14\": \"从端口2发送IGMP离开组请求（igmp_send_leave）\",\n  \"子任务15\": \"发送流量并验证：离开组成员不接收组播流量（start_stream, stop_stream, get_streamblock_statistic，预期RxStreamFrames=0）\",\n  \"子任务16\": \"释放端口资源并清理环境（release_port, teardown）\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.6 IGMP-Snooping 组播: 二层交换机应支持 IGMP-Snooping 组播功能\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示，交换机端口为同一VLAN 内的UNTAGGED 端口；\n                   测试步骤2: 端口1 向端口2 发送1 个组的组播流量\n                   测试步骤3: 在被测交换机上禁用IGMP Snooping 功能，观察端口2 流量接收情况；\n                   测试步骤4: 在被测交换机上启用IGMP Snooping 功能，观察端口2 流量接收情况；\n                   测试步骤5: 端口2 使用IGMP 协议V2 加入组播组，观察端口2 流量接收情况；\n                   测试步骤6: 端口2 发送离开组请求，观察端口2 流量接收情况。\n\n Criteria    \t:   预期结果1: 步骤2）在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量；\n                   预期结果2: 步骤3）在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量；\n                   预期结果3: 步骤4）端口2 发送组加入请求后，可接收组播流量；\n                   预期结果4: 步骤5）端口2 发送离开组请求后，不能接收组播流量。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port_1, port_2 = ports\n    # 创建接口\n    interface_1 = create_interface(Port=port_1,Layers=['eth', 'ipv4'])\n    interface_2 = create_interface(Port=port_2,Layers=['eth', 'ipv4'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_2, Version='IGMPV2')\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interface_2)\n\n    # 创建全局组播组\n    multicast_group = create_multicast_group(Start='225.0.1.2',Count=1)\n\n    # 创建组播协议和组播组绑定关系对象\n    memberships = create_memberships(Session=igmp)\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP绑定流\n    src_point = get_layer_from_interfaces(Interfaces=interface_1)\n\n    stream = add_stream(Type='binding', SrcPoints=src_point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        # 获取流量统计结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'RxLossStreamFrames',\n                                                                    'RealtimeLossRate'])\n        if  Result['RxStreamFrames'] > 0  and Result['RxLossStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，没有所有端口都接收到组播流量', step=5, result=False)\n\n        # 被测设备使能igmp snooping\n        cmd_cfg = '_'.join('DeviceA_Step3'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        # 清空统计计数\n        clear_result()\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        printf(message='step3：端口1向端口2发送1个组的组播流量, 在被测交换机上启用IGMP Snooping 功能')\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=False)\n\n        igmp_send_report(Sessions=igmp)\n        time.sleep(3)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=False)\n\n        igmp_send_leave(Sessions=igmp)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if Result['TxStreamFrames'] != Result['RxStreamFrames'] and Result['RxStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\ncreate_igmp:创建IGMP协议会话对象;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_6_1/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.6.1 三层转发速率\n\n Step\t\t\t:\t测试步骤1: 按拓扑图搭建测试环境；\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为192.168.2.100/24；\n                   测试步骤3: DUT port1 地址为 192.168.1.1/24，port2 地址为 192.168.2.1/24；\n                   测试步骤4: 测试仪从端口以最大负荷，不同帧长度（64、128、256、512、1024、1518byte）发送数据，测试时间为 30 秒。\n\n Criteria    \t:   预期结果1: 记录转发速率。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['seconds']['default'])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 初始化一个空的DataFrame来存储所有数据\n        printf(message='Test start')\n        all_data = pd.DataFrame()\n        for frame_size in cfg['arg']['stream']['default']['frame_size']['default']:\n            # 修改帧长\n            for s in streams:\n                s.edit(FixedLength=frame_size)\n            # 发送流量\n            start_stream()\n            time.sleep(3)\n            df = get_streamblock_statistic()\n            wait_stream_state(TimeOut=cfg['arg']['load_profile']['default']['seconds']['default'] + 3)\n            time.sleep(3)\n            result = get_streamblock_statistic()\n            # 使用 concat 拼接 DataFrame\n            df = pd.concat([df, result])\n            # 重置索引\n            df = df.reset_index(drop=True)\n            # 添加一列帧长，全部值为当前循环的frame_length，并命名为'frame_length'\n            # 注意：这里我们假设原始DataFrame中没有名为'frame_length'的列，或者即使有，我们也想要覆盖它\n            df['FrameSize'] = frame_size\n            # 但是，由于我们想要将'frame_length'放在第二列，我们需要重新排列列\n            # 首先获取当前列名列表\n            columns = df.columns.tolist()\n            # 如果'FrameSize'已经在列表中，移除它以便我们可以重新插入到正确的位置\n            if 'FrameSize' in columns:\n                columns.remove('FrameSize')\n            # 将'frame_length'插入到第二列的位置（索引为1）\n            columns.insert(1, 'FrameSize')\n            # 重新排序DataFrame的列\n            df = df.reindex(columns=columns)\n            # 将当前循环的数据追加到所有数据的DataFrame中\n            all_data = pd.concat([all_data, df])\n            # 重置all_data的索引，虽然这不是严格必要的，但可以保持索引的连续性\n            all_data = all_data.reset_index(drop=True)\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(all_data, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(all_data)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表系统环境。\",\n  \"子任务2\": \"预约测试仪指定物理端口资源。\",\n  \"子任务3\": \"配置测试仪端口基础参数（速率、双工模式等）。\",\n  \"子任务4\": \"等待测试仪端口链路状态变为UP。\",\n  \"子任务5\": \"在测试仪端口1创建IPv4接口。\",\n  \"子任务6\": \"在测试仪端口2创建IPv4接口。\",\n  \"子任务7\": \"配置测试仪端口1接口MAC地址。\",\n  \"子任务8\": \"配置测试仪端口2接口MAC地址。\",\n  \"子任务9\": \"配置测试仪端口1接口IPv4地址为192.168.1.100/24，网关为192.168.1.1。\",\n  \"子任务10\": \"配置测试仪端口2接口IPv4地址为192.168.2.100/24，网关为192.168.2.1。\",\n  \"子任务11\": \"创建双向流量流：源为端口1 IPv4层，目的为端口2 IPv4层。\",\n  \"子任务12\": \"配置端口负载模式：基于端口、百分比单位、时间传输模式。\",\n  \"子任务13\": \"设置负载速率为100%（最大负荷）。\",\n  \"子任务14\": \"设置测试持续时间为30秒。\",\n  \"子任务15\": \"订阅端口统计和流统计视图。\",\n  \"子任务16\": \"保存当前测试配置文件。\",\n  \"子任务17\": \"修改流量帧长度为64字节。\",\n  \"子任务18\": \"开始发送流量。\",\n  \"子任务19\": \"等待33秒（包含30秒测试时间+3秒缓冲）。\",\n  \"子任务20\": \"获取流统计结果并记录转发速率。\",\n  \"子任务21\": \"修改流量帧长度为128字节。\",\n  \"子任务22\": \"开始发送流量。\",\n  \"子任务23\": \"等待33秒。\",\n  \"子任务24\": \"获取流统计结果并记录转发速率。\",\n  \"子任务25\": \"修改流量帧长度为256字节。\",\n  \"子任务26\": \"开始发送流量。\",\n  \"子任务27\": \"等待33秒。\",\n  \"子任务28\": \"获取流统计结果并记录转发速率。\",\n  \"子任务29\": \"修改流量帧长度为512字节。\",\n  \"子任务30\": \"开始发送流量。\",\n  \"子任务31\": \"等待33秒。\",\n  \"子任务32\": \"获取流统计结果并记录转发速率。\",\n  \"子任务33\": \"修改流量帧长度为1024字节。\",\n  \"子任务34\": \"开始发送流量。\",\n  \"子任务35\": \"等待33秒。\",\n  \"子任务36\": \"获取流统计结果并记录转发速率。\",\n  \"子任务37\": \"修改流量帧长度为1518字节。\",\n  \"子任务38\": \"开始发送流量。\",\n  \"子任务39\": \"等待33秒。\",\n  \"子任务40\": \"获取流统计结果并记录转发速率。\",\n  \"子任务41\": \"释放测试仪端口资源。\",\n  \"子任务42\": \"关闭测试仪表系统。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.6.1 三层转发速率\n\n Step\t\t\t:\t测试步骤1: 按拓扑图搭建测试环境；\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为192.168.2.100/24；\n                   测试步骤3: DUT port1 地址为 192.168.1.1/24，port2 地址为 192.168.2.1/24；\n                   测试步骤4: 测试仪从端口以最大负荷，不同帧长度（64、128、256、512、1024、1518byte）发送数据，测试时间为 30 秒。\n\n Criteria    \t:   预期结果1: 记录转发速率。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['seconds']['default'])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 初始化一个空的DataFrame来存储所有数据\n        printf(message='Test start')\n        all_data = pd.DataFrame()\n        for frame_size in cfg['arg']['stream']['default']['frame_size']['default']:\n            # 修改帧长\n            for s in streams:\n                s.edit(FixedLength=frame_size)\n            # 发送流量\n            start_stream()\n            time.sleep(3)\n            df = get_streamblock_statistic()\n            wait_stream_state(TimeOut=cfg['arg']['load_profile']['default']['seconds']['default'] + 3)\n            time.sleep(3)\n            result = get_streamblock_statistic()\n            # 使用 concat 拼接 DataFrame\n            df = pd.concat([df, result])\n            # 重置索引\n            df = df.reset_index(drop=True)\n            # 添加一列帧长，全部值为当前循环的frame_length，并命名为'frame_length'\n            # 注意：这里我们假设原始DataFrame中没有名为'frame_length'的列，或者即使有，我们也想要覆盖它\n            df['FrameSize'] = frame_size\n            # 但是，由于我们想要将'frame_length'放在第二列，我们需要重新排列列\n            # 首先获取当前列名列表\n            columns = df.columns.tolist()\n            # 如果'FrameSize'已经在列表中，移除它以便我们可以重新插入到正确的位置\n            if 'FrameSize' in columns:\n                columns.remove('FrameSize')\n            # 将'frame_length'插入到第二列的位置（索引为1）\n            columns.insert(1, 'FrameSize')\n            # 重新排序DataFrame的列\n            df = df.reindex(columns=columns)\n            # 将当前循环的数据追加到所有数据的DataFrame中\n            all_data = pd.concat([all_data, df])\n            # 重置all_data的索引，虽然这不是严格必要的，但可以保持索引的连续性\n            all_data = all_data.reset_index(drop=True)\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(all_data, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(all_data)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_3/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  6.7.3动态主机配置协议（DHCP）\n\n Step\t\t\t:\t测试步骤1: ：按图10搭建测试环境\n                   测试步骤2: DUT port1 地址为192.168.1.1/24，DUT 上开启 DHCP 服务，设置为DHCP服务器，配置地址池192.168.1.2~192.168.1.254；\n                   测试步骤3: tester port1 作为 DHCP 客户端，发送DHCP请求\n                   测试步骤4: 观察客户端能否接收到正确的地址配置\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    # 创建DHCPv4协议会话\n    client = create_dhcp_client(Port=port_up)\n\n    # DHCPv4协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_up)\n\n    # # 获取DHCP Server地址池\n    # configDict = get_configs(Configs='Dhcpv4AddressPool')\n    # dhcpv4AddressPool = list(configDict.values())[0]\n    # edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='192.168.1.2', PrefixLength=19, PoolAddressCount=253)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n        start_protocol()\n        # dhcp_bind(Sessions=client)\n        # 等待DHCP协议协议会话状态正确\n        result = wait_dhcp_client_state(Sessions=client)\n\n        if result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is Bound', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is not Bound', step=4, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "create_dhcp_client:创建DHCPv4客户端协议会话对象",
      "wait_dhcp_client_state:等待DHCP协议会话达到指定状态"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试环境的连接。\",\n  \"子任务2\": \"预约测试仪表端口资源，确保端口可用性。\",\n  \"子任务3\": \"修改测试仪表端口参数，根据测试需求配置端口属性。\",\n  \"子任务4\": \"等待测试仪表端口链路状态达到Up状态，确保物理连接正常。\",\n  \"子任务5\": \"在测试仪端口上创建IPv4协议接口。\",\n  \"子任务6\": \"创建DHCPv4客户端协议会话对象，模拟客户端行为。\",\n  \"子任务7\": \"将DHCPv4客户端协议会话绑定到IPv4接口，建立协议关联。\",\n  \"子任务8\": \"启动所有协议，触发DHCP请求发送过程。\",\n  \"子任务9\": \"等待DHCPv4客户端协议会话状态达到Bound状态，验证地址分配结果。\",\n  \"子任务10\": \"释放测试仪表端口资源，清理测试环境。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 :  6.7.3动态主机配置协议（DHCP）\n\n Step\t\t\t:\t测试步骤1: ：按图10搭建测试环境\n                   测试步骤2: DUT port1 地址为192.168.1.1/24，DUT 上开启 DHCP 服务，设置为DHCP服务器，配置地址池192.168.1.2~192.168.1.254；\n                   测试步骤3: tester port1 作为 DHCP 客户端，发送DHCP请求\n                   测试步骤4: 观察客户端能否接收到正确的地址配置\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    # 创建DHCPv4协议会话\n    client = create_dhcp_client(Port=port_up)\n\n    # DHCPv4协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_up)\n\n    # # 获取DHCP Server地址池\n    # configDict = get_configs(Configs='Dhcpv4AddressPool')\n    # dhcpv4AddressPool = list(configDict.values())[0]\n    # edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='192.168.1.2', PrefixLength=19, PoolAddressCount=253)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n        start_protocol()\n        # dhcp_bind(Sessions=client)\n        # 等待DHCP协议协议会话状态正确\n        result = wait_dhcp_client_state(Sessions=client)\n\n        if result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is Bound', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is not Bound', step=4, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\ncreate_dhcp_client:创建DHCPv4客户端协议会话对象;\nwait_dhcp_client_state:等待DHCP协议会话达到指定状态\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_1/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.1IP 广播功能\n\n Step\t\t\t:\t测试步骤1: ：1.按图10搭建测试环境；\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为 192.168.2.100/24；\n                   测试步骤3: DUT port1 地址为 192.168.1.1/24，port2 地址为 192.168.2.1/24；port1和port2 均开启直接广播支持；\n                   测试步骤4: tester port1 发送目的地址为255.255.255.255的数据包；\n                   测试步骤5: tester port1 发送目的地址为192.168.2.255的数据包；\n                   测试步骤6: DUT port2 配置192.168.3.0 路由；\n                   测试步骤7: tester port1 发送目的地址为192.168.3.255的数据包；\n                   测试步骤8: 记录步骤4、5、7中tester port2是否收到广播包。\n\n Criteria    \t:   预期结果1: 1.有限广播不能转发。2.三层交换机必须将网络前缀直接广播作为有效\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        TransmitMode=\"CONTINUOUS\",\n    #                        Frames=100,\n    #                        Unit='FRAME_PER_SEC')\n    # edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['255.255.255.255', '192.168.2.255', '192.168.3.255']\n\n    # 创建广播流量\n    # edit_port_load_profile(Ports=port1,LoadProfileType='PORT_BASE',Rate=30,Unit='FRAME_PER_SEC',TransmitMode=\"STEP\",Frames=20)\n    # tester port1 发送目的地址为255.255.255.255的数据包\n    stream = add_stream(Ports=port1, Names=f'step4')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168\n    # .2.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step5')\n\n    edit_stream(Stream=stream, FixedLength=64, )\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168.3.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[2],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_port_load_profile(Ports=port1, LoadProfileType='STREAM_BASE', TransmitMode='TIME', Seconds=30)\n\n    # 订阅统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        streams = get_streams(Ports=port1)\n        start_stream(Type='stream', Objects=streams[0])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[0],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 未收到广播包',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 收到广播包',\n                step=3, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[1])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[1],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=4, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[2])\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[2],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=5, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l3_learning:启动测试仪表流量三层ARP ND学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"搭建测试环境：连接测试仪Port1至DUT Port1，测试仪Port2至DUT Port2\",\n  \"子任务2\": \"配置测试仪Port1的IPv4地址为192.168.1.100/24\",\n  \"子任务3\": \"配置测试仪Port2的IPv4地址为192.168.2.100/24\",\n  \"子任务4\": \"配置DUT Port1的IPv4地址为192.168.1.1/24并开启直接广播支持\",\n  \"子任务5\": \"配置DUT Port2的IPv4地址为192.168.2.1/24并开启直接广播支持\",\n  \"子任务6\": \"在测试仪Port1创建目的IP为255.255.255.255的IPv4广播流\",\n  \"子任务7\": \"发送步骤6的广播流并验证测试仪Port2未收到数据包\",\n  \"子任务8\": \"在测试仪Port1创建目的IP为192.168.2.255的IPv4广播流\",\n  \"子任务9\": \"发送步骤8的广播流并验证测试仪Port2收到数据包\",\n  \"子任务10\": \"在DUT Port2配置192.168.3.0/24静态路由（下一跳指向192.168.2.100）\",\n  \"子任务11\": \"在测试仪Port1创建目的IP为192.168.3.255的IPv4广播流\",\n  \"子任务12\": \"发送步骤11的广播流并验证测试仪Port2收到数据包\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.7.1IP 广播功能\n\n Step\t\t\t:\t测试步骤1: ：1.按图10搭建测试环境；\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为 192.168.2.100/24；\n                   测试步骤3: DUT port1 地址为 192.168.1.1/24，port2 地址为 192.168.2.1/24；port1和port2 均开启直接广播支持；\n                   测试步骤4: tester port1 发送目的地址为255.255.255.255的数据包；\n                   测试步骤5: tester port1 发送目的地址为192.168.2.255的数据包；\n                   测试步骤6: DUT port2 配置192.168.3.0 路由；\n                   测试步骤7: tester port1 发送目的地址为192.168.3.255的数据包；\n                   测试步骤8: 记录步骤4、5、7中tester port2是否收到广播包。\n\n Criteria    \t:   预期结果1: 1.有限广播不能转发。2.三层交换机必须将网络前缀直接广播作为有效\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        TransmitMode=\"CONTINUOUS\",\n    #                        Frames=100,\n    #                        Unit='FRAME_PER_SEC')\n    # edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['255.255.255.255', '192.168.2.255', '192.168.3.255']\n\n    # 创建广播流量\n    # edit_port_load_profile(Ports=port1,LoadProfileType='PORT_BASE',Rate=30,Unit='FRAME_PER_SEC',TransmitMode=\"STEP\",Frames=20)\n    # tester port1 发送目的地址为255.255.255.255的数据包\n    stream = add_stream(Ports=port1, Names=f'step4')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168\n    # .2.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step5')\n\n    edit_stream(Stream=stream, FixedLength=64, )\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168.3.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[2],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_port_load_profile(Ports=port1, LoadProfileType='STREAM_BASE', TransmitMode='TIME', Seconds=30)\n\n    # 订阅统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        streams = get_streams(Ports=port1)\n        start_stream(Type='stream', Objects=streams[0])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[0],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 未收到广播包',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 收到广播包',\n                step=3, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[1])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[1],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=4, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[2])\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[2],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=5, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l3_learning:启动测试仪表流量三层ARP ND学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_8/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.8 网络风暴抑制: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示；\n                   测试步骤2: 测试帧长设为64，端口负载为满负载，测试时间30s；\n                   测试步骤3: 交换机分别开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能；\n                   测试步骤4: 设置抑制值为1M+粒度；\n                   测试步骤5: 端口1 向端口2 发送3 条数据流，分别为Stream1（广播帧）、Stream2（广播帧）、Stream3（IPv4 帧），端口2 向端口1 发送2 条数据流，分别为Stream1（组播帧）、Stream2（未知单播帧）；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断网络风暴抑制功能是否设置成功；\n                   测试步骤7: 根据帧丢失率，计算网络风暴抑制比偏差。\n\n Criteria    \t:   预期结果1: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启；\n                   预期结果2: 网络风暴实际抑制值不应超过抑制设定值的110%。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并预约端口资源\",\n  \"子任务2\": \"导入交换机配置文件以开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，设置抑制值为1Mbps\",\n  \"子任务3\": \"配置测试仪端口参数：固定帧长64字节，端口负载100%，测试时长30秒\",\n  \"子任务4\": \"在端口1创建三条数据流：两条广播帧流（Stream1、Stream2）和一条IPv4帧流（Stream3）\",\n  \"子任务5\": \"在端口2创建两条数据流：一条组播帧流（Stream1）和一条未知单播帧流（Stream2）\",\n  \"子任务6\": \"订阅流模板块统计视图用于结果采集\",\n  \"子任务7\": \"启动端口1流量发送，等待流量稳定后获取流统计结果\",\n  \"子任务8\": \"验证端口1流结果：广播帧流丢包率>99%（抑制成功），IPv4帧流无丢包（正常转发）\",\n  \"子任务9\": \"清除统计结果后启动端口2流量发送，等待流量稳定后获取流统计结果\",\n  \"子任务10\": \"验证端口2流结果：组播帧和未知单播帧丢包率>99%（抑制成功）\",\n  \"子任务11\": \"计算实际抑制带宽：根据接收帧数×帧长/时间，验证不超过设定值1.1Mbps（110%）\",\n  \"子任务12\": \"释放端口资源并关闭测试仪表\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.8 网络风暴抑制: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示；\n                   测试步骤2: 测试帧长设为64，端口负载为满负载，测试时间30s；\n                   测试步骤3: 交换机分别开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能；\n                   测试步骤4: 设置抑制值为1M+粒度；\n                   测试步骤5: 端口1 向端口2 发送3 条数据流，分别为Stream1（广播帧）、Stream2（广播帧）、Stream3（IPv4 帧），端口2 向端口1 发送2 条数据流，分别为Stream1（组播帧）、Stream2（未知单播帧）；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断网络风暴抑制功能是否设置成功；\n                   测试步骤7: 根据帧丢失率，计算网络风暴抑制比偏差。\n\n Criteria    \t:   预期结果1: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启；\n                   预期结果2: 网络风暴实际抑制值不应超过抑制设定值的110%。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_3/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.3 队头阻塞测试\n\n Step\t\t\t:\t测试步骤1: 按图7，从交换机任意选取4 个端口与测试仪相连接，分别定为端口A、端口B、端口C 和端口D；\n                   测试步骤2: 网络测试仪、交换机均关闭流控，12 发送100%流量，32 发送50%流量，34 发送50%流量；\n                    1) 口建立untag流量 连接交换机端口 access vlan 100,\n                    2) 口连接交换机trunk vlan 100,200\n                    3) 口建立vlan 200,vlan4094流量 连接交换机trunk vlan 200,4094\n                    4) 口连接交换机access vlan 4094\n                   测试步骤3: 记录端口D 是否有丢包。\n\n Criteria    \t:   预期结果1: 记录端口D 是否有丢包。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=100, Seconds=30)\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 绑定流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4', 'tcp'])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 绑定流量\n    edit_port_load_profile(Ports=port3, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    #edit_port_load_profile(Ports=port3, Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan200_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 50)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan4094_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=4094)\n    edit_stream_load_profile(Streams=stream, Rate=50)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        stream1=get_streams(Ports=port1)\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n        stream_object = get_streams(Ports=port3)\n        for stream in stream_object:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=3, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=3, result=True)\n\n        stream = stream_object[1]\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames}),端口D丢包',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),端口D未丢包',\n                step=4, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立测试环境连接\",\n  \"子任务2\": \"预约测试仪表的四个端口（端口A、B、C、D）\",\n  \"子任务3\": \"配置测试仪表端口参数：关闭所有端口流控功能\",\n  \"子任务4\": \"设置端口1负载配置：发送模式为时间模式，速率100%，持续时间30秒\",\n  \"子任务5\": \"在端口1创建流量：untagged VLAN100流量，固定帧长128字节，包含Ethernet/VLAN/IPv4/TCP头部\",\n  \"子任务6\": \"设置端口3负载配置：基于流的负载类型，发送模式为时间模式，持续时间30秒\",\n  \"子任务7\": \"在端口3创建第一条流量：VLAN200流量，速率50%，固定帧长128字节，包含Ethernet/VLAN/IPv4/TCP头部\",\n  \"子任务8\": \"在端口3创建第二条流量：VLAN4094流量，速率50%，固定帧长128字节，包含Ethernet/VLAN/IPv4/TCP头部\",\n  \"子任务9\": \"订阅流模板块统计视图，准备收集流量统计数据\",\n  \"子任务10\": \"保存当前测试配置到文件\",\n  \"子任务11\": \"启动二层地址学习功能\",\n  \"子任务12\": \"在所有端口开始发送数据流\",\n  \"子任务13\": \"等待所有数据流发送完成\",\n  \"子任务14\": \"获取端口1流量统计结果，验证发送帧数不为零\",\n  \"子任务15\": \"获取端口3两条流量的统计结果，分别验证发送帧数不为零\",\n  \"子任务16\": \"获取端口3第二条流量（VLAN4094）的接收统计，比较发送帧数与接收帧数是否相等\",\n  \"子任务17\": \"根据接收帧数统计判断端口D是否丢包：若接收帧数小于发送帧数则判定丢包\",\n  \"子任务18\": \"清除测试仪表统计结果\",\n  \"子任务19\": \"释放所有测试仪表端口资源\",\n  \"子任务20\": \"关闭测试仪表连接\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.3 队头阻塞测试\n\n Step\t\t\t:\t测试步骤1: 按图7，从交换机任意选取4 个端口与测试仪相连接，分别定为端口A、端口B、端口C 和端口D；\n                   测试步骤2: 网络测试仪、交换机均关闭流控，12 发送100%流量，32 发送50%流量，34 发送50%流量；\n                    1) 口建立untag流量 连接交换机端口 access vlan 100,\n                    2) 口连接交换机trunk vlan 100,200\n                    3) 口建立vlan 200,vlan4094流量 连接交换机trunk vlan 200,4094\n                    4) 口连接交换机access vlan 4094\n                   测试步骤3: 记录端口D 是否有丢包。\n\n Criteria    \t:   预期结果1: 记录端口D 是否有丢包。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=100, Seconds=30)\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 绑定流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4', 'tcp'])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 绑定流量\n    edit_port_load_profile(Ports=port3, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    #edit_port_load_profile(Ports=port3, Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan200_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 50)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan4094_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=4094)\n    edit_stream_load_profile(Streams=stream, Rate=50)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        stream1=get_streams(Ports=port1)\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n        stream_object = get_streams(Ports=port3)\n        for stream in stream_object:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=3, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=3, result=True)\n\n        stream = stream_object[1]\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames}),端口D丢包',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),端口D未丢包',\n                step=4, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_8_1/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.8.1错误帧过滤功能\n\n Step\t\t\t:\t测试步骤1: ：按图4，任选交换机两个端口作为测试端口；\n                   测试步骤2: 端口1向端口2发送CRC校验错误帧，观察接收情况；\n                   测试步骤3: 端口1向端口2发送源MAC地址错误帧，观察接收情况\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100,\n                           GenerateError='CRC')\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=False)\n\n        clear_result()\n        edit_port_load_profile(Ports=port1,\n                               LoadProfileType='PORT_BASE',\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=100,\n                               GenerateError='NO_ERROR')\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames == RxStreamFrames and  RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表\",\n  \"子任务2\": \"预约测试仪的两个端口（对应交换机两个测试端口）\",\n  \"子任务3\": \"修改测试仪表端口参数\",\n  \"子任务4\": \"等待测试仪表端口链路达到指定状态\",\n  \"子任务5\": \"在两个端口上创建网络接口\",\n  \"子任务6\": \"配置端口1接口的MAC地址和IPv4地址\",\n  \"子任务7\": \"配置端口2接口的MAC地址和IPv4地址\",\n  \"子任务8\": \"设置端口1负载配置为生成CRC错误帧\",\n  \"子任务9\": \"在端口1创建第一个流量流(stream1)，固定帧长度64字节\",\n  \"子任务10\": \"为stream1创建以太网和IPv4报文头部，配置正常源MAC和目的MAC\",\n  \"子任务11\": \"在端口1创建第二个流量流(stream2)，固定帧长度64字节\",\n  \"子任务12\": \"为stream2创建以太网和IPv4报文头部，配置源MAC地址为00:00:00:00:00:00\",\n  \"子任务13\": \"订阅测试仪表统计视图（端口统计和流模板块统计）\",\n  \"子任务14\": \"启动二层MAC地址学习\",\n  \"子任务15\": \"开始发送stream1流量（CRC错误帧）\",\n  \"子任务16\": \"停止发送stream1流量\",\n  \"子任务17\": \"获取stream1统计结果（发送帧数和接收帧数），验证接收帧数是否为0\",\n  \"子任务18\": \"清除测试仪表统计结果\",\n  \"子任务19\": \"修改端口1负载配置为不生成错误帧\",\n  \"子任务20\": \"启动二层MAC地址学习\",\n  \"子任务21\": \"开始发送stream2流量（源MAC错误帧）\",\n  \"子任务22\": \"停止发送stream2流量\",\n  \"子任务23\": \"获取stream2统计结果（发送帧数和接收帧数），验证接收帧数是否等于发送帧数\",\n  \"子任务24\": \"释放测试仪表端口资源\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.8.1错误帧过滤功能\n\n Step\t\t\t:\t测试步骤1: ：按图4，任选交换机两个端口作为测试端口；\n                   测试步骤2: 端口1向端口2发送CRC校验错误帧，观察接收情况；\n                   测试步骤3: 端口1向端口2发送源MAC地址错误帧，观察接收情况\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100,\n                           GenerateError='CRC')\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=False)\n\n        clear_result()\n        edit_port_load_profile(Ports=port1,\n                               LoadProfileType='PORT_BASE',\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=100,\n                               GenerateError='NO_ERROR')\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames == RxStreamFrames and  RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_9/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.9 支持网关数\n\n Step\t\t\t:\t测试步骤1: 记录三层交换机配置网络层地址的方式（路由口配置方式或者VLANInterface 方式）。\n                   测试步骤2: 记录三层交换机可配置的网关数目\n                   测试步骤3: 按图10建立测试环境\n                   测试步骤4: tester port1 地 址 为 192.168.9.100/24 ， port2 地 址 为192.168.11.100/24；DUT port1\n                   和 port2 分别配置 192.168.9.0 网段和192.168.11.0 网段网关，抽样验证网关是否配置成功。\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.9.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n        ipv4_ping(Interface=interfaces_down, IpAddr='192.168.11.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表环境。\",\n  \"子任务2\": \"预约测试仪端口，指定端口位置以建立测试连接。\",\n  \"子任务3\": \"在预约的测试仪端口上创建IPv4接口。\",\n  \"子任务4\": \"编辑接口的以太网层参数，设置MAC地址（根据测试需求指定具体值）。\",\n  \"子任务5\": \"编辑接口的IPv4层参数，设置IP地址和网关地址（具体值：port1 IP为192.168.9.100/24，网关为192.168.9.1；port2 IP为192.168.11.100/24，网关为192.168.11.1）。\",\n  \"子任务6\": \"保存当前测试配置到文件。\",\n  \"子任务7\": \"执行ping测试从测试仪接口到DUT网关IP（192.168.9.1和192.168.11.1），验证网关连通性是否成功。\",\n  \"子任务8\": \"释放测试仪端口资源。\",\n  \"子任务9\": \"关闭测试仪表进行清理。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.7.9 支持网关数\n\n Step\t\t\t:\t测试步骤1: 记录三层交换机配置网络层地址的方式（路由口配置方式或者VLANInterface 方式）。\n                   测试步骤2: 记录三层交换机可配置的网关数目\n                   测试步骤3: 按图10建立测试环境\n                   测试步骤4: tester port1 地 址 为 192.168.9.100/24 ， port2 地 址 为192.168.11.100/24；DUT port1\n                   和 port2 分别配置 192.168.9.0 网段和192.168.11.0 网段网关，抽样验证网关是否配置成功。\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.9.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n        ipv4_ping(Interface=interfaces_down, IpAddr='192.168.11.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_4/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.4 端口镜像:支持单端口镜像和多端口镜像，镜像端口在不丢失数据的前提下应保证系统要求的转发速率。\n\n Step\t\t\t:\t测试步骤1: 测试帧长度为 64 字节，测试时间不小于 30s；\n                   测试步骤2: 测试配置图如图 7 所示，交换机端口 4 设置成镜像端口，端口 1 和端口 3设置成被镜像端口，镜像方式为输入和输出同时镜像；\n                   测试步骤3: 端口 1 向端口 2 双向发送数据，端口 2 和端口 3 双向发送数据，负载率分别为 25%；\n\n Criteria    \t:   预期结果1: 记录端口 4 接收到的数据帧数量，判断镜像功能是否设置成功。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_25%')\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=25, Seconds=30)\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 流量\n    edit_port_load_profile(Ports=port2, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan200_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 25)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan100_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_stream_load_profile(Streams=stream, Rate= 25)\n\n    # 端口3创建绑定1-》2 绑定流量\n    edit_port_load_profile(Ports=port3, TransmitMode='TIME', Rate=25, Seconds=30)\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        #清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        result = get_port_statistic(StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port1_Result = get_port_statistic(Port=port1, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port3_Result = get_port_statistic(Port=port3, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port4_Result = get_port_statistic(Port=port4, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        MirrotFrames = Port1_Result['TxStreamFrames']+Port1_Result['RxSignatureStreamFrames']+Port3_Result['TxStreamFrames']+Port3_Result['RxSignatureStreamFrames']\n        RX_Result=Port4_Result['RxSignatureStreamFrames']\n        if MirrotFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is not equal to 0',\n                step=3, result=True)\n\n        if  MirrotFrames == RX_Result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is not equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_port_statistic:获取测试仪表端口统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"配置交换机：设置端口4为镜像端口，端口1和端口3为被镜像端口，镜像方式为输入和输出同时镜像。\",\n  \"子任务2\": \"初始化测试仪表并预约端口：端口1、端口2、端口3、端口4。\",\n  \"子任务3\": \"设置测试帧长度为64字节，测试时间为30秒。\",\n  \"子任务4\": \"配置端口负载：所有端口负载率设置为25%，使用TIME模式持续30秒。\",\n  \"子任务5\": \"创建流量模板：在端口1创建流向端口2的流量，在端口2创建流向端口1和端口3的流量，在端口3创建流向端口2的流量。\",\n  \"子任务6\": \"编辑流量头部：设置所有流量的Ethernet头部源MAC和目的MAC地址。\",\n  \"子任务7\": \"订阅统计视图：订阅PortStats统计类型。\",\n  \"子任务8\": \"启动二层学习：确保MAC地址学习完成。\",\n  \"子任务9\": \"清除统计结果：清空所有端口的统计计数。\",\n  \"子任务10\": \"启动流量发送：开始所有端口的数据传输。\",\n  \"子任务11\": \"等待流量发送完成：确保测试时间达到30秒。\",\n  \"子任务12\": \"获取端口统计：采集端口1的TxStreamFrames和RxSignatureStreamFrames，端口3的TxStreamFrames和RxSignatureStreamFrames，端口4的RxSignatureStreamFrames。\",\n  \"子任务13\": \"计算镜像帧总量：求和端口1和端口3的发送与接收帧数（TxStreamFrames + RxSignatureStreamFrames）。\",\n  \"子任务14\": \"验证镜像功能：比较端口4接收帧数是否等于镜像帧总量，并记录验证结果。\",\n  \"子任务15\": \"释放测试仪表端口资源。\",\n  \"子任务16\": \"关闭测试仪表进程。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.4 端口镜像:支持单端口镜像和多端口镜像，镜像端口在不丢失数据的前提下应保证系统要求的转发速率。\n\n Step\t\t\t:\t测试步骤1: 测试帧长度为 64 字节，测试时间不小于 30s；\n                   测试步骤2: 测试配置图如图 7 所示，交换机端口 4 设置成镜像端口，端口 1 和端口 3设置成被镜像端口，镜像方式为输入和输出同时镜像；\n                   测试步骤3: 端口 1 向端口 2 双向发送数据，端口 2 和端口 3 双向发送数据，负载率分别为 25%；\n\n Criteria    \t:   预期结果1: 记录端口 4 接收到的数据帧数量，判断镜像功能是否设置成功。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_25%')\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=25, Seconds=30)\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 流量\n    edit_port_load_profile(Ports=port2, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan200_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 25)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan100_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_stream_load_profile(Streams=stream, Rate= 25)\n\n    # 端口3创建绑定1-》2 绑定流量\n    edit_port_load_profile(Ports=port3, TransmitMode='TIME', Rate=25, Seconds=30)\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        #清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        result = get_port_statistic(StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port1_Result = get_port_statistic(Port=port1, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port3_Result = get_port_statistic(Port=port3, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port4_Result = get_port_statistic(Port=port4, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        MirrotFrames = Port1_Result['TxStreamFrames']+Port1_Result['RxSignatureStreamFrames']+Port3_Result['TxStreamFrames']+Port3_Result['RxSignatureStreamFrames']\n        RX_Result=Port4_Result['RxSignatureStreamFrames']\n        if MirrotFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is not equal to 0',\n                step=3, result=True)\n\n        if  MirrotFrames == RX_Result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is not equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_port_statistic:获取测试仪表端口统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_5/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.5 多链路聚合: 链路聚合时不应丢失数据\n\n Step\t\t\t:\t测试步骤1: 按图8 建立测试环境；\n                   测试步骤2: 将交换机1 的2 个端口和交换机2 的2 个端口对应连接。将交换机1 的 2个端口配置为一个静态聚合端口，交换机2 的2 个端口配置为一个静态聚合端口；\n                   测试步骤3: 由测试仪1、3 端口分别向2、4 端口发送数据流，负载率为100%；\n                   测试步骤4: 在测试仪的2、4 端口观察流量的接收情况，应无丢包；\n                   测试步骤5: 断开交换机1 和交换机2 间的1 条链路，观察流量的接收情况，应各丢 50%；\n                   测试步骤6: 停掉3 向4 的数据流，观察1 向2 的数据流的接收情况，应无丢包。\n\n Criteria    \t:   预期结果1: 记录端口4 接收到的数据帧数量，判断镜像功能是否设置成功。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    # 端口1创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream1 = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream1, FixedLength=128)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 端口3创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream2 = add_stream(Ports=port3, Names=f'{port3.Name}_100%')\n    edit_stream(Stream=stream2, FixedLength=128)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取流量结果\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step4：get  stream statistic')\n        # 获取流量1统计结果\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames'] and Result2['TxStreamFrames']==Result2['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames']*2 and Result2['TxStreamFrames']==Result2['RxStreamFrames']*2:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        # 停止3口流量\n        stop_stream(Type='stream',Objects=stream2)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result1['TxStreamFrames'] == Result1['RxStreamFrames']  and Result2['TxStreamFrames'] == Result2[\n            'RxStreamFrames'] :\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并预约端口：初始化测试仪表系统，预约四个测试端口（端口1、2、3、4）。\",\n  \"子任务2\": \"配置交换机链路聚合：通过NTO导入配置文件，将交换机1的两个端口和交换机2的两个端口配置为静态聚合端口。\",\n  \"子任务3\": \"设置端口负载参数：配置所有测试端口负载率为100%，传输模式为时间模式，持续30秒。\",\n  \"子任务4\": \"创建测试流量流：在端口1创建发往端口2的TCP数据流（128字节帧长），在端口3创建发往端口4的TCP数据流（128字节帧长）。\",\n  \"子任务5\": \"订阅统计视图：订阅流模板块统计视图用于结果采集。\",\n  \"子任务6\": \"执行基准测试：启动二层地址学习，清除统计计数后发送所有数据流，等待流量稳定。\",\n  \"子任务7\": \"验证全链路无丢包：获取端口2和端口4的流量统计，验证接收帧数等于发送帧数（预期无丢包）。\",\n  \"子任务8\": \"模拟链路断开：断开交换机间一条物理链路（通过外部操作实现）。\",\n  \"子任务9\": \"执行断链测试：清除统计计数后重新发送所有数据流，等待流量稳定。\",\n  \"子任务10\": \"验证50%丢包率：获取流量统计，验证每个流的接收帧数为发送帧数的50%（预期各丢50%）。\",\n  \"子任务11\": \"停止端口3数据流：停止从端口3发往端口4的数据流传输。\",\n  \"子任务12\": \"执行单流测试：清除统计计数后仅发送端口1到端口2的数据流，等待流量稳定。\",\n  \"子任务13\": \"验证单流无丢包：获取端口1到端口2的流量统计，验证接收帧数等于发送帧数（预期无丢包）。\",\n  \"子任务14\": \"释放资源：释放所有测试端口并关闭测试仪表进程。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.5 多链路聚合: 链路聚合时不应丢失数据\n\n Step\t\t\t:\t测试步骤1: 按图8 建立测试环境；\n                   测试步骤2: 将交换机1 的2 个端口和交换机2 的2 个端口对应连接。将交换机1 的 2个端口配置为一个静态聚合端口，交换机2 的2 个端口配置为一个静态聚合端口；\n                   测试步骤3: 由测试仪1、3 端口分别向2、4 端口发送数据流，负载率为100%；\n                   测试步骤4: 在测试仪的2、4 端口观察流量的接收情况，应无丢包；\n                   测试步骤5: 断开交换机1 和交换机2 间的1 条链路，观察流量的接收情况，应各丢 50%；\n                   测试步骤6: 停掉3 向4 的数据流，观察1 向2 的数据流的接收情况，应无丢包。\n\n Criteria    \t:   预期结果1: 记录端口4 接收到的数据帧数量，判断镜像功能是否设置成功。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    # 端口1创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream1 = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream1, FixedLength=128)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 端口3创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream2 = add_stream(Ports=port3, Names=f'{port3.Name}_100%')\n    edit_stream(Stream=stream2, FixedLength=128)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取流量结果\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step4：get  stream statistic')\n        # 获取流量1统计结果\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames'] and Result2['TxStreamFrames']==Result2['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames']*2 and Result2['TxStreamFrames']==Result2['RxStreamFrames']*2:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        # 停止3口流量\n        stop_stream(Type='stream',Objects=stream2)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result1['TxStreamFrames'] == Result1['RxStreamFrames']  and Result2['TxStreamFrames'] == Result2[\n            'RxStreamFrames'] :\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_7/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.7 网络风暴抑制: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示；\n                   测试步骤2: 测试帧长设为64，端口负载为满负载，测试时间30s；\n                   测试步骤3: 交换机分别开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能；\n                   测试步骤4: 使用默认抑制值或者设置抑制值为1M；\n                   测试步骤5: 端口1 向端口2 发送3 条数据流，分别为Stream1（广播帧）、Stream2（广播帧）、Stream3（IPv4 帧），端口2 向端口1 发送2 条数据流，分别为Stream1（组播帧）、Stream2（未知单播帧）；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断网络风暴抑制功能是否设置成功；\n                   测试步骤7: 根据帧丢失率，计算网络风暴抑制比偏差。\n\n Criteria    \t:   预期结果1: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启；\n                   预期结果2: 网络风暴实际抑制值不应超过抑制设定值的110%。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        expected_value = 0.1 * 1.1\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 3 * 2\n\n            if round(prss, 2) < expected_value:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 2\n            if round(prss, 2) < expected_value:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并预约指定端口\",\n  \"子任务2\": \"编辑端口负载配置文件：设置传输模式为时间模式，速率100%，持续时间30秒\",\n  \"子任务3\": \"在端口1创建3条数据流：两条广播帧流（Stream1和Stream2）和一条IPv4单播帧流（Stream3），固定帧长64字节\",\n  \"子任务4\": \"在端口2创建两条数据流：组播帧流（Stream1）和未知单播帧流（Stream2），固定帧长64字节\",\n  \"子任务5\": \"配置以太网报文头部：设置广播流目的MAC为ff:ff:ff:ff:ff:ff，组播流目的MAC为01:00:5E前缀，未知单播流使用非标准MAC\",\n  \"子任务6\": \"订阅流模板块统计视图用于结果采集\",\n  \"子任务7\": \"启动端口1的流量发送并等待传输完成\",\n  \"子任务8\": \"获取端口1各数据流的统计结果：记录发送帧数、接收帧数和帧丢失率\",\n  \"子任务9\": \"验证广播流抑制效果：计算实际抑制比（接收帧数/发送帧数），判断是否小于1.1倍设定值\",\n  \"子任务10\": \"验证IPv4单播流转发：确认接收帧数等于发送帧数\",\n  \"子任务11\": \"清除当前统计结果\",\n  \"子任务12\": \"启动端口2的流量发送并等待传输完成\",\n  \"子任务13\": \"获取端口2各数据流的统计结果：记录发送帧数、接收帧数和帧丢失率\",\n  \"子任务14\": \"验证组播流和未知单播流抑制效果：计算实际抑制比（接收帧数/发送帧数），判断是否小于1.1倍设定值\",\n  \"子任务15\": \"释放测试端口并关闭仪表连接\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.7 网络风暴抑制: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示；\n                   测试步骤2: 测试帧长设为64，端口负载为满负载，测试时间30s；\n                   测试步骤3: 交换机分别开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能；\n                   测试步骤4: 使用默认抑制值或者设置抑制值为1M；\n                   测试步骤5: 端口1 向端口2 发送3 条数据流，分别为Stream1（广播帧）、Stream2（广播帧）、Stream3（IPv4 帧），端口2 向端口1 发送2 条数据流，分别为Stream1（组播帧）、Stream2（未知单播帧）；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断网络风暴抑制功能是否设置成功；\n                   测试步骤7: 根据帧丢失率，计算网络风暴抑制比偏差。\n\n Criteria    \t:   预期结果1: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启；\n                   预期结果2: 网络风暴实际抑制值不应超过抑制设定值的110%。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        expected_value = 0.1 * 1.1\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 3 * 2\n\n            if round(prss, 2) < expected_value:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 2\n            if round(prss, 2) < expected_value:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_1/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.1 虚拟局域网 VLAN 功能\n\n Step\t\t\t:\t测试步骤1: 测试帧长度为 128 字节，测试时间为 30；\n                   测试步骤2: 任意选取 3 个端口与测试仪相连接，测试配置图如图 6 所示；\n                   测试步骤3: 在测试仪端口 3 上构造 7 个数据流；\n                   测试步骤4: 交换机端口均设置为 untagged，端口 A 设置为 VLAN100，端口 B 设置为 VLAN4094，端口 C 设置为 TRUNK 口、VLAN1，其他端口默认设；\n                   测试步骤5: 网络测试仪端口 3 向端口 1、端口 2 分别以 10%负载发送数；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断 VLAN 是否划分成功；\n                   测试步骤7: 在测试仪端口 1、端口 2 上构造以上 7 个数据；\n                   测试步骤8: 端口 1、端口 2 分别向端口 3 以 10%负载发送数据；\n                   测试步骤9: 记录不同数据流的帧丢失率，判断 VLAN TRUNK 是否成功。\n\n Criteria    \t:   预期结果1: 测试仪发送到交换机的数据流，若 VLAN ID 不同，则交换机丢弃该数据流（入口不透传）或转发至相应 VLAN 端口（入口透传）；若相同则转发至相同 VLAN 的端口。广播风暴仅可在 VLAN 内广播。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n\n    # 端口1创建流量\n    mac_address_list = ['00:02:00:00:00:01', '00:02:00:00:00:02', '00:02:00:00:00:03']\n    vlan_id_list = [100, 4094, 1]\n\n    # interfaces_1 = create_interface(Port=ports[0], Layers=['eth', 'vlan'])\n    # interfaces_2 = create_interface(Port=ports[1], Layers=['eth', 'vlan'])\n    # interfaces_3 = create_interface(Port=ports[2], Layers=['eth', 'vlan'])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[2])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[2])\n\n    streams = {}\n    # 端口创建7条流量\n    number = -1\n    for port in ports:\n        number += 1\n        test_mac_address = mac_address_list.copy()\n        source_mac = test_mac_address.pop(number)\n        # 数据流 1：无 VID 标识 IPv4 报文\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 2：VID 为 100 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 3：VID 为 4094 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 4：无 VID 标识的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n        # 数据流 5：VID 为 100 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 6：VID 为 4094 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 7：广播报文，无 VID 标识；\n        stream_port1_VID_100 = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Broadcast')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream_port1_VID_100, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream_port1_VID_100, SourceMacAdd=source_mac,\n                                      DestMacAdd='ff:ff:ff:ff:ff:ff')\n        streams.update({stream[0].Name: stream})\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 步骤5：端口3发流量测试\n        printf(message='step5：port3 start stream')\n        start_stream(Type='port', Objects=ports[2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step6：get port3 stream statistic')\n        # 获取端口3下所有流量统计结果\n        streams_obj = get_streams(ports[2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=6, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=6, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0', step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0', step=6,\n                        result=False)\n            if 'VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_1':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n            if 'VID_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n        clear_result()\n        # 步骤8：端口1，2发流量测试\n        printf(message='step8：port1,port2 start stream')\n        start_stream(Type='port', Objects=ports[:2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，3口收到报文\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=9, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=9, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}))',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=9, result=False)\n            if 'Port_1_VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_3':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            if 'Port_2_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            else:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0,RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0',\n                        step=9, result=True)\n\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并预约三个测试端口\",\n  \"子任务2\": \"配置测试仪端口参数：帧长度128字节，测试时间30秒，负载率10%\",\n  \"子任务3\": \"配置交换机端口：端口A设置为untagged VLAN100，端口B设置为untagged VLAN4094，端口C设置为TRUNK口VLAN1\",\n  \"子任务4\": \"在测试仪端口3上构造7个数据流：无VID的IPv4报文、VID100的IPv4报文、VID4094的IPv4报文、无VID的组播报文、VID100的组播报文、VID4094的组播报文、无VID的广播报文\",\n  \"子任务5\": \"订阅流模板块统计视图\",\n  \"子任务6\": \"启动端口3的流量发送\",\n  \"子任务7\": \"获取端口1和端口2的流量统计结果，记录不同数据流的帧丢失率\",\n  \"子任务8\": \"验证端口3发送的流量：VLAN ID不同的数据流应被丢弃或透传，相同VLAN应转发，广播仅限VLAN内\",\n  \"子任务9\": \"清除测试仪统计结果\",\n  \"子任务10\": \"在测试仪端口1和端口2上分别构造7个数据流（同子任务4类型）\",\n  \"子任务11\": \"启动端口1和端口2的流量发送\",\n  \"子任务12\": \"获取端口3的流量统计结果，记录不同数据流的帧丢失率\",\n  \"子任务13\": \"验证TRUNK口功能：端口3应正确处理来自不同VLAN的数据流\",\n  \"子任务14\": \"释放测试端口并关闭测试仪表\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.1 虚拟局域网 VLAN 功能\n\n Step\t\t\t:\t测试步骤1: 测试帧长度为 128 字节，测试时间为 30；\n                   测试步骤2: 任意选取 3 个端口与测试仪相连接，测试配置图如图 6 所示；\n                   测试步骤3: 在测试仪端口 3 上构造 7 个数据流；\n                   测试步骤4: 交换机端口均设置为 untagged，端口 A 设置为 VLAN100，端口 B 设置为 VLAN4094，端口 C 设置为 TRUNK 口、VLAN1，其他端口默认设；\n                   测试步骤5: 网络测试仪端口 3 向端口 1、端口 2 分别以 10%负载发送数；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断 VLAN 是否划分成功；\n                   测试步骤7: 在测试仪端口 1、端口 2 上构造以上 7 个数据；\n                   测试步骤8: 端口 1、端口 2 分别向端口 3 以 10%负载发送数据；\n                   测试步骤9: 记录不同数据流的帧丢失率，判断 VLAN TRUNK 是否成功。\n\n Criteria    \t:   预期结果1: 测试仪发送到交换机的数据流，若 VLAN ID 不同，则交换机丢弃该数据流（入口不透传）或转发至相应 VLAN 端口（入口透传）；若相同则转发至相同 VLAN 的端口。广播风暴仅可在 VLAN 内广播。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n\n    # 端口1创建流量\n    mac_address_list = ['00:02:00:00:00:01', '00:02:00:00:00:02', '00:02:00:00:00:03']\n    vlan_id_list = [100, 4094, 1]\n\n    # interfaces_1 = create_interface(Port=ports[0], Layers=['eth', 'vlan'])\n    # interfaces_2 = create_interface(Port=ports[1], Layers=['eth', 'vlan'])\n    # interfaces_3 = create_interface(Port=ports[2], Layers=['eth', 'vlan'])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[2])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[2])\n\n    streams = {}\n    # 端口创建7条流量\n    number = -1\n    for port in ports:\n        number += 1\n        test_mac_address = mac_address_list.copy()\n        source_mac = test_mac_address.pop(number)\n        # 数据流 1：无 VID 标识 IPv4 报文\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 2：VID 为 100 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 3：VID 为 4094 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 4：无 VID 标识的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n        # 数据流 5：VID 为 100 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 6：VID 为 4094 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 7：广播报文，无 VID 标识；\n        stream_port1_VID_100 = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Broadcast')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream_port1_VID_100, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream_port1_VID_100, SourceMacAdd=source_mac,\n                                      DestMacAdd='ff:ff:ff:ff:ff:ff')\n        streams.update({stream[0].Name: stream})\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 步骤5：端口3发流量测试\n        printf(message='step5：port3 start stream')\n        start_stream(Type='port', Objects=ports[2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step6：get port3 stream statistic')\n        # 获取端口3下所有流量统计结果\n        streams_obj = get_streams(ports[2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=6, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=6, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0', step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0', step=6,\n                        result=False)\n            if 'VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_1':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n            if 'VID_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n        clear_result()\n        # 步骤8：端口1，2发流量测试\n        printf(message='step8：port1,port2 start stream')\n        start_stream(Type='port', Objects=ports[:2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，3口收到报文\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=9, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=9, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}))',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=9, result=False)\n            if 'Port_1_VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_3':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            if 'Port_2_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            else:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0,RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0',\n                        step=9, result=True)\n\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_6/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  开放式最短路径优先路由协议（OSPF)\n\n Step\t\t\t:\t测试步骤1: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24；\n                   测试步骤2: DUT port1 IP地址为192.168.1.1/24，port2为 192.168.2.1/24；\n                   测试步骤3: 在DUT上配置OSPFv2路由协议；\n                   测试步骤4: 测试仪tester使用port1、port2建立OSPF路由器，在port1插入一些LSA，并使port1和DUT的port1达到FULL状态，port2和DUT的port2达到FULL状态，观察port2是否能得到port1的LSA。\n\n Criteria    \t:   预期结果1: ospf建立成功，可以收到lsa\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    #创建ospf协议\n    session_1 = create_ospf(Port=port_up, Priority=1)\n    session_2 = create_ospf(Port=port_down, Priority=2)\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    # OSPFv2协议会话1创建Summary Lsa\n    summary_lsa = create_ospf_summary_lsa(Session=session_1)\n\n    # OSPFv2协议会话2创建External Lsa\n    external_lsa = create_ospf_external_lsa(Session=session_2)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=summary_lsa)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        advertise_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n\n        # 发送流量\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        withdraw_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n        stop_protocol()\n        time.sleep(3)\n\n        # 获取OSPFv2会话1统计\n        import pandas\n        result = get_ospf_statistic()\n        print(result)\n        if not isinstance(result, pandas.DataFrame):\n            verdict = 'fail'\n\n        result = get_ospf_statistic(Session=session_1)\n        print(result)\n        TxSummaryLsa = result['TxSummaryLsa']\n        RxAsExternalLsa = result['RxAsExternalLsa']\n        print('TxSummaryLsa: {}'.format(TxSummaryLsa))\n        print('RxAsExternalLsa: {}'.format(RxAsExternalLsa))\n\n        # 获取OSPFv2会话2统计\n        result = get_ospf_statistic(Session=session_2)\n        print(result)\n        RxSummaryLsa = result['RxSummaryLsa']\n        TxAsExternalLsa = result['TxAsExternalLsa']\n        print('RxSummaryLsa: {}'.format(RxSummaryLsa))\n        print('TxAsExternalLsa: {}'.format(TxAsExternalLsa))\n\n        # 获取流量1统计\n        result = get_streamblock_statistic(Stream=streams[0])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name,TxStreamFrames,RxStreamFrames)\n\n        # 获取流量2统计\n\n        result = get_streamblock_statistic(Stream=streams[1])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name,TxStreamFrames,RxStreamFrames)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_ospf_lsa:通告 OSPFv2 协议会话 lsa",
      "create_ospf:创建OSPFv2协议会话对象",
      "create_ospf_external_lsa:创建OSPFv2 External LSA对象",
      "create_ospf_summary_lsa:创建OSPFv2 Summary LSA对象",
      "get_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象",
      "get_ospf_statistic:获取OSPFv2协议会话统计结果",
      "wait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态",
      "withdraw_ospf_lsa:撤销OSPFv2协议会话lsa",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，准备测试环境。\",\n  \"子任务2\": \"预约测试仪端口 port1 和 port2，并配置端口参数。\",\n  \"子任务3\": \"在 port1 创建网络接口，配置 MAC 地址为默认值，IPv4 地址为 192.168.1.100/24，网关为 192.168.1.1。\",\n  \"子任务4\": \"在 port2 创建网络接口，配置 MAC 地址为默认值，IPv4 地址为 192.168.2.100/24，网关为 192.168.2.1。\",\n  \"子任务5\": \"在 port1 创建 OSPFv2 协议会话对象，优先级设置为 1。\",\n  \"子任务6\": \"在 port2 创建 OSPFv2 协议会话对象，优先级设置为 2。\",\n  \"子任务7\": \"将 port1 的 OSPF 会话绑定到 port1 接口。\",\n  \"子任务8\": \"将 port2 的 OSPF 会话绑定到 port2 接口。\",\n  \"子任务9\": \"在 port1 的 OSPF 会话上创建 Summary LSA。\",\n  \"子任务10\": \"启动 OSPFv2 协议会话。\",\n  \"子任务11\": \"等待 port1 和 port2 的 OSPF 邻接状态达到 FULL。\",\n  \"子任务12\": \"通告 port1 创建的 Summary LSA。\",\n  \"子任务13\": \"获取 port2 的 OSPF 会话统计信息，验证是否收到 Summary LSA（RxSummaryLsa > 0）。\",\n  \"子任务14\": \"停止 OSPF 协议会话并释放测试资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 :  开放式最短路径优先路由协议（OSPF)\n\n Step\t\t\t:\t测试步骤1: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24；\n                   测试步骤2: DUT port1 IP地址为192.168.1.1/24，port2为 192.168.2.1/24；\n                   测试步骤3: 在DUT上配置OSPFv2路由协议；\n                   测试步骤4: 测试仪tester使用port1、port2建立OSPF路由器，在port1插入一些LSA，并使port1和DUT的port1达到FULL状态，port2和DUT的port2达到FULL状态，观察port2是否能得到port1的LSA。\n\n Criteria    \t:   预期结果1: ospf建立成功，可以收到lsa\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    #创建ospf协议\n    session_1 = create_ospf(Port=port_up, Priority=1)\n    session_2 = create_ospf(Port=port_down, Priority=2)\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    # OSPFv2协议会话1创建Summary Lsa\n    summary_lsa = create_ospf_summary_lsa(Session=session_1)\n\n    # OSPFv2协议会话2创建External Lsa\n    external_lsa = create_ospf_external_lsa(Session=session_2)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=summary_lsa)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        advertise_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n\n        # 发送流量\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        withdraw_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n        stop_protocol()\n        time.sleep(3)\n\n        # 获取OSPFv2会话1统计\n        import pandas\n        result = get_ospf_statistic()\n        print(result)\n        if not isinstance(result, pandas.DataFrame):\n            verdict = 'fail'\n\n        result = get_ospf_statistic(Session=session_1)\n        print(result)\n        TxSummaryLsa = result['TxSummaryLsa']\n        RxAsExternalLsa = result['RxAsExternalLsa']\n        print('TxSummaryLsa: {}'.format(TxSummaryLsa))\n        print('RxAsExternalLsa: {}'.format(RxAsExternalLsa))\n\n        # 获取OSPFv2会话2统计\n        result = get_ospf_statistic(Session=session_2)\n        print(result)\n        RxSummaryLsa = result['RxSummaryLsa']\n        TxAsExternalLsa = result['TxAsExternalLsa']\n        print('RxSummaryLsa: {}'.format(RxSummaryLsa))\n        print('TxAsExternalLsa: {}'.format(TxAsExternalLsa))\n\n        # 获取流量1统计\n        result = get_streamblock_statistic(Stream=streams[0])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name,TxStreamFrames,RxStreamFrames)\n\n        # 获取流量2统计\n\n        result = get_streamblock_statistic(Stream=streams[1])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name,TxStreamFrames,RxStreamFrames)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_ospf_lsa:通告 OSPFv2 协议会话 lsa;\ncreate_ospf:创建OSPFv2协议会话对象;\ncreate_ospf_external_lsa:创建OSPFv2 External LSA对象;\ncreate_ospf_summary_lsa:创建OSPFv2 Summary LSA对象;\nget_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象;\nget_ospf_statistic:获取OSPFv2协议会话统计结果;\nwait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态;\nwithdraw_ospf_lsa:撤销OSPFv2协议会话lsa;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_4/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  6.7.4静态路由\n\n Step\t\t\t:\t测试步骤1: ：按图搭建测试环境\n                   测试步骤2: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24\n                   测试步骤3:  DUT1 port1 IP地址为192.168.1.1/24，port2 为1.1.1.1/24；\n                   测试步骤4:  DUT2 port2 IP地址为192.168.2.1/24，port1 为1.1.1.2/24；\n                   测试步骤5: 在DUT1、DUT2上配置tester port1和port2之间的静态路由；\n                   测试步骤6: 测试仪tester使用port1、port2发送双向数据流，检验连通性\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import time\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    sip_address_list = ['192.168.1.100','192.168.2.100']\n    dip_address_list = ['192.168.3.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'stream1_2')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0])\n\n    stream = add_stream(Ports=port_down, Names=f'stream2_1')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[1], Destination=dip_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        if RxStreamFrames == TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is avaliable',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is not avaliable',\n                step=6, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表\",\n  \"子任务2\": \"预约测试仪表端口 port1 和 port2\",\n  \"子任务3\": \"配置测试仪表端口参数\",\n  \"子任务4\": \"等待端口链路状态达到 UP\",\n  \"子任务5\": \"在 port1 上创建网络接口并配置 MAC 地址\",\n  \"子任务6\": \"在 port2 上创建网络接口并配置 MAC 地址\",\n  \"子任务7\": \"配置 port1 接口的 IPv4 地址为 192.168.1.100/24，网关为 192.168.1.1\",\n  \"子任务8\": \"配置 port2 接口的 IPv4 地址为 192.168.2.100/24，网关为 192.168.2.1\",\n  \"子任务9\": \"设置端口负载参数：发送模式为时间模式，速率 100%，持续时间 30 秒\",\n  \"子任务10\": \"在 port1 上创建流量流 stream1，目的 IP 为 192.168.3.1\",\n  \"子任务11\": \"在 port2 上创建流量流 stream2，目的 IP 为 192.168.3.1\",\n  \"子任务12\": \"配置 stream1 帧长度为固定 128 字节\",\n  \"子任务13\": \"配置 stream2 帧长度为固定 128 字节\",\n  \"子任务14\": \"为 stream1 创建以太网和 IPv4 报文头部\",\n  \"子任务15\": \"为 stream2 创建以太网和 IPv4 报文头部\",\n  \"子任务16\": \"编辑 stream1 的 IPv4 头部：源 IP 192.168.1.100，目的 IP 192.168.3.1\",\n  \"子任务17\": \"编辑 stream2 的 IPv4 头部：源 IP 192.168.2.100，目的 IP 192.168.3.1\",\n  \"子任务18\": \"订阅端口统计和流统计视图\",\n  \"子任务19\": \"保存测试配置文件\",\n  \"子任务20\": \"启动所有端口流量发送\",\n  \"子任务21\": \"等待流量发送完成\",\n  \"子任务22\": \"获取 stream1 流量统计：发送帧数和接收帧数\",\n  \"子任务23\": \"获取 stream2 流量统计：发送帧数和接收帧数\",\n  \"子任务24\": \"验证 stream1 发送帧数不为零\",\n  \"子任务25\": \"验证 stream2 发送帧数不为零\",\n  \"子任务26\": \"验证接收帧数等于发送帧数（双向连通性）\",\n  \"子任务27\": \"清除测试统计结果\",\n  \"子任务28\": \"释放测试仪表端口资源\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 :  6.7.4静态路由\n\n Step\t\t\t:\t测试步骤1: ：按图搭建测试环境\n                   测试步骤2: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24\n                   测试步骤3:  DUT1 port1 IP地址为192.168.1.1/24，port2 为1.1.1.1/24；\n                   测试步骤4:  DUT2 port2 IP地址为192.168.2.1/24，port1 为1.1.1.2/24；\n                   测试步骤5: 在DUT1、DUT2上配置tester port1和port2之间的静态路由；\n                   测试步骤6: 测试仪tester使用port1、port2发送双向数据流，检验连通性\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    sip_address_list = ['192.168.1.100','192.168.2.100']\n    dip_address_list = ['192.168.3.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'stream1_2')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0])\n\n    stream = add_stream(Ports=port_down, Names=f'stream2_1')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[1], Destination=dip_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        if RxStreamFrames == TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is avaliable',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is not avaliable',\n                step=6, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_3/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.3 端口吞吐量\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2544 中规定，将交换机任意两个同类型端口与测试仪相连接，见图 3；\n                   测试步骤2: 配置流量发生器：测试帧长度分别为（64、65、256、1024、1518）字节；\n                   测试步骤3: 测试时间为 60s。\n\n Criteria    \t:   预期结果1: 技术要求吞吐量为100%。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\nimport time\n\nstart_time=time.time()\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_search(Config=Config, Mode='binary', Init=cfg['arg']['search']['default']['init']['default'],\n                          Lower=cfg['arg']['search']['default']['lower']['default'], Upper=cfg['arg']['search']['default']['upper']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试仪的控制连接。\",\n  \"子任务2\": \"预约测试仪的两个指定端口用于测试连接。\",\n  \"子任务3\": \"修改预约端口的参数配置，确保端口状态符合测试要求。\",\n  \"子任务4\": \"等待端口链路状态变为UP状态，确保物理连接就绪。\",\n  \"子任务5\": \"在预约端口上创建以太网接口层。\",\n  \"子任务6\": \"配置接口的MAC地址参数，区分上行和下行接口。\",\n  \"子任务7\": \"获取接口的以太网层对象用于流量绑定。\",\n  \"子任务8\": \"创建双向流量流，绑定源和目的接口的以太网层。\",\n  \"子任务9\": \"创建RFC2544吞吐量测试套件，指定测试类型为吞吐量。\",\n  \"子任务10\": \"将测试套件关联到预约的两个测试端口。\",\n  \"子任务11\": \"配置测试套件使用已创建的流量流进行测试。\",\n  \"子任务12\": \"设置测试套件的地址学习参数：启用学习，频率为单次。\",\n  \"子任务13\": \"配置测试时长为60秒，模式为秒级计时。\",\n  \"子任务14\": \"设置测试帧长度为自定义值：64、65、256、1024、1518字节。\",\n  \"子任务15\": \"配置测试负载搜索模式为二分搜索，设置初始/下限/上限负载值。\",\n  \"子任务16\": \"生成并扩展测试套件配置。\",\n  \"子任务17\": \"保存测试配置文件到指定路径。\",\n  \"子任务18\": \"执行测试套件，运行时长设置为3600秒超时保护。\",\n  \"子任务19\": \"获取RFC2544吞吐量测试结果数据。\",\n  \"子任务20\": \"验证吞吐量结果是否达到100%的技术要求。\",\n  \"子任务21\": \"释放测试端口资源，清理测试环境。\",\n  \"子任务22\": \"关闭测试仪表连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.3 端口吞吐量\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2544 中规定，将交换机任意两个同类型端口与测试仪相连接，见图 3；\n                   测试步骤2: 配置流量发生器：测试帧长度分别为（64、65、256、1024、1518）字节；\n                   测试步骤3: 测试时间为 60s。\n\n Criteria    \t:   预期结果1: 技术要求吞吐量为100%。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\nimport time\n\nstart_time=time.time()\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_search(Config=Config, Mode='binary', Init=cfg['arg']['search']['default']['init']['default'],\n                          Lower=cfg['arg']['search']['default']['lower']['default'], Upper=cfg['arg']['search']['default']['upper']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_2/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  6.7.2互联网控制消息协议（ICMP）\n\n Step\t\t\t:\t测试步骤1: ：按图10搭建测试环境\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为192.168.2.100/24\n                   测试步骤3: DUT port1 地址为192.168.1.1/24，port2 地址为192.168.2.1/24\n                   测试步骤4: tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n                   测试步骤5: tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n                   测试步骤6: tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n                   测试步骤7: tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # edit_port_load_profile(Ports=port_up, TransmitMode='TIME', Rate=1, Seconds=30)\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['192.168.3.1 ','192.168.1.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'step5')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0], Gateway='192.168.1.1')\n\n    # step6 tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n    stream = add_stream(Ports=port_up, Names=f'step6')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=100, Gateway='192.168.1.1')\n\n    # step7 tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n    stream = add_stream(Ports=port_up, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=17, Gateway='192.168.1.1')\n    edit_header_udp(Stream=stream, SourcePort=100)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.1.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n\n        stream1, stream2, stream3 = get_streams(Ports=port_up)\n        # 端口1测试\n        net_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step5', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '0' and pkt.icmp.type == '3':\n                net_unreached_pkt.append(pkt)\n\n        if len(net_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到网络不可达报文，类型为 3，编码为 0',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到网络不可达报文',\n                step=5, result=False)\n\n        protocol_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '2' and pkt.icmp.type == '3':\n                protocol_unreached_pkt.append(pkt)\n        if len(protocol_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到协议不可达报文，类型为 3，编码为 2',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到协议不可达报文',\n                step=6, result=False)\n\n        port_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream3)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '3' and pkt.icmp.code == '3':\n                port_unreached_pkt.append(pkt)\n\n        if len(port_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到端口不可达报文，类型为 3，编码为 3',\n                step=7, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到端口不可达报文',\n                step=7, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "edit_header_udp:修改测试仪表流量模板中UDP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l3_learning:启动测试仪表流量三层ARP ND学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试设备的连接。\",\n  \"子任务2\": \"预约测试仪表端口 port1，配置端口参数并等待端口链路状态就绪。\",\n  \"子任务3\": \"在 port1 上创建网络接口，配置 IPv4 地址为 192.168.1.100/24，网关为 192.168.1.1。\",\n  \"子任务4\": \"配置端口负载参数：传输模式为连续发送，速率为 100 帧/秒。\",\n  \"子任务5\": \"创建网络不可达测试流量：目标地址 192.168.3.1，固定帧长 128 字节，包含以太网和 IPv4 头部。\",\n  \"子任务6\": \"创建协议不可达测试流量：目标地址 192.168.1.1，协议号 100，固定帧长 128 字节，包含以太网和 IPv4 头部。\",\n  \"子任务7\": \"创建端口不可达测试流量：目标地址 192.168.1.1，协议号 17，UDP 源端口 100，固定帧长 128 字节，包含以太网/IPv4/UDP 头部。\",\n  \"子任务8\": \"保存当前测试配置到文件系统。\",\n  \"子任务9\": \"订阅端口统计和流统计视图用于结果监控。\",\n  \"子任务10\": \"执行 ICMP ping 测试：从 port1 向 192.168.1.1 发送 5 个 ping 包，验证是否收到正确响应。\",\n  \"子任务11\": \"执行网络不可达测试：启动三层学习，捕获 port1 流量，发送步骤5的流量流，下载抓包文件，验证是否收到 ICMP 类型3编码0的响应报文。\",\n  \"子任务12\": \"执行协议不可达测试：启动三层学习，捕获 port1 流量，发送步骤6的流量流，下载抓包文件，验证是否收到 ICMP 类型3编码2的响应报文。\",\n  \"子任务13\": \"执行端口不可达测试：启动三层学习，捕获 port1 流量，发送步骤7的流量流，下载抓包文件，验证是否收到 ICMP 类型3编码3的响应报文。\",\n  \"子任务14\": \"释放测试仪表端口资源，关闭仪表连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 :  6.7.2互联网控制消息协议（ICMP）\n\n Step\t\t\t:\t测试步骤1: ：按图10搭建测试环境\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为192.168.2.100/24\n                   测试步骤3: DUT port1 地址为192.168.1.1/24，port2 地址为192.168.2.1/24\n                   测试步骤4: tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n                   测试步骤5: tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n                   测试步骤6: tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n                   测试步骤7: tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # edit_port_load_profile(Ports=port_up, TransmitMode='TIME', Rate=1, Seconds=30)\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['192.168.3.1 ','192.168.1.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'step5')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0], Gateway='192.168.1.1')\n\n    # step6 tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n    stream = add_stream(Ports=port_up, Names=f'step6')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=100, Gateway='192.168.1.1')\n\n    # step7 tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n    stream = add_stream(Ports=port_up, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=17, Gateway='192.168.1.1')\n    edit_header_udp(Stream=stream, SourcePort=100)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.1.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n\n        stream1, stream2, stream3 = get_streams(Ports=port_up)\n        # 端口1测试\n        net_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step5', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '0' and pkt.icmp.type == '3':\n                net_unreached_pkt.append(pkt)\n\n        if len(net_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到网络不可达报文，类型为 3，编码为 0',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到网络不可达报文',\n                step=5, result=False)\n\n        protocol_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '2' and pkt.icmp.type == '3':\n                protocol_unreached_pkt.append(pkt)\n        if len(protocol_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到协议不可达报文，类型为 3，编码为 2',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到协议不可达报文',\n                step=6, result=False)\n\n        port_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream3)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '3' and pkt.icmp.code == '3':\n                port_unreached_pkt.append(pkt)\n\n        if len(port_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到端口不可达报文，类型为 3，编码为 3',\n                step=7, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到端口不可达报文',\n                step=7, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nedit_header_udp:修改测试仪表流量模板中UDP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l3_learning:启动测试仪表流量三层ARP ND学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_4/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.4 存储转发时延\n\n Step\t\t\t:\t测试步骤1: 按照图 4，将交换机任意两个同类型端口与测试仪相连接；\n                   测试步骤2: 两个端口同时以相应负载互相发送数据，测试帧长度分别为（64、65、256、1024、1518）字节，测试时间为 60s；负载率设置为：重载 95%，轻载10%；\n                   测试步骤3: 记录不同帧长的平均存储转发时延。\n\n Criteria    \t:   预期结果1: 技术要求平均时延应小于10µs。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\nimport time\n\nstart_time=time.time()\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        print(\"111\",testbed['tester']['rtsm']['ip'])\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    print(\"port_up\",port_up)\n    print(\"port_down\", port_down)\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    for k, v in testbed['tester'].items():\n        edit_port_kwargs = {}\n        if k in edit_port_params:\n            edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    print(\"interfaces_up\", interfaces_up)\n    print(\"interfaces_down\", interfaces_down)\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['latency'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并建立连接\",\n  \"子任务2\": \"预约测试仪的两个同类型端口（根据测试床配置）\",\n  \"子任务3\": \"配置测试仪端口参数（根据测试床设置）\",\n  \"子任务4\": \"在每个端口上创建以太网接口\",\n  \"子任务5\": \"配置接口的MAC地址（根据测试床配置）\",\n  \"子任务6\": \"创建双向流量流（源端口到目标端口双向绑定）\",\n  \"子任务7\": \"创建RFC2544测试套件，测试指标为时延\",\n  \"子任务8\": \"关联测试套件与预约的端口\",\n  \"子任务9\": \"配置测试套件使用已创建的流量流\",\n  \"子任务10\": \"配置测试套件地址学习模式为单次学习\",\n  \"子任务11\": \"配置测试套件测试时长为60秒\",\n  \"子任务12\": \"配置测试套件帧长度序列为64、65、256、1024、1518字节\",\n  \"子任务13\": \"配置测试套件负载循环模式为自定义负载（95%和10%）\",\n  \"子任务14\": \"生成测试套件结构并保存配置文件\",\n  \"子任务15\": \"执行测试套件并收集测试结果\",\n  \"子任务16\": \"从结果中提取不同帧长在不同负载下的平均存储转发时延\",\n  \"子任务17\": \"验证所有测试结果的平均时延是否小于10微秒\",\n  \"子任务18\": \"释放测试仪端口资源并关闭连接\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.4 存储转发时延\n\n Step\t\t\t:\t测试步骤1: 按照图 4，将交换机任意两个同类型端口与测试仪相连接；\n                   测试步骤2: 两个端口同时以相应负载互相发送数据，测试帧长度分别为（64、65、256、1024、1518）字节，测试时间为 60s；负载率设置为：重载 95%，轻载10%；\n                   测试步骤3: 记录不同帧长的平均存储转发时延。\n\n Criteria    \t:   预期结果1: 技术要求平均时延应小于10µs。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\nimport time\n\nstart_time=time.time()\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        print(\"111\",testbed['tester']['rtsm']['ip'])\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    print(\"port_up\",port_up)\n    print(\"port_down\", port_down)\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    for k, v in testbed['tester'].items():\n        edit_port_kwargs = {}\n        if k in edit_port_params:\n            edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    print(\"interfaces_up\", interfaces_up)\n    print(\"interfaces_down\", interfaces_down)\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['latency'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_2/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.2 优先级QoS\n\n Step\t\t\t:\t测试步骤1: 按图6，从交换机任意选取三个端口与测试仪相连接，分别定为端口1、端口2 和端口3，交换机配置为绝对优先级，交换机设置端口trunk模式保证不剥掉vlan1；\n                   测试步骤2: 端口1 和端口2 同时端口3 发送数据；\n                   测试步骤3: 在端口1 构造两条优先级分别为7 和5 的数据流，在端口2 构造两条优先级分别为3 和1 的数据流，vlan1 的优先级设置为7 和5，3 和1；\n                   测试步骤4: 测试帧长度为64 字节，测试时间30s，端口负荷设置为100%；\n                   测试步骤5: 记录不同数据流的帧丢失率，判断优先级是否设置成功。\n\n Criteria    \t:   预期结果1: 不同数据流的帧丢失率，与优先级设置一致。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    port1,port2,port3=ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建流量\n    # 数据流 1：qos优先级为 7 的 IPv4 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_7')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    edit_header_vlan(Stream=stream, Priority=7)\n    # 数据流 2：qos优先级为 5 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_5')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, Priority=5)\n\n    # 端口2创建流量\n    # 数据流 1：qos优先级为 3 的 IPv4 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_3')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, Priority=3)\n    # 数据流 2：qos优先级为 1 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_1')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[3])\n    edit_header_vlan(Stream=stream, Priority=1)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(5)\n        # 检查统计结果\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxPortID'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            TxPortID = Result['TxPortID']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=5, result=True)\n            if RxStreamFrames != TxStreamFrames:\n                if TxPortID == port2.Name:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=5, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并预约端口1、端口2、端口3的测试资源\",\n  \"子任务2\": \"配置交换机端口为绝对优先级和trunk模式，保留vlan1标签\",\n  \"子任务3\": \"设置测试仪端口负载参数：帧长度64字节，测试时间30秒，端口负荷100%\",\n  \"子任务4\": \"在端口1创建两条数据流：优先级7的IPv4流（vlan1）和优先级5的IPv4流（vlan1）\",\n  \"子任务5\": \"在端口2创建两条数据流：优先级3的IPv4流（vlan1）和优先级1的IPv4流（vlan1）\",\n  \"子任务6\": \"订阅流模板块统计视图（StreamBlockStats）\",\n  \"子任务7\": \"启动二层地址学习并等待5秒\",\n  \"子任务8\": \"同时启动端口1和端口2向端口3发送数据流\",\n  \"子任务9\": \"等待数据流发送完成并暂停5秒\",\n  \"子任务10\": \"获取四条数据流的发送帧数（TxStreamFrames）和接收帧数（RxStreamFrames）统计\",\n  \"子任务11\": \"计算每条数据流的帧丢失率：(发送帧数-接收帧数)/发送帧数\",\n  \"子任务12\": \"验证优先级7流的帧丢失率 < 优先级5流的帧丢失率 < 优先级3流的帧丢失率 < 优先级1流的帧丢失率\",\n  \"子任务13\": \"清除测试统计结果并释放端口资源\",\n  \"子任务14\": \"关闭测试仪表进程\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.2 优先级QoS\n\n Step\t\t\t:\t测试步骤1: 按图6，从交换机任意选取三个端口与测试仪相连接，分别定为端口1、端口2 和端口3，交换机配置为绝对优先级，交换机设置端口trunk模式保证不剥掉vlan1；\n                   测试步骤2: 端口1 和端口2 同时端口3 发送数据；\n                   测试步骤3: 在端口1 构造两条优先级分别为7 和5 的数据流，在端口2 构造两条优先级分别为3 和1 的数据流，vlan1 的优先级设置为7 和5，3 和1；\n                   测试步骤4: 测试帧长度为64 字节，测试时间30s，端口负荷设置为100%；\n                   测试步骤5: 记录不同数据流的帧丢失率，判断优先级是否设置成功。\n\n Criteria    \t:   预期结果1: 不同数据流的帧丢失率，与优先级设置一致。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    port1,port2,port3=ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建流量\n    # 数据流 1：qos优先级为 7 的 IPv4 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_7')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    edit_header_vlan(Stream=stream, Priority=7)\n    # 数据流 2：qos优先级为 5 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_5')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, Priority=5)\n\n    # 端口2创建流量\n    # 数据流 1：qos优先级为 3 的 IPv4 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_3')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, Priority=3)\n    # 数据流 2：qos优先级为 1 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_1')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[3])\n    edit_header_vlan(Stream=stream, Priority=1)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(5)\n        # 检查统计结果\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxPortID'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            TxPortID = Result['TxPortID']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=5, result=True)\n            if RxStreamFrames != TxStreamFrames:\n                if TxPortID == port2.Name:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=5, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_5/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.5 路由信息协议（RIP）\n\n Step\t\t\t:\t测试步骤1: 按图4，任选交换机两个端口作为测试端口；\n                   测试步骤2:  tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24;\n                   测试步骤3:  DUT1 port1 IP 地 址 为 192.168.1.1/24 ， port2 IP 地 址 为192.168.2.1/24\n                   测试步骤3:  在DUT上配置RIPv2路由协议；\n                   测试步骤3:   tester port1 从 UDP端口520向组播地址224.0.0.9的520 UDP端口发\n                               送地址簇为2，RIP条目为192.168.4.0/255.255.255.0/8 的RIPv2 应答报\n                               文，周期为1s，观察DUT的路由表变化，观察testerport2是否收到路由更新报文；\n                   测试步骤3:  停止发送步骤6的报文，tester port1 从UDP端口520向组播地址\n                               224.0.0.9 的 520 UDP 端 口 发 送 地 址 簇 为 2 ， RIP 条 目 为\n                               192.168.4.0/255.255.255.0/6 的 RIPv2 应答报文，周期为 1s，观察 DUT\n                               的路由表变化，观察tester port2是否收到路由更新报文；\n                   测试步骤3:   停止发送步骤7的报文，tester port1 从UDP端口520向组播地址\n                               224.0.0.9 的 520 UDP 端 口 发 送 地 址 簇 为 2 ， RIP 条 目 为\n                               192.168.4.0/255.255.255.0/10 的 RIPv2 应答报文，周期为 1s，观察 DUT\n                               的路由表变化，观察tester port2是否收到路由更新报文\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建RIP协议会话\n    session_1 = create_rip(Port=port_up)\n    session_2 = create_rip(Port=port_down)\n\n    # RIP协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    #创建流量\n    port1, port2 = ports\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n\n        route = create_rip_ipv4_route(Session=session_1, StartIpv4Prefix='192.168.4.0', Increment=8)\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 6\n        save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 10\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step8', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_rip:通告RIP协议路由",
      "create_rip:创建RIP协议会话对象",
      "create_rip_ipv4_route:创建RIP IPv4路由对象",
      "wait_rip_state:等待RIP协议会话达到指定状态",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并预约两个测试端口。\",\n  \"子任务2\": \"配置测试仪端口参数：端口1 IP为192.168.1.100/24，端口2 IP为192.168.2.100/24。\",\n  \"子任务3\": \"在测试仪端口1上创建接口并配置MAC地址和IPv4地址（网关指向192.168.1.1）。\",\n  \"子任务4\": \"在测试仪端口2上创建接口并配置MAC地址和IPv4地址（网关指向192.168.2.1）。\",\n  \"子任务5\": \"在测试仪两个端口上创建RIP协议会话对象。\",\n  \"子任务6\": \"将RIP协议会话分别绑定到对应的测试仪接口。\",\n  \"子任务7\": \"在端口1的RIP会话上创建IPv4路由条目：起始路由192.168.4.0，步长8。\",\n  \"子任务8\": \"启动RIP协议并等待协议状态就绪。\",\n  \"子任务9\": \"在端口2启动数据包捕获。\",\n  \"子任务10\": \"从端口1通告RIPv2路由更新：UDP 520端口发往组播地址224.0.0.9，周期1秒。\",\n  \"子任务11\": \"停止端口2的数据包捕获并下载捕获文件。\",\n  \"子任务12\": \"分析捕获报文：验证端口2是否收到包含192.168.4.0/24的路由更新报文。\",\n  \"子任务13\": \"停止RIP协议并修改路由条目步长为6。\",\n  \"子任务14\": \"重新启动RIP协议并等待状态就绪。\",\n  \"子任务15\": \"在端口2启动数据包捕获。\",\n  \"子任务16\": \"从端口1通告修改后的RIPv2路由更新（步长6）。\",\n  \"子任务17\": \"停止端口2的数据包捕获并下载捕获文件。\",\n  \"子任务18\": \"分析捕获报文：验证端口2是否收到步长6的路由更新报文。\",\n  \"子任务19\": \"停止RIP协议并修改路由条目步长为10。\",\n  \"子任务20\": \"重新启动RIP协议并等待状态就绪。\",\n  \"子任务21\": \"在端口2启动数据包捕获。\",\n  \"子任务22\": \"从端口1通告修改后的RIPv2路由更新（步长10）。\",\n  \"子任务23\": \"停止端口2的数据包捕获并下载捕获文件。\",\n  \"子任务24\": \"分析捕获报文：验证端口2是否收到步长10的路由更新报文。\",\n  \"子任务25\": \"停止RIP协议并释放测试仪端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.7.5 路由信息协议（RIP）\n\n Step\t\t\t:\t测试步骤1: 按图4，任选交换机两个端口作为测试端口；\n                   测试步骤2:  tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24;\n                   测试步骤3:  DUT1 port1 IP 地 址 为 192.168.1.1/24 ， port2 IP 地 址 为192.168.2.1/24\n                   测试步骤3:  在DUT上配置RIPv2路由协议；\n                   测试步骤3:   tester port1 从 UDP端口520向组播地址224.0.0.9的520 UDP端口发\n                               送地址簇为2，RIP条目为192.168.4.0/255.255.255.0/8 的RIPv2 应答报\n                               文，周期为1s，观察DUT的路由表变化，观察testerport2是否收到路由更新报文；\n                   测试步骤3:  停止发送步骤6的报文，tester port1 从UDP端口520向组播地址\n                               224.0.0.9 的 520 UDP 端 口 发 送 地 址 簇 为 2 ， RIP 条 目 为\n                               192.168.4.0/255.255.255.0/6 的 RIPv2 应答报文，周期为 1s，观察 DUT\n                               的路由表变化，观察tester port2是否收到路由更新报文；\n                   测试步骤3:   停止发送步骤7的报文，tester port1 从UDP端口520向组播地址\n                               224.0.0.9 的 520 UDP 端 口 发 送 地 址 簇 为 2 ， RIP 条 目 为\n                               192.168.4.0/255.255.255.0/10 的 RIPv2 应答报文，周期为 1s，观察 DUT\n                               的路由表变化，观察tester port2是否收到路由更新报文\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建RIP协议会话\n    session_1 = create_rip(Port=port_up)\n    session_2 = create_rip(Port=port_down)\n\n    # RIP协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    #创建流量\n    port1, port2 = ports\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n\n        route = create_rip_ipv4_route(Session=session_1, StartIpv4Prefix='192.168.4.0', Increment=8)\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 6\n        save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 10\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step8', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_rip:通告RIP协议路由;\ncreate_rip:创建RIP协议会话对象;\ncreate_rip_ipv4_route:创建RIP IPv4路由对象;\nwait_rip_state:等待RIP协议会话达到指定状态;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_6_2/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.6.2 路由表容量\n\n Step\t\t\t:\t测试步骤1: 按拓扑图搭建测试环境；\n                   测试步骤2: tester port1 IP 地址为 192.168.1.100/24，port2 为 192.168.2.100/24；\n                   测试步骤3: DUT port1 IP地址为192.168.1.1/24，port2 IP地址为192.168.2.1/24；\n                   测试步骤4: 配置 DUT 与 tester 在相同 Area 域，DUT 的接口 1、2 分别和 tester 建立 OSPF 邻居；\n                   测试步骤5: Tester 的接口 port1、port2 分别向 DUT 的接口 port1、port2 发布 Type类型的 LSA，总数为被测交换机路由表容量的规定值。\n\n Criteria    \t:   预期结果1: 查看并记录被测交换机的 OSPF 生成的路由表统计信息。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建OSPFv2协议会话\n    session_1 = create_ospf(Port=port_up, Priority=cfg['arg']['ospf']['default']['priority_session_up']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n    session_2 = create_ospf(Port=port_down, Priority=cfg['arg']['ospf']['default']['priority_session_down']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    route_count = int(cfg['arg']['ospf']['default']['advertise_count']['default'] / 2)\n    # OSPFv2协议会话创建External Lsa\n    external_lsa_1 = create_ospf_external_lsa(Session=session_1, RouteCount=route_count)\n    external_lsa_2 = create_ospf_external_lsa(Session=session_2, RouteCount=route_count)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=external_lsa_1)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa_2)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['rate']['default'])\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats', 'Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 启动协议\n        printf(message='Test start')\n        start_protocol()\n        time.sleep(3)\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        advertise_ospf_lsa(Lsa=[external_lsa_1, external_lsa_2])\n        time.sleep(cfg['arg']['ospf']['default']['advertise_wait']['default'])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 发送流量\n        printf(message='Stream test start')\n        start_stream()\n        time.sleep(3)\n        df = get_streamblock_statistic()\n        wait_stream_state(State='RUNNING')\n        time.sleep(3)\n        result = get_streamblock_statistic()\n        # 使用 concat 拼接 DataFrame\n        df = pd.concat([df, result])\n        # 重置索引\n        df = df.reset_index(drop=True)\n        printf(message='Test completed')\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        stop_protocol()\n        time.sleep(3)\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_ospf_lsa:通告 OSPFv2 协议会话 lsa",
      "create_ospf:创建OSPFv2协议会话对象",
      "create_ospf_external_lsa:创建OSPFv2 External LSA对象",
      "get_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象",
      "get_ospf_statistic:获取OSPFv2协议会话统计结果",
      "wait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表\",\n  \"子任务2\": \"预约测试仪表端口资源\",\n  \"子任务3\": \"编辑测试仪表端口参数（速率、双工模式等）\",\n  \"子任务4\": \"在测试仪表端口上创建网络接口\",\n  \"子任务5\": \"配置接口的MAC地址和IPv4地址（Tester端口1:192.168.1.100/24，端口2:192.168.2.100/24，网关指向DUT接口IP）\",\n  \"子任务6\": \"在测试仪表端口上创建OSPFv2协议会话（区域ID相同）\",\n  \"子任务7\": \"将OSPFv2协议会话绑定到对应网络接口\",\n  \"子任务8\": \"创建OSPF External LSA对象（总数量等于被测路由表容量规定值，平均分配到两个端口）\",\n  \"子任务9\": \"启动OSPF协议\",\n  \"子任务10\": \"等待OSPFv2会话达到Full邻接状态\",\n  \"子任务11\": \"通告创建的OSPF External LSA\",\n  \"子任务12\": \"获取并记录OSPFv2协议会话统计信息（包含路由表统计）\",\n  \"子任务13\": \"停止OSPF协议\",\n  \"子任务14\": \"释放测试仪表端口资源\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.6.2 路由表容量\n\n Step\t\t\t:\t测试步骤1: 按拓扑图搭建测试环境；\n                   测试步骤2: tester port1 IP 地址为 192.168.1.100/24，port2 为 192.168.2.100/24；\n                   测试步骤3: DUT port1 IP地址为192.168.1.1/24，port2 IP地址为192.168.2.1/24；\n                   测试步骤4: 配置 DUT 与 tester 在相同 Area 域，DUT 的接口 1、2 分别和 tester 建立 OSPF 邻居；\n                   测试步骤5: Tester 的接口 port1、port2 分别向 DUT 的接口 port1、port2 发布 Type类型的 LSA，总数为被测交换机路由表容量的规定值。\n\n Criteria    \t:   预期结果1: 查看并记录被测交换机的 OSPF 生成的路由表统计信息。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建OSPFv2协议会话\n    session_1 = create_ospf(Port=port_up, Priority=cfg['arg']['ospf']['default']['priority_session_up']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n    session_2 = create_ospf(Port=port_down, Priority=cfg['arg']['ospf']['default']['priority_session_down']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    route_count = int(cfg['arg']['ospf']['default']['advertise_count']['default'] / 2)\n    # OSPFv2协议会话创建External Lsa\n    external_lsa_1 = create_ospf_external_lsa(Session=session_1, RouteCount=route_count)\n    external_lsa_2 = create_ospf_external_lsa(Session=session_2, RouteCount=route_count)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=external_lsa_1)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa_2)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['rate']['default'])\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats', 'Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 启动协议\n        printf(message='Test start')\n        start_protocol()\n        time.sleep(3)\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        advertise_ospf_lsa(Lsa=[external_lsa_1, external_lsa_2])\n        time.sleep(cfg['arg']['ospf']['default']['advertise_wait']['default'])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 发送流量\n        printf(message='Stream test start')\n        start_stream()\n        time.sleep(3)\n        df = get_streamblock_statistic()\n        wait_stream_state(State='RUNNING')\n        time.sleep(3)\n        result = get_streamblock_statistic()\n        # 使用 concat 拼接 DataFrame\n        df = pd.concat([df, result])\n        # 重置索引\n        df = df.reset_index(drop=True)\n        printf(message='Test completed')\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        stop_protocol()\n        time.sleep(3)\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_ospf_lsa:通告 OSPFv2 协议会话 lsa;\ncreate_ospf:创建OSPFv2协议会话对象;\ncreate_ospf_external_lsa:创建OSPFv2 External LSA对象;\nget_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象;\nget_ospf_statistic:获取OSPFv2协议会话统计结果;\nwait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_5/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.5 帧丢失率\n\n Step\t\t\t:\t测试步骤1: 按照图 4，将交换机任意两个同类型端口与测试仪相连接；\n                   测试步骤2: 两个端口同时互相发送数据，测试帧长度分别为（64、65、256、1024、1518）字节，测试时间为 60s；负载率设置为 100%；\n                   测试步骤3: 记录不同帧长的丢包率。\n\n Criteria    \t:   预期结果1: 技术要求在端口转发速率达到 100%的情况下，丢包率应为0。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['frameloss'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试仪的控制连接。\",\n  \"子任务2\": \"预约测试仪的两个同类型端口（根据配置确定端口位置）。\",\n  \"子任务3\": \"配置测试仪端口参数（根据testbed配置设置速率、双工模式等）。\",\n  \"子任务4\": \"等待测试仪端口链路状态达到就绪状态。\",\n  \"子任务5\": \"在端口1上创建以太网接口并配置源MAC地址。\",\n  \"子任务6\": \"在端口2上创建以太网接口并配置源MAC地址。\",\n  \"子任务7\": \"获取端口1接口的以太网层对象。\",\n  \"子任务8\": \"获取端口2接口的以太网层对象。\",\n  \"子任务9\": \"创建双向流量流（端口1<->端口2）。\",\n  \"子任务10\": \"创建RFC2544测试套件（测试类型为帧丢失率）。\",\n  \"子任务11\": \"关联测试套件与预约的测试仪端口（端口1和端口2）。\",\n  \"子任务12\": \"配置测试套件使用已创建的流量流。\",\n  \"子任务13\": \"配置测试套件地址学习（频率：单次学习）。\",\n  \"子任务14\": \"配置测试套件测试时长（60秒）。\",\n  \"子任务15\": \"配置测试套件帧长度（64、65、256、1024、1518字节）。\",\n  \"子任务16\": \"配置测试套件负载率（100%负载，自定义模式）。\",\n  \"子任务17\": \"生成并扩展测试套件配置。\",\n  \"子任务18\": \"保存测试配置文件。\",\n  \"子任务19\": \"执行测试套件（运行帧丢失率测试）。\",\n  \"子任务20\": \"获取测试结果数据（RFC2544帧丢失率结果集）。\",\n  \"子任务21\": \"验证测试结果：各帧长（64/65/256/1024/1518字节）丢包率是否为0%。\",\n  \"子任务22\": \"记录不同帧长的丢包率结果（生成测试报告）。\",\n  \"子任务23\": \"释放测试仪端口资源。\",\n  \"子任务24\": \"关闭测试仪表连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.5 帧丢失率\n\n Step\t\t\t:\t测试步骤1: 按照图 4，将交换机任意两个同类型端口与测试仪相连接；\n                   测试步骤2: 两个端口同时互相发送数据，测试帧长度分别为（64、65、256、1024、1518）字节，测试时间为 60s；负载率设置为 100%；\n                   测试步骤3: 记录不同帧长的丢包率。\n\n Criteria    \t:   预期结果1: 技术要求在端口转发速率达到 100%的情况下，丢包率应为0。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['frameloss'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_8/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :   6.7.8 互联网组管理协议（IGMP)\n\n Step\t\t\t:\t测试步骤1:  按图10建立测试环境；\n                   测试步骤2:  tester port1 地 址 为 192.168.1.100/24 ， port2 地 址 为192.168.2.100/24\n                   测试步骤3:  DUT port1 地址为192.168.1.1/24，port2 地址为192.168.2.1/24\n                   测试步骤4:   DUT 设置IGMPv2组播查询；\n                   测试步骤5:   tester 向port1 发目的地址为225.1.1.1，TTL=1的IGMPv2应答报文，其组地址域也为225.1.1.1，周期为1秒\n                   测试步骤6:   停止发送步骤5中的IGMPv2应答报文，观察交换机组播组成员变化；\n                   测试步骤7:    tester 向port1 发目的地址为225.1.1.1，TTL=1的IGMPv2应答报文，\n                               其组地址域也为225.1.1.1，周期为1秒，停止发送应答报文之后tester\n                               立刻向port1发目的地址为224.0.0.2，TTL=1的IGMPv2离开报文，其组地址域为225.1.1.1。观察交换机组播组成员变化\n                   测试步骤8:   停止发送步骤7中的报文；\n                   测试步骤9:   检查DUT配置，看是否支持IGMPv1、IGMPv2、IGMPv3\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_up, Version='IGMPV2')\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interfaces_up)\n\n    # 创建组播组\n    multicast_group = create_multicast_group(Start='225.1.1.1')\n\n    # IGMP协议会话创建组成员关系\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=port_down, Version='IGMPV2')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_down)\n\n    # 创建IGMP绑定流\n\n    # point = get_layer_from_interfaces(Interfaces=interfaces_down)\n    #\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints='224.0.0', Bidirection=False)\n\n\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        Rate=100,\n    #                        Unit='FRAME_PER_SEC',\n    #                        TransmitMode=\"STEP\",\n    #                        Frames=20)\n\n\n    #创建IGMPv2报文\n    # stream1 = add_stream(Ports=port_up, Names=f'igmpv2_report')\n    # edit_stream(Stream=stream1, FixedLength=128)\n    # create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4','igmpv2'])\n    # edit_header_ipv4(Stream=stream1, Source='192.168.1.100', Destination= '225.1.1.1', TTl=1)\n    #\n    # stream2 = add_stream(Ports=port_up, Names=f'igmpv2_query')\n    # edit_stream(Stream=stream2, FixedLength=128)\n    # create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4','igmpv2query'])\n    # edit_header_ipv4(Stream=stream2, Source='192.168.1.100', Destination= '224.0.0.2', TTl=1)\n\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        #停止协议\n        stop_protocol()\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_igmp:创建IGMP协议会话对象",
      "create_igmp_querier:创建IGMP Querier协议会话对象",
      "edit_igmp:编辑IGMP协议会话对象",
      "edit_igmp_querier:编辑IGMP Querier协议会话对象",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试环境的连接。\",\n  \"子任务2\": \"预约测试仪表端口 port1 和 port2，准备测试资源。\",\n  \"子任务3\": \"在测试仪 port1 上创建接口，配置 IPv4 地址为 192.168.1.100/24，网关为 192.168.1.1。\",\n  \"子任务4\": \"在测试仪 port2 上创建接口，配置 IPv4 地址为 192.168.2.100/24，网关为 192.168.2.1。\",\n  \"子任务5\": \"在 DUT 上配置端口 port1 地址为 192.168.1.1/24，端口 port2 地址为 192.168.2.1/24。\",\n  \"子任务6\": \"在 DUT 上启用 IGMPv2 组播查询功能。\",\n  \"子任务7\": \"在测试仪 port1 上创建 IGMPv2 协议会话，绑定已配置的接口。\",\n  \"子任务8\": \"创建全局组播组 225.1.1.1，并与 IGMP 会话绑定。\",\n  \"子任务9\": \"在测试仪 port2 上创建 IGMPv2 Querier 协议会话，绑定接口并设置健壮系数为 3。\",\n  \"子任务10\": \"启动所有协议会话，开始模拟组播行为。\",\n  \"子任务11\": \"等待 IGMP 会话状态稳定，确保周期性发送目的地址为 225.1.1.1、TTL=1 的 IGMPv2 报告报文。\",\n  \"子任务12\": \"停止发送 IGMPv2 报告报文，通过 DUT 查询组播组成员变化状态。\",\n  \"子任务13\": \"重新启动 IGMPv2 报告报文发送（周期 1 秒）。\",\n  \"子任务14\": \"停止报告报文后立即发送目的地址为 224.0.0.2、TTL=1 的 IGMPv2 离开报文，组地址域为 225.1.1.1。\",\n  \"子任务15\": \"通过 DUT 查询组播组成员变化状态，验证离开报文效果。\",\n  \"子任务16\": \"停止所有协议会话，结束流量发送。\",\n  \"子任务17\": \"检查 DUT 配置，验证对 IGMPv1、IGMPv2、IGMPv3 协议的支持情况。\",\n  \"子任务18\": \"释放测试仪表端口资源，清理测试环境。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 :   6.7.8 互联网组管理协议（IGMP)\n\n Step\t\t\t:\t测试步骤1:  按图10建立测试环境；\n                   测试步骤2:  tester port1 地 址 为 192.168.1.100/24 ， port2 地 址 为192.168.2.100/24\n                   测试步骤3:  DUT port1 地址为192.168.1.1/24，port2 地址为192.168.2.1/24\n                   测试步骤4:   DUT 设置IGMPv2组播查询；\n                   测试步骤5:   tester 向port1 发目的地址为225.1.1.1，TTL=1的IGMPv2应答报文，其组地址域也为225.1.1.1，周期为1秒\n                   测试步骤6:   停止发送步骤5中的IGMPv2应答报文，观察交换机组播组成员变化；\n                   测试步骤7:    tester 向port1 发目的地址为225.1.1.1，TTL=1的IGMPv2应答报文，\n                               其组地址域也为225.1.1.1，周期为1秒，停止发送应答报文之后tester\n                               立刻向port1发目的地址为224.0.0.2，TTL=1的IGMPv2离开报文，其组地址域为225.1.1.1。观察交换机组播组成员变化\n                   测试步骤8:   停止发送步骤7中的报文；\n                   测试步骤9:   检查DUT配置，看是否支持IGMPv1、IGMPv2、IGMPv3\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_up, Version='IGMPV2')\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interfaces_up)\n\n    # 创建组播组\n    multicast_group = create_multicast_group(Start='225.1.1.1')\n\n    # IGMP协议会话创建组成员关系\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=port_down, Version='IGMPV2')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_down)\n\n    # 创建IGMP绑定流\n\n    # point = get_layer_from_interfaces(Interfaces=interfaces_down)\n    #\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints='224.0.0', Bidirection=False)\n\n\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        Rate=100,\n    #                        Unit='FRAME_PER_SEC',\n    #                        TransmitMode=\"STEP\",\n    #                        Frames=20)\n\n\n    #创建IGMPv2报文\n    # stream1 = add_stream(Ports=port_up, Names=f'igmpv2_report')\n    # edit_stream(Stream=stream1, FixedLength=128)\n    # create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4','igmpv2'])\n    # edit_header_ipv4(Stream=stream1, Source='192.168.1.100', Destination= '225.1.1.1', TTl=1)\n    #\n    # stream2 = add_stream(Ports=port_up, Names=f'igmpv2_query')\n    # edit_stream(Stream=stream2, FixedLength=128)\n    # create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4','igmpv2query'])\n    # edit_header_ipv4(Stream=stream2, Source='192.168.1.100', Destination= '224.0.0.2', TTl=1)\n\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        #停止协议\n        stop_protocol()\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_igmp:创建IGMP协议会话对象;\ncreate_igmp_querier:创建IGMP Querier协议会话对象;\nedit_igmp:编辑IGMP协议会话对象;\nedit_igmp_querier:编辑IGMP Querier协议会话对象;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  }
]
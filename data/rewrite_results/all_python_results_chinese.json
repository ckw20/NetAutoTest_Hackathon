[
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_BroadcastForwarding.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastForwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型\",\n  \"子任务2\": \"预约测试仪表端口，强制占用指定物理位置端口\",\n  \"子任务3\": \"创建RFC2889测试套件，选择广播帧转发测试项\",\n  \"子任务4\": \"关联测试套件使用的测试仪表端口\",\n  \"子任务5\": \"在预约端口上创建以太网接口\",\n  \"子任务6\": \"获取接口的以太网层配置对象\",\n  \"子任务7\": \"创建测试套件流量，配置源/目的端点及单向传输\",\n  \"子任务8\": \"配置测试套件时延参数：FIFO模式，前后延迟时间\",\n  \"子任务9\": \"配置测试结果保存路径\",\n  \"子任务10\": \"配置地址学习参数：学习频率、速率、重复次数及延迟\",\n  \"子任务11\": \"配置测试时长参数：试验次数、突发模式及计数\",\n  \"子任务12\": \"配置帧长度参数：自定义64字节帧\",\n  \"子任务13\": \"配置负载参数：步进模式，设置下限/上限/步长值\",\n  \"子任务14\": \"配置突发帧数参数：自定义模式设置帧数\",\n  \"子任务15\": \"配置自定义测试结果文件名及时间戳选项\",\n  \"子任务16\": \"生成测试套件智能脚本\",\n  \"子任务17\": \"保存当前测试配置文件\",\n  \"子任务18\": \"执行测试套件，设置超时时间并启用分析器\",\n  \"子任务19\": \"从测试结果数据库获取RFC2889测试结果数据\",\n  \"子任务20\": \"格式化测试结果为二维表格输出\",\n  \"子任务21\": \"验证测试结果是否符合预期：正确测出设备地址缓存容量\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastForwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_AddressLearningRate.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的地址学习速率\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项地址学习速率;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressLearningRate'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *地址学习速率参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 地址学习速率和地址数量\n    edit_benchmark_address_learning_rate(Config=Config, MinRateCount=1000, MaxRateCount=5000, InitRateCount=5000,\n                                         Resolution=2, AgingTime=30, AddressCount=5000)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='addressLearningRate',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_address_learning_rate:编辑RFC2889测试套件地址容量测试项参数",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型（如DarYu）。\",\n  \"子任务2\": \"预约测试仪表端口，强制占用指定物理位置（如//10.0.11.191/1/5和//10.0.11.191/1/6）。\",\n  \"子任务3\": \"创建RFC2889测试套件，选择地址学习速率测试项。\",\n  \"子任务4\": \"关联测试套件与预约的端口，建立端口映射关系。\",\n  \"子任务5\": \"在预约端口上创建以太网接口层（eth）。\",\n  \"子任务6\": \"从接口中提取以太网层对象，作为流量端点。\",\n  \"子任务7\": \"创建测试套件流量流，配置源/目的端点及单向传输模式。\",\n  \"子任务8\": \"配置测试时间参数：设置FIFO时延（延迟前2秒，延迟后10秒）。\",\n  \"子任务9\": \"配置测试结果保存路径（如D:/test）。\",\n  \"子任务10\": \"设置测试时长参数：指定试验次数为1。\",\n  \"子任务11\": \"配置帧长参数：使用自定义帧长64字节。\",\n  \"子任务12\": \"配置地址学习速率参数：设置最小速率1000、最大速率5000、初始速率5000、分辨率2、老化时间30秒、地址数量5000。\",\n  \"子任务13\": \"配置自定义结果文件名：启用自定义名称（addressLearningRate），添加时间戳。\",\n  \"子任务14\": \"生成测试套件智能脚本。\",\n  \"子任务15\": \"保存当前测试配置文件（.xcfg格式）。\",\n  \"子任务16\": \"执行测试套件，启用结果分析器，设置超时1200秒。\",\n  \"子任务17\": \"从测试结果数据库中获取RFC2889格式的原始结果数据。\",\n  \"子任务18\": \"格式化测试结果为二维表格形式。\",\n  \"子任务19\": \"验证测试结果是否正确输出设备地址缓存容量，判断测试通过/失败状态。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的地址学习速率\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项地址学习速率;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressLearningRate'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *地址学习速率参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 地址学习速率和地址数量\n    edit_benchmark_address_learning_rate(Config=Config, MinRateCount=1000, MaxRateCount=5000, InitRateCount=5000,\n                                         Resolution=2, AgingTime=30, AddressCount=5000)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='addressLearningRate',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_address_learning_rate:编辑RFC2889测试套件地址容量测试项参数;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc3918_ScaledGroupForwarding.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定再DUT/SUT在一定数量端口加入不同数量的组播组时的转发率\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项组转发矩阵测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置组转发矩阵;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成组转发矩阵测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['scaledGroupForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=2, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed',\n                                   DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置组转发矩阵* ===============\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', MinGroup=10, MaxGroup=50)\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True,\n                                    ResultFileName='Rfc3918Scaledgroupforwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='scaledGroupForwarding')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数",
      "edit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组",
      "edit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他",
      "edit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型\",\n  \"子任务2\": \"预约测试仪表端口，强制占用指定物理位置端口\",\n  \"子任务3\": \"创建RFC3918测试套件，选择组转发矩阵测试项\",\n  \"子任务4\": \"关联测试套件与预约端口，建立端口映射关系\",\n  \"子任务5\": \"在预约端口上创建IPv4接口，配置IP地址和网关\",\n  \"子任务6\": \"创建测试套件流量，使用IPv4层作为源和目的端点，配置单向流\",\n  \"子任务7\": \"配置组播基本参数：IGMP版本、组播组地址范围、加入离开延迟、组分配模式\",\n  \"子任务8\": \"配置传输层参数：UDP头、随机端口号\",\n  \"子任务9\": \"配置组播流参数：TOS值、TTL、优先级\",\n  \"子任务10\": \"配置地址学习参数：学习频率、ARP使能、学习速率和重复次数\",\n  \"子任务11\": \"配置测试时长参数：试验次数、突发模式\",\n  \"子任务12\": \"配置帧长度参数：步进模式、最小/最大帧长范围\",\n  \"子任务13\": \"配置时延参数：FIFO时延类型、测试后延迟时间\",\n  \"子任务14\": \"配置其他组播参数：失败停止条件、验证频率、持续时间、发送速率\",\n  \"子任务15\": \"配置结果保存路径\",\n  \"子任务16\": \"配置组播组数量循环参数：随机模式、最小/最大组数量\",\n  \"子任务17\": \"配置流量负载循环参数：百分比单位、随机模式、最小/最大负载值\",\n  \"子任务18\": \"配置自定义结果文件名格式，启用时间戳\",\n  \"子任务19\": \"生成测试套件智能脚本\",\n  \"子任务20\": \"验证智能脚本是否成功生成组转发矩阵测试项\",\n  \"子任务21\": \"保存测试配置文件到指定路径\",\n  \"子任务22\": \"执行测试套件，设置超时时间和分析器\",\n  \"子任务23\": \"获取组转发矩阵测试结果数据\",\n  \"子任务24\": \"格式化测试结果为二维表格并输出\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定再DUT/SUT在一定数量端口加入不同数量的组播组时的转发率\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项组转发矩阵测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置组转发矩阵;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成组转发矩阵测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['scaledGroupForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=2, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed',\n                                   DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置组转发矩阵* ===============\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', MinGroup=10, MaxGroup=50)\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True,\n                                    ResultFileName='Rfc3918Scaledgroupforwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='scaledGroupForwarding')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数;\nedit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组;\nedit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他;\nedit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_BackToBack.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备背靠背测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2544向导, 选择背靠背测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址缓存容量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "import pandas\n\nfrom TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2544', Items=['backtoback'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth', 'ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth', 'ipv4'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置rfc2544* ===============\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_latency(Configs=Config, Type='FILO', DelayBefore=1, DelayAfter=2)\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='tcp')\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *配置背靠背* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[128])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 时间阈值\n    edit_benchmark_backtoback_binary_search(Config=Config, MinDuration=0.01)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='backtoback',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2544')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n    pandas.to_excel(tmp, index=False)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约测试仪表端口，强制占用指定物理位置。\",\n  \"子任务3\": \"创建RFC2544测试套件，选择背靠背测试类型。\",\n  \"子任务4\": \"关联测试套件与已预约的仪表端口。\",\n  \"子任务5\": \"在端口1创建以太网和IPv4协议栈接口。\",\n  \"子任务6\": \"在端口2创建以太网和IPv4协议栈接口。\",\n  \"子任务7\": \"从端口1接口获取IPv4层对象作为源端点。\",\n  \"子任务8\": \"从端口2接口获取IPv4层对象作为目的端点。\",\n  \"子任务9\": \"创建测试流量流，配置为单向IPv4流量。\",\n  \"子任务10\": \"配置地址学习参数：单次学习且禁用ARP。\",\n  \"子任务11\": \"配置延迟参数：类型FILO，前延迟1秒，后延迟2秒。\",\n  \"子任务12\": \"配置传输层协议为TCP。\",\n  \"子任务13\": \"设置测试结果存储路径。\",\n  \"子任务14\": \"配置试验次数为1次。\",\n  \"子任务15\": \"配置测试帧长为128字节（自定义长度）。\",\n  \"子任务16\": \"配置流量负载：步进模式，起始10%，结束20%，步长10%。\",\n  \"子任务17\": \"配置背靠背二进制搜索参数：最小持续时间0.01秒。\",\n  \"子任务18\": \"配置测试结果文件名格式：自定义名称+时间戳。\",\n  \"子任务19\": \"生成测试套件智能脚本。\",\n  \"子任务20\": \"保存当前测试配置到.xcfg文件。\",\n  \"子任务21\": \"执行测试套件，启用分析器，超时1200秒。\",\n  \"子任务22\": \"获取RFC2544测试结果数据库。\",\n  \"子任务23\": \"格式化测试结果为二维表格。\",\n  \"子任务24\": \"导出测试结果到Excel文件。\",\n  \"子任务25\": \"验证测试结果是否准确测量设备地址缓存容量。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备背靠背测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2544向导, 选择背靠背测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址缓存容量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  import pandas\n\nfrom TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2544', Items=['backtoback'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth', 'ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth', 'ipv4'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置rfc2544* ===============\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_latency(Configs=Config, Type='FILO', DelayBefore=1, DelayAfter=2)\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='tcp')\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *配置背靠背* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[128])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 时间阈值\n    edit_benchmark_backtoback_binary_search(Config=Config, MinDuration=0.01)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='backtoback',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2544')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n    pandas.to_excel(tmp, index=False)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_Congestion.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的拥塞控制\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项拥塞控制;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 4 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 5 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_congested, port_uncongested = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['congestionControl'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_1, port_2, port_congested, port_uncongested])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_1, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_2, Layers=['eth'])\n    interfaces_3 = create_interface(Port=port_congested, Layers=['eth'])\n    interfaces_4 = create_interface(Port=port_uncongested, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')[0]\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')[0]\n    point_congested = get_layer_from_interfaces(Interfaces=interfaces_3, Layer='eth')[0]\n    point_uncongested = get_layer_from_interfaces(Interfaces=interfaces_4, Layer='eth')[0]\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=[point_1, point_2],\n                                       DstPoints=[point_congested, point_uncongested], Mode='congestion')\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *拥塞控制参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='congestionControl',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约指定位置的测试仪表端口，并强制占用。\",\n  \"子任务3\": \"创建RFC2889测试套件，选择拥塞控制测试项。\",\n  \"子任务4\": \"关联测试套件与预约的四个端口。\",\n  \"子任务5\": \"在所有预约端口上创建以太网接口层。\",\n  \"子任务6\": \"获取各接口的以太网封装层对象。\",\n  \"子任务7\": \"创建测试流量，指定源接口和目的接口，设置拥塞模式。\",\n  \"子任务8\": \"配置测试套件时延参数（FIFO类型，前后延迟时间）。\",\n  \"子任务9\": \"配置测试结果保存路径。\",\n  \"子任务10\": \"配置地址学习参数（学习频率、速率、重复次数及时延）。\",\n  \"子任务11\": \"设置测试时长参数（试验次数、突发模式、帧计数）。\",\n  \"子任务12\": \"配置测试帧长度（自定义64字节）。\",\n  \"子任务13\": \"设置流量负载参数（步进模式，起始终止负载及步长）。\",\n  \"子任务14\": \"配置突发帧数参数（自定义值）。\",\n  \"子任务15\": \"设置自定义测试结果文件名并添加时间戳。\",\n  \"子任务16\": \"生成测试套件的智能脚本。\",\n  \"子任务17\": \"保存当前测试配置文件。\",\n  \"子任务18\": \"执行测试套件，启用分析器并设置超时时间。\",\n  \"子任务19\": \"从测试结果数据库中获取RFC2889测试数据。\",\n  \"子任务20\": \"格式化测试结果为二维表格形式。\",\n  \"子任务21\": \"验证测试结果中设备地址缓存容量测量值是否符合预期。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的拥塞控制\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项拥塞控制;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 4 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 5 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_congested, port_uncongested = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['congestionControl'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_1, port_2, port_congested, port_uncongested])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_1, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_2, Layers=['eth'])\n    interfaces_3 = create_interface(Port=port_congested, Layers=['eth'])\n    interfaces_4 = create_interface(Port=port_uncongested, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')[0]\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')[0]\n    point_congested = get_layer_from_interfaces(Interfaces=interfaces_3, Layer='eth')[0]\n    point_uncongested = get_layer_from_interfaces(Interfaces=interfaces_4, Layer='eth')[0]\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=[point_1, point_2],\n                                       DstPoints=[point_congested, point_uncongested], Mode='congestion')\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *拥塞控制参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='congestionControl',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_throughput.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的吞吐量\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2544向导, 选择测试项吞吐量;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 吞吐量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备吞吐量;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='custom')\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约指定位置的测试仪表端口。\",\n  \"子任务3\": \"在上行端口创建包含IPv4层的接口。\",\n  \"子任务4\": \"在下行端口创建包含IPv4层的接口。\",\n  \"子任务5\": \"配置上行端口接口的IPv4层参数（IP地址和网关）。\",\n  \"子任务6\": \"配置下行端口接口的IPv4层参数（IP地址和网关）。\",\n  \"子任务7\": \"从上行端口接口获取IPv4层对象。\",\n  \"子任务8\": \"从下行端口接口获取IPv4层对象。\",\n  \"子任务9\": \"创建双向绑定流，源为上行IPv4对象，目的为下行IPv4对象。\",\n  \"子任务10\": \"创建RFC2544测试套件，指定测试项为吞吐量。\",\n  \"子任务11\": \"关联测试套件使用的上行和下行端口。\",\n  \"子任务12\": \"配置测试套件使用已创建的绑定流。\",\n  \"子任务13\": \"配置测试套件的地址学习设置（频率为once，禁用ARP）。\",\n  \"子任务14\": \"配置测试套件的测试时长（count=1）。\",\n  \"子任务15\": \"配置测试套件的帧类型为custom。\",\n  \"子任务16\": \"配置吞吐量搜索参数（初始值、下限、上限）。\",\n  \"子任务17\": \"生成测试套件脚本。\",\n  \"子任务18\": \"保存测试配置文件到指定路径。\",\n  \"子任务19\": \"执行测试并获取吞吐量结果。\",\n  \"子任务20\": \"验证设备吞吐量测量结果是否符合预期。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的吞吐量\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2544向导, 选择测试项吞吐量;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 吞吐量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备吞吐量;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='custom')\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_imix.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查BLDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 获取仪表已有imix模板\n    imix_template = [get_imix_from_name(Name='Default'), get_imix_from_name(Name='4-Point'),\n                     get_imix_from_name(Name='IPSEC'), get_imix_from_name(Name='TCPv4')]\n\n    # 创建新imix模板\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_02')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_03')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    # 创建RFC2544 Throughput测试套件\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='imix', ImixTemplates=imix_template)\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n    imix = create_imix(Name='CTRI_IMIX424')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "add_imix_distribution_frame:在Imix模板添加自定义帧长",
      "create_imix:创建流量Imix模板",
      "get_imix_from_name:通过Imix模板名称获取流量Imix模板对象",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu（使用init_tester函数）\",\n  \"子任务2\": \"预约8个离线测试端口（使用reserve_port函数，指定端口位置参数）\",\n  \"子任务3\": \"在预约端口上创建网络接口（使用create_interface函数，每个端口创建独立接口）\",\n  \"子任务4\": \"配置客户端侧接口参数（使用edit_interface函数，设置IPv4地址和网关）\",\n  \"子任务5\": \"配置提供商侧接口参数（使用edit_interface函数，设置IPv4地址和网关）\",\n  \"子任务6\": \"创建双向绑定流量（使用add_stream函数，指定源/目的接口及Bidirection=True）\",\n  \"子任务7\": \"创建LDP VPLS向导测试套件（使用create_benchmark函数，类型指定为VPLS相关参数）\",\n  \"子任务8\": \"关联测试套件与端口（使用relate_benchmark_ports函数，绑定所有预约端口）\",\n  \"子任务9\": \"配置测试套件使用已创建流量（使用benchmark_stream_use_exist函数，关联步骤6的流量）\",\n  \"子任务10\": \"配置提供商侧路由器参数（通过编辑向导配置路由协议相关参数）\",\n  \"子任务11\": \"配置VPLS实例参数（通过编辑向导设置VPLS ID等关键参数）\",\n  \"子任务12\": \"配置Host主机参数（通过编辑向导设置主机IP/MAC地址）\",\n  \"子任务13\": \"生成LDP VPLS向导完整配置（使用expand_benchmark函数）\",\n  \"子任务14\": \"保存测试配置文件（使用save_case函数，指定文件路径）\",\n  \"子任务15\": \"验证配置生成过程无异常（检查API执行状态，确认无错误信息输出）\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查BLDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 获取仪表已有imix模板\n    imix_template = [get_imix_from_name(Name='Default'), get_imix_from_name(Name='4-Point'),\n                     get_imix_from_name(Name='IPSEC'), get_imix_from_name(Name='TCPv4')]\n\n    # 创建新imix模板\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_02')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_03')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    # 创建RFC2544 Throughput测试套件\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='imix', ImixTemplates=imix_template)\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n    imix = create_imix(Name='CTRI_IMIX424')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nadd_imix_distribution_frame:在Imix模板添加自定义帧长;\ncreate_imix:创建流量Imix模板;\nget_imix_from_name:通过Imix模板名称获取流量Imix模板对象;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_AddressCachingCapacity.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的地址缓存容量\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项地址缓存容量;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址缓存容量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressCachingCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64, 128])\n    # 提供学习的地址数和地址学习速率\n    edit_benchmark_address_learning_capacity(Config=Config, MinAddressCount=1000, MaxAddressCount=5000,\n                                             InitAddressCount=5000, Resolution=2, AgingTime=30, LearningRate=1000)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='addressCachingCapacity',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_address_learning_capacity:编辑RFC2889测试套件地址容量测试项参数",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表，指定仪表型号为DarYu或其他输入参数\",\n  \"子任务2\": \"预约两个指定位置的测试端口\",\n  \"子任务3\": \"创建RFC2889测试套件，选择地址缓存容量测试项\",\n  \"子任务4\": \"关联测试套件使用的两个预约端口\",\n  \"子任务5\": \"在第一个端口创建以太网接口层\",\n  \"子任务6\": \"在第二个端口创建以太网接口层\",\n  \"子任务7\": \"从接口对象中提取以太网层对象作为流量端点\",\n  \"子任务8\": \"创建测试套件流量，配置源和目的端点，双向流量设为False\",\n  \"子任务9\": \"配置测试延迟参数：类型FIFO，延迟前2秒，延迟后10秒\",\n  \"子任务10\": \"配置测试结果保存路径为D:/test\",\n  \"子任务11\": \"设置地址缓存容量测试参数：试验次数1次\",\n  \"子任务12\": \"设置测试帧长：自定义64和128字节\",\n  \"子任务13\": \"配置地址学习参数：最小地址数1000，最大5000，初始5000，分辨率2，老化时间30秒，学习速率1000\",\n  \"子任务14\": \"配置自定义测试结果文件名：启用自定义，文件名addressCachingCapacity，添加时间戳\",\n  \"子任务15\": \"生成测试套件智能脚本\",\n  \"子任务16\": \"保存配置文件到当前目录xcfg子目录\",\n  \"子任务17\": \"执行测试套件：模式0，超时1200秒，启用分析器\",\n  \"子任务18\": \"从结果数据库获取RFC2889测试结果数据\",\n  \"子任务19\": \"格式化测试结果为二维表格形式\",\n  \"子任务20\": \"输出格式化后的测试结果\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的地址缓存容量\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项地址缓存容量;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址缓存容量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressCachingCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64, 128])\n    # 提供学习的地址数和地址学习速率\n    edit_benchmark_address_learning_capacity(Config=Config, MinAddressCount=1000, MaxAddressCount=5000,\n                                             InitAddressCount=5000, Resolution=2, AgingTime=30, LearningRate=1000)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='addressCachingCapacity',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_address_learning_capacity:编辑RFC2889测试套件地址容量测试项参数;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc3918_MulticastJoinLeaveLatency.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定再DUT/SUT收到IGMP陈工加入离开组消息开始，DUT/SUT开始/停止转发多播帧需要的时间\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项加入离开组时延测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置加入离开组时延;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成加入离开组时延测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastJoinLeaveLatency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='random', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed', DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置加入离开组时延* ===============\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', FixedGroup=10, MinGroup=10, MaxGroup=50,\n                                              StartGroup=10, EndGroup=50, StepGroup=10, CustomGroup=(10, 20, 100))\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 延迟设置\n    edit_benchmark_multicast_join_leave_delay(Config=Config, DelayBetweenJoinAndStartStream=20, DelayBetweenJoinAndLeave=15)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='Rfc3918MixedThroughput',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastThroughput')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数",
      "edit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组",
      "edit_benchmark_multicast_join_leave_delay:RFC3918测试套件-配置加入离开组时延",
      "edit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他",
      "edit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约两个测试端口，强制占用指定位置。\",\n  \"子任务3\": \"创建RFC3918测试向导，选择测试项为'加入离开组时延测试'。\",\n  \"子任务4\": \"关联测试套件与预约的测试端口。\",\n  \"子任务5\": \"在端口1创建IPv4接口并配置地址(1.1.1.1)和网关(1.1.1.2)。\",\n  \"子任务6\": \"在端口2创建IPv4接口并配置地址(1.1.1.2)和网关(1.1.1.1)。\",\n  \"子任务7\": \"从接口获取IPv4层对象作为流端点。\",\n  \"子任务8\": \"创建测试套件流量，指定IPv4类型、单向非对称模式。\",\n  \"子任务9\": \"配置组播基础参数：IGMPv2版本、组播组地址范围(225.0.0.1起)、加入/离开延迟(15ms)、组分配模式(even)。\",\n  \"子任务10\": \"配置传输层参数：UDP协议、启用随机源/目的端口。\",\n  \"子任务11\": \"配置流参数：TOS=2、TTL=11、优先级=1。\",\n  \"子任务12\": \"配置地址学习参数：帧触发模式、学习速率1000fps、ARP使能。\",\n  \"子任务13\": \"配置测试时长：单次突发模式、计数1次。\",\n  \"子任务14\": \"配置帧长度：随机范围128-512字节。\",\n  \"子任务15\": \"配置时延类型：FIFO测量模式。\",\n  \"子任务16\": \"配置组播其他参数：失败停止、拓扑变化验证、持续时长2秒、发送速率1000fps。\",\n  \"子任务17\": \"配置结果保存路径为'D:/test'。\",\n  \"子任务18\": \"配置延迟后等待时间20ms。\",\n  \"子任务19\": \"配置组播组数量循环：随机模式(10-50组)。\",\n  \"子任务20\": \"配置流量负载循环：百分比负载随机模式(10%-50%)。\",\n  \"子任务21\": \"配置加入/离开组延迟参数：加入到开始流延迟20ms，加入离开间隔15ms。\",\n  \"子任务22\": \"配置自定义结果文件名格式并添加时间戳。\",\n  \"子任务23\": \"生成智能脚本扩展测试套件。\",\n  \"子任务24\": \"保存测试配置到指定路径的.xcfg文件。\",\n  \"子任务25\": \"执行测试套件，设置3600秒超时并启用分析器。\",\n  \"子任务26\": \"获取测试结果中'加入离开组时延'数据项。\",\n  \"子任务27\": \"格式化测试结果为二维表格并输出。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定再DUT/SUT收到IGMP陈工加入离开组消息开始，DUT/SUT开始/停止转发多播帧需要的时间\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项加入离开组时延测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置加入离开组时延;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成加入离开组时延测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastJoinLeaveLatency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='random', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed', DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置加入离开组时延* ===============\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', FixedGroup=10, MinGroup=10, MaxGroup=50,\n                                              StartGroup=10, EndGroup=50, StepGroup=10, CustomGroup=(10, 20, 100))\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 延迟设置\n    edit_benchmark_multicast_join_leave_delay(Config=Config, DelayBetweenJoinAndStartStream=20, DelayBetweenJoinAndLeave=15)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='Rfc3918MixedThroughput',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastThroughput')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数;\nedit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组;\nedit_benchmark_multicast_join_leave_delay:RFC3918测试套件-配置加入离开组时延;\nedit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他;\nedit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_ErroredFrameFilter.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的错误帧过滤\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项错误帧过滤;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['erroredFrameFilter'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *错误帧过滤参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 错误以太帧、突发和帧长设置\n    edit_benchmark_errored_frame_filtering(Config=Config, CrcTested=True, CrcFrameLength=128,\n                                           UndersizedTested=True, UndersizedFrameLength=58,\n                                           OversizedTested=True, OversizedFrameLength=1600,\n                                           MaxLegalFrameLength=1518, BurstSize=100)\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='erroredFrameFilter',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_errored_frame_filtering:编辑RFC2889测试套件错误帧过滤测试项参数",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约测试端口，获取端口控制权。\",\n  \"子任务3\": \"创建RFC2889测试套件，选择错误帧过滤测试项。\",\n  \"子任务4\": \"关联测试套件与预约的物理端口。\",\n  \"子任务5\": \"在测试端口上创建以太网接口层。\",\n  \"子任务6\": \"获取接口的以太层对象用于流量构造。\",\n  \"子任务7\": \"创建测试流量流，配置源和目的端点。\",\n  \"子任务8\": \"配置测试时延参数（FIFO模式、延迟前后时间）。\",\n  \"子任务9\": \"设置测试结果保存路径。\",\n  \"子任务10\": \"配置地址学习参数（学习频率、速率、重复次数）。\",\n  \"子任务11\": \"设置测试时长参数（试验次数、突发模式、帧计数）。\",\n  \"子任务12\": \"配置错误帧过滤参数（CRC/过小帧/过大帧的测试状态、帧长度范围、最大合法帧长、突发尺寸）。\",\n  \"子任务13\": \"配置流量负载参数（步进模式、起始/结束/步长负载值）。\",\n  \"子任务14\": \"设置自定义测试结果文件名格式（包含时间戳）。\",\n  \"子任务15\": \"生成测试套件智能脚本。\",\n  \"子任务16\": \"保存当前测试配置文件。\",\n  \"子任务17\": \"执行测试套件并启动分析器（1200秒超时）。\",\n  \"子任务18\": \"从结果数据库中获取RFC2889测试数据。\",\n  \"子任务19\": \"格式化测试结果为二维表格形式。\",\n  \"子任务20\": \"验证测试结果是否正确反映设备地址缓存容量。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的错误帧过滤\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项错误帧过滤;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['erroredFrameFilter'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *错误帧过滤参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 错误以太帧、突发和帧长设置\n    edit_benchmark_errored_frame_filtering(Config=Config, CrcTested=True, CrcFrameLength=128,\n                                           UndersizedTested=True, UndersizedFrameLength=58,\n                                           OversizedTested=True, OversizedFrameLength=1600,\n                                           MaxLegalFrameLength=1518, BurstSize=100)\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='erroredFrameFilter',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_errored_frame_filtering:编辑RFC2889测试套件错误帧过滤测试项参数;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc3918_MixedThroughput.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 如RFC2432规定，混合吞吐量测试是确定想一定数量的接口同时发送单播和组播流量时，DUT/SUT的吞吐量\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项混合吞吐量测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置混合吞吐量;\n                   测试步骤9: 配置单播流量;\n                   测试步骤10: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤10 正确生成混合吞吐量测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['mixedThroughput'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed', DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置混合吞吐量* ===============\n    # 搜索算法\n    edit_benchmark_search(Config=Config, Mode='step', Lower=1, Upper=50, Init=10, Step=10, Resolution=1, Ratio=50,\n                          Acceptance=0, Ignore=False, EnableLatency=False, Maxlatency=30)\n    # 组播流百分比\n    edit_benchmark_multicast_traffic_ratio_loop(Config=Config, LoopMode='random', MinRatio=10, MaxRatio=50)\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', MinGroup=10, MaxGroup=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='Rfc3918MixedThroughput',\n                                    AddTimeStamp=True)\n\n    # =============== *配置单播流量* ===============\n    unicast_streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=False)\n    edit_benchmark_multicast_mixed_throughput_unicast_streams(Config=Config, Streams=unicast_streams)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='mixedThroughput')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数",
      "edit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组",
      "edit_benchmark_multicast_mixed_throughput_unicast_streams:RFC3918测试套件组播混合吞吐量-配置单播流量",
      "edit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他",
      "edit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置",
      "edit_benchmark_multicast_traffic_ratio_loop:RFC3918测试套件配置组播混合吞吐量-组播百分比设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表平台，指定仪表型号为DarYu。\",\n  \"子任务2\": \"预约测试仪表端口，强制占用指定物理位置。\",\n  \"子任务3\": \"创建RFC3918测试套件，选择混合吞吐量测试项。\",\n  \"子任务4\": \"将预约的端口关联到测试套件。\",\n  \"子任务5\": \"在预约的上行端口创建IPv4接口。\",\n  \"子任务6\": \"在预约的下行端口创建IPv4接口。\",\n  \"子任务7\": \"配置上行端口IPv4接口地址和网关。\",\n  \"子任务8\": \"配置下行端口IPv4接口地址和网关。\",\n  \"子任务9\": \"从接口获取IPv4层对象作为流量端点。\",\n  \"子任务10\": \"为测试套件创建IPv4流量，指定源/目的端点及多对多模式。\",\n  \"子任务11\": \"配置组播基本参数：IGMPv2版本、组播组地址范围、加入/离开延迟。\",\n  \"子任务12\": \"配置传输层协议为UDP并启用随机端口。\",\n  \"子任务13\": \"配置流参数：TOS值、TTL和优先级。\",\n  \"子任务14\": \"配置地址学习参数：学习频率、速率、ARP设置。\",\n  \"子任务15\": \"配置测试时长：单次突发模式。\",\n  \"子任务16\": \"配置帧长度参数：步进模式及长度范围。\",\n  \"子任务17\": \"配置时延测量类型为FIFO。\",\n  \"子任务18\": \"配置组播其他参数：停止条件、验证频率、发送速率。\",\n  \"子任务19\": \"配置测试结果保存路径。\",\n  \"子任务20\": \"配置延迟后等待时间。\",\n  \"子任务21\": \"配置吞吐量搜索算法：步进模式及阈值参数。\",\n  \"子任务22\": \"配置组播流量百分比循环：随机模式及比例范围。\",\n  \"子任务23\": \"配置组播组数量循环：随机模式及组数范围。\",\n  \"子任务24\": \"配置自定义结果文件名并启用时间戳。\",\n  \"子任务25\": \"创建单播流量并绑定源/目的端点。\",\n  \"子任务26\": \"为混合吞吐量测试配置单播流量。\",\n  \"子任务27\": \"生成智能脚本扩展测试套件配置。\",\n  \"子任务28\": \"验证智能脚本生成操作是否成功完成。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 如RFC2432规定，混合吞吐量测试是确定想一定数量的接口同时发送单播和组播流量时，DUT/SUT的吞吐量\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项混合吞吐量测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置混合吞吐量;\n                   测试步骤9: 配置单播流量;\n                   测试步骤10: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤10 正确生成混合吞吐量测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['mixedThroughput'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed', DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置混合吞吐量* ===============\n    # 搜索算法\n    edit_benchmark_search(Config=Config, Mode='step', Lower=1, Upper=50, Init=10, Step=10, Resolution=1, Ratio=50,\n                          Acceptance=0, Ignore=False, EnableLatency=False, Maxlatency=30)\n    # 组播流百分比\n    edit_benchmark_multicast_traffic_ratio_loop(Config=Config, LoopMode='random', MinRatio=10, MaxRatio=50)\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', MinGroup=10, MaxGroup=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='Rfc3918MixedThroughput',\n                                    AddTimeStamp=True)\n\n    # =============== *配置单播流量* ===============\n    unicast_streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=False)\n    edit_benchmark_multicast_mixed_throughput_unicast_streams(Config=Config, Streams=unicast_streams)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='mixedThroughput')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数;\nedit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组;\nedit_benchmark_multicast_mixed_throughput_unicast_streams:RFC3918测试套件组播混合吞吐量-配置单播流量;\nedit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他;\nedit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置;\nedit_benchmark_multicast_traffic_ratio_loop:RFC3918测试套件配置组播混合吞吐量-组播百分比设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_Lantency.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备时延测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2544向导, 选择时延测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址缓存容量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2544', Items=['latency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth', 'ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth', 'ipv4'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置rfc2544* ===============\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_latency(Configs=Config, Type='FILO', DelayBefore=1, DelayAfter=2)\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='tcp')\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *配置时延* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[128])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='latency',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2544')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu\",\n  \"子任务2\": \"预约测试仪表的两个端口，并强制占用\",\n  \"子任务3\": \"创建RFC2544测试套件，选择时延测试项\",\n  \"子任务4\": \"将预约端口关联到测试套件\",\n  \"子任务5\": \"在预约端口上创建以太网和IPv4接口\",\n  \"子任务6\": \"获取端口接口的IPv4层对象\",\n  \"子任务7\": \"创建单向IPv4流量流，源为端口1，目的为端口2\",\n  \"子任务8\": \"配置地址缓存参数：学习频率为单次，禁用ARP\",\n  \"子任务9\": \"配置时延参数：类型为FILO，延迟前1秒，延迟后2秒\",\n  \"子任务10\": \"配置传输层协议为TCP\",\n  \"子任务11\": \"设置测试结果保存路径\",\n  \"子任务12\": \"配置测试次数为1次\",\n  \"子任务13\": \"配置帧长为128字节（自定义长度）\",\n  \"子任务14\": \"配置流量负载模式：步进模式，起始10%，结束20%，步长10%\",\n  \"子任务15\": \"配置测试结果文件名：启用自定义名称'latency'并添加时间戳\",\n  \"子任务16\": \"生成智能测试脚本\",\n  \"子任务17\": \"保存测试配置文件到指定路径\",\n  \"子任务18\": \"执行测试套件，设置超时1200秒并启用分析器\",\n  \"子任务19\": \"从测试结果数据库中获取RFC2544时延测试结果\",\n  \"子任务20\": \"格式化测试结果为二维表格\",\n  \"子任务21\": \"验证设备地址缓存容量参数设置的正确性\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备时延测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2544向导, 选择时延测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址缓存容量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2544', Items=['latency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth', 'ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth', 'ipv4'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置rfc2544* ===============\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_latency(Configs=Config, Type='FILO', DelayBefore=1, DelayAfter=2)\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='tcp')\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *配置时延* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[128])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='latency',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2544')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_Forwarding.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['forwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='forwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台（如DarYu）。\",\n  \"子任务2\": \"预约测试仪表端口，强制占用指定物理位置（如//10.0.11.191/1/5和//10.0.11.191/1/6）。\",\n  \"子任务3\": \"创建RFC2889测试套件，选择测试类型为转发（forwarding）。\",\n  \"子任务4\": \"关联测试套件与已预约的端口，建立端口映射关系。\",\n  \"子任务5\": \"在预约端口上创建以太网接口层（eth）。\",\n  \"子任务6\": \"获取接口的以太网层对象，用于流量配置。\",\n  \"子任务7\": \"创建测试套件流量，指定源和目的以太网层对象。\",\n  \"子任务8\": \"配置测试套件时间参数：时延类型为FIFO，延迟前2秒，延迟后10秒。\",\n  \"子任务9\": \"配置测试结果保存路径（如D:/test）。\",\n  \"子任务10\": \"配置地址学习参数：按trial频率学习，速率100，重复3次，延迟前5秒。\",\n  \"子任务11\": \"配置测试时长参数：试验1次，突发模式，计数100帧。\",\n  \"子任务12\": \"配置帧长参数：自定义帧长64字节。\",\n  \"子任务13\": \"配置负载搜索参数：步进模式，下限10%，上限20%，步长10%。\",\n  \"子任务14\": \"配置自定义测试结果名称：启用自定义文件名（如forwarding），添加时间戳。\",\n  \"子任务15\": \"生成测试套件智能脚本（扩展测试配置）。\",\n  \"子任务16\": \"保存当前测试配置文件到指定路径（xcfg格式）。\",\n  \"子任务17\": \"执行测试套件：模式0，超时1200秒，启用分析器。\",\n  \"子任务18\": \"从测试结果数据库获取RFC2889测试结果数据。\",\n  \"子任务19\": \"格式化测试结果为表格形式输出。\",\n  \"子任务20\": \"验证设备地址缓存容量测量结果是否符合预期。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['forwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='forwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TSN/tsn_qcr.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备背靠背测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建TSN Qcr向导;\n                   测试步骤3: 配置Qcr stream;\n                   测试步骤4: 配置Stream identification function;\n                   测试步骤5: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤5 向导配置生成成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(\n    ' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2 = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard = create_tsn_wizard(Type='qcr')\n\n    # =============== *创建Qcr stream* ===============\n    qcr_stream_config = create_tsn_qcr_stream(wizard, TalkerPort=port_1, ListenerPortList=port_2, Priority=3)\n\n    # =============== *配置Stream identification function* ===============\n    config_tsn_qcr_stream_identification_function(qcr_stream_config, StreamIdentificationFunction='IP_OCTUPLE_STREAM',\n                                                  SourceMacAddress='00:01:02:03:00:02',\n                                                  DestinationMacAddress='00:02:02:03:00:02', VlanId=100)\n\n    # =============== *生成向导配置* ===============\n    expand_tsn_wizard(Wizard=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约测试仪表的两个物理端口，确保端口可用性。\",\n  \"子任务3\": \"创建TSN Qcr向导，指定向导类型为'qcr'。\",\n  \"子任务4\": \"在向导中配置Qcr流，设置发送端口、接收端口列表和流优先级。\",\n  \"子任务5\": \"配置流的识别功能，指定识别方法为IP八元组，并设置源MAC地址、目的MAC地址及VLAN ID。\",\n  \"子任务6\": \"生成并应用向导配置，完成TSN Qcr流的部署。\",\n  \"子任务7\": \"验证向导配置是否成功生成，无错误信息输出。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备背靠背测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建TSN Qcr向导;\n                   测试步骤3: 配置Qcr stream;\n                   测试步骤4: 配置Stream identification function;\n                   测试步骤5: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤5 向导配置生成成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(\n    ' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2 = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard = create_tsn_wizard(Type='qcr')\n\n    # =============== *创建Qcr stream* ===============\n    qcr_stream_config = create_tsn_qcr_stream(wizard, TalkerPort=port_1, ListenerPortList=port_2, Priority=3)\n\n    # =============== *配置Stream identification function* ===============\n    config_tsn_qcr_stream_identification_function(qcr_stream_config, StreamIdentificationFunction='IP_OCTUPLE_STREAM',\n                                                  SourceMacAddress='00:01:02:03:00:02',\n                                                  DestinationMacAddress='00:02:02:03:00:02', VlanId=100)\n\n    # =============== *生成向导配置* ===============\n    expand_tsn_wizard(Wizard=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_BroadcastLatency.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧时延\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧时延;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastLatency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧时延参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastLatency',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约测试仪表的两个端口，并强制占用端口资源。\",\n  \"子任务3\": \"创建RFC2889测试套件，选择广播帧时延测试项。\",\n  \"子任务4\": \"将预约的端口关联到测试套件中。\",\n  \"子任务5\": \"在预约端口上创建以太网接口层。\",\n  \"子任务6\": \"获取接口的以太网层对象作为流量端点。\",\n  \"子任务7\": \"创建单向测试流量，源端为端口1的以太网层，目的端为端口2的以太网层。\",\n  \"子任务8\": \"配置测试时延参数：FIFO模式，延迟前2秒，延迟后10秒。\",\n  \"子任务9\": \"设置测试结果保存路径为D:/test。\",\n  \"子任务10\": \"配置地址学习参数：每次测试前学习，速率100帧/秒，重复3次，学习前延迟5秒。\",\n  \"子任务11\": \"配置测试时长参数：1次试验，突发模式，发送100帧。\",\n  \"子任务12\": \"配置帧长参数：自定义64字节帧长。\",\n  \"子任务13\": \"配置测试结果文件名：启用自定义名称'broadcastLatency'并添加时间戳。\",\n  \"子任务14\": \"生成测试套件智能脚本。\",\n  \"子任务15\": \"保存当前测试配置为xcfg文件。\",\n  \"子任务16\": \"执行测试套件，启用结果分析器，设置1200秒超时。\",\n  \"子任务17\": \"获取RFC2889类型测试结果数据。\",\n  \"子任务18\": \"格式化测试结果为二维表格。\",\n  \"子任务19\": \"验证广播帧时延测试结果是否符合预期。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧时延\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧时延;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastLatency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧时延参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastLatency',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc3918_MulticastThroughput.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定再DUT/SUT在一定数量端口加入不同数量的组播组时的转发率\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项聚合组播吞吐量测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置聚合组播吞吐量;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成聚合组播吞吐量测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastThroughput'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=2, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed', DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置聚合组播吞吐量* ===============\n    # 搜索算法\n    edit_benchmark_search(Config=Config, Mode='step', Lower=1, Upper=20, Init=10, Step=10, Resolution=1, Ratio=50,\n                          Acceptance=0, Ignore=False, EnableLatency=False, Maxlatency=30)\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', FixedGroup=10, MinGroup=10, MaxGroup=50,\n                                              StartGroup=10, EndGroup=50, StepGroup=10, CustomGroup=(10, 20, 100))\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='Rfc3918MulticastThroughput',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastThroughput')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数",
      "edit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组",
      "edit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他",
      "edit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表\",\n  \"子任务2\": \"预约指定位置的测试仪表端口\",\n  \"子任务3\": \"创建RFC3918测试套件，选择聚合组播吞吐量测试项\",\n  \"子任务4\": \"将预约端口关联到测试套件\",\n  \"子任务5\": \"在端口上创建IPv4接口并配置IP地址与网关\",\n  \"子任务6\": \"获取接口的IPv4层对象用于流量配置\",\n  \"子任务7\": \"创建测试流量，指定源和目的IPv4端点，单向模式\",\n  \"子任务8\": \"配置组播基本参数：IGMPv2版本、组播组地址范围、加入/离开延迟、组分配模式\",\n  \"子任务9\": \"配置传输层参数：UDP协议，启用随机端口\",\n  \"子任务10\": \"配置流参数：TOS=2，TTL=11，优先级=1\",\n  \"子任务11\": \"配置地址学习参数：按帧学习，启用ARP，指定学习速率和重复次数\",\n  \"子任务12\": \"配置测试时长：2次测试，突发模式\",\n  \"子任务13\": \"配置帧长度：步进模式，128-512字节范围\",\n  \"子任务14\": \"配置时延类型：FIFO模式\",\n  \"子任务15\": \"配置组播其他参数：失败停止，拓扑变化验证，2秒持续时间\",\n  \"子任务16\": \"配置结果保存路径\",\n  \"子任务17\": \"配置延迟后等待时间20秒\",\n  \"子任务18\": \"配置搜索算法：步进模式，1%-20%负载范围\",\n  \"子任务19\": \"配置组播组数量循环：随机模式，10-50组范围\",\n  \"子任务20\": \"配置自定义结果文件名并添加时间戳\",\n  \"子任务21\": \"生成智能测试脚本\",\n  \"子任务22\": \"验证是否成功生成聚合组播吞吐量测试项\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定再DUT/SUT在一定数量端口加入不同数量的组播组时的转发率\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项聚合组播吞吐量测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置聚合组播吞吐量;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成聚合组播吞吐量测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastThroughput'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=2, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed', DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置聚合组播吞吐量* ===============\n    # 搜索算法\n    edit_benchmark_search(Config=Config, Mode='step', Lower=1, Upper=20, Init=10, Step=10, Resolution=1, Ratio=50,\n                          Acceptance=0, Ignore=False, EnableLatency=False, Maxlatency=30)\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', FixedGroup=10, MinGroup=10, MaxGroup=50,\n                                              StartGroup=10, EndGroup=50, StepGroup=10, CustomGroup=(10, 20, 100))\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='Rfc3918MulticastThroughput',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastThroughput')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数;\nedit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组;\nedit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他;\nedit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/ospf_lsa/ospfv2_lsa_wizard.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查Ospfv2 Lsa向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Ospfv2会话;\n                   测试步骤3: 创建Ospfv2 Lsa向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Ospfv2 Lsa向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='ipv4')\n    interfaces_2 = create_interface(Port=Port_2, Layers='ipv4')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建Ospfv2会话\n    ospf_1 = create_ospf(Port=Port_1)\n    ospf_2 = create_ospf(Port=Port_2)\n\n    select_interface(Session=ospf_1, Interface=interfaces_1)\n    select_interface(Session=ospf_2, Interface=interfaces_2)\n\n    # 创建Ospfv2 lsa向导\n    wizard = create_ospfv2_lsa_wizard(Sessions=[ospf_1, ospf_2])\n\n    # 配置ospfv2拓扑\n    config_ospfv2_lsa_wizard_ospfv2_topo(Wizards=wizard, Type='GRID',\n                                         RowCount=10,\n                                         ColumnCount=20)\n\n    # 配置ospfv2\n    config_ospfv2_lsa_wizard_ospfv2(Wizards=wizard,\n                                    EnableTeOption=True,\n                                    EnableSegmentRouting=True)\n    te = config_ospfv2_lsa_wizard_ospfv2_te_option(Wizards=wizard,\n                                                   EnableGroup=True,\n                                                   Group=10)\n    sr = config_ospfv2_lsa_wizard_ospfv2_sr(Wizards=wizard,\n                                            SidLabelType='BIT32')\n\n    # 配置ospfv2 stub network\n    config_ospfv2_lsa_wizard_ospfv2_stub_network(Wizards=wizard,\n                                                 StubDistributionType='INTERNET',\n                                                 StubInternetPrefixLength=\n                                                 [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                  0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 30, 0.0, 0.0, 0.0, 0.0,\n                                                  0.0, 0.0, 0.0, 50]\n                                                 )\n\n    # 配置ospfv2 summary network\n    config_ospfv2_lsa_wizard_ospfv2_summary_route(Wizards=wizard,\n                                                  SummaryEmulated='NONE',\n                                                  SummarySimulated='ALL')\n\n    # 配置ospfv2 external network\n    config_ospfv2_lsa_wizard_ospfv2_external_route(Wizards=wizard,\n                                                   ExternalPrimaryMetric=20)\n\n    # 生成Ospfv2 Lsa向导配置\n    expand_ospfv2_lsa_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "create_ospf:创建OSPFv2协议会话对象"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个离线端口Port_1和Port_2，使用指定物理位置。\",\n  \"子任务3\": \"在Port_1上创建IPv4接口，并配置IP地址192.168.1.2及网关192.168.1.3。\",\n  \"子任务4\": \"在Port_2上创建IPv4接口，并配置IP地址192.168.1.3及网关192.168.1.2。\",\n  \"子任务5\": \"在Port_1上创建OSPFv2会话对象。\",\n  \"子任务6\": \"在Port_2上创建OSPFv2会话对象。\",\n  \"子任务7\": \"将Port_1的接口绑定到其OSPFv2会话。\",\n  \"子任务8\": \"将Port_2的接口绑定到其OSPFv2会话。\",\n  \"子任务9\": \"创建OSPFv2 LSA向导，关联两个OSPFv2会话。\",\n  \"子任务10\": \"配置OSPFv2拓扑为网格类型，设置行数10、列数20。\",\n  \"子任务11\": \"配置OSPFv2参数：启用TE选项和段路由功能。\",\n  \"子任务12\": \"配置OSPFv2 TE选项：启用组功能并设置组号为10。\",\n  \"子任务13\": \"配置OSPFv2段路由：设置SID标签类型为32位。\",\n  \"子任务14\": \"配置OSPFv2 Stub网络：设置分布类型为INTERNET并指定前缀长度数组。\",\n  \"子任务15\": \"配置OSPFv2汇总路由：设置模拟汇总类型为NONE，仿真汇总类型为ALL。\",\n  \"子任务16\": \"配置OSPFv2外部路由：设置主度量值为20。\",\n  \"子任务17\": \"生成OSPFv2 LSA向导配置并校验无异常。\",\n  \"子任务18\": \"保存测试配置文件到指定路径。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查Ospfv2 Lsa向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Ospfv2会话;\n                   测试步骤3: 创建Ospfv2 Lsa向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Ospfv2 Lsa向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='ipv4')\n    interfaces_2 = create_interface(Port=Port_2, Layers='ipv4')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建Ospfv2会话\n    ospf_1 = create_ospf(Port=Port_1)\n    ospf_2 = create_ospf(Port=Port_2)\n\n    select_interface(Session=ospf_1, Interface=interfaces_1)\n    select_interface(Session=ospf_2, Interface=interfaces_2)\n\n    # 创建Ospfv2 lsa向导\n    wizard = create_ospfv2_lsa_wizard(Sessions=[ospf_1, ospf_2])\n\n    # 配置ospfv2拓扑\n    config_ospfv2_lsa_wizard_ospfv2_topo(Wizards=wizard, Type='GRID',\n                                         RowCount=10,\n                                         ColumnCount=20)\n\n    # 配置ospfv2\n    config_ospfv2_lsa_wizard_ospfv2(Wizards=wizard,\n                                    EnableTeOption=True,\n                                    EnableSegmentRouting=True)\n    te = config_ospfv2_lsa_wizard_ospfv2_te_option(Wizards=wizard,\n                                                   EnableGroup=True,\n                                                   Group=10)\n    sr = config_ospfv2_lsa_wizard_ospfv2_sr(Wizards=wizard,\n                                            SidLabelType='BIT32')\n\n    # 配置ospfv2 stub network\n    config_ospfv2_lsa_wizard_ospfv2_stub_network(Wizards=wizard,\n                                                 StubDistributionType='INTERNET',\n                                                 StubInternetPrefixLength=\n                                                 [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                  0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 30, 0.0, 0.0, 0.0, 0.0,\n                                                  0.0, 0.0, 0.0, 50]\n                                                 )\n\n    # 配置ospfv2 summary network\n    config_ospfv2_lsa_wizard_ospfv2_summary_route(Wizards=wizard,\n                                                  SummaryEmulated='NONE',\n                                                  SummarySimulated='ALL')\n\n    # 配置ospfv2 external network\n    config_ospfv2_lsa_wizard_ospfv2_external_route(Wizards=wizard,\n                                                   ExternalPrimaryMetric=20)\n\n    # 生成Ospfv2 Lsa向导配置\n    expand_ospfv2_lsa_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\ncreate_ospf:创建OSPFv2协议会话对象\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TSN/tsn_avb.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备背靠背测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建TSN Avb向导,选择端口;\n                   测试步骤3: 配置Qav;\n                   测试步骤4: 配置gPTP;\n                   测试步骤5: 配置Non-AVB stream;\n                   测试步骤6: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤6 向导配置生成成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6', '//10.0.11.191/1/7'] if len(sys.argv) < 2 else sys.argv[1].split(\n    ' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_3 = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard = create_tsn_wizard(Type='avb', TalkerPort=port_1, ListenerPort=port_2, NonAvbPort=port_3, IsAppended=False)\n\n    # =============== *配置Qav* ===============\n    config_tsn_avb_qav(wizard, FrameSize=120, SrClassVid=10, EnableClassA=True, ClassABwRsvPct=50,\n                       ClassAStreamNum=2, ClassAStreamsBwRsvPct=[25, 25], EnableClassB=True, ClassBBwRsvPct=25,\n                       ClassBStreamNum=1, ClassBStreamsBwRsvPct=[25])\n\n    # =============== *配置gPTP* ===============\n    config_tsn_avb_gptp(wizard, Priority1=100, Priority2=101, ClockAccuracy=EnumClockAccuracy.CLOCK_ACCURACY_22,\n                        LogAnnounceInterval=1, LogSyncInterval=1, AnnounceReceiptTimeout=4, PropogationDelay=1000)\n\n    # =============== *配置Non-AVB stream* ===============\n    config_tsn_avb_non_stream(wizard, NonAvbFrameSize=150, LoadRate=10, StreamNumber=1)\n\n    # =============== *生成向导配置* ===============\n    expand_tsn_wizard(Wizard=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表型号为DarYu。\",\n  \"子任务2\": \"预约测试仪表的三个指定端口（//10.0.11.191/1/5、//10.0.11.191/1/6、//10.0.11.191/1/7），并强制占用（Force=True）。\",\n  \"子任务3\": \"创建TSN AVB向导，选择预约的端口作为Talker端口、Listener端口和Non-AVB端口，配置为非追加模式（IsAppended=False）。\",\n  \"子任务4\": \"配置Qav参数：设置帧大小为120字节，服务等级VLAN ID为10，启用ClassA并分配50%带宽，配置2条ClassA流各占25%带宽，启用ClassB并分配25%带宽，配置1条ClassB流占25%带宽。\",\n  \"子任务5\": \"配置gPTP参数：设置优先级1为100、优先级2为101，时钟精度为22，宣告间隔1秒，同步间隔1秒，宣告接收超时4秒，传播延迟1000纳秒。\",\n  \"子任务6\": \"配置Non-AVB流参数：设置帧大小为150字节，负载率10%，流数量为1条。\",\n  \"子任务7\": \"生成TSN向导配置并验证生成成功。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备背靠背测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建TSN Avb向导,选择端口;\n                   测试步骤3: 配置Qav;\n                   测试步骤4: 配置gPTP;\n                   测试步骤5: 配置Non-AVB stream;\n                   测试步骤6: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤6 向导配置生成成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6', '//10.0.11.191/1/7'] if len(sys.argv) < 2 else sys.argv[1].split(\n    ' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_3 = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard = create_tsn_wizard(Type='avb', TalkerPort=port_1, ListenerPort=port_2, NonAvbPort=port_3, IsAppended=False)\n\n    # =============== *配置Qav* ===============\n    config_tsn_avb_qav(wizard, FrameSize=120, SrClassVid=10, EnableClassA=True, ClassABwRsvPct=50,\n                       ClassAStreamNum=2, ClassAStreamsBwRsvPct=[25, 25], EnableClassB=True, ClassBBwRsvPct=25,\n                       ClassBStreamNum=1, ClassBStreamsBwRsvPct=[25])\n\n    # =============== *配置gPTP* ===============\n    config_tsn_avb_gptp(wizard, Priority1=100, Priority2=101, ClockAccuracy=EnumClockAccuracy.CLOCK_ACCURACY_22,\n                        LogAnnounceInterval=1, LogSyncInterval=1, AnnounceReceiptTimeout=4, PropogationDelay=1000)\n\n    # =============== *配置Non-AVB stream* ===============\n    config_tsn_avb_non_stream(wizard, NonAvbFrameSize=150, LoadRate=10, StreamNumber=1)\n\n    # =============== *生成向导配置* ===============\n    expand_tsn_wizard(Wizard=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/mpls/mpls_ip_vpn.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查MPLS IP VPN向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建MPLS IP VPN向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPN;\n                   测试步骤6: 配置VPN路由;\n                   测试步骤7: 配置VPN流量;\n                   测试步骤8: 配置LSP Ping;\n                   测试步骤9: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤9 MPLS IP VPN向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations[0]], Force=True)\n    Port_provider = reserve_port(Locations=[locations[1]], Force=True)\n\n    # 创建MPLS IP VPN向导\n\n    wizard = create_mpls_wizard(Type='mpls_ip_vpn')\n\n    # 配置客户端侧端口和提供商侧端口\n    edit_mpls_customer_port(Wizard=wizard, Port=Port_customer[0],\n                            EnableSubInterface=True, SubInterfaceCount=250,\n                            DutIpv4Address='1.1.1.1', VlanId=1000)\n    edit_mpls_provider_port(Wizard=wizard, Port=Port_provider[0],\n                            DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='2.2.2.2',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=True,\n                                               PRoutersPerInterface=10,\n                                               TopologyType='Grid',\n                                               PRouterStartIp='3.3.3.3',\n                                               PRouterIdStart='4.4.4.4',\n                                               PeRoutersPerInterface=20,\n                                               PeRouterIdStart='5.5.5.5',\n                                               EnableRouteReflectors=True)\n    edit_mpls_provider_router_isis(Wizard=wizard,\n                                   UseSrcMacAsSystemId=False,\n                                   SystemId='22:22:22:22:22:22',\n                                   Level='L1L2',\n                                   NetworkType='P2P',\n                                   RouterPriority=10,\n                                   MetricMode='WIDE',\n                                   AuthenticationMode='SIMPLE',\n                                   Password='test',\n                                   AreaId=20,\n                                   EnableGracefulRestart=True,\n                                   MultiTopologyId='IPV4',\n                                   EnableBfd=True,\n                                   )\n    edit_mpls_provider_router_ldp(Wizard=wizard,\n                                  HelloType='DIRECT_TARGETED',\n                                  TransportAddressTlvMode='ROUTER_ID',\n                                  LabelAdvertisementMode='DOD',\n                                  EgressLabelMode='IMPLICIT',\n                                  MinLabel=20,\n                                  AuthenticationMode='MD5',\n                                  Password='test')\n    # edit_mpls_provider_route_reflector(Wizard=wizard,\n    #                                    RouteReflectorSource='DutAsRouteReflector',\n    #                                    RrsPerPortOrSubInterface=1,\n    #                                    RrsPerPe=1,\n    #                                    RrRouterIdStart='1.1.1.1',\n    #                                    ClusterIdStart='2.2.2.2')\n    edit_mpls_provider_route_reflector(Wizard=wizard,\n                                       RrRouterIds=['1.1.1.1','2.2.2.2'])\n\n    # 配置VPN\n\n    edit_mpls_vpn_parameters(Wizard=wizard,\n                             NumberOfVpns=10,\n                             RdAssignment='Manual',\n                             RouteTargetStart='2:0')\n\n    edit_mpls_vpn_customer_parameters(Wizard=wizard,\n                                      VpnAssignment='Sequential',\n                                      CeProtocol='Mixed',\n                                      CeProAssignment='BGP=20%,RIP=40%,OSPF=30%,IS-IS=5%,Static=5%',\n                                      CustomerRdStart='3:0',\n                                      CustomerRdStepPerVpn='4:0',\n                                      CustomerRdStepPerCeEnabled=True,\n                                      CustomerRdStepPerCe='5:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            CustomerCeAsNumberStart=10,\n                            CustomerCeAsNumberStepPerVpn=20,\n                            CustomerCeAsNumberStepPerCeEnabled=True,\n                            CustomerCeAsNumberStepPerCe=30)\n\n    edit_mpls_vpn_provider_parameters(Wizard=wizard,\n                                      ProviderDisSel='PEsPerVPN',\n                                      ProviderMeshed=True,\n                                      ProviderRdStart='6:0',\n                                      ProviderRdStepPerVpn='7:0',\n                                      ProviderRdStepPerCeEnabled=True,\n                                      ProviderRdStepPerCe='8:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            ProviderAppendCeAsToPath=True,\n                            ProviderCeAsNumberStart=10,\n                            ProviderCeAsNumberStepPerVpnEnabled=True,\n                            ProviderCeAsNumberStepPerVpn=20,\n                            ProviderCeAsNumberStepPerCeEnabled=True,\n                            ProviderCeAsNumberStepPerCe=30)\n\n    # 配置VPN路由\n\n    edit_mpls_vpn_ipv4_route_customer_parameters(Wizard=wizard,\n                                                 CustomerStartRoute='1.1.1.1',\n                                                 CustomerRouteStep='0.1.0.0',\n                                                 CustomerPrefixLength=16,\n                                                 CustomerRoutesPerCe=10,\n                                                 CustomerOverlapRoutes=True,\n                                                 CustomerRouteType='External')\n    edit_mpls_vpn_ipv4_route_provider_parameters(Wizard=wizard,\n                                                 ProviderStartRoute='2.2.2.2',\n                                                 ProviderRouteStep='0.1.0.0',\n                                                 ProviderPrefixLength=16,\n                                                 ProviderRoutesPerCe=20,\n                                                 ProviderOverlapRoutes=True,\n                                                 ProviderLabelType='LabelPerRoute',\n                                                 ProviderStartLabel=30)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            UseSingleStreamNumber=True,\n                            TrafficLoadPercentProvider=10,\n                            TrafficLoadPercentCustomer=20)\n\n    # 配置Lsp Ping\n\n    edit_lsp_ping(Wizard=wizard,\n                  EnableLspPing=True,\n                  DestinationIpv4Address='1.1.1.1',\n                  PingInterval=10,\n                  PingTimeout=20,\n                  TimeToLive=30,\n                  LspExpValue=7,\n                  ValidateFecStack=True,\n                  PadMode='RequestPeerToDropPadTlv',\n                  PadData=[1,2,3])\n\n    # 生成MPLS IP VPN向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_mpls_wizard:测试仪表创建MPLS向导",
      "edit_lsp_ping:配置MPLS流量LSP Ping参数",
      "edit_mpls_customer_port:配置MPLS向导客户侧端口",
      "edit_mpls_provider_port:配置MPLS向导提供商侧端口",
      "edit_mpls_provider_route_reflector:not_found",
      "edit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由",
      "edit_mpls_provider_router_isis:配置MPLS提供商侧路由路由器OSPF协议",
      "edit_mpls_provider_router_ldp:配置MPLS提供商侧路由路由器LDP协议",
      "edit_mpls_vpn_as_number:not_found",
      "edit_mpls_vpn_customer_parameters:配置MPLS VPN客户侧参数",
      "edit_mpls_vpn_ipv4_route_customer_parameters:配置MPLS VPN路由客户端侧参数",
      "edit_mpls_vpn_ipv4_route_provider_parameters:配置MPLS VPN路由提供商端侧参数",
      "edit_mpls_vpn_parameters:配置MPLS VPN基本参数",
      "edit_mpls_vpn_provider_parameters:配置MPLS VPN提供商侧参数",
      "edit_traffic_parameters:配置MPLS流量",
      "expand_mpls_wizard:生成测试仪表MPLS向导配置"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品型号为DarYu。\",\n  \"子任务2\": \"预约客户侧端口Port_1，强制占用指定物理位置。\",\n  \"子任务3\": \"预约提供商侧端口Port_2，强制占用指定物理位置。\",\n  \"子任务4\": \"创建MPLS IP VPN向导，类型设置为mpls_ip_vpn。\",\n  \"子任务5\": \"配置客户侧端口参数：启用子接口，设置子接口数量250，DUT IPv4地址1.1.1.1，VLAN ID 1000。\",\n  \"子任务6\": \"配置提供商侧端口参数：DUT IPv4地址50.1.1.1，IPv4前缀长度24。\",\n  \"子任务7\": \"配置提供商路由器基本参数：路由器ID 2.2.2.2，AS号100，IGP协议ISIS，MPLS协议LDP，启用P路由器，拓扑类型网格。\",\n  \"子任务8\": \"配置提供商路由器ISIS参数：系统ID 22:22:22:22:22:22，级别L1L2，网络类型P2P，认证模式SIMPLE，密码test。\",\n  \"子任务9\": \"配置提供商路由器LDP参数：Hello类型DIRECT_TARGETED，标签通告模式DOD，认证模式MD5，密码test。\",\n  \"子任务10\": \"配置提供商路由反射器：指定路由反射器ID列表['1.1.1.1','2.2.2.2']。\",\n  \"子任务11\": \"配置VPN基本参数：VPN数量10，RD分配方式Manual，路由目标起始值2:0。\",\n  \"子任务12\": \"配置VPN客户侧参数：VPN分配顺序，CE协议混合，RD起始值3:0，启用每CE的RD步进。\",\n  \"子任务13\": \"配置VPN客户侧AS号：CE AS号起始值10，启用每VPN和每CE的AS号步进。\",\n  \"子任务14\": \"配置VPN提供商侧参数：分发选择PEsPerVPN，启用全连接，RD起始值6:0。\",\n  \"子任务15\": \"配置VPN提供商侧AS号：启用追加CE AS到路径，CE AS号起始值10，启用步进配置。\",\n  \"子任务16\": \"配置VPN路由客户侧参数：起始路由1.1.1.1，前缀长度16，路由数10，启用重叠路由。\",\n  \"子任务17\": \"配置VPN路由提供商侧参数：起始路由2.2.2.2，前缀长度16，路由数20，标签类型LabelPerRoute。\",\n  \"子任务18\": \"配置流量参数：流量方向CustomerProviderBoth，分组方式Aggregate，提供商负载10%，客户负载20%。\",\n  \"子任务19\": \"配置LSP Ping：启用LSP Ping，目的地址1.1.1.1，间隔10秒，超时20秒，TTL 30，验证FEC栈。\",\n  \"子任务20\": \"生成MPLS向导配置。\",\n  \"子任务21\": \"验证配置生成过程无异常。\",\n  \"子任务22\": \"保存配置文件到指定路径。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查MPLS IP VPN向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建MPLS IP VPN向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPN;\n                   测试步骤6: 配置VPN路由;\n                   测试步骤7: 配置VPN流量;\n                   测试步骤8: 配置LSP Ping;\n                   测试步骤9: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤9 MPLS IP VPN向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations[0]], Force=True)\n    Port_provider = reserve_port(Locations=[locations[1]], Force=True)\n\n    # 创建MPLS IP VPN向导\n\n    wizard = create_mpls_wizard(Type='mpls_ip_vpn')\n\n    # 配置客户端侧端口和提供商侧端口\n    edit_mpls_customer_port(Wizard=wizard, Port=Port_customer[0],\n                            EnableSubInterface=True, SubInterfaceCount=250,\n                            DutIpv4Address='1.1.1.1', VlanId=1000)\n    edit_mpls_provider_port(Wizard=wizard, Port=Port_provider[0],\n                            DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='2.2.2.2',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=True,\n                                               PRoutersPerInterface=10,\n                                               TopologyType='Grid',\n                                               PRouterStartIp='3.3.3.3',\n                                               PRouterIdStart='4.4.4.4',\n                                               PeRoutersPerInterface=20,\n                                               PeRouterIdStart='5.5.5.5',\n                                               EnableRouteReflectors=True)\n    edit_mpls_provider_router_isis(Wizard=wizard,\n                                   UseSrcMacAsSystemId=False,\n                                   SystemId='22:22:22:22:22:22',\n                                   Level='L1L2',\n                                   NetworkType='P2P',\n                                   RouterPriority=10,\n                                   MetricMode='WIDE',\n                                   AuthenticationMode='SIMPLE',\n                                   Password='test',\n                                   AreaId=20,\n                                   EnableGracefulRestart=True,\n                                   MultiTopologyId='IPV4',\n                                   EnableBfd=True,\n                                   )\n    edit_mpls_provider_router_ldp(Wizard=wizard,\n                                  HelloType='DIRECT_TARGETED',\n                                  TransportAddressTlvMode='ROUTER_ID',\n                                  LabelAdvertisementMode='DOD',\n                                  EgressLabelMode='IMPLICIT',\n                                  MinLabel=20,\n                                  AuthenticationMode='MD5',\n                                  Password='test')\n    # edit_mpls_provider_route_reflector(Wizard=wizard,\n    #                                    RouteReflectorSource='DutAsRouteReflector',\n    #                                    RrsPerPortOrSubInterface=1,\n    #                                    RrsPerPe=1,\n    #                                    RrRouterIdStart='1.1.1.1',\n    #                                    ClusterIdStart='2.2.2.2')\n    edit_mpls_provider_route_reflector(Wizard=wizard,\n                                       RrRouterIds=['1.1.1.1','2.2.2.2'])\n\n    # 配置VPN\n\n    edit_mpls_vpn_parameters(Wizard=wizard,\n                             NumberOfVpns=10,\n                             RdAssignment='Manual',\n                             RouteTargetStart='2:0')\n\n    edit_mpls_vpn_customer_parameters(Wizard=wizard,\n                                      VpnAssignment='Sequential',\n                                      CeProtocol='Mixed',\n                                      CeProAssignment='BGP=20%,RIP=40%,OSPF=30%,IS-IS=5%,Static=5%',\n                                      CustomerRdStart='3:0',\n                                      CustomerRdStepPerVpn='4:0',\n                                      CustomerRdStepPerCeEnabled=True,\n                                      CustomerRdStepPerCe='5:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            CustomerCeAsNumberStart=10,\n                            CustomerCeAsNumberStepPerVpn=20,\n                            CustomerCeAsNumberStepPerCeEnabled=True,\n                            CustomerCeAsNumberStepPerCe=30)\n\n    edit_mpls_vpn_provider_parameters(Wizard=wizard,\n                                      ProviderDisSel='PEsPerVPN',\n                                      ProviderMeshed=True,\n                                      ProviderRdStart='6:0',\n                                      ProviderRdStepPerVpn='7:0',\n                                      ProviderRdStepPerCeEnabled=True,\n                                      ProviderRdStepPerCe='8:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            ProviderAppendCeAsToPath=True,\n                            ProviderCeAsNumberStart=10,\n                            ProviderCeAsNumberStepPerVpnEnabled=True,\n                            ProviderCeAsNumberStepPerVpn=20,\n                            ProviderCeAsNumberStepPerCeEnabled=True,\n                            ProviderCeAsNumberStepPerCe=30)\n\n    # 配置VPN路由\n\n    edit_mpls_vpn_ipv4_route_customer_parameters(Wizard=wizard,\n                                                 CustomerStartRoute='1.1.1.1',\n                                                 CustomerRouteStep='0.1.0.0',\n                                                 CustomerPrefixLength=16,\n                                                 CustomerRoutesPerCe=10,\n                                                 CustomerOverlapRoutes=True,\n                                                 CustomerRouteType='External')\n    edit_mpls_vpn_ipv4_route_provider_parameters(Wizard=wizard,\n                                                 ProviderStartRoute='2.2.2.2',\n                                                 ProviderRouteStep='0.1.0.0',\n                                                 ProviderPrefixLength=16,\n                                                 ProviderRoutesPerCe=20,\n                                                 ProviderOverlapRoutes=True,\n                                                 ProviderLabelType='LabelPerRoute',\n                                                 ProviderStartLabel=30)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            UseSingleStreamNumber=True,\n                            TrafficLoadPercentProvider=10,\n                            TrafficLoadPercentCustomer=20)\n\n    # 配置Lsp Ping\n\n    edit_lsp_ping(Wizard=wizard,\n                  EnableLspPing=True,\n                  DestinationIpv4Address='1.1.1.1',\n                  PingInterval=10,\n                  PingTimeout=20,\n                  TimeToLive=30,\n                  LspExpValue=7,\n                  ValidateFecStack=True,\n                  PadMode='RequestPeerToDropPadTlv',\n                  PadData=[1,2,3])\n\n    # 生成MPLS IP VPN向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_mpls_wizard:测试仪表创建MPLS向导;\nedit_lsp_ping:配置MPLS流量LSP Ping参数;\nedit_mpls_customer_port:配置MPLS向导客户侧端口;\nedit_mpls_provider_port:配置MPLS向导提供商侧端口;\nedit_mpls_provider_route_reflector:not_found;\nedit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由;\nedit_mpls_provider_router_isis:配置MPLS提供商侧路由路由器OSPF协议;\nedit_mpls_provider_router_ldp:配置MPLS提供商侧路由路由器LDP协议;\nedit_mpls_vpn_as_number:not_found;\nedit_mpls_vpn_customer_parameters:配置MPLS VPN客户侧参数;\nedit_mpls_vpn_ipv4_route_customer_parameters:配置MPLS VPN路由客户端侧参数;\nedit_mpls_vpn_ipv4_route_provider_parameters:配置MPLS VPN路由提供商端侧参数;\nedit_mpls_vpn_parameters:配置MPLS VPN基本参数;\nedit_mpls_vpn_provider_parameters:配置MPLS VPN提供商侧参数;\nedit_traffic_parameters:配置MPLS流量;\nexpand_mpls_wizard:生成测试仪表MPLS向导配置\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/ospf_lsa/ospfv3_lsa_wizard.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查Ospfv3 Lsa向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Ospfv3会话;\n                   测试步骤3: 创建Ospfv3 Lsa向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Ospfv3 Lsa向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='ipv6')\n    interfaces_2 = create_interface(Port=Port_2, Layers='ipv6')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建Ospfv3会话\n    ospf_1 = create_ospfv3(Port=Port_1)\n    ospf_2 = create_ospfv3(Port=Port_2)\n\n    select_interface(Session=ospf_1, Interface=interfaces_1)\n    select_interface(Session=ospf_2, Interface=interfaces_2)\n\n    # 创建Ospfv3 lsa向导\n    wizard = create_ospfv3_lsa_wizard(Sessions=[ospf_1, ospf_2])\n\n    # 配置Ospfv3拓扑\n    config_ospfv3_lsa_wizard_ospfv3_topo(Wizards=wizard, Type='GRID',\n                                         RowCount=10,\n                                         ColumnCount=20)\n\n    # 配置Ospfv3\n    config_ospfv3_lsa_wizard_ospfv3(Wizards=wizard,\n                                    AreaType='STUB')\n\n    # 配置Ospfv3 intra area route\n    config_ospfv3_lsa_wizard_ospfv3_intra_area_route(Wizards=wizard,\n                                                     IntraAreaEmulated='ALL',\n                                                     IntraAreaSimulated='NONE'\n                                                     )\n\n    # 配置Ospfv3 inter area route\n    config_ospfv3_lsa_wizard_ospfv3_inter_area_route(Wizards=wizard,\n                                                     InterAreaRoutesCount=10)\n\n    # 配置Ospfv3 external network\n    config_ospfv3_lsa_wizard_ospfv3_external_route(Wizards=wizard,\n                                                   ExternalDistributionType='CUSTOM',\n                                                   ExternalCustomPrefixLength=[10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 0.0,\n                                                                               10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0,\n                                                                               10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               10,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               ])\n\n    # 生成Ospfv3 Lsa向导配置\n    expand_ospfv3_lsa_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "create_ospfv3:创建OSPFv3协议会话对象"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"创建并预约两个离线端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建IPv6接口。\",\n  \"子任务4\": \"配置Port_1的IPv6接口参数：地址2001::1，网关2001::2。\",\n  \"子任务5\": \"在Port_2上创建IPv6接口。\",\n  \"子任务6\": \"配置Port_2的IPv6接口参数：地址2001::2，网关2001::1。\",\n  \"子任务7\": \"在Port_1上创建OSPFv3会话对象。\",\n  \"子任务8\": \"在Port_2上创建OSPFv3会话对象。\",\n  \"子任务9\": \"将Port_1的IPv6接口绑定到Port_1的OSPFv3会话。\",\n  \"子任务10\": \"将Port_2的IPv6接口绑定到Port_2的OSPFv3会话。\",\n  \"子任务11\": \"创建OSPFv3 LSA向导，关联两个OSPFv3会话。\",\n  \"子任务12\": \"配置OSPFv3 LSA向导的拓扑类型为GRID，设置行数10，列数20。\",\n  \"子任务13\": \"配置OSPFv3 LSA向导的区域类型为STUB。\",\n  \"子任务14\": \"配置OSPFv3 LSA向导的区域内部路由：模拟所有路由，仿真路由无。\",\n  \"子任务15\": \"配置OSPFv3 LSA向导的区域间路由，设置路由数量为10。\",\n  \"子任务16\": \"配置OSPFv3 LSA向导的外部路由，设置分布类型为CUSTOM，指定自定义前缀长度列表。\",\n  \"子任务17\": \"生成OSPFv3 LSA向导配置。\",\n  \"子任务18\": \"保存生成的配置文件到指定路径。\",\n  \"子任务19\": \"验证配置生成过程无异常，测试结果为通过。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查Ospfv3 Lsa向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Ospfv3会话;\n                   测试步骤3: 创建Ospfv3 Lsa向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Ospfv3 Lsa向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='ipv6')\n    interfaces_2 = create_interface(Port=Port_2, Layers='ipv6')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建Ospfv3会话\n    ospf_1 = create_ospfv3(Port=Port_1)\n    ospf_2 = create_ospfv3(Port=Port_2)\n\n    select_interface(Session=ospf_1, Interface=interfaces_1)\n    select_interface(Session=ospf_2, Interface=interfaces_2)\n\n    # 创建Ospfv3 lsa向导\n    wizard = create_ospfv3_lsa_wizard(Sessions=[ospf_1, ospf_2])\n\n    # 配置Ospfv3拓扑\n    config_ospfv3_lsa_wizard_ospfv3_topo(Wizards=wizard, Type='GRID',\n                                         RowCount=10,\n                                         ColumnCount=20)\n\n    # 配置Ospfv3\n    config_ospfv3_lsa_wizard_ospfv3(Wizards=wizard,\n                                    AreaType='STUB')\n\n    # 配置Ospfv3 intra area route\n    config_ospfv3_lsa_wizard_ospfv3_intra_area_route(Wizards=wizard,\n                                                     IntraAreaEmulated='ALL',\n                                                     IntraAreaSimulated='NONE'\n                                                     )\n\n    # 配置Ospfv3 inter area route\n    config_ospfv3_lsa_wizard_ospfv3_inter_area_route(Wizards=wizard,\n                                                     InterAreaRoutesCount=10)\n\n    # 配置Ospfv3 external network\n    config_ospfv3_lsa_wizard_ospfv3_external_route(Wizards=wizard,\n                                                   ExternalDistributionType='CUSTOM',\n                                                   ExternalCustomPrefixLength=[10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 0.0,\n                                                                               10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0,\n                                                                               10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               10,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               ])\n\n    # 生成Ospfv3 Lsa向导配置\n    expand_ospfv3_lsa_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\ncreate_ospfv3:创建OSPFv3协议会话对象\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/mpls/6pe_6vpe.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查6PE/6VPE向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建6PE/6VPE向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPN;\n                   测试步骤6: 配置VPN路由;\n                   测试步骤7: 配置VPN流量;\n                   测试步骤8: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 6PE/6VPE向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations[0]], Force=True)\n    Port_provider = reserve_port(Locations=[locations[1]], Force=True)\n\n    # 创建6PE/6VPE向导\n\n    wizard = create_mpls_wizard(Type='mpls_6vpe')\n\n    # 配置客户端侧端口和提供商侧端口\n    edit_mpls_customer_port(Wizard=wizard, Port=Port_customer[0],\n                            EnableSubInterface=True, SubInterfaceCount=250,\n                            DutIpv4Address='1.1.1.1', VlanId=1000)\n    edit_mpls_provider_port(Wizard=wizard, Port=Port_provider[0],\n                            DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='2.2.2.2',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=True,\n                                               PRoutersPerInterface=10,\n                                               TopologyType='Grid',\n                                               PRouterStartIp='3.3.3.3',\n                                               PRouterIdStart='4.4.4.4',\n                                               PeRoutersPerInterface=20,\n                                               PeRouterIdStart='5.5.5.5',\n                                               EnableRouteReflectors=True,\n                                               Enable6Vpe=True)\n    edit_mpls_provider_router_isis(Wizard=wizard,\n                                   UseSrcMacAsSystemId=False,\n                                   SystemId='22:22:22:22:22:22',\n                                   Level='L1L2',\n                                   NetworkType='P2P',\n                                   RouterPriority=10,\n                                   MetricMode='WIDE',\n                                   AuthenticationMode='SIMPLE',\n                                   Password='test',\n                                   AreaId=20,\n                                   EnableGracefulRestart=True,\n                                   MultiTopologyId='IPV4',\n                                   EnableBfd=True,\n                                   )\n    edit_mpls_provider_router_ldp(Wizard=wizard,\n                                  HelloType='DIRECT_TARGETED',\n                                  TransportAddressTlvMode='ROUTER_ID',\n                                  LabelAdvertisementMode='DOD',\n                                  EgressLabelMode='IMPLICIT',\n                                  MinLabel=20,\n                                  AuthenticationMode='MD5',\n                                  Password='test')\n    # edit_mpls_provider_route_reflector(Wizard=wizard,\n    #                                    RouteReflectorSource='DutAsRouteReflector',\n    #                                    RrsPerPortOrSubInterface=1,\n    #                                    RrsPerPe=1,\n    #                                    RrRouterIdStart='1.1.1.1',\n    #                                    ClusterIdStart='2.2.2.2')\n    edit_mpls_provider_route_reflector(Wizard=wizard,\n                                       RrRouterIds=['1.1.1.1','2.2.2.2'])\n\n    # 配置VPN\n\n    edit_mpls_vpn_parameters(Wizard=wizard,\n                             NumberOfVpns=10,\n                             RdAssignment='Manual',\n                             RouteTargetStart='2:0')\n\n    edit_mpls_vpn_customer_parameters(Wizard=wizard,\n                                      VpnAssignment='Sequential',\n                                      CeProtocol='Mixed',\n                                      CeProAssignment='BGP=20%,RIP=40%,OSPF=30%,IS-IS=5%,Static=5%',\n                                      CustomerRdStart='3:0',\n                                      CustomerRdStepPerVpn='4:0',\n                                      CustomerRdStepPerCeEnabled=True,\n                                      CustomerRdStepPerCe='5:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            CustomerCeAsNumberStart=10,\n                            CustomerCeAsNumberStepPerVpn=20,\n                            CustomerCeAsNumberStepPerCeEnabled=True,\n                            CustomerCeAsNumberStepPerCe=30)\n\n    edit_mpls_vpn_provider_parameters(Wizard=wizard,\n                                      ProviderDisSel='PEsPerVPN',\n                                      ProviderMeshed=True,\n                                      ProviderRdStart='6:0',\n                                      ProviderRdStepPerVpn='7:0',\n                                      ProviderRdStepPerCeEnabled=True,\n                                      ProviderRdStepPerCe='8:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            ProviderAppendCeAsToPath=True,\n                            ProviderCeAsNumberStart=10,\n                            ProviderCeAsNumberStepPerVpnEnabled=True,\n                            ProviderCeAsNumberStepPerVpn=20,\n                            ProviderCeAsNumberStepPerCeEnabled=True,\n                            ProviderCeAsNumberStepPerCe=30)\n\n    # 配置VPN路由\n\n    edit_mpls_vpn_ipv6_route_customer_parameters(Wizard=wizard,\n                                                 CustomerStartRoute='2022::',\n                                                 CustomerRouteStep='0:1::',\n                                                 CustomerPrefixLength=32,\n                                                 CustomerRoutesPerCe=10,\n                                                 CustomerOverlapRoutes=True,\n                                                 CustomerRouteType='External')\n    edit_mpls_vpn_ipv6_route_provider_parameters(Wizard=wizard,\n                                                 ProviderStartRoute='2033::',\n                                                 ProviderRouteStep='0:1::',\n                                                 ProviderPrefixLength=32,\n                                                 ProviderRoutesPerCe=20,\n                                                 ProviderOverlapRoutes=True,\n                                                 ProviderLabelType='LabelPerRoute',\n                                                 ProviderStartLabel=20)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            UseSingleStreamNumber=True,\n                            TrafficLoadPercentProvider=10,\n                            TrafficLoadPercentCustomer=20)\n\n    # 生成6PE/6VPE向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_mpls_wizard:测试仪表创建MPLS向导",
      "edit_mpls_customer_port:配置MPLS向导客户侧端口",
      "edit_mpls_provider_port:配置MPLS向导提供商侧端口",
      "edit_mpls_provider_route_reflector:not_found",
      "edit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由",
      "edit_mpls_provider_router_isis:配置MPLS提供商侧路由路由器OSPF协议",
      "edit_mpls_provider_router_ldp:配置MPLS提供商侧路由路由器LDP协议",
      "edit_mpls_vpn_as_number:not_found",
      "edit_mpls_vpn_customer_parameters:配置MPLS VPN客户侧参数",
      "edit_mpls_vpn_ipv6_route_customer_parameters:配置MPLS VPN路由客户端侧IPv6参数",
      "edit_mpls_vpn_ipv6_route_provider_parameters:配置MPLS VPN路由提供商端侧IPv6参数",
      "edit_mpls_vpn_parameters:配置MPLS VPN基本参数",
      "edit_mpls_vpn_provider_parameters:配置MPLS VPN提供商侧参数",
      "edit_traffic_parameters:配置MPLS流量",
      "expand_mpls_wizard:生成测试仪表MPLS向导配置"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个离线端口：Port_1作为客户端侧端口，Port_2作为提供商侧端口。\",\n  \"子任务3\": \"创建6VPE向导配置模板。\",\n  \"子任务4\": \"配置客户端侧端口参数：启用子接口，设置子接口数量为250，指定DUT IPv4地址为1.1.1.1，VLAN ID为1000。\",\n  \"子任务5\": \"配置提供商侧端口参数：指定DUT IPv4地址为50.1.1.1，IPv4前缀长度为24。\",\n  \"子任务6\": \"配置提供商侧路由器基本参数：设置DUT路由器ID为2.2.2.2，AS号为100，IGP协议为ISIS，MPLS协议为LDP，启用提供商路由器和6VPE功能。\",\n  \"子任务7\": \"配置提供商侧路由器ISIS协议：设置系统ID为22:22:22:22:22:22，级别为L1L2，网络类型为P2P，启用BFD和MD5认证。\",\n  \"子任务8\": \"配置提供商侧路由器LDP协议：设置Hello类型为DIRECT_TARGETED，标签通告模式为DOD，启用MD5认证。\",\n  \"子任务9\": \"配置提供商侧路由反射器：指定路由反射器ID列表为['1.1.1.1','2.2.2.2']。\",\n  \"子任务10\": \"配置VPN基本参数：设置VPN数量为10，RD分配模式为手动，路由目标起始值为2:0。\",\n  \"子任务11\": \"配置VPN客户侧参数：设置CE协议混合比例，客户RD起始值为3:0，启用每CE的RD步进。\",\n  \"子任务12\": \"配置VPN提供商侧参数：设置提供商RD起始值为6:0，启用全连接和每CE的RD步进。\",\n  \"子任务13\": \"配置VPN客户侧IPv6路由：设置起始路由为2022::，前缀长度32，启用路由重叠，路由类型为External。\",\n  \"子任务14\": \"配置VPN提供商侧IPv6路由：设置起始路由为2033::，前缀长度32，标签类型为LabelPerRoute，起始标签为20。\",\n  \"子任务15\": \"配置流量参数：设置双向流量，流分组模式为Aggregate，提供商侧负载10%，客户侧负载20%。\",\n  \"子任务16\": \"生成6VPE向导配置。\",\n  \"子任务17\": \"验证向导配置生成过程无异常。\",\n  \"子任务18\": \"保存生成的配置文件到指定路径。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查6PE/6VPE向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建6PE/6VPE向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPN;\n                   测试步骤6: 配置VPN路由;\n                   测试步骤7: 配置VPN流量;\n                   测试步骤8: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 6PE/6VPE向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations[0]], Force=True)\n    Port_provider = reserve_port(Locations=[locations[1]], Force=True)\n\n    # 创建6PE/6VPE向导\n\n    wizard = create_mpls_wizard(Type='mpls_6vpe')\n\n    # 配置客户端侧端口和提供商侧端口\n    edit_mpls_customer_port(Wizard=wizard, Port=Port_customer[0],\n                            EnableSubInterface=True, SubInterfaceCount=250,\n                            DutIpv4Address='1.1.1.1', VlanId=1000)\n    edit_mpls_provider_port(Wizard=wizard, Port=Port_provider[0],\n                            DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='2.2.2.2',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=True,\n                                               PRoutersPerInterface=10,\n                                               TopologyType='Grid',\n                                               PRouterStartIp='3.3.3.3',\n                                               PRouterIdStart='4.4.4.4',\n                                               PeRoutersPerInterface=20,\n                                               PeRouterIdStart='5.5.5.5',\n                                               EnableRouteReflectors=True,\n                                               Enable6Vpe=True)\n    edit_mpls_provider_router_isis(Wizard=wizard,\n                                   UseSrcMacAsSystemId=False,\n                                   SystemId='22:22:22:22:22:22',\n                                   Level='L1L2',\n                                   NetworkType='P2P',\n                                   RouterPriority=10,\n                                   MetricMode='WIDE',\n                                   AuthenticationMode='SIMPLE',\n                                   Password='test',\n                                   AreaId=20,\n                                   EnableGracefulRestart=True,\n                                   MultiTopologyId='IPV4',\n                                   EnableBfd=True,\n                                   )\n    edit_mpls_provider_router_ldp(Wizard=wizard,\n                                  HelloType='DIRECT_TARGETED',\n                                  TransportAddressTlvMode='ROUTER_ID',\n                                  LabelAdvertisementMode='DOD',\n                                  EgressLabelMode='IMPLICIT',\n                                  MinLabel=20,\n                                  AuthenticationMode='MD5',\n                                  Password='test')\n    # edit_mpls_provider_route_reflector(Wizard=wizard,\n    #                                    RouteReflectorSource='DutAsRouteReflector',\n    #                                    RrsPerPortOrSubInterface=1,\n    #                                    RrsPerPe=1,\n    #                                    RrRouterIdStart='1.1.1.1',\n    #                                    ClusterIdStart='2.2.2.2')\n    edit_mpls_provider_route_reflector(Wizard=wizard,\n                                       RrRouterIds=['1.1.1.1','2.2.2.2'])\n\n    # 配置VPN\n\n    edit_mpls_vpn_parameters(Wizard=wizard,\n                             NumberOfVpns=10,\n                             RdAssignment='Manual',\n                             RouteTargetStart='2:0')\n\n    edit_mpls_vpn_customer_parameters(Wizard=wizard,\n                                      VpnAssignment='Sequential',\n                                      CeProtocol='Mixed',\n                                      CeProAssignment='BGP=20%,RIP=40%,OSPF=30%,IS-IS=5%,Static=5%',\n                                      CustomerRdStart='3:0',\n                                      CustomerRdStepPerVpn='4:0',\n                                      CustomerRdStepPerCeEnabled=True,\n                                      CustomerRdStepPerCe='5:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            CustomerCeAsNumberStart=10,\n                            CustomerCeAsNumberStepPerVpn=20,\n                            CustomerCeAsNumberStepPerCeEnabled=True,\n                            CustomerCeAsNumberStepPerCe=30)\n\n    edit_mpls_vpn_provider_parameters(Wizard=wizard,\n                                      ProviderDisSel='PEsPerVPN',\n                                      ProviderMeshed=True,\n                                      ProviderRdStart='6:0',\n                                      ProviderRdStepPerVpn='7:0',\n                                      ProviderRdStepPerCeEnabled=True,\n                                      ProviderRdStepPerCe='8:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            ProviderAppendCeAsToPath=True,\n                            ProviderCeAsNumberStart=10,\n                            ProviderCeAsNumberStepPerVpnEnabled=True,\n                            ProviderCeAsNumberStepPerVpn=20,\n                            ProviderCeAsNumberStepPerCeEnabled=True,\n                            ProviderCeAsNumberStepPerCe=30)\n\n    # 配置VPN路由\n\n    edit_mpls_vpn_ipv6_route_customer_parameters(Wizard=wizard,\n                                                 CustomerStartRoute='2022::',\n                                                 CustomerRouteStep='0:1::',\n                                                 CustomerPrefixLength=32,\n                                                 CustomerRoutesPerCe=10,\n                                                 CustomerOverlapRoutes=True,\n                                                 CustomerRouteType='External')\n    edit_mpls_vpn_ipv6_route_provider_parameters(Wizard=wizard,\n                                                 ProviderStartRoute='2033::',\n                                                 ProviderRouteStep='0:1::',\n                                                 ProviderPrefixLength=32,\n                                                 ProviderRoutesPerCe=20,\n                                                 ProviderOverlapRoutes=True,\n                                                 ProviderLabelType='LabelPerRoute',\n                                                 ProviderStartLabel=20)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            UseSingleStreamNumber=True,\n                            TrafficLoadPercentProvider=10,\n                            TrafficLoadPercentCustomer=20)\n\n    # 生成6PE/6VPE向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_mpls_wizard:测试仪表创建MPLS向导;\nedit_mpls_customer_port:配置MPLS向导客户侧端口;\nedit_mpls_provider_port:配置MPLS向导提供商侧端口;\nedit_mpls_provider_route_reflector:not_found;\nedit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由;\nedit_mpls_provider_router_isis:配置MPLS提供商侧路由路由器OSPF协议;\nedit_mpls_provider_router_ldp:配置MPLS提供商侧路由路由器LDP协议;\nedit_mpls_vpn_as_number:not_found;\nedit_mpls_vpn_customer_parameters:配置MPLS VPN客户侧参数;\nedit_mpls_vpn_ipv6_route_customer_parameters:配置MPLS VPN路由客户端侧IPv6参数;\nedit_mpls_vpn_ipv6_route_provider_parameters:配置MPLS VPN路由提供商端侧IPv6参数;\nedit_mpls_vpn_parameters:配置MPLS VPN基本参数;\nedit_mpls_vpn_provider_parameters:配置MPLS VPN提供商侧参数;\nedit_traffic_parameters:配置MPLS流量;\nexpand_mpls_wizard:生成测试仪表MPLS向导配置\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/mpls/pwe.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查PWE向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建PWE向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置PWE;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 配置LSP Ping;\n                   测试步骤9: 生成PWE向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 PWE向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\n# locations_1 = ['//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16']\n# locations_2 = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6']\n\nlocations_1 = locations[0]\nlocations_2 = locations[1]\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations_1], Debug=True)\n    Port_provider = reserve_port(Locations=[locations_2], Debug=True)\n\n    # 创建PWE向导\n\n    wizard = create_mpls_wizard(Type='pwe')\n\n    # 配置客户端侧端口和提供商侧端口\n    for port in Port_customer:\n        edit_mpls_customer_port(Wizard=wizard, Port=port, EnableSubInterface=True, SubInterfaceCount=250,\n                                VlanId=1000)\n    for port in Port_provider:\n        edit_mpls_provider_port(Wizard=wizard, Port=port, DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='1.1.1.1',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=False,\n                                               PeRouterIdStart='2.1.1.1',\n                                               PeRouterIdStep='0.0.0.1')\n\n    # 配置PWE\n\n    edit_mpls_pwe_basic_parameters(Wizard=wizard,\n                                   NumberOfPseudoWire=10,\n                                   Mtu=1518,\n                                   GroupId=20,\n                                   EnableCBit=True,\n                                   IncludeStatusTlv=True,\n                                   StatusCode='LocalAttachmentCircuitReceiveFault',\n                                   EnableOverrideEncapsulation=True,\n                                   Encapsulation='Ethernet',\n                                   EnableOverlapVcidsOnDifferentPes=True,\n                                   EnableCreateProviderHostsForUnusedVpls=True,\n                                   FecType='FEC129')\n\n    edit_mpls_fec129(Wizard=wizard,\n                     Agi='10:1',\n                     AgiIncrement='0:2',\n                     Saii='1.1.1.1',\n                     SaiiIncrement='0.0.0.2',\n                     Taii='2.2.2.2',\n                     TaiiIncrement='0.0.0.3',\n                     EnableBgpAutoDiscovery=True,\n                     DutAsNumber=10,\n                     RdAssignment='Manual',\n                     AgiAssignment='Manual',\n                     Rt='20:0',\n                     RtIncrement='0:2',\n                     Rd='30:0',\n                     RdIncrement='0:3')\n\n    # 配置Host\n\n    edit_mpls_host(Wizard=wizard,\n                   HostAssignmentVpls='HostsOrMacsPerVpls',\n                   HostsPerVpls=32,\n                   CustomerHostPercent=50,\n                   ProviderHostPercent=50)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            TrafficLoadPercentProvider=10)\n\n    # LSP Ping\n    edit_lsp_ping(Wizard=wizard,\n                  EnableLspPing=True,\n                  DestinationIpv4Address='1.1.1.1',\n                  PingInterval=10,\n                  PingTimeout=20,\n                  TimeToLive=30,\n                  LspExpValue=7,\n                  ValidateFecStack=True,\n                  PadMode='RequestPeerToDropPadTlv',\n                  PadData=[1, 2, 3])\n\n    # 生成PWE向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_mpls_wizard:测试仪表创建MPLS向导",
      "edit_lsp_ping:配置MPLS流量LSP Ping参数",
      "edit_mpls_customer_port:配置MPLS向导客户侧端口",
      "edit_mpls_fec129:配置MPLS fec129参数",
      "edit_mpls_host:配置MPLS向导Host参数",
      "edit_mpls_provider_port:配置MPLS向导提供商侧端口",
      "edit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由",
      "edit_mpls_pwe_basic_parameters:配置MPLS pwe参数",
      "edit_traffic_parameters:配置MPLS流量",
      "expand_mpls_wizard:生成测试仪表MPLS向导配置"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品型号。\",\n  \"子任务2\": \"预约客户端侧端口和提供商侧端口，获取端口对象。\",\n  \"子任务3\": \"创建MPLS向导，类型设置为PWE。\",\n  \"子任务4\": \"配置客户端侧端口参数：启用子接口、设置子接口数量为250、VLAN ID为1000。\",\n  \"子任务5\": \"配置提供商侧端口参数：设置DUT IPv4地址为50.1.1.1、IPv4前缀长度为24。\",\n  \"子任务6\": \"配置提供商侧路由器基本参数：设置DUT路由器ID、AS号、IGP协议为ISIS、MPLS协议为LDP、PE路由器ID起始值。\",\n  \"子任务7\": \"配置PWE基本参数：设置伪线数量、MTU、组ID、C比特、状态TLV、封装类型、FEC类型为FEC129。\",\n  \"子任务8\": \"配置FEC129参数：设置AGI/SAII/TAII值及增量、启用BGP自动发现、设置AS号、RD/RT分配策略。\",\n  \"子任务9\": \"配置Host参数：设置主机分配策略为VPLS主机分配、每VPLS主机数32、客户侧与提供商侧主机比例50:50。\",\n  \"子任务10\": \"配置流量参数：设置流量方向为双向、流分组方式为聚合、提供商侧流量负载百分比10%。\",\n  \"子任务11\": \"配置LSP Ping参数：启用LSP Ping、设置目的IPv4地址、Ping间隔、超时时间、TTL、LSP EXP值、FEC栈验证、填充模式及数据。\",\n  \"子任务12\": \"生成PWE向导配置并验证配置生成无异常。\",\n  \"子任务13\": \"保存生成的配置文件到指定路径。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查PWE向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建PWE向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置PWE;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 配置LSP Ping;\n                   测试步骤9: 生成PWE向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 PWE向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\n# locations_1 = ['//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16']\n# locations_2 = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6']\n\nlocations_1 = locations[0]\nlocations_2 = locations[1]\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations_1], Debug=True)\n    Port_provider = reserve_port(Locations=[locations_2], Debug=True)\n\n    # 创建PWE向导\n\n    wizard = create_mpls_wizard(Type='pwe')\n\n    # 配置客户端侧端口和提供商侧端口\n    for port in Port_customer:\n        edit_mpls_customer_port(Wizard=wizard, Port=port, EnableSubInterface=True, SubInterfaceCount=250,\n                                VlanId=1000)\n    for port in Port_provider:\n        edit_mpls_provider_port(Wizard=wizard, Port=port, DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='1.1.1.1',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=False,\n                                               PeRouterIdStart='2.1.1.1',\n                                               PeRouterIdStep='0.0.0.1')\n\n    # 配置PWE\n\n    edit_mpls_pwe_basic_parameters(Wizard=wizard,\n                                   NumberOfPseudoWire=10,\n                                   Mtu=1518,\n                                   GroupId=20,\n                                   EnableCBit=True,\n                                   IncludeStatusTlv=True,\n                                   StatusCode='LocalAttachmentCircuitReceiveFault',\n                                   EnableOverrideEncapsulation=True,\n                                   Encapsulation='Ethernet',\n                                   EnableOverlapVcidsOnDifferentPes=True,\n                                   EnableCreateProviderHostsForUnusedVpls=True,\n                                   FecType='FEC129')\n\n    edit_mpls_fec129(Wizard=wizard,\n                     Agi='10:1',\n                     AgiIncrement='0:2',\n                     Saii='1.1.1.1',\n                     SaiiIncrement='0.0.0.2',\n                     Taii='2.2.2.2',\n                     TaiiIncrement='0.0.0.3',\n                     EnableBgpAutoDiscovery=True,\n                     DutAsNumber=10,\n                     RdAssignment='Manual',\n                     AgiAssignment='Manual',\n                     Rt='20:0',\n                     RtIncrement='0:2',\n                     Rd='30:0',\n                     RdIncrement='0:3')\n\n    # 配置Host\n\n    edit_mpls_host(Wizard=wizard,\n                   HostAssignmentVpls='HostsOrMacsPerVpls',\n                   HostsPerVpls=32,\n                   CustomerHostPercent=50,\n                   ProviderHostPercent=50)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            TrafficLoadPercentProvider=10)\n\n    # LSP Ping\n    edit_lsp_ping(Wizard=wizard,\n                  EnableLspPing=True,\n                  DestinationIpv4Address='1.1.1.1',\n                  PingInterval=10,\n                  PingTimeout=20,\n                  TimeToLive=30,\n                  LspExpValue=7,\n                  ValidateFecStack=True,\n                  PadMode='RequestPeerToDropPadTlv',\n                  PadData=[1, 2, 3])\n\n    # 生成PWE向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_mpls_wizard:测试仪表创建MPLS向导;\nedit_lsp_ping:配置MPLS流量LSP Ping参数;\nedit_mpls_customer_port:配置MPLS向导客户侧端口;\nedit_mpls_fec129:配置MPLS fec129参数;\nedit_mpls_host:配置MPLS向导Host参数;\nedit_mpls_provider_port:配置MPLS向导提供商侧端口;\nedit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由;\nedit_mpls_pwe_basic_parameters:配置MPLS pwe参数;\nedit_traffic_parameters:配置MPLS流量;\nexpand_mpls_wizard:生成测试仪表MPLS向导配置\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc3918_MulticastGroupCapacity.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定再DUT/SUT能够正确转发数据包到注册在该DUT/SUT的组播组情况下，DUT/SUT能够支持的最大的组播组数量\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项组播组容量测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置组播组容量;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成配置组播组容量测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastGroupCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed',\n                                   DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置组播组容量* ===============\n    # 组播搜索算法\n    edit_benchmark_search(Config=Config, Mode='binary', Lower=1, Upper=20, Init=10, Step=10, Resolution=1, Ratio=50,\n                          Acceptance=0, Ignore=False, EnableLatency=False, Maxlatency=30)\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True,\n                                    ResultFileName='Rfc3918MulticastGroupCapacity',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastGroupCapacity')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数",
      "edit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他",
      "edit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个测试端口并建立连接。\",\n  \"子任务3\": \"创建RFC3918测试向导，选择组播组容量测试项。\",\n  \"子任务4\": \"将预约端口关联到测试向导配置。\",\n  \"子任务5\": \"在端口1创建IPv4接口并配置IP地址与网关。\",\n  \"子任务6\": \"在端口2创建IPv4接口并配置IP地址与网关。\",\n  \"子任务7\": \"从接口获取IPv4层对象作为流端点。\",\n  \"子任务8\": \"创建单向多对多IPv4测试流，关联源和目的端点。\",\n  \"子任务9\": \"配置组播基础参数：IGMP版本、组播组地址范围、加入/离开延迟、组分配模式。\",\n  \"子任务10\": \"配置传输层参数：UDP协议、随机端口设置。\",\n  \"子任务11\": \"配置流参数：TOS值、TTL、优先级。\",\n  \"子任务12\": \"配置地址学习参数：学习频率、ARP设置、学习速率。\",\n  \"子任务13\": \"配置测试时长参数：突发模式、单次测试。\",\n  \"子任务14\": \"配置帧长度参数：步进模式、长度范围及步长。\",\n  \"子任务15\": \"配置时延类型为FIFO。\",\n  \"子任务16\": \"配置组播其他参数：失败停止条件、验证频率、发送帧速率。\",\n  \"子任务17\": \"配置结果保存路径。\",\n  \"子任务18\": \"配置延迟后等待时间。\",\n  \"子任务19\": \"配置组播组容量搜索算法：二分法、上下边界、分辨率。\",\n  \"子任务20\": \"配置流量负载参数：百分比模式、随机负载范围。\",\n  \"子任务21\": \"配置自定义结果文件名并启用时间戳。\",\n  \"子任务22\": \"生成测试智能脚本并展开配置。\",\n  \"子任务23\": \"保存当前测试配置文件。\",\n  \"子任务24\": \"执行测试套件并设置超时与分析器。\",\n  \"子任务25\": \"获取组播组容量测试结果数据。\",\n  \"子任务26\": \"格式化测试结果为表格并输出。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定再DUT/SUT能够正确转发数据包到注册在该DUT/SUT的组播组情况下，DUT/SUT能够支持的最大的组播组数量\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项组播组容量测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置组播组容量;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成配置组播组容量测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastGroupCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed',\n                                   DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置组播组容量* ===============\n    # 组播搜索算法\n    edit_benchmark_search(Config=Config, Mode='binary', Lower=1, Upper=20, Init=10, Step=10, Resolution=1, Ratio=50,\n                          Acceptance=0, Ignore=False, EnableLatency=False, Maxlatency=30)\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True,\n                                    ResultFileName='Rfc3918MulticastGroupCapacity',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastGroupCapacity')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数;\nedit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他;\nedit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_Frameloss.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备丢包率测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2544向导, 选择丢包率测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址缓存容量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2544', Items=['frameloss'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth', 'ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth', 'ipv4'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置rfc2544* ===============\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_latency(Configs=Config, Type='FILO', DelayBefore=1, DelayAfter=2)\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='tcp')\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *配置丢包率* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[128])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='frameloss',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2544')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约指定位置的测试端口，强制占用并获取端口对象。\",\n  \"子任务3\": \"创建RFC2544测试套件，选择丢包率测试项。\",\n  \"子任务4\": \"关联测试套件与预约的测试端口。\",\n  \"子任务5\": \"在测试端口上创建以太网和IPv4层接口。\",\n  \"子任务6\": \"从接口对象中提取IPv4层端点信息。\",\n  \"子任务7\": \"创建单向IPv4流量流，源端点为端口1，目的端点为端口2。\",\n  \"子任务8\": \"配置测试套件地址学习参数：频率为单次，禁用ARP。\",\n  \"子任务9\": \"配置测试时延参数：类型FILO，延迟前1秒，延迟后2秒。\",\n  \"子任务10\": \"配置传输层协议为TCP。\",\n  \"子任务11\": \"设置测试结果保存路径。\",\n  \"子任务12\": \"配置测试次数为1次试验。\",\n  \"子任务13\": \"设置帧长类型为自定义，指定128字节帧长。\",\n  \"子任务14\": \"配置流量负载模式：步进模式，起始10%，结束20%，步长10%。\",\n  \"子任务15\": \"启用自定义测试结果文件名，添加时间戳。\",\n  \"子任务16\": \"生成测试智能脚本。\",\n  \"子任务17\": \"保存当前测试配置到指定路径的配置文件。\",\n  \"子任务18\": \"执行测试套件，启用结果分析器，设置1200秒超时。\",\n  \"子任务19\": \"从测试结果数据库中获取RFC2544测试结果数据。\",\n  \"子任务20\": \"格式化测试结果为二维表格并输出。\",\n  \"子任务21\": \"验证测试结果是否包含设备地址缓存容量参数。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备丢包率测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2544向导, 选择丢包率测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址缓存容量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2544', Items=['frameloss'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth', 'ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth', 'ipv4'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置rfc2544* ===============\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_latency(Configs=Config, Type='FILO', DelayBefore=1, DelayAfter=2)\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='tcp')\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *配置丢包率* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[128])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='frameloss',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2544')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/bgp_route/bgp_route_wizard.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查Bgp Route向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Bgp会话;\n                   测试步骤3: 创建Bgp Route向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Bgp Route向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1 = Port(upper=get_sys_entry())\n    Port_2 = Port(upper=get_sys_entry())\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='eth', Tops=['ipv4', 'ipv6'])\n    interfaces_2 = create_interface(Port=Port_2, Layers='eth', Tops=['ipv4', 'ipv6'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建BGP会话\n    Bgp_1 = create_bgp(Port=Port_1)\n    Bgp_2 = create_bgp(Port=Port_2)\n\n    select_interface(Session=Bgp_1, Interface=interfaces_1)\n    select_interface(Session=Bgp_2, Interface=interfaces_2)\n\n    # 创建BGP Route向导\n    wizard = create_bgp_route_wizard(Sessions=[Bgp_1, Bgp_2],\n                                     BgpRouteType='IPV4_IPV6',\n                                     EnableLinkState=True)\n\n    # 配置ipv4 route\n    config_bgp_route_wizard_ipv4(Wizards=wizard,\n                                 TotalIpv4RouteCount=2,\n                                 IPv4DistributionType='LINEAR',\n                                 PrefixLength=16,\n                                 EndPrefixLength=32)\n\n    # 配置ipv6 route\n    config_bgp_route_wizard_ipv6(Wizards=wizard,\n                                 TotalIpv6RouteCount=10)\n\n    # 配置IGP拓扑\n    config_bgp_route_wizard_igp_topo(Wizards=wizard,\n                                     ProtocolType='ISIS_IPV4')\n\n    # 配置IGP\n    config_bgp_route_wizard_igp(Wizards=wizard,\n                                EnableTeOptions=True)\n    config_bgp_route_wizard_igp_te_option(Wizards=wizard,\n                                          EnableUnreserved=True)\n\n    # 生成BGP Route向导配置\n    expand_bgp_route_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "create_bgp:创建BGP协议会话对象",
      "select_interface:协议绑定测试仪表接口"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表平台，指定产品型号为DarYu。\",\n  \"子任务2\": \"创建两个离线测试端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建以太网接口，并配置IPv4地址192.168.1.2（网关192.168.1.3）及IPv6地址2001::1（网关2001::2）。\",\n  \"子任务4\": \"在Port_2上创建以太网接口，并配置IPv4地址192.168.1.3（网关192.168.1.2）及IPv6地址2001::2（网关2001::1）。\",\n  \"子任务5\": \"在Port_1上创建BGP会话Bgp_1，并将其绑定到该端口的网络接口。\",\n  \"子任务6\": \"在Port_2上创建BGP会话Bgp_2，并将其绑定到该端口的网络接口。\",\n  \"子任务7\": \"创建BGP Route向导，指定会话为Bgp_1和Bgp_2，路由类型为IPV4_IPV6，并启用链路状态功能。\",\n  \"子任务8\": \"配置向导的IPv4路由参数：总路由数2，线性分布，前缀长度16-32。\",\n  \"子任务9\": \"配置向导的IPv6路由参数：总路由数10。\",\n  \"子任务10\": \"配置向导的IGP拓扑协议类型为ISIS_IPV4。\",\n  \"子任务11\": \"启用IGP的流量工程选项，并特别启用未保留带宽功能。\",\n  \"子任务12\": \"执行BGP Route向导配置生成操作。\",\n  \"子任务13\": \"验证向导配置生成过程无异常错误。\",\n  \"子任务14\": \"保存当前测试配置到指定路径的.xcfg文件。\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查Bgp Route向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Bgp会话;\n                   测试步骤3: 创建Bgp Route向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Bgp Route向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1 = Port(upper=get_sys_entry())\n    Port_2 = Port(upper=get_sys_entry())\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='eth', Tops=['ipv4', 'ipv6'])\n    interfaces_2 = create_interface(Port=Port_2, Layers='eth', Tops=['ipv4', 'ipv6'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建BGP会话\n    Bgp_1 = create_bgp(Port=Port_1)\n    Bgp_2 = create_bgp(Port=Port_2)\n\n    select_interface(Session=Bgp_1, Interface=interfaces_1)\n    select_interface(Session=Bgp_2, Interface=interfaces_2)\n\n    # 创建BGP Route向导\n    wizard = create_bgp_route_wizard(Sessions=[Bgp_1, Bgp_2],\n                                     BgpRouteType='IPV4_IPV6',\n                                     EnableLinkState=True)\n\n    # 配置ipv4 route\n    config_bgp_route_wizard_ipv4(Wizards=wizard,\n                                 TotalIpv4RouteCount=2,\n                                 IPv4DistributionType='LINEAR',\n                                 PrefixLength=16,\n                                 EndPrefixLength=32)\n\n    # 配置ipv6 route\n    config_bgp_route_wizard_ipv6(Wizards=wizard,\n                                 TotalIpv6RouteCount=10)\n\n    # 配置IGP拓扑\n    config_bgp_route_wizard_igp_topo(Wizards=wizard,\n                                     ProtocolType='ISIS_IPV4')\n\n    # 配置IGP\n    config_bgp_route_wizard_igp(Wizards=wizard,\n                                EnableTeOptions=True)\n    config_bgp_route_wizard_igp_te_option(Wizards=wizard,\n                                          EnableUnreserved=True)\n\n    # 生成BGP Route向导配置\n    expand_bgp_route_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\ncreate_bgp:创建BGP协议会话对象;\nselect_interface:协议绑定测试仪表接口\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/rip_route/rip_route_wizard.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查Rip Route向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Rip会话;\n                   测试步骤3: 创建Rip Route向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Rip Route向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='eth', Tops=['ipv4', 'ipv6'])\n    interfaces_2 = create_interface(Port=Port_2, Layers='eth', Tops=['ipv4', 'ipv6'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建Rip会话\n    rip_1 = create_rip(Port=Port_1)\n    rip_2 = create_rip(Port=Port_2, Version='RIPNG')\n\n    select_interface(Session=rip_1, Interface=interfaces_1)\n    select_interface(Session=rip_2, Interface=interfaces_2)\n\n    # 创建Rip Route向导\n    wizard = create_rip_route_wizard(Sessions=[rip_1, rip_2])\n\n    # 配置ipv4 route\n    config_rip_route_wizard_ipv4(Wizards=wizard,\n                                 Ipv4RoutesPrefixLenType='LINEAR',\n                                 Ipv4RoutesPrefixLenStart=8,\n                                 Ipv4RoutesPrefixLenEnd=24)\n\n    # 配置ipv6 route\n    config_rip_route_wizard_ipv6(Wizards=wizard,\n                                 Ipv6StartRoutesPrefix='2022::',\n                                 Ipv6EndRoutesPrefix='2033::')\n\n    # 生成Rip Route向导配置\n    expand_rip_route_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "create_rip:创建RIP协议会话对象"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个指定位置的物理端口，分别命名为Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1端口上创建三层接口，配置以太网、IPv4和IPv6协议栈，设置IPv4地址为192.168.1.2/网关192.168.1.3，IPv6地址为2001::1/网关2001::2。\",\n  \"子任务4\": \"在Port_2端口上创建三层接口，配置以太网、IPv4和IPv6协议栈，设置IPv4地址为192.168.1.3/网关192.168.1.2，IPv6地址为2001::2/网关2001::1。\",\n  \"子任务5\": \"在Port_1端口创建RIPv2会话对象。\",\n  \"子任务6\": \"在Port_2端口创建RIPNG会话对象（IPv6版本）。\",\n  \"子任务7\": \"将Port_1的接口绑定到其RIPv2会话。\",\n  \"子任务8\": \"将Port_2的接口绑定到其RIPNG会话。\",\n  \"子任务9\": \"创建RIP Route向导对象，关联两个端口的RIP会话。\",\n  \"子任务10\": \"配置向导的IPv4路由参数：前缀长度类型为线性，起始长度8，结束长度24。\",\n  \"子任务11\": \"配置向导的IPv6路由参数：起始路由前缀2022::，结束路由前缀2033::。\",\n  \"子任务12\": \"执行向导配置生成操作，扩展路由配置。\",\n  \"子任务13\": \"验证配置生成过程无异常错误。\",\n  \"子任务14\": \"保存当前测试仪表配置文件到指定路径。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查Rip Route向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Rip会话;\n                   测试步骤3: 创建Rip Route向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Rip Route向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='eth', Tops=['ipv4', 'ipv6'])\n    interfaces_2 = create_interface(Port=Port_2, Layers='eth', Tops=['ipv4', 'ipv6'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建Rip会话\n    rip_1 = create_rip(Port=Port_1)\n    rip_2 = create_rip(Port=Port_2, Version='RIPNG')\n\n    select_interface(Session=rip_1, Interface=interfaces_1)\n    select_interface(Session=rip_2, Interface=interfaces_2)\n\n    # 创建Rip Route向导\n    wizard = create_rip_route_wizard(Sessions=[rip_1, rip_2])\n\n    # 配置ipv4 route\n    config_rip_route_wizard_ipv4(Wizards=wizard,\n                                 Ipv4RoutesPrefixLenType='LINEAR',\n                                 Ipv4RoutesPrefixLenStart=8,\n                                 Ipv4RoutesPrefixLenEnd=24)\n\n    # 配置ipv6 route\n    config_rip_route_wizard_ipv6(Wizards=wizard,\n                                 Ipv6StartRoutesPrefix='2022::',\n                                 Ipv6EndRoutesPrefix='2033::')\n\n    # 生成Rip Route向导配置\n    expand_rip_route_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\ncreate_rip:创建RIP协议会话对象\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/mpls/ldp_vpls.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查LDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\n# locations_1 = ['//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16']\n# locations_2 = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6']\n\nlocations_1 = locations[0]\nlocations_2 = locations[1]\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations_1], Debug=True)\n    Port_provider = reserve_port(Locations=[locations_2], Debug=True)\n\n    # 创建LDP VPLS向导\n\n    wizard = create_mpls_wizard(Type='ldp_vpls')\n\n    # 配置客户端侧端口和提供商侧端口\n    for port in Port_customer:\n        edit_mpls_customer_port(Wizard=wizard, Port=port, EnableSubInterface=True, SubInterfaceCount=250,\n                                VlanId=1000)\n    for port in Port_provider:\n        edit_mpls_provider_port(Wizard=wizard, Port=port, DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='1.1.1.1',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=False,\n                                               PeRouterIdStart='2.1.1.1',\n                                               PeRouterIdStep='0.0.0.1')\n\n    # 配置VPLS\n\n    edit_mpls_vpls_basic_parameters(Wizard=wizard,\n                                    NumberOfVpls=1000,\n                                    Mtu=9000,\n                                    GroupId=0,\n                                    EnableOverrideEncapsulation=True,\n                                    Encapsulation='EthernetVlan')\n\n    edit_mpls_fec128(Wizard=wizard, StartVcId=1, StepVcId=1)\n\n    # 配置Host\n\n    edit_mpls_host(Wizard=wizard,\n                   HostAssignmentVpls='HostsOrMacsPerVpls',\n                   HostsPerVpls=32,\n                   CustomerHostPercent=50,\n                   ProviderHostPercent=50)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            TrafficLoadPercentProvider=10)\n\n    # 生成LDP VPLS向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_mpls_wizard:测试仪表创建MPLS向导",
      "edit_mpls_customer_port:配置MPLS向导客户侧端口",
      "edit_mpls_fec128:配置MPLS fec128参数",
      "edit_mpls_host:配置MPLS向导Host参数",
      "edit_mpls_provider_port:配置MPLS向导提供商侧端口",
      "edit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由",
      "edit_mpls_vpls_basic_parameters:配置MPLS VPLS参数",
      "edit_traffic_parameters:配置MPLS流量",
      "expand_mpls_wizard:生成测试仪表MPLS向导配置"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个测试端口：Port_1作为客户端侧端口，Port_2作为提供商侧端口。\",\n  \"子任务3\": \"创建LDP VPLS类型的MPLS向导。\",\n  \"子任务4\": \"配置客户端侧端口：启用子接口，设置子接口数量为250，VLAN ID为1000。\",\n  \"子任务5\": \"配置提供商侧端口：设置DUT IPv4地址为50.1.1.1，前缀长度24。\",\n  \"子任务6\": \"配置提供商侧路由器：设置路由器ID为1.1.1.1，AS号为100，IGP协议为ISIS，MPLS协议为LDP，PE路由器起始地址为2.1.1.1，步长0.0.0.1。\",\n  \"子任务7\": \"配置VPLS基本参数：VPLS数量1000，MTU 9000，Group ID 0，启用EthernetVlan封装覆盖。\",\n  \"子任务8\": \"配置FEC128参数：起始VC ID为1，步长为1。\",\n  \"子任务9\": \"配置Host参数：Host分配方式为HostsOrMacsPerVpls，每个VPLS主机数32，客户侧/提供商侧主机比例各50%。\",\n  \"子任务10\": \"配置流量参数：流量方向为CustomerProviderBoth，流分组方式为Aggregate，提供商侧流量负载10%。\",\n  \"子任务11\": \"生成LDP VPLS向导配置。\",\n  \"子任务12\": \"保存生成的配置文件到指定路径。\",\n  \"子任务13\": \"验证配置生成过程无异常，确认verdict状态为pass。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查LDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\n# locations_1 = ['//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16']\n# locations_2 = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6']\n\nlocations_1 = locations[0]\nlocations_2 = locations[1]\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations_1], Debug=True)\n    Port_provider = reserve_port(Locations=[locations_2], Debug=True)\n\n    # 创建LDP VPLS向导\n\n    wizard = create_mpls_wizard(Type='ldp_vpls')\n\n    # 配置客户端侧端口和提供商侧端口\n    for port in Port_customer:\n        edit_mpls_customer_port(Wizard=wizard, Port=port, EnableSubInterface=True, SubInterfaceCount=250,\n                                VlanId=1000)\n    for port in Port_provider:\n        edit_mpls_provider_port(Wizard=wizard, Port=port, DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='1.1.1.1',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=False,\n                                               PeRouterIdStart='2.1.1.1',\n                                               PeRouterIdStep='0.0.0.1')\n\n    # 配置VPLS\n\n    edit_mpls_vpls_basic_parameters(Wizard=wizard,\n                                    NumberOfVpls=1000,\n                                    Mtu=9000,\n                                    GroupId=0,\n                                    EnableOverrideEncapsulation=True,\n                                    Encapsulation='EthernetVlan')\n\n    edit_mpls_fec128(Wizard=wizard, StartVcId=1, StepVcId=1)\n\n    # 配置Host\n\n    edit_mpls_host(Wizard=wizard,\n                   HostAssignmentVpls='HostsOrMacsPerVpls',\n                   HostsPerVpls=32,\n                   CustomerHostPercent=50,\n                   ProviderHostPercent=50)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            TrafficLoadPercentProvider=10)\n\n    # 生成LDP VPLS向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_mpls_wizard:测试仪表创建MPLS向导;\nedit_mpls_customer_port:配置MPLS向导客户侧端口;\nedit_mpls_fec128:配置MPLS fec128参数;\nedit_mpls_host:配置MPLS向导Host参数;\nedit_mpls_provider_port:配置MPLS向导提供商侧端口;\nedit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由;\nedit_mpls_vpls_basic_parameters:配置MPLS VPLS参数;\nedit_traffic_parameters:配置MPLS流量;\nexpand_mpls_wizard:生成测试仪表MPLS向导配置\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/mpls/bgp_vpls.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查BGP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建BGP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成BGP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 BGP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\n# locations_1 = ['//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16']\n# locations_2 = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6']\n\nlocations_1 = locations[0]\nlocations_2 = locations[1]\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations_1], Debug=True)\n    Port_provider = reserve_port(Locations=[locations_2], Debug=True)\n\n    # 创建BGP VPLS向导\n\n    wizard = create_mpls_wizard(Type='bgp_vpls', enable_vpls_scalability=True)\n\n    # 配置客户端侧端口和提供商侧端口\n    for port in Port_customer:\n        edit_mpls_customer_port(Wizard=wizard, Port=port, EnableSubInterface=True, SubInterfaceCount=250,\n                                VlanId=1000)\n    for port in Port_provider:\n        edit_mpls_provider_port(Wizard=wizard, Port=port, DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='1.1.1.1',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=False,\n                                               PeRouterIdStart='2.1.1.1',\n                                               PeRouterIdStep='0.0.0.1')\n    edit_mpls_provider_router_isis(Wizard=wizard,\n                                   UseSrcMacAsSystemId=False,\n                                   SystemId='22:11:11:11:11:11',\n                                   SystemIdStep='00:00:00:00:00:02',\n                                   Level='L1L2',\n                                   NetworkType='P2P',\n                                   RouterPriority=10,\n                                   MetricMode='WIDE',\n                                   AuthenticationMode='SIMPLE',\n                                   Password='passwd',\n                                   AreaId=20,\n                                   EnableGracefulRestart=True,\n                                   MultiTopologyId='IPV4',\n                                   EnableBfd=True,\n                                   HelloPadding=False,\n                                   Algorithm=30,\n                                   SidLabelBase=40,\n                                   SidLabelRange=50,\n                                   NodeSidIndex=60,\n                                   NodeSidIdnexStep=2)\n\n    edit_mpls_provider_router_ldp(Wizard=wizard,\n                                  HelloType='TARGETED',\n                                  TransportAddressTlvMode='ROUTER_ID',\n                                  LabelAdvertisementMode='DOD',\n                                  EgressLabelMode='IMPLICIT',\n                                  MinLabel=20,\n                                  AuthenticationMode='MD5',\n                                  Password='test')\n    # 配置VPLS\n\n    edit_bgp_vpls(Wizard=wizard,\n                  NumberOfVplss=10,\n                  RdAssignment='Manual',\n                  RouteTargetStart='2:0',\n                  RouteTargetStep='3:0',\n                  Mtu=1518,\n                  VplsAssignment='Sequential',\n                  CustomerRdStart='4:0',\n                  CustomerVeIdStart=20,\n                  CustomerStepPerVplsEnabled=True,\n                  CustomerRdStepPerVpls='5:0',\n                  CustomerStepPerCeEnabled=True,\n                  CustomerRdStepPerCe='6:0',\n                  CustomerVeIdStepPerCe=30,\n                  CustomerOverlapEnabled=True,\n                  ProviderDistributionSelector='PEsPerVPLS',\n                  ProviderDistributionSelectorCount=40,\n                  ProviderMeshed=False,\n                  ProviderRdStart='7:0',\n                  ProviderVeIdStart=50,\n                  ProviderStepPerVplsEnabled=True,\n                  ProviderRdStepPerVpls='8:0',\n                  ProviderStepPerCeEnabled=True,\n                  ProviderRdStepPerCe='9:0',\n                  ProviderVeIdStepPerCe=60,\n                  ProviderOverlapEnabled=True)\n\n    # 配置Host\n\n    edit_mpls_host(Wizard=wizard,\n                   HostAssignmentVpls='HostsOrMacsPerVpls',\n                   HostsPerVpls=32,\n                   CustomerHostPercent=50,\n                   ProviderHostPercent=50)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            TrafficLoadPercentProvider=10)\n\n    # 生成BGP VPLS向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_mpls_wizard:测试仪表创建MPLS向导",
      "edit_mpls_customer_port:配置MPLS向导客户侧端口",
      "edit_mpls_host:配置MPLS向导Host参数",
      "edit_mpls_provider_port:配置MPLS向导提供商侧端口",
      "edit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由",
      "edit_mpls_provider_router_isis:配置MPLS提供商侧路由路由器OSPF协议",
      "edit_mpls_provider_router_ldp:配置MPLS提供商侧路由路由器LDP协议",
      "edit_traffic_parameters:配置MPLS流量",
      "expand_mpls_wizard:生成测试仪表MPLS向导配置"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约客户侧端口，指定物理位置并启用调试模式。\",\n  \"子任务3\": \"预约提供商侧端口，指定物理位置并启用调试模式。\",\n  \"子任务4\": \"创建BGP VPLS向导，启用VPLS扩展功能。\",\n  \"子任务5\": \"配置客户侧端口参数：启用子接口，设置子接口数量为250，VLAN ID为1000。\",\n  \"子任务6\": \"配置提供商侧端口参数：设置DUT IPv4地址为50.1.1.1，前缀长度为24。\",\n  \"子任务7\": \"配置提供商路由器基础参数：路由器ID为1.1.1.1，AS号为100，IGP协议为ISIS，MPLS协议为LDP，禁用P-Router。\",\n  \"子任务8\": \"配置提供商路由器ISIS协议：禁用源MAC作为系统ID，设置系统ID为22:11:11:11:11:11，级别为L1L2，认证模式为SIMPLE，启用BFD。\",\n  \"子任务9\": \"配置提供商路由器LDP协议：设置Hello类型为TARGETED，标签通告模式为DOD，认证模式为MD5。\",\n  \"子任务10\": \"配置VPLS参数：设置VPLS数量为10，手动分配RD，MTU为1518，配置客户侧和提供商侧的RD/VE ID步长及重叠功能。\",\n  \"子任务11\": \"配置Host参数：设置每个VPLS的主机数为32，客户侧与提供商侧主机各占50%。\",\n  \"子任务12\": \"配置流量参数：设置流量方向为双向，分组模式为聚合，提供商侧负载百分比为10%。\",\n  \"子任务13\": \"生成BGP VPLS向导配置并验证无异常。\",\n  \"子任务14\": \"保存生成的配置文件到指定路径。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查BGP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建BGP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成BGP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 BGP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\n# locations_1 = ['//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16']\n# locations_2 = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6']\n\nlocations_1 = locations[0]\nlocations_2 = locations[1]\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations_1], Debug=True)\n    Port_provider = reserve_port(Locations=[locations_2], Debug=True)\n\n    # 创建BGP VPLS向导\n\n    wizard = create_mpls_wizard(Type='bgp_vpls', enable_vpls_scalability=True)\n\n    # 配置客户端侧端口和提供商侧端口\n    for port in Port_customer:\n        edit_mpls_customer_port(Wizard=wizard, Port=port, EnableSubInterface=True, SubInterfaceCount=250,\n                                VlanId=1000)\n    for port in Port_provider:\n        edit_mpls_provider_port(Wizard=wizard, Port=port, DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='1.1.1.1',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=False,\n                                               PeRouterIdStart='2.1.1.1',\n                                               PeRouterIdStep='0.0.0.1')\n    edit_mpls_provider_router_isis(Wizard=wizard,\n                                   UseSrcMacAsSystemId=False,\n                                   SystemId='22:11:11:11:11:11',\n                                   SystemIdStep='00:00:00:00:00:02',\n                                   Level='L1L2',\n                                   NetworkType='P2P',\n                                   RouterPriority=10,\n                                   MetricMode='WIDE',\n                                   AuthenticationMode='SIMPLE',\n                                   Password='passwd',\n                                   AreaId=20,\n                                   EnableGracefulRestart=True,\n                                   MultiTopologyId='IPV4',\n                                   EnableBfd=True,\n                                   HelloPadding=False,\n                                   Algorithm=30,\n                                   SidLabelBase=40,\n                                   SidLabelRange=50,\n                                   NodeSidIndex=60,\n                                   NodeSidIdnexStep=2)\n\n    edit_mpls_provider_router_ldp(Wizard=wizard,\n                                  HelloType='TARGETED',\n                                  TransportAddressTlvMode='ROUTER_ID',\n                                  LabelAdvertisementMode='DOD',\n                                  EgressLabelMode='IMPLICIT',\n                                  MinLabel=20,\n                                  AuthenticationMode='MD5',\n                                  Password='test')\n    # 配置VPLS\n\n    edit_bgp_vpls(Wizard=wizard,\n                  NumberOfVplss=10,\n                  RdAssignment='Manual',\n                  RouteTargetStart='2:0',\n                  RouteTargetStep='3:0',\n                  Mtu=1518,\n                  VplsAssignment='Sequential',\n                  CustomerRdStart='4:0',\n                  CustomerVeIdStart=20,\n                  CustomerStepPerVplsEnabled=True,\n                  CustomerRdStepPerVpls='5:0',\n                  CustomerStepPerCeEnabled=True,\n                  CustomerRdStepPerCe='6:0',\n                  CustomerVeIdStepPerCe=30,\n                  CustomerOverlapEnabled=True,\n                  ProviderDistributionSelector='PEsPerVPLS',\n                  ProviderDistributionSelectorCount=40,\n                  ProviderMeshed=False,\n                  ProviderRdStart='7:0',\n                  ProviderVeIdStart=50,\n                  ProviderStepPerVplsEnabled=True,\n                  ProviderRdStepPerVpls='8:0',\n                  ProviderStepPerCeEnabled=True,\n                  ProviderRdStepPerCe='9:0',\n                  ProviderVeIdStepPerCe=60,\n                  ProviderOverlapEnabled=True)\n\n    # 配置Host\n\n    edit_mpls_host(Wizard=wizard,\n                   HostAssignmentVpls='HostsOrMacsPerVpls',\n                   HostsPerVpls=32,\n                   CustomerHostPercent=50,\n                   ProviderHostPercent=50)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            TrafficLoadPercentProvider=10)\n\n    # 生成BGP VPLS向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_mpls_wizard:测试仪表创建MPLS向导;\nedit_mpls_customer_port:配置MPLS向导客户侧端口;\nedit_mpls_host:配置MPLS向导Host参数;\nedit_mpls_provider_port:配置MPLS向导提供商侧端口;\nedit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由;\nedit_mpls_provider_router_isis:配置MPLS提供商侧路由路由器OSPF协议;\nedit_mpls_provider_router_ldp:配置MPLS提供商侧路由路由器LDP协议;\nedit_traffic_parameters:配置MPLS流量;\nexpand_mpls_wizard:生成测试仪表MPLS向导配置\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/L2TP/L2TP.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查L2TP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建L2TP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    \n    edit_interface_stack(Interfaces=interfaces_1, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    edit_interface_stack(Interfaces=interfaces_2, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    \n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Level=0, Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Level=0, Address='1.1.1.2', Gateway='1.1.1.1')\n\n\n    # 创建L2TP协议会话\n\n    l2tp_1 = create_l2tp(Port=Port_UP)\n    l2tp_2 = create_l2tp(Port=Port_Down, EmulationMode='LNS')\n\n    select_interface(Session=l2tp_1, Interface=interfaces_1)\n    select_interface(Session=l2tp_2, Interface=interfaces_2)\n\n    pppoe_1 = create_pppoe(Port=Port_UP, EmulationMode='CLIENT')\n    pppoe_2 = create_pppoe(Port=Port_Down, EmulationMode='SERVER')\n    pppoe_1.EmulationMode = 'PPPOL2TP'\n    pppoe_2.EmulationMode = 'PPPOL2TP'\n    select_interface(Session=pppoe_1, Interface=interfaces_1)\n    select_interface(Session=pppoe_2, Interface=interfaces_2)\n\n\n    # 获取接口绑定流端点对象\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    # 创建接口绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['L2tpPortStatistic', 'L2tpBlockStatistic', 'L2tpSessionStatistic', 'L2tpTunnelStatistic', 'PppoeClientStatistic', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PPPoE协议会话达到CONNECTED状态\n\n    wait_l2tp_state(Sessions=[l2tp_1, l2tp_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取L2TP会话1统计\n    import pandas\n    result = get_l2tp_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_l2tp_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_l2tp_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_session_statistic(Session=l2tp_1, NodeIndexInBlock=1)\n    print(result)\n    result = get_l2tp_session_statistic(Session=l2tp_2, NodeIndexInBlock=1)\n    print(result)\n\n    result = get_l2tp_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_block_statistic(Session=l2tp_1)\n    print(result)\n    result = get_l2tp_block_statistic(Session=l2tp_2)\n    print(result)\n\n    result = get_l2tp_tunnel_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_tunnel_statistic(Session=l2tp_1, NodeIndexInBlock=1)\n    print(result)\n    result = get_l2tp_tunnel_statistic(Session=l2tp_2, NodeIndexInBlock=1)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "edit_interface_stack:修改测试仪表接口的结构",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_l2tp:创建L2tp协议会话对象",
      "get_l2tp_block_statistic:获取L2tp Block Statistic统计结果",
      "get_l2tp_port_statistic:获取L2tp Session Statistic统计结果",
      "get_l2tp_session_statistic:获取L2tp Session Statistic统计结果",
      "get_l2tp_tunnel_statistic:获取L2tp Tunnel Statistic统计结果",
      "wait_l2tp_state:等待L2tp协议会话达到指定状态",
      "create_pppoe:创建PPPoE协议会话对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表。\",\n  \"子任务2\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务3\": \"在 Port_1 和 Port_2 上分别创建网络接口。\",\n  \"子任务4\": \"修改两个接口的协议栈结构：依次添加 eth、l2tp、ipv4 层并设置顶层为 ipv4。\",\n  \"子任务5\": \"配置两个接口的 IPv4 参数：Port_1 接口地址为 1.1.1.1/网关 1.1.1.2，Port_2 接口地址为 1.1.1.2/网关 1.1.1.1。\",\n  \"子任务6\": \"在 Port_1 创建 L2TP 会话（LAC 模式），在 Port_2 创建 L2TP 会话（LNS 模式）。\",\n  \"子任务7\": \"将 L2TP 会话分别绑定到对应接口。\",\n  \"子任务8\": \"在 Port_1 创建 PPPoE 会话（PPPOL2TP 客户端模式），在 Port_2 创建 PPPoE 会话（PPPOL2TP 服务器模式）。\",\n  \"子任务9\": \"将 PPPoE 会话分别绑定到对应接口。\",\n  \"子任务10\": \"获取两个接口的封装层对象作为流端点。\",\n  \"子任务11\": \"创建双向绑定流：源端点(Port_1)到目的端点(Port_2)。\",\n  \"子任务12\": \"订阅流模板块统计(StreamBlockStats)。\",\n  \"子任务13\": \"保存当前测试配置。\",\n  \"子任务14\": \"启动所有协议会话。\",\n  \"子任务15\": \"等待 L2TP 会话达到连接状态并稳定 5 秒。\",\n  \"子任务16\": \"开始发送所有流量。\",\n  \"子任务17\": \"持续发送流量 10 秒。\",\n  \"子任务18\": \"停止所有流量发送。\",\n  \"子任务19\": \"停止所有协议会话。\",\n  \"子任务20\": \"获取每个流的 StreamBlockStats 统计信息。\",\n  \"子任务21\": \"验证每个流的发送帧数(TxStreamFrames)与接收帧数(RxStreamFrames)是否相等。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查L2TP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建L2TP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    \n    edit_interface_stack(Interfaces=interfaces_1, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    edit_interface_stack(Interfaces=interfaces_2, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    \n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Level=0, Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Level=0, Address='1.1.1.2', Gateway='1.1.1.1')\n\n\n    # 创建L2TP协议会话\n\n    l2tp_1 = create_l2tp(Port=Port_UP)\n    l2tp_2 = create_l2tp(Port=Port_Down, EmulationMode='LNS')\n\n    select_interface(Session=l2tp_1, Interface=interfaces_1)\n    select_interface(Session=l2tp_2, Interface=interfaces_2)\n\n    pppoe_1 = create_pppoe(Port=Port_UP, EmulationMode='CLIENT')\n    pppoe_2 = create_pppoe(Port=Port_Down, EmulationMode='SERVER')\n    pppoe_1.EmulationMode = 'PPPOL2TP'\n    pppoe_2.EmulationMode = 'PPPOL2TP'\n    select_interface(Session=pppoe_1, Interface=interfaces_1)\n    select_interface(Session=pppoe_2, Interface=interfaces_2)\n\n\n    # 获取接口绑定流端点对象\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    # 创建接口绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['L2tpPortStatistic', 'L2tpBlockStatistic', 'L2tpSessionStatistic', 'L2tpTunnelStatistic', 'PppoeClientStatistic', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PPPoE协议会话达到CONNECTED状态\n\n    wait_l2tp_state(Sessions=[l2tp_1, l2tp_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取L2TP会话1统计\n    import pandas\n    result = get_l2tp_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_l2tp_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_l2tp_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_session_statistic(Session=l2tp_1, NodeIndexInBlock=1)\n    print(result)\n    result = get_l2tp_session_statistic(Session=l2tp_2, NodeIndexInBlock=1)\n    print(result)\n\n    result = get_l2tp_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_block_statistic(Session=l2tp_1)\n    print(result)\n    result = get_l2tp_block_statistic(Session=l2tp_2)\n    print(result)\n\n    result = get_l2tp_tunnel_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_tunnel_statistic(Session=l2tp_1, NodeIndexInBlock=1)\n    print(result)\n    result = get_l2tp_tunnel_statistic(Session=l2tp_2, NodeIndexInBlock=1)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nedit_interface_stack:修改测试仪表接口的结构;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_l2tp:创建L2tp协议会话对象;\nget_l2tp_block_statistic:获取L2tp Block Statistic统计结果;\nget_l2tp_port_statistic:获取L2tp Session Statistic统计结果;\nget_l2tp_session_statistic:获取L2tp Session Statistic统计结果;\nget_l2tp_tunnel_statistic:获取L2tp Tunnel Statistic统计结果;\nwait_l2tp_state:等待L2tp协议会话达到指定状态;\ncreate_pppoe:创建PPPoE协议会话对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/OpenFlow/openflow.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查openflow统计获取正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建switch / controller;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    # 创建协议会话\n\n    switch = create_openflow_switch(Port=Port_UP)\n    controller = create_openflow_controller(Port=Port_Down)\n\n    select_interface(Session=switch, Interface=interfaces_1)\n    select_interface(Session=controller, Interface=interfaces_2)\n\n    # 创建desc\n    controller_desc = edit_controller_desc(Sessions=switch)\n    switch_desc = edit_switch_desc(Sessions=controller)\n\n    # 订阅统计\n\n    subscribe_result(Types=['OfpControllerStats', 'OfpSwitchDescStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n    time.sleep(5)\n\n    # 获取统计\n    result = get_openflow_controller_statistic(Controller=controller)\n    print(result)\n\n    result = get_openflow_switch_statistic(Switch=switch_desc)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表。\",\n  \"子任务2\": \"预约两个端口用于测试。\",\n  \"子任务3\": \"在第一个预约端口上创建网络接口。\",\n  \"子任务4\": \"在第二个预约端口上创建网络接口。\",\n  \"子任务5\": \"在第一个端口上创建openflow switch协议会话。\",\n  \"子任务6\": \"在第二个端口上创建openflow controller协议会话。\",\n  \"子任务7\": \"将第一个端口的接口绑定到openflow switch会话。\",\n  \"子任务8\": \"将第二个端口的接口绑定到openflow controller会话。\",\n  \"子任务9\": \"编辑controller描述信息。\",\n  \"子任务10\": \"编辑switch描述信息。\",\n  \"子任务11\": \"订阅OfpControllerStats和OfpSwitchDescStats统计视图。\",\n  \"子任务12\": \"保存当前测试配置到文件。\",\n  \"子任务13\": \"启动所有协议会话。\",\n  \"子任务14\": \"等待5秒确保协议稳定运行。\",\n  \"子任务15\": \"获取openflow controller统计信息。\",\n  \"子任务16\": \"获取openflow switch统计信息。\",\n  \"子任务17\": \"验证controller统计信息是否符合预期。\",\n  \"子任务18\": \"验证switch统计信息是否符合预期。\",\n  \"子任务19\": \"停止所有协议会话。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查openflow统计获取正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建switch / controller;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    # 创建协议会话\n\n    switch = create_openflow_switch(Port=Port_UP)\n    controller = create_openflow_controller(Port=Port_Down)\n\n    select_interface(Session=switch, Interface=interfaces_1)\n    select_interface(Session=controller, Interface=interfaces_2)\n\n    # 创建desc\n    controller_desc = edit_controller_desc(Sessions=switch)\n    switch_desc = edit_switch_desc(Sessions=controller)\n\n    # 订阅统计\n\n    subscribe_result(Types=['OfpControllerStats', 'OfpSwitchDescStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n    time.sleep(5)\n\n    # 获取统计\n    result = get_openflow_controller_statistic(Controller=controller)\n    print(result)\n\n    result = get_openflow_switch_statistic(Switch=switch_desc)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/vxlan-h3c.py",
    "intent": "=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/9', '//10.0.11.191/1/10', '//10.0.11.191/1/11', '//10.0.11.191/1/12',\n             '//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16',\n             '//10.0.11.191/1/5', '//10.0.11.191/1/6', '//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(\n    sys.argv) < 2 else sys.argv[\n    1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port1, Port2, Port3, Port4, Port5, Port6, Port7, Port8, Port9, Port10, Port11, Port12 = reserve_port(\n        Locations=locations, Force=True)\n\n    # 创建接口\n    vxlans_1 = []\n    vxlans_2 = []\n    vxlans_3 = []\n    vxlans_4 = []\n    vxlans_5 = []\n    vxlans_6 = []\n    vxlans_7 = []\n    vxlans_8 = []\n    stream_names = ['L3 dut3-stc_T11-30']\n    stream_names_TC4_V6 = ['L3 dut3-dut4-v6_T11-30']\n    Interface_TC4_T_All = []\n    Interface_TC4_V6_1 = []\n    Interface_TC4_V6_2 = []\n    Interface_TC4_V6_All = []\n    Interface_TC5_T_All = []\n    Interface_TC5_All = []\n    Interface_TC5_V6_1 = []\n    Interface_TC5_V6_2 = []\n    Interface_TC5_V6_All = []\n    udplayer = ['udp']\n    headerlayers = ['eth', 'vlan']\n    headerlayers_ipv4 = ['ipv4']\n    headerlayers_ipv6 = ['ipv6']\n\n    for num in range(1, 21):\n        h = hex(num)[2:]\n        i = num + 1\n        interfaces_vtep1 = create_interface(Port=Port1, Layers='ipv4', Name=\"VTEP Device 1-\" + str(num))\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='EthIILayer',\n                       Address='10:00:00:50:00:' + h)\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='IPv4Layer',\n                       Address='13.6.1.' + str(i),\n                       Gateway='13.6.1.1')\n        Session_vxlan = create_vxlan(Port=Port1, Name=\"VTEP Device 1-\" + str(num))\n        vxlans_1.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep1)\n\n        T1 = 20 + num\n        interfaces_vtep2 = create_interface(Port=Port4, Layers='ipv4', Name=\"VTEP Device 1-\" + str(T1))\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='EthIILayer',\n                       Address='10:00:00:51:00:' + h)\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='IPv4Layer',\n                       Address='13.6.2.' + str(i),\n                       Gateway='13.6.2.1')\n        Session_vxlan = create_vxlan(Port=Port4, Name=\"VTEP Device 1-\" + str(T1))\n        vxlans_3.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep2)\n\n        T2 = 40 + num\n        interfaces_vtep3 = create_interface(Port=Port7, Layers='ipv4', Name=\"VTEP Device 1-\" + str(T2))\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='EthIILayer',\n                       Address='10:00:00:52:00:' + h)\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='IPv4Layer',\n                       Address='13.6.3.' + str(i),\n                       Gateway='13.6.3.1')\n        Session_vxlan = create_vxlan(Port=Port7, Name=\"VTEP Device 1-\" + str(T2))\n        vxlans_5.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep3)\n\n        T3 = 60 + num\n        interfaces_vtep4 = create_interface(Port=Port10, Layers='ipv4', Name=\"VTEP Device 1-\" + str(T3))\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='EthIILayer',\n                       Address='10:00:00:53:00:' + h)\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='IPv4Layer',\n                       Address='13.6.4.' + str(i),\n                       Gateway='13.6.4.1')\n        Session_vxlan = create_vxlan(Port=Port10, Name=\"VTEP Device 1-\" + str(T3))\n        vxlans_7.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep4)\n\n    for num in range(1, 21):\n        h = hex(num)[2:]\n        i = num + 1\n        interfaces_vtep1 = create_interface(Port=Port1, Layers='ipv4', Name=\"VTEP Device 2-\" + str(num))\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='EthIILayer',\n                       Address='10:00:00:50:00:' + h)\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='IPv4Layer',\n                       Address='13.6.1.' + str(i),\n                       Gateway='13.6.1.1')\n        Session_vxlan = create_vxlan(Port=Port1, Name=\"VTEP Device 2-\" + str(num))\n        vxlans_2.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep1)\n\n        T1 = 20 + num\n        interfaces_vtep2 = create_interface(Port=Port4, Layers='ipv4', Name=\"VTEP Device 2-\" + str(T1))\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='EthIILayer',\n                       Address='10:00:00:51:00:' + h)\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='IPv4Layer',\n                       Address='13.6.2.' + str(i),\n                       Gateway='13.6.2.1')\n        Session_vxlan = create_vxlan(Port=Port4, Name=\"VTEP Device 2-\" + str(T1))\n        vxlans_4.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep2)\n\n        T2 = 40 + num\n        interfaces_vtep3 = create_interface(Port=Port7, Layers='ipv4', Name=\"VTEP Device 2-\" + str(T2))\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='EthIILayer',\n                       Address='10:00:00:52:00:' + h)\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='IPv4Layer',\n                       Address='13.6.3.' + str(i),\n                       Gateway='13.6.3.1')\n        Session_vxlan = create_vxlan(Port=Port7, Name=\"VTEP Device 2-\" + str(T2))\n        vxlans_6.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep3)\n\n        T3 = 60 + num\n        interfaces_vtep4 = create_interface(Port=Port10, Layers='ipv4', Name=\"VTEP Device 2-\" + str(T3))\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='EthIILayer',\n                       Address='10:00:00:53:00:' + h)\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='IPv4Layer',\n                       Address='13.6.4.' + str(i),\n                       Gateway='13.6.4.1')\n        Session_vxlan = create_vxlan(Port=Port10, Name=\"VTEP Device 2-\" + str(T3))\n        vxlans_8.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep4)\n\n    count = 1\n    xin = 0\n    number = 0\n    l3vni = 10011\n    e = 200\n    f = 11\n    for num in range(1, 41):\n        a = hex(num - 1)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device ' + str(num))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(num))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port1, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.' + str(count) + '.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port1, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.' + str(count) + '.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port1, Layers='ipv6', Count=10, Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:' + hex(count)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port1, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:' + hex(count)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.2',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC4_T_All.append(interfaces_host_1)\n            interfaces_host_2 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC4_V6_1.append(interfaces_host_2)\n            interfaces_host_3 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.102',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC5_T_All.append(interfaces_host_3)\n            interfaces_host_4 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC5_V6_1.append(interfaces_host_4)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_rt5_4)\n\n\n        else:\n            number = number + 1\n            e = e + 1\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device ' + str(num))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(num))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.2',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC4_T_All.append(interfaces_host_1)\n            interfaces_host_2 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC4_V6_2.append(interfaces_host_2)\n            interfaces_host_3 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.102',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC5_T_All.append(interfaces_host_3)\n            interfaces_host_4 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC5_V6_2.append(interfaces_host_4)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    count = 21\n    xin = 0\n    number = 0\n    l3vni = 10031\n    e = 240\n    f = 31\n    for num in range(1, 41):\n        a = hex(num + 39)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            T = 40 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port4, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port4, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port4, Layers='ipv6', Count=10, Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port4, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_rt5_4)\n\n        else:\n            number = number + 1\n            e = e + 1\n            T = 40 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    count = 41\n    xin = 0\n    number = 0\n    l3vni = 10051\n    e = 280\n    f = 51\n    for num in range(1, 41):\n        a = hex(num + 79)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            T = 80 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port7, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port7, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port7, Layers='ipv6', Count=10, Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port7, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_rt5_4)\n\n        else:\n            number = number + 1\n            e = e + 1\n            T = 80 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    count = 61\n    xin = 0\n    number = 0\n    l3vni = 10071\n    e = 320\n    f = 71\n    for num in range(1, 41):\n        a = hex(num + 119)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            T = 120 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port10, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port10, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port10, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port10, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_rt5_4)\n\n        else:\n            number = number + 1\n            e = e + 1\n            T = 120 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    Points_TC4_T_All = get_layer_from_interfaces(Interfaces=Interface_TC4_T_All, Layer='ipv4')\n    Points_TC5_T_All = get_layer_from_interfaces(Interfaces=Interface_TC5_T_All, Layer='ipv4')\n    stream_TC4_T_TC5_T = add_stream(Type='binding', Names=stream_names, SrcPoints=Points_TC4_T_All,\n                                    DstPoints=Points_TC5_T_All,\n                                    TrafficMeshMode='ONE_TO_ONE', Layer='IPV4')\n    create_stream_header(Stream=stream_TC4_T_TC5_T, Index=0, HeaderTypes=udplayer)\n    edit_header_udp(Stream=stream_TC4_T_TC5_T, Level=0, SourcePort=20000, DestPort=10000)\n    edit_modifier(Stream=stream_TC4_T_TC5_T, Attribute='SourcePort', Level=0, Type='Increment', Count=1000,\n                  HeaderType='udp')\n    edit_modifier(Stream=stream_TC4_T_TC5_T, Attribute='DestPort', Level=0, Type='Increment', Count=100,\n                  HeaderType='udp')\n\n    Interface_TC4_V6_All = Interface_TC4_V6_1 + Interface_TC4_V6_2\n    Interface_TC5_V6_All = Interface_TC5_V6_2 + Interface_TC5_V6_1\n    Points_TC4_V6_All = get_layer_from_interfaces(Interfaces=Interface_TC4_V6_All, Layer='ipv6')\n    Points_TC5_V6_All = get_layer_from_interfaces(Interfaces=Interface_TC5_V6_All, Layer='ipv6')\n    stream_TC4_V6_TC5_V6 = add_stream(Type='binding', Names=stream_names_TC4_V6, SrcPoints=Points_TC4_V6_All,\n                                      DstPoints=Points_TC5_V6_All,\n                                      TrafficMeshMode='ONE_TO_ONE', Layer='IPV6')\n    create_stream_header(Stream=stream_TC4_V6_TC5_V6, Index=0, HeaderTypes=udplayer)\n    edit_header_udp(Stream=stream_TC4_V6_TC5_V6, Level=0, SourcePort=20000, DestPort=10000)\n    edit_modifier(Stream=stream_TC4_V6_TC5_V6, Attribute='SourcePort', Level=0, Type='Increment', Count=1000,\n                  HeaderType='udp')\n    edit_modifier(Stream=stream_TC4_V6_TC5_V6, Attribute='DestPort', Level=0, Type='Increment', Count=100,\n                  HeaderType='udp')\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "binding_vxlan_vm:绑定 Vxlan Vm 对象",
      "binding_vxlan_vtep:绑定 Vxlan Vtep 对象",
      "create_vxlan:创建Vxlan协议会话对象",
      "create_vxlan_segment:创建Vxlan Segment对象",
      "edit_header_udp:修改测试仪表流量模板中UDP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约12个测试端口，位置为['//10.0.11.191/1/9', '//10.0.11.191/1/10', ..., '//10.0.11.191/1/8']，强制占用模式。\",\n  \"子任务3\": \"在端口1、4、7、10上创建两组IPv4接口（VTEP Device 1和2），每组20个接口，配置MAC地址（'10:00:00:50:00:XX'模式）和IPv4地址（'13.6.X.Y'模式）。\",\n  \"子任务4\": \"在相同端口创建VXLAN会话，将接口绑定到VXLAN会话。\",\n  \"子任务5\": \"循环创建40个VXLAN Segment（每组端口10个），配置通信类型为2，启用L3 VNI，指定VNI和L3 VNI起始值。\",\n  \"子任务6\": \"为每个Segment创建并配置：IPv4 VM接口（30个/组）、IPv6 VM接口（6个/组）、RT5设备接口（IPv4/IPv6各10个），设置MAC地址、IP地址和网关。\",\n  \"子任务7\": \"为每个Segment创建并配置：TC4-T/TC5-T主机接口（IPv4 20个）、TC4-V6/TC5-V6主机接口（IPv6 20个），设置VLAN ID、优先级、MAC地址和IP地址。\",\n  \"子任务8\": \"将VM接口、RT5接口和主机接口绑定到对应VXLAN Segment。\",\n  \"子任务9\": \"将VM接口和RT5接口绑定到对应VXLAN VTEP。\",\n  \"子任务10\": \"从TC4-T接口组提取IPv4层对象，从TC5-T接口组提取IPv4层对象。\",\n  \"子任务11\": \"创建IPv4 UDP流量流，源为TC4-T接口组，目的为TC5-T接口组，流量模式为ONE_TO_ONE。\",\n  \"子任务12\": \"配置UDP头部：源端口20000，目的端口10000，设置源端口增量（步长1000），目的端口增量（步长100）。\",\n  \"子任务13\": \"从TC4-V6/TC5-V6接口组提取IPv6层对象。\",\n  \"子任务14\": \"创建IPv6 UDP流量流，源为TC4-V6接口组，目的为TC5-V6接口组，流量模式为ONE_TO_ONE。\",\n  \"子任务15\": \"配置IPv6流量UDP头部：源端口20000，目的端口10000，设置源端口增量（步长1000），目的端口增量（步长100）。\",\n  \"子任务16\": \"保存测试用例配置文件到执行脚本同目录的xcfg文件夹。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/9', '//10.0.11.191/1/10', '//10.0.11.191/1/11', '//10.0.11.191/1/12',\n             '//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16',\n             '//10.0.11.191/1/5', '//10.0.11.191/1/6', '//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(\n    sys.argv) < 2 else sys.argv[\n    1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port1, Port2, Port3, Port4, Port5, Port6, Port7, Port8, Port9, Port10, Port11, Port12 = reserve_port(\n        Locations=locations, Force=True)\n\n    # 创建接口\n    vxlans_1 = []\n    vxlans_2 = []\n    vxlans_3 = []\n    vxlans_4 = []\n    vxlans_5 = []\n    vxlans_6 = []\n    vxlans_7 = []\n    vxlans_8 = []\n    stream_names = ['L3 dut3-stc_T11-30']\n    stream_names_TC4_V6 = ['L3 dut3-dut4-v6_T11-30']\n    Interface_TC4_T_All = []\n    Interface_TC4_V6_1 = []\n    Interface_TC4_V6_2 = []\n    Interface_TC4_V6_All = []\n    Interface_TC5_T_All = []\n    Interface_TC5_All = []\n    Interface_TC5_V6_1 = []\n    Interface_TC5_V6_2 = []\n    Interface_TC5_V6_All = []\n    udplayer = ['udp']\n    headerlayers = ['eth', 'vlan']\n    headerlayers_ipv4 = ['ipv4']\n    headerlayers_ipv6 = ['ipv6']\n\n    for num in range(1, 21):\n        h = hex(num)[2:]\n        i = num + 1\n        interfaces_vtep1 = create_interface(Port=Port1, Layers='ipv4', Name=\"VTEP Device 1-\" + str(num))\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='EthIILayer',\n                       Address='10:00:00:50:00:' + h)\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='IPv4Layer',\n                       Address='13.6.1.' + str(i),\n                       Gateway='13.6.1.1')\n        Session_vxlan = create_vxlan(Port=Port1, Name=\"VTEP Device 1-\" + str(num))\n        vxlans_1.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep1)\n\n        T1 = 20 + num\n        interfaces_vtep2 = create_interface(Port=Port4, Layers='ipv4', Name=\"VTEP Device 1-\" + str(T1))\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='EthIILayer',\n                       Address='10:00:00:51:00:' + h)\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='IPv4Layer',\n                       Address='13.6.2.' + str(i),\n                       Gateway='13.6.2.1')\n        Session_vxlan = create_vxlan(Port=Port4, Name=\"VTEP Device 1-\" + str(T1))\n        vxlans_3.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep2)\n\n        T2 = 40 + num\n        interfaces_vtep3 = create_interface(Port=Port7, Layers='ipv4', Name=\"VTEP Device 1-\" + str(T2))\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='EthIILayer',\n                       Address='10:00:00:52:00:' + h)\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='IPv4Layer',\n                       Address='13.6.3.' + str(i),\n                       Gateway='13.6.3.1')\n        Session_vxlan = create_vxlan(Port=Port7, Name=\"VTEP Device 1-\" + str(T2))\n        vxlans_5.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep3)\n\n        T3 = 60 + num\n        interfaces_vtep4 = create_interface(Port=Port10, Layers='ipv4', Name=\"VTEP Device 1-\" + str(T3))\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='EthIILayer',\n                       Address='10:00:00:53:00:' + h)\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='IPv4Layer',\n                       Address='13.6.4.' + str(i),\n                       Gateway='13.6.4.1')\n        Session_vxlan = create_vxlan(Port=Port10, Name=\"VTEP Device 1-\" + str(T3))\n        vxlans_7.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep4)\n\n    for num in range(1, 21):\n        h = hex(num)[2:]\n        i = num + 1\n        interfaces_vtep1 = create_interface(Port=Port1, Layers='ipv4', Name=\"VTEP Device 2-\" + str(num))\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='EthIILayer',\n                       Address='10:00:00:50:00:' + h)\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='IPv4Layer',\n                       Address='13.6.1.' + str(i),\n                       Gateway='13.6.1.1')\n        Session_vxlan = create_vxlan(Port=Port1, Name=\"VTEP Device 2-\" + str(num))\n        vxlans_2.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep1)\n\n        T1 = 20 + num\n        interfaces_vtep2 = create_interface(Port=Port4, Layers='ipv4', Name=\"VTEP Device 2-\" + str(T1))\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='EthIILayer',\n                       Address='10:00:00:51:00:' + h)\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='IPv4Layer',\n                       Address='13.6.2.' + str(i),\n                       Gateway='13.6.2.1')\n        Session_vxlan = create_vxlan(Port=Port4, Name=\"VTEP Device 2-\" + str(T1))\n        vxlans_4.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep2)\n\n        T2 = 40 + num\n        interfaces_vtep3 = create_interface(Port=Port7, Layers='ipv4', Name=\"VTEP Device 2-\" + str(T2))\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='EthIILayer',\n                       Address='10:00:00:52:00:' + h)\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='IPv4Layer',\n                       Address='13.6.3.' + str(i),\n                       Gateway='13.6.3.1')\n        Session_vxlan = create_vxlan(Port=Port7, Name=\"VTEP Device 2-\" + str(T2))\n        vxlans_6.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep3)\n\n        T3 = 60 + num\n        interfaces_vtep4 = create_interface(Port=Port10, Layers='ipv4', Name=\"VTEP Device 2-\" + str(T3))\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='EthIILayer',\n                       Address='10:00:00:53:00:' + h)\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='IPv4Layer',\n                       Address='13.6.4.' + str(i),\n                       Gateway='13.6.4.1')\n        Session_vxlan = create_vxlan(Port=Port10, Name=\"VTEP Device 2-\" + str(T3))\n        vxlans_8.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep4)\n\n    count = 1\n    xin = 0\n    number = 0\n    l3vni = 10011\n    e = 200\n    f = 11\n    for num in range(1, 41):\n        a = hex(num - 1)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device ' + str(num))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(num))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port1, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.' + str(count) + '.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port1, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.' + str(count) + '.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port1, Layers='ipv6', Count=10, Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:' + hex(count)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port1, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:' + hex(count)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.2',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC4_T_All.append(interfaces_host_1)\n            interfaces_host_2 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC4_V6_1.append(interfaces_host_2)\n            interfaces_host_3 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.102',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC5_T_All.append(interfaces_host_3)\n            interfaces_host_4 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC5_V6_1.append(interfaces_host_4)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_rt5_4)\n\n\n        else:\n            number = number + 1\n            e = e + 1\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device ' + str(num))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(num))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.2',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC4_T_All.append(interfaces_host_1)\n            interfaces_host_2 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC4_V6_2.append(interfaces_host_2)\n            interfaces_host_3 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.102',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC5_T_All.append(interfaces_host_3)\n            interfaces_host_4 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC5_V6_2.append(interfaces_host_4)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    count = 21\n    xin = 0\n    number = 0\n    l3vni = 10031\n    e = 240\n    f = 31\n    for num in range(1, 41):\n        a = hex(num + 39)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            T = 40 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port4, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port4, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port4, Layers='ipv6', Count=10, Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port4, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_rt5_4)\n\n        else:\n            number = number + 1\n            e = e + 1\n            T = 40 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    count = 41\n    xin = 0\n    number = 0\n    l3vni = 10051\n    e = 280\n    f = 51\n    for num in range(1, 41):\n        a = hex(num + 79)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            T = 80 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port7, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port7, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port7, Layers='ipv6', Count=10, Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port7, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_rt5_4)\n\n        else:\n            number = number + 1\n            e = e + 1\n            T = 80 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    count = 61\n    xin = 0\n    number = 0\n    l3vni = 10071\n    e = 320\n    f = 71\n    for num in range(1, 41):\n        a = hex(num + 119)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            T = 120 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port10, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port10, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port10, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port10, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_rt5_4)\n\n        else:\n            number = number + 1\n            e = e + 1\n            T = 120 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    Points_TC4_T_All = get_layer_from_interfaces(Interfaces=Interface_TC4_T_All, Layer='ipv4')\n    Points_TC5_T_All = get_layer_from_interfaces(Interfaces=Interface_TC5_T_All, Layer='ipv4')\n    stream_TC4_T_TC5_T = add_stream(Type='binding', Names=stream_names, SrcPoints=Points_TC4_T_All,\n                                    DstPoints=Points_TC5_T_All,\n                                    TrafficMeshMode='ONE_TO_ONE', Layer='IPV4')\n    create_stream_header(Stream=stream_TC4_T_TC5_T, Index=0, HeaderTypes=udplayer)\n    edit_header_udp(Stream=stream_TC4_T_TC5_T, Level=0, SourcePort=20000, DestPort=10000)\n    edit_modifier(Stream=stream_TC4_T_TC5_T, Attribute='SourcePort', Level=0, Type='Increment', Count=1000,\n                  HeaderType='udp')\n    edit_modifier(Stream=stream_TC4_T_TC5_T, Attribute='DestPort', Level=0, Type='Increment', Count=100,\n                  HeaderType='udp')\n\n    Interface_TC4_V6_All = Interface_TC4_V6_1 + Interface_TC4_V6_2\n    Interface_TC5_V6_All = Interface_TC5_V6_2 + Interface_TC5_V6_1\n    Points_TC4_V6_All = get_layer_from_interfaces(Interfaces=Interface_TC4_V6_All, Layer='ipv6')\n    Points_TC5_V6_All = get_layer_from_interfaces(Interfaces=Interface_TC5_V6_All, Layer='ipv6')\n    stream_TC4_V6_TC5_V6 = add_stream(Type='binding', Names=stream_names_TC4_V6, SrcPoints=Points_TC4_V6_All,\n                                      DstPoints=Points_TC5_V6_All,\n                                      TrafficMeshMode='ONE_TO_ONE', Layer='IPV6')\n    create_stream_header(Stream=stream_TC4_V6_TC5_V6, Index=0, HeaderTypes=udplayer)\n    edit_header_udp(Stream=stream_TC4_V6_TC5_V6, Level=0, SourcePort=20000, DestPort=10000)\n    edit_modifier(Stream=stream_TC4_V6_TC5_V6, Attribute='SourcePort', Level=0, Type='Increment', Count=1000,\n                  HeaderType='udp')\n    edit_modifier(Stream=stream_TC4_V6_TC5_V6, Attribute='DestPort', Level=0, Type='Increment', Count=100,\n                  HeaderType='udp')\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nbinding_vxlan_vm:绑定 Vxlan Vm 对象;\nbinding_vxlan_vtep:绑定 Vxlan Vtep 对象;\ncreate_vxlan:创建Vxlan协议会话对象;\ncreate_vxlan_segment:创建Vxlan Segment对象;\nedit_header_udp:修改测试仪表流量模板中UDP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/ping.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查仪表创建接口正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建各种类型接口;\n\n Criteria    \t:   预期结果1: 步骤2中所有接口创建成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n    interface_1 = create_interface(Port=Port_UP, Layers='ipv4')\n    edit_interface(Interface=interface_1, Layer='IPv4Layer', Address='20.0.0.1', Gateway='20.0.0.2')\n    interface_2 = create_interface(Port=Port_Down, Layers='ipv4')\n    edit_interface(Interface=interface_2, Layer='IPv4Layer', Address='20.0.0.2', Gateway='20.0.0.1')\n    ipv4_ping(Interface=interface_1, IpAddr='20.0.0.2', PacketCount=5)\n\n    # 保存配置文件s\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型（如DarYu）\",\n  \"子任务2\": \"预约两个自环端口（Port_1和Port_2），指定端口物理位置\",\n  \"子任务3\": \"在Port_1端口上创建IPv4类型接口\",\n  \"子任务4\": \"在Port_2端口上创建IPv4类型接口\",\n  \"子任务5\": \"在Port_1端口上创建其他指定类型接口（如IPv6等）\",\n  \"子任务6\": \"在Port_2端口上创建其他指定类型接口（如IPv6等）\",\n  \"子任务7\": \"验证所有接口创建操作是否成功（检查接口对象返回值有效性）\",\n  \"子任务8\": \"保存当前测试配置到指定路径的配置文件\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查仪表创建接口正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建各种类型接口;\n\n Criteria    \t:   预期结果1: 步骤2中所有接口创建成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n    interface_1 = create_interface(Port=Port_UP, Layers='ipv4')\n    edit_interface(Interface=interface_1, Layer='IPv4Layer', Address='20.0.0.1', Gateway='20.0.0.2')\n    interface_2 = create_interface(Port=Port_Down, Layers='ipv4')\n    edit_interface(Interface=interface_2, Layer='IPv4Layer', Address='20.0.0.2', Gateway='20.0.0.1')\n    ipv4_ping(Interface=interface_1, IpAddr='20.0.0.2', PacketCount=5)\n\n    # 保存配置文件s\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/Dot1ag/Dot1ag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查802.1ag协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建802.1ag协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface_stack(Interfaces=interfaces_1)\n    edit_interface_stack(Interfaces=interfaces_2)\n\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建802.1ag协议会话\n\n    session_1 = create_dot1ag(Port=Port_UP)\n    session_2 = create_dot1ag(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建802.1ag ma\n    config_ma = create_dot1ag_ma()\n\n    # 创建802.1ag mp\n    create_dot1ag_mp(Session=[session_1, session_2], SelectMa=config_ma)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Dot1agMpStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待802.1ag协议会话达到RUNNING状态\n\n    wait_dot1ag_state(Sessions=[session_1, session_2], State='RUNNING')\n\n    time.sleep(5)\n\n    # 获取802.1ag会话1统计\n    import pandas\n    result = get_dot1ag_mp_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dot1ag_mp_stats(Session=session_1)\n    print(result)\n    result = get_dot1ag_mp_stats(Session=session_2)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "edit_interface_stack:修改测试仪表接口的结构",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建网络接口。\",\n  \"子任务4\": \"在Port_2上创建网络接口。\",\n  \"子任务5\": \"修改Port_1接口的协议栈结构。\",\n  \"子任务6\": \"修改Port_2接口的协议栈结构。\",\n  \"子任务7\": \"配置Port_1接口的IPv4地址和网关。\",\n  \"子任务8\": \"配置Port_2接口的IPv4地址和网关。\",\n  \"子任务9\": \"在Port_1上创建802.1ag协议会话。\",\n  \"子任务10\": \"在Port_2上创建802.1ag协议会话。\",\n  \"子任务11\": \"将Port_1接口绑定到其802.1ag会话。\",\n  \"子任务12\": \"将Port_2接口绑定到其802.1ag会话。\",\n  \"子任务13\": \"创建802.1ag维护关联(MA)。\",\n  \"子任务14\": \"在两个端口会话上创建802.1ag维护点(MP)并关联MA。\",\n  \"子任务15\": \"订阅802.1ag MP统计视图。\",\n  \"子任务16\": \"保存当前测试配置文件。\",\n  \"子任务17\": \"启动所有网络协议。\",\n  \"子任务18\": \"等待两个802.1ag会话达到RUNNING状态。\",\n  \"子任务19\": \"等待5秒确保协议稳定运行。\",\n  \"子任务20\": \"获取Port_1的802.1ag MP统计信息。\",\n  \"子任务21\": \"获取Port_2的802.1ag MP统计信息。\",\n  \"子任务22\": \"验证两个端口的802.1ag流量收发包数量相等。\",\n  \"子任务23\": \"停止所有网络协议。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查802.1ag协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建802.1ag协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface_stack(Interfaces=interfaces_1)\n    edit_interface_stack(Interfaces=interfaces_2)\n\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建802.1ag协议会话\n\n    session_1 = create_dot1ag(Port=Port_UP)\n    session_2 = create_dot1ag(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建802.1ag ma\n    config_ma = create_dot1ag_ma()\n\n    # 创建802.1ag mp\n    create_dot1ag_mp(Session=[session_1, session_2], SelectMa=config_ma)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Dot1agMpStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待802.1ag协议会话达到RUNNING状态\n\n    wait_dot1ag_state(Sessions=[session_1, session_2], State='RUNNING')\n\n    time.sleep(5)\n\n    # 获取802.1ag会话1统计\n    import pandas\n    result = get_dot1ag_mp_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dot1ag_mp_stats(Session=session_1)\n    print(result)\n    result = get_dot1ag_mp_stats(Session=session_2)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nedit_interface_stack:修改测试仪表接口的结构;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/Dot3ah/Dot3ah.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查802.3ah协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建802.3ah协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/9', '//10.0.11.191/1/10'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface_stack(Interfaces=interfaces_1)\n    edit_interface_stack(Interfaces=interfaces_2)\n\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建802.3ah协议会话\n\n    session_1 = create_dot3ah(Port=Port_UP)\n    session_2 = create_dot3ah(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n\n    # 订阅统计\n\n    subscribe_result(Types=['Dot3ahErrorEventStats', 'Dot3ahSessionStatistic'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待802.3ah协议会话达到COMPLETED状态\n\n    wait_dot3ah_state(Sessions=[session_1, session_2], State='COMPLETED')\n\n    time.sleep(5)\n\n    # 获取802.3ah会话1统计\n    import pandas\n    result = get_dot3ah_error_event_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dot3ah_error_event_stats(Session=session_1)\n    print(result)\n    result = get_dot3ah_error_event_stats(Session=session_2)\n    print(result)\n\n    result = get_dot3ah_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dot3ah_session_statistic(Session=session_1)\n    print(result)\n    result = get_dot3ah_session_statistic(Session=session_2)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "edit_interface_stack:修改测试仪表接口的结构",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环测试端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1端口上创建网络接口并配置协议栈。\",\n  \"子任务4\": \"在Port_2端口上创建网络接口并配置协议栈。\",\n  \"子任务5\": \"为Port_1接口配置IPv4地址(1.1.1.1)和网关(1.1.1.2)。\",\n  \"子任务6\": \"为Port_2接口配置IPv4地址(1.1.1.2)和网关(1.1.1.1)。\",\n  \"子任务7\": \"在Port_1端口上创建802.3ah协议会话。\",\n  \"子任务8\": \"在Port_2端口上创建802.3ah协议会话。\",\n  \"子任务9\": \"将Port_1接口绑定到对应的802.3ah协议会话。\",\n  \"子任务10\": \"将Port_2接口绑定到对应的802.3ah协议会话。\",\n  \"子任务11\": \"订阅802.3ah错误事件统计和会话统计视图。\",\n  \"子任务12\": \"保存当前测试配置文件。\",\n  \"子任务13\": \"启动所有配置的协议。\",\n  \"子任务14\": \"等待两个802.3ah会话达到COMPLETED状态。\",\n  \"子任务15\": \"获取全局802.3ah错误事件统计并验证数据格式有效性。\",\n  \"子任务16\": \"获取Port_1会话的802.3ah错误事件统计。\",\n  \"子任务17\": \"获取Port_2会话的802.3ah错误事件统计。\",\n  \"子任务18\": \"获取全局802.3ah会话统计并验证数据格式有效性。\",\n  \"子任务19\": \"获取Port_1会话的802.3ah会话统计。\",\n  \"子任务20\": \"获取Port_2会话的802.3ah会话统计。\",\n  \"子任务21\": \"验证所有802.3ah流量收包数量与发包数量相等。\",\n  \"子任务22\": \"停止所有运行中的协议。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查802.3ah协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建802.3ah协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/9', '//10.0.11.191/1/10'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface_stack(Interfaces=interfaces_1)\n    edit_interface_stack(Interfaces=interfaces_2)\n\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建802.3ah协议会话\n\n    session_1 = create_dot3ah(Port=Port_UP)\n    session_2 = create_dot3ah(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n\n    # 订阅统计\n\n    subscribe_result(Types=['Dot3ahErrorEventStats', 'Dot3ahSessionStatistic'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待802.3ah协议会话达到COMPLETED状态\n\n    wait_dot3ah_state(Sessions=[session_1, session_2], State='COMPLETED')\n\n    time.sleep(5)\n\n    # 获取802.3ah会话1统计\n    import pandas\n    result = get_dot3ah_error_event_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dot3ah_error_event_stats(Session=session_1)\n    print(result)\n    result = get_dot3ah_error_event_stats(Session=session_2)\n    print(result)\n\n    result = get_dot3ah_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dot3ah_session_statistic(Session=session_1)\n    print(result)\n    result = get_dot3ah_session_statistic(Session=session_2)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nedit_interface_stack:修改测试仪表接口的结构;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/ISIS/ISIS_IPv4.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查ISIS协议IPv4绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建ISIS协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                          Layer='IPv4Layer',\n                          Address='192.168.1.2',\n                          Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                          Layer='IPv4Layer',\n                          Address='192.168.1.3',\n                          Gateway='192.168.1.2')\n\n    # 创建ISIS协议会话\n\n    session_1 = create_isis(Port=Port_UP)\n    session_2 = create_isis(Port=Port_Down)\n\n    edit_isis(Session=session_1, Level='L1L2', MtParams=2, PerPduAuthentication=4)\n    edit_isis(Session=session_2, Level='L1L2', MtParams=2, PerPduAuthentication=4)\n\n    # 修改ISIS Mt参数\n\n    edit_isis_mt_params(Session=session_1, Index=0, MtId='IPV4', MtFlags='NOSHOW')\n    edit_isis_mt_params(Session=session_1, Index=1, MtId='IPV6', MtFlags=['ABIT', 'OBIT'])\n    mt = get_isis_mt_params(Session=session_1, Index=0)\n    print(mt)\n    mt = get_isis_mt_params(Session=session_1, Index=1)\n    print(mt)\n\n    edit_isis_mt_params(Session=session_2, Index=0, MtId='IPV4', MtFlags='NOSHOW')\n    edit_isis_mt_params(Session=session_2, Index=1, MtId='IPV6', MtFlags=['ABIT', 'OBIT'])\n    mt = get_isis_mt_params(Session=session_2, Index=0)\n    print(mt)\n    mt = get_isis_mt_params(Session=session_2, Index=1)\n    print(mt)\n\n    # 修改ISIS PerPduAuthentication参数\n\n    edit_isis_per_pdu(Session=session_1, Index=0, PdusType='L1_HELLO', AuthMethod='NONE')\n    edit_isis_per_pdu(Session=session_1, Index=1, PdusType='L2_HELLO', AuthMethod='SIMPLE', Password='test')\n    edit_isis_per_pdu(Session=session_1, Index=2, PdusType='L1_AREA_PDUS', AuthMethod='MD5', Password='test')\n    edit_isis_per_pdu(Session=session_1, Index=3, PdusType='L2_DOMAIN_PDUS', AuthMethod='NONE')\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=0)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=1)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=2)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=3)\n    print(per_pdu)\n\n    edit_isis_per_pdu(Session=session_2, Index=0, PdusType='L1_HELLO', AuthMethod='NONE')\n    edit_isis_per_pdu(Session=session_2, Index=1, PdusType='L2_HELLO', AuthMethod='SIMPLE', Password='test')\n    edit_isis_per_pdu(Session=session_2, Index=2, PdusType='L1_AREA_PDUS', AuthMethod='MD5', Password='test')\n    edit_isis_per_pdu(Session=session_2, Index=3, PdusType='L2_DOMAIN_PDUS', AuthMethod='NONE')\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=0)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=1)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=2)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=3)\n    print(per_pdu)\n\n    # ISIS协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # ISIS协议会话创建LSP\n\n    ipv4_lsp_1 = create_isis_lsp(Session=session_1, Level='L1')\n    ipv4_lsp_2 = create_isis_lsp(Session=session_2, Level='L1')\n\n    # ISIS协议会话LSP创建IPv4 TLV\n\n    ipv4_tlv_1 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_1, RouteCount=10)\n    ipv4_tlv_2 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_2, RouteCount=10)\n\n    # 获取ISIS协议绑定流端点对象\n\n    point_1 = get_isis_router_from_tlv(Configs=ipv4_tlv_1)\n    point_2 = get_isis_router_from_tlv(Configs=ipv4_tlv_2)\n\n    # 创建ISIS绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['IsisSessionStats', 'IsisTlvStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待ISIS协议会话稳定状态\n\n    wait_isis_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    import pandas\n    result = get_isis_session_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_isis_tlv_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_isis:创建ISIS协议会话对象",
      "create_isis_ipv4_tlv:创建ISIS IPv4 TLV对象",
      "create_isis_lsp:创建ISIS LSP对象",
      "edit_isis:编辑ISIS协议会话对象参数",
      "edit_isis_mt_params:编辑ISIS协议会话MT参数",
      "edit_isis_per_pdu:编辑ISIS协议会话Per Pdu Authentication参数",
      "get_isis_mt_params:获取ISIS协议会话MT参数",
      "get_isis_per_pdu:获取ISIS协议会话Per Pdu Authentication参数",
      "get_isis_router_from_tlv:获取 ISIS TLV 对应的绑定流源或目的端点对象",
      "get_isis_session_stats:获取 Isis Session 统计结果",
      "get_isis_tlv_stats:获取 Isis Session 统计结果",
      "wait_isis_state:等待ISIS协议会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表环境，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口（Port_1 和 Port_2）。\",\n  \"子任务3\": \"在 Port_1 上创建 IPv4 接口并配置 IP 地址与网关。\",\n  \"子任务4\": \"在 Port_2 上创建 IPv4 接口并配置 IP 地址与网关。\",\n  \"子任务5\": \"在 Port_1 上创建 ISIS 协议会话对象。\",\n  \"子任务6\": \"在 Port_2 上创建 ISIS 协议会话对象。\",\n  \"子任务7\": \"配置 ISIS 会话参数（Level、MT Params、Per PDU Authentication）。\",\n  \"子任务8\": \"将 ISIS 会话绑定到对应端口的 IPv4 接口。\",\n  \"子任务9\": \"为 ISIS 会话创建 LSP 对象（Level L1）。\",\n  \"子任务10\": \"在 LSP 上创建 IPv4 TLV 并配置路由数量。\",\n  \"子任务11\": \"从 IPv4 TLV 获取绑定流端点对象。\",\n  \"子任务12\": \"创建双向绑定流（源端点为 Port_1 TLV，目的端点为 Port_2 TLV）。\",\n  \"子任务13\": \"订阅 StreamBlockStats 统计视图。\",\n  \"子任务14\": \"启动 ISIS 协议会话。\",\n  \"子任务15\": \"等待 ISIS 会话达到稳定状态。\",\n  \"子任务16\": \"开始发送所有绑定流量。\",\n  \"子任务17\": \"持续发送流量并等待指定时间（10秒）。\",\n  \"子任务18\": \"停止所有流量发送。\",\n  \"子任务19\": \"停止 ISIS 协议会话。\",\n  \"子任务20\": \"获取所有绑定流的 StreamBlockStats 统计信息。\",\n  \"子任务21\": \"验证每个绑定流的 TxStreamFrames 等于 RxStreamFrames。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查ISIS协议IPv4绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建ISIS协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                          Layer='IPv4Layer',\n                          Address='192.168.1.2',\n                          Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                          Layer='IPv4Layer',\n                          Address='192.168.1.3',\n                          Gateway='192.168.1.2')\n\n    # 创建ISIS协议会话\n\n    session_1 = create_isis(Port=Port_UP)\n    session_2 = create_isis(Port=Port_Down)\n\n    edit_isis(Session=session_1, Level='L1L2', MtParams=2, PerPduAuthentication=4)\n    edit_isis(Session=session_2, Level='L1L2', MtParams=2, PerPduAuthentication=4)\n\n    # 修改ISIS Mt参数\n\n    edit_isis_mt_params(Session=session_1, Index=0, MtId='IPV4', MtFlags='NOSHOW')\n    edit_isis_mt_params(Session=session_1, Index=1, MtId='IPV6', MtFlags=['ABIT', 'OBIT'])\n    mt = get_isis_mt_params(Session=session_1, Index=0)\n    print(mt)\n    mt = get_isis_mt_params(Session=session_1, Index=1)\n    print(mt)\n\n    edit_isis_mt_params(Session=session_2, Index=0, MtId='IPV4', MtFlags='NOSHOW')\n    edit_isis_mt_params(Session=session_2, Index=1, MtId='IPV6', MtFlags=['ABIT', 'OBIT'])\n    mt = get_isis_mt_params(Session=session_2, Index=0)\n    print(mt)\n    mt = get_isis_mt_params(Session=session_2, Index=1)\n    print(mt)\n\n    # 修改ISIS PerPduAuthentication参数\n\n    edit_isis_per_pdu(Session=session_1, Index=0, PdusType='L1_HELLO', AuthMethod='NONE')\n    edit_isis_per_pdu(Session=session_1, Index=1, PdusType='L2_HELLO', AuthMethod='SIMPLE', Password='test')\n    edit_isis_per_pdu(Session=session_1, Index=2, PdusType='L1_AREA_PDUS', AuthMethod='MD5', Password='test')\n    edit_isis_per_pdu(Session=session_1, Index=3, PdusType='L2_DOMAIN_PDUS', AuthMethod='NONE')\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=0)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=1)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=2)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=3)\n    print(per_pdu)\n\n    edit_isis_per_pdu(Session=session_2, Index=0, PdusType='L1_HELLO', AuthMethod='NONE')\n    edit_isis_per_pdu(Session=session_2, Index=1, PdusType='L2_HELLO', AuthMethod='SIMPLE', Password='test')\n    edit_isis_per_pdu(Session=session_2, Index=2, PdusType='L1_AREA_PDUS', AuthMethod='MD5', Password='test')\n    edit_isis_per_pdu(Session=session_2, Index=3, PdusType='L2_DOMAIN_PDUS', AuthMethod='NONE')\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=0)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=1)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=2)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=3)\n    print(per_pdu)\n\n    # ISIS协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # ISIS协议会话创建LSP\n\n    ipv4_lsp_1 = create_isis_lsp(Session=session_1, Level='L1')\n    ipv4_lsp_2 = create_isis_lsp(Session=session_2, Level='L1')\n\n    # ISIS协议会话LSP创建IPv4 TLV\n\n    ipv4_tlv_1 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_1, RouteCount=10)\n    ipv4_tlv_2 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_2, RouteCount=10)\n\n    # 获取ISIS协议绑定流端点对象\n\n    point_1 = get_isis_router_from_tlv(Configs=ipv4_tlv_1)\n    point_2 = get_isis_router_from_tlv(Configs=ipv4_tlv_2)\n\n    # 创建ISIS绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['IsisSessionStats', 'IsisTlvStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待ISIS协议会话稳定状态\n\n    wait_isis_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    import pandas\n    result = get_isis_session_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_isis_tlv_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_isis:创建ISIS协议会话对象;\ncreate_isis_ipv4_tlv:创建ISIS IPv4 TLV对象;\ncreate_isis_lsp:创建ISIS LSP对象;\nedit_isis:编辑ISIS协议会话对象参数;\nedit_isis_mt_params:编辑ISIS协议会话MT参数;\nedit_isis_per_pdu:编辑ISIS协议会话Per Pdu Authentication参数;\nget_isis_mt_params:获取ISIS协议会话MT参数;\nget_isis_per_pdu:获取ISIS协议会话Per Pdu Authentication参数;\nget_isis_router_from_tlv:获取 ISIS TLV 对应的绑定流源或目的端点对象;\nget_isis_session_stats:获取 Isis Session 统计结果;\nget_isis_tlv_stats:获取 Isis Session 统计结果;\nwait_isis_state:等待ISIS协议会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/IEEE8021As/IEEE8021As.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查IEEE802.1As协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建Ieee802.1As协议，并且绑定接口;\n                   测试步骤3: 订阅Ieee802.1As相关统计;\n                   测试步骤4: 启动会话，等待一段时间;\n                   测试步骤5: 查看统计信息;\n\n Criteria    \t:   预期结果1: 步骤5中所有统计结果均有数据;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IEEE802.1As协议会话\n    session_1 = create_ieee8021as(Port=Port_UP)\n    session_2 = create_ieee8021as(Port=Port_Down)\n\n    # IEEE802.1As协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 订阅统计\n    subscribe_result(\n        Types=['Ieee8021asClockStatistic', 'Ieee8021asClockSyncStatistic', 'Ieee8021asMessageRateStatistic',\n               'Ieee8021asParentClockInfoStatistic', 'Ieee8021asStateSummaryStatistic',\n               'Ieee8021asTimePropertiesStatistic'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n    start_protocol()\n\n    # 等待IEEE802.1As协议会话达到RUNNING状态\n    time.sleep(3)\n    wait_ieee8021as_state(Sessions=[session_1, session_2])\n    wait_ieee8021as_clock_state(Sessions=[session_1, session_2])\n\n    time.sleep(10)\n\n    import pandas\n\n    result = get_ieee8021as_clock_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_clock_sync_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_message_rate_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_parent_clock_info_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_state_summary_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_time_properties_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    stop_protocol()\n    time.sleep(3)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台型号。\",\n  \"子任务2\": \"预约两个测试端口作为自环端口 Port_1 和 Port_2。\",\n  \"子任务3\": \"在 Port_1 上创建 IPv4 接口并配置 IP 地址和网关。\",\n  \"子任务4\": \"在 Port_2 上创建 IPv4 接口并配置 IP 地址和网关。\",\n  \"子任务5\": \"在 Port_1 上创建 IEEE802.1As 协议会话。\",\n  \"子任务6\": \"在 Port_2 上创建 IEEE802.1As 协议会话。\",\n  \"子任务7\": \"将 Port_1 的 IEEE802.1As 会话绑定到其 IPv4 接口。\",\n  \"子任务8\": \"将 Port_2 的 IEEE802.1As 会话绑定到其 IPv4 接口。\",\n  \"子任务9\": \"订阅六类 IEEE802.1As 统计：时钟统计、时钟同步统计、消息速率统计、父时钟信息统计、状态摘要统计、时间属性统计。\",\n  \"子任务10\": \"保存当前测试配置到文件。\",\n  \"子任务11\": \"启动所有协议会话。\",\n  \"子任务12\": \"等待 IEEE802.1As 会话状态达到 RUNNING 状态。\",\n  \"子任务13\": \"等待 IEEE802.1As 时钟状态同步完成。\",\n  \"子任务14\": \"等待 10 秒协议运行时间。\",\n  \"子任务15\": \"获取 IEEE802.1As 时钟统计信息。\",\n  \"子任务16\": \"获取 IEEE802.1As 时钟同步统计信息。\",\n  \"子任务17\": \"获取 IEEE802.1As 消息速率统计信息。\",\n  \"子任务18\": \"获取 IEEE802.1As 父时钟信息统计信息。\",\n  \"子任务19\": \"获取 IEEE802.1As 状态摘要统计信息。\",\n  \"子任务20\": \"获取 IEEE802.1As 时间属性统计信息。\",\n  \"子任务21\": \"验证所有六类统计信息均有数据（非空）。\",\n  \"子任务22\": \"停止所有协议会话。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查IEEE802.1As协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建Ieee802.1As协议，并且绑定接口;\n                   测试步骤3: 订阅Ieee802.1As相关统计;\n                   测试步骤4: 启动会话，等待一段时间;\n                   测试步骤5: 查看统计信息;\n\n Criteria    \t:   预期结果1: 步骤5中所有统计结果均有数据;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IEEE802.1As协议会话\n    session_1 = create_ieee8021as(Port=Port_UP)\n    session_2 = create_ieee8021as(Port=Port_Down)\n\n    # IEEE802.1As协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 订阅统计\n    subscribe_result(\n        Types=['Ieee8021asClockStatistic', 'Ieee8021asClockSyncStatistic', 'Ieee8021asMessageRateStatistic',\n               'Ieee8021asParentClockInfoStatistic', 'Ieee8021asStateSummaryStatistic',\n               'Ieee8021asTimePropertiesStatistic'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n    start_protocol()\n\n    # 等待IEEE802.1As协议会话达到RUNNING状态\n    time.sleep(3)\n    wait_ieee8021as_state(Sessions=[session_1, session_2])\n    wait_ieee8021as_clock_state(Sessions=[session_1, session_2])\n\n    time.sleep(10)\n\n    import pandas\n\n    result = get_ieee8021as_clock_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_clock_sync_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_message_rate_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_parent_clock_info_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_state_summary_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_time_properties_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    stop_protocol()\n    time.sleep(3)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/OvsDb/ovsdb.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查ovsdb统计获取正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 创建ovsdb;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.3')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.3', Gateway='1.1.1.2')\n\n    # 创建协议会话\n\n    ovsdb = create_ovsdb(Port=Port_UP)\n    select_interface(Session=ovsdb, Interface=interfaces_1)\n\n\n    # 订阅统计\n\n    subscribe_result(Types=['OvsdbResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n    wait_ovsdb_state(Sessions=ovsdb)\n    time.sleep(2)\n\n    # 获取统计\n    result = get_ovsdb_statistic(Sessions=ovsdb)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表型号。\",\n  \"子任务2\": \"预约两个测试仪端口用于自环连接。\",\n  \"子任务3\": \"在第一个端口创建网络接口并配置IPv4地址和网关。\",\n  \"子任务4\": \"在第二个端口创建网络接口并配置IPv4地址和网关（与第一个端口互为网关）。\",\n  \"子任务5\": \"在第一个端口创建OVSDB协议会话。\",\n  \"子任务6\": \"将第一个接口绑定到OVSDB会话。\",\n  \"子任务7\": \"订阅OVSDB结果统计视图。\",\n  \"子任务8\": \"保存当前测试配置到文件。\",\n  \"子任务9\": \"启动所有协议会话。\",\n  \"子任务10\": \"等待OVSDB会话达到稳定状态。\",\n  \"子任务11\": \"获取OVSDB会话的统计信息数据。\",\n  \"子任务12\": \"停止所有协议会话。\",\n  \"子任务13\": \"验证获取的OVSDB统计信息是否符合预期（数据完整性和正确性）。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查ovsdb统计获取正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 创建ovsdb;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.3')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.3', Gateway='1.1.1.2')\n\n    # 创建协议会话\n\n    ovsdb = create_ovsdb(Port=Port_UP)\n    select_interface(Session=ovsdb, Interface=interfaces_1)\n\n\n    # 订阅统计\n\n    subscribe_result(Types=['OvsdbResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n    wait_ovsdb_state(Sessions=ovsdb)\n    time.sleep(2)\n\n    # 获取统计\n    result = get_ovsdb_statistic(Sessions=ovsdb)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/VXLAN/VXLAN.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查VXLAN协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 创建VXLAN协议及组播组;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    interfaces_3 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_4 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    edit_interface(Interface=interfaces_3,\n                   Layer='IPv4Layer',\n                   Address='2.2.2.1',\n                   Gateway='2.2.2.2')\n\n    edit_interface(Interface=interfaces_4,\n                   Layer='IPv4Layer',\n                   Address='2.2.2.2',\n                   Gateway='2.2.2.1')\n    # 创建VXLAN协议会话\n\n    session_1 = create_vxlan(Port=Port_UP)\n\n    session_2 = create_vxlan(Port=Port_Down)\n\n    # VXLAN协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建VXLAN Segment\n\n    segment = create_vxlan_segment(StartVni=10)\n\n    # 绑定VXLAN VM\n\n    binding_vxlan_vm(Segments=segment, Interfaces=interfaces_3)\n\n    binding_vxlan_vm(Segments=segment, Interfaces=interfaces_4)\n\n    binding_vxlan_vtep(Vteps=session_1, Interfaces=interfaces_3)\n\n    binding_vxlan_vtep(Vteps=session_2, Interfaces=interfaces_4)\n\n    # 创建VXLAN绑定流\n\n    point_1 = get_vxlan_vm_point(Vxlan=session_1)\n\n    point_2 = get_vxlan_vm_point(Vxlan=session_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['VxlanBindingStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待VXLAN协议会话达到STARTED状态\n\n    wait_vxlan_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    import pandas\n    result = get_vxlan_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    # 获取VXLAN会话1统计\n\n    result = get_vxlan_statistic(Session=session_1)\n    print(result)\n\n    # 获取VXLAN会话2统计\n\n    result = get_vxlan_statistic(Session=session_2)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "binding_vxlan_vm:绑定 Vxlan Vm 对象",
      "binding_vxlan_vtep:绑定 Vxlan Vtep 对象",
      "create_vxlan:创建Vxlan协议会话对象",
      "create_vxlan_segment:创建Vxlan Segment对象",
      "get_vxlan_statistic:获取测试仪表vxlan统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表并设置产品类型\",\n  \"子任务2\": \"预约两个自环端口Port_UP和Port_Down\",\n  \"子任务3\": \"在Port_UP端口创建两个IPv4接口并配置地址与网关\",\n  \"子任务4\": \"在Port_Down端口创建两个IPv4接口并配置地址与网关\",\n  \"子任务5\": \"在Port_UP端口创建VXLAN协议会话对象\",\n  \"子任务6\": \"在Port_Down端口创建VXLAN协议会话对象\",\n  \"子任务7\": \"将VXLAN会话绑定到对应端口的IPv4接口\",\n  \"子任务8\": \"创建VXLAN Segment对象并设置起始VNI为10\",\n  \"子任务9\": \"将端口接口绑定到VXLAN VM对象\",\n  \"子任务10\": \"将VXLAN会话绑定到端口接口作为VTEP\",\n  \"子任务11\": \"获取VXLAN VM端点作为流量的源点和终点\",\n  \"子任务12\": \"创建双向绑定流量，源点为Port_UP的VM点，终点为Port_Down的VM点\",\n  \"子任务13\": \"订阅VxlanBindingStats和StreamBlockStats统计视图\",\n  \"子任务14\": \"保存当前测试配置文件\",\n  \"子任务15\": \"启动所有协议会话\",\n  \"子任务16\": \"等待VXLAN协议会话达到STARTED状态\",\n  \"子任务17\": \"开始发送所有绑定流量\",\n  \"子任务18\": \"等待流量发送持续时间10秒\",\n  \"子任务19\": \"停止所有流量发送\",\n  \"子任务20\": \"停止所有协议会话\",\n  \"子任务21\": \"获取并验证VXLAN整体会话统计信息\",\n  \"子任务22\": \"分别获取Port_UP和Port_Down的VXLAN会话统计信息\",\n  \"子任务23\": \"获取第一个绑定流的StreamBlock统计信息\",\n  \"子任务24\": \"验证第一个流的TxStreamFrames等于RxStreamFrames\",\n  \"子任务25\": \"获取第二个绑定流的StreamBlock统计信息\",\n  \"子任务26\": \"验证第二个流的TxStreamFrames等于RxStreamFrames\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查VXLAN协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 创建VXLAN协议及组播组;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    interfaces_3 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_4 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    edit_interface(Interface=interfaces_3,\n                   Layer='IPv4Layer',\n                   Address='2.2.2.1',\n                   Gateway='2.2.2.2')\n\n    edit_interface(Interface=interfaces_4,\n                   Layer='IPv4Layer',\n                   Address='2.2.2.2',\n                   Gateway='2.2.2.1')\n    # 创建VXLAN协议会话\n\n    session_1 = create_vxlan(Port=Port_UP)\n\n    session_2 = create_vxlan(Port=Port_Down)\n\n    # VXLAN协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建VXLAN Segment\n\n    segment = create_vxlan_segment(StartVni=10)\n\n    # 绑定VXLAN VM\n\n    binding_vxlan_vm(Segments=segment, Interfaces=interfaces_3)\n\n    binding_vxlan_vm(Segments=segment, Interfaces=interfaces_4)\n\n    binding_vxlan_vtep(Vteps=session_1, Interfaces=interfaces_3)\n\n    binding_vxlan_vtep(Vteps=session_2, Interfaces=interfaces_4)\n\n    # 创建VXLAN绑定流\n\n    point_1 = get_vxlan_vm_point(Vxlan=session_1)\n\n    point_2 = get_vxlan_vm_point(Vxlan=session_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['VxlanBindingStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待VXLAN协议会话达到STARTED状态\n\n    wait_vxlan_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    import pandas\n    result = get_vxlan_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    # 获取VXLAN会话1统计\n\n    result = get_vxlan_statistic(Session=session_1)\n    print(result)\n\n    # 获取VXLAN会话2统计\n\n    result = get_vxlan_statistic(Session=session_2)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nbinding_vxlan_vm:绑定 Vxlan Vm 对象;\nbinding_vxlan_vtep:绑定 Vxlan Vtep 对象;\ncreate_vxlan:创建Vxlan协议会话对象;\ncreate_vxlan_segment:创建Vxlan Segment对象;\nget_vxlan_statistic:获取测试仪表vxlan统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/LDP/LDP.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查LDP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建LDP协议;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建LDP协议会话\n\n    session_1 = create_ldp(Port=Port_UP, DutIpv4Address='1.1.1.2')\n\n    session_2 = create_ldp(Port=Port_Down, DutIpv4Address='1.1.1.1')\n\n    # LDP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建LSP\n\n    lsp_1 = create_ldp_ipv4_egress(Session=session_1)\n\n    lsp_2 = create_ldp_ipv4_egress(Session=session_2)\n\n    # 获取接口绑定流端点对象\n\n    point_1, point_2 = get_ldp_point_from_lsp(Configs=[lsp_1, lsp_2])\n\n    # 创建LDP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'LdpSessionStatistic', 'LdpLspStatistic'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待LDP协议协议会话状态正确\n\n    wait_ldp_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取LDP端口统计\n    import pandas\n\n    result = get_ldp_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ldp_session_statistic(Session=session_1)\n    print(result)\n    result = get_ldp_session_statistic(Session=session_2)\n    print(result)\n\n    # 获取LDP客户端统计\n    result = get_ldp_lsp_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ldp_lsp_statistic(Session=session_1)\n    print(result)\n    result = get_ldp_lsp_statistic(Session=session_2)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_ldp:创建LDP协议会话对象",
      "create_ldp_ipv4_egress:创建LDP IPv4 Egress对象",
      "get_ldp_lsp_statistic:获取Ldp Lsp统计结果",
      "get_ldp_point_from_lsp:获取LDP LSP对应的绑定流源或目的端点对象",
      "get_ldp_session_statistic:获取Ldp Session统计结果",
      "wait_ldp_state:等待LDP协议会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口（Port_UP和Port_Down）并获取端口对象。\",\n  \"子任务3\": \"在Port_UP端口上创建网络接口。\",\n  \"子任务4\": \"配置Port_UP接口的IPv4层参数（地址1.1.1.1，网关1.1.1.2）。\",\n  \"子任务5\": \"在Port_Down端口上创建网络接口。\",\n  \"子任务6\": \"配置Port_Down接口的IPv4层参数（地址1.1.1.2，网关1.1.1.1）。\",\n  \"子任务7\": \"在Port_UP端口创建LDP协议会话（指定对端DUT地址1.1.1.2）。\",\n  \"子任务8\": \"在Port_Down端口创建LDP协议会话（指定对端DUT地址1.1.1.1）。\",\n  \"子任务9\": \"将Port_UP端口的LDP会话绑定到该端口的网络接口。\",\n  \"子任务10\": \"将Port_Down端口的LDP会话绑定到该端口的网络接口。\",\n  \"子任务11\": \"在Port_UP端口的LDP会话上创建IPv4 Egress LSP。\",\n  \"子任务12\": \"在Port_Down端口的LDP会话上创建IPv4 Egress LSP。\",\n  \"子任务13\": \"从两个LSP配置中获取绑定流端点对象（源端点和目的端点）。\",\n  \"子任务14\": \"创建双向绑定流（源端点指向目的端点，双向传输）。\",\n  \"子任务15\": \"订阅流统计信息（StreamBlockStats）。\",\n  \"子任务16\": \"保存当前测试配置文件。\",\n  \"子任务17\": \"启动所有网络协议。\",\n  \"子任务18\": \"等待两个LDP会话状态达到稳定状态。\",\n  \"子任务19\": \"开始发送所有绑定流量。\",\n  \"子任务20\": \"持续发送流量10秒。\",\n  \"子任务21\": \"停止所有流量发送。\",\n  \"子任务22\": \"停止所有网络协议。\",\n  \"子任务23\": \"获取第一个绑定流的统计信息（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务24\": \"验证第一个绑定流的发送帧数等于接收帧数。\",\n  \"子任务25\": \"获取第二个绑定流的统计信息（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务26\": \"验证第二个绑定流的发送帧数等于接收帧数。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查LDP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建LDP协议;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建LDP协议会话\n\n    session_1 = create_ldp(Port=Port_UP, DutIpv4Address='1.1.1.2')\n\n    session_2 = create_ldp(Port=Port_Down, DutIpv4Address='1.1.1.1')\n\n    # LDP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建LSP\n\n    lsp_1 = create_ldp_ipv4_egress(Session=session_1)\n\n    lsp_2 = create_ldp_ipv4_egress(Session=session_2)\n\n    # 获取接口绑定流端点对象\n\n    point_1, point_2 = get_ldp_point_from_lsp(Configs=[lsp_1, lsp_2])\n\n    # 创建LDP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'LdpSessionStatistic', 'LdpLspStatistic'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待LDP协议协议会话状态正确\n\n    wait_ldp_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取LDP端口统计\n    import pandas\n\n    result = get_ldp_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ldp_session_statistic(Session=session_1)\n    print(result)\n    result = get_ldp_session_statistic(Session=session_2)\n    print(result)\n\n    # 获取LDP客户端统计\n    result = get_ldp_lsp_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ldp_lsp_statistic(Session=session_1)\n    print(result)\n    result = get_ldp_lsp_statistic(Session=session_2)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_ldp:创建LDP协议会话对象;\ncreate_ldp_ipv4_egress:创建LDP IPv4 Egress对象;\nget_ldp_lsp_statistic:获取Ldp Lsp统计结果;\nget_ldp_point_from_lsp:获取LDP LSP对应的绑定流源或目的端点对象;\nget_ldp_session_statistic:获取Ldp Session统计结果;\nwait_ldp_state:等待LDP协议会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/RIP/RIP.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查RIP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 创建RIP协议及组播组;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建RIP协议会话\n\n    session_1 = create_rip(Port=Port_UP)\n\n    session_2 = create_rip(Port=Port_Down)\n\n    # RIP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # RIP协议会话1创建IPv4 Route\n\n    ipv4_route_1 = create_rip_ipv4_route(Session=session_1)\n\n    # RIP协议会话2创建IPv4 Route\n\n    ipv4_route_2 = create_rip_ipv4_route(Session=session_2)\n\n    # 获取RIP协议绑定流端点对象\n\n    point_1 = get_rip_router_from_route(Route=ipv4_route_1)\n\n    point_2 = get_rip_router_from_route(Route=ipv4_route_2)\n\n    # 创建RIP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['RipSessionBlockStats', 'RipSessionStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待RIP协议会话达到Full状态\n\n    wait_rip_state(Sessions=[session_1, session_2])\n\n    advertise_rip(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    withdraw_rip(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    import pandas\n    result = get_rip_session_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    # 获取RIP会话1统计\n\n    result = get_rip_session_block_statistic(Session=session_1)\n    print(result)\n    TxAdvertised = result['TxAdvertised']\n    RxAdvertised = result['RxAdvertised']\n    print('TxAdvertised:', TxAdvertised)\n    print('RxAdvertised:', RxAdvertised)\n    TxWithdrawn = result['TxWithdrawn']\n    RxWithdrawn = result['RxWithdrawn']\n    print('TxWithdrawn:', TxWithdrawn)\n    print('RxWithdrawn:', RxWithdrawn)\n\n    # 获取RIP会话2统计\n\n    result = get_rip_session_block_statistic(Session=session_2)\n    print(result)\n    TxAdvertised = result['TxAdvertised']\n    RxAdvertised = result['RxAdvertised']\n    print('TxAdvertised:', TxAdvertised)\n    print('RxAdvertised:', RxAdvertised)\n    TxWithdrawn = result['TxWithdrawn']\n    RxWithdrawn = result['RxWithdrawn']\n    print('TxWithdrawn:', TxWithdrawn)\n    print('RxWithdrawn:', RxWithdrawn)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_rip:通告RIP协议路由",
      "create_rip:创建RIP协议会话对象",
      "create_rip_ipv4_route:创建RIP IPv4路由对象",
      "get_rip_router_from_route:获取OSPF LSA对应的绑定流源或目的端点对象",
      "get_rip_session_block_statistic:获取RIP协议会话统计结果",
      "wait_rip_state:等待RIP协议会话达到指定状态",
      "withdraw_rip:撤销 RIP 协议通告路由",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2\",\n  \"子任务3\": \"在Port_1端口创建IPv4接口并配置地址192.168.1.2/网关192.168.1.3\",\n  \"子任务4\": \"在Port_2端口创建IPv4接口并配置地址192.168.1.3/网关192.168.1.2\",\n  \"子任务5\": \"在Port_1端口创建RIP协议会话\",\n  \"子任务6\": \"在Port_2端口创建RIP协议会话\",\n  \"子任务7\": \"将Port_1接口绑定到其RIP会话\",\n  \"子任务8\": \"将Port_2接口绑定到其RIP会话\",\n  \"子任务9\": \"在Port_1的RIP会话上创建IPv4路由\",\n  \"子任务10\": \"在Port_2的RIP会话上创建IPv4路由\",\n  \"子任务11\": \"从IPv4路由1获取RIP绑定流源端点\",\n  \"子任务12\": \"从IPv4路由2获取RIP绑定流目的端点\",\n  \"子任务13\": \"创建双向RIP绑定流（源端点→目的端点）\",\n  \"子任务14\": \"订阅统计视图（包括StreamBlockStats、RipSessionBlockStats、RipSessionStats）\",\n  \"子任务15\": \"保存当前测试配置\",\n  \"子任务16\": \"启动RIP协议\",\n  \"子任务17\": \"等待两个RIP会话达到Full状态\",\n  \"子任务18\": \"通告所有RIP会话路由\",\n  \"子任务19\": \"等待5秒使路由稳定\",\n  \"子任务20\": \"开始发送所有流量\",\n  \"子任务21\": \"等待10秒流量发送时间\",\n  \"子任务22\": \"停止所有流量发送\",\n  \"子任务23\": \"撤销所有RIP通告路由\",\n  \"子任务24\": \"等待5秒路由撤销完成\",\n  \"子任务25\": \"停止所有协议\",\n  \"子任务26\": \"获取每个流量的StreamBlockStats统计信息\",\n  \"子任务27\": \"验证每个流量的TxStreamFrames等于RxStreamFrames\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查RIP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 创建RIP协议及组播组;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建RIP协议会话\n\n    session_1 = create_rip(Port=Port_UP)\n\n    session_2 = create_rip(Port=Port_Down)\n\n    # RIP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # RIP协议会话1创建IPv4 Route\n\n    ipv4_route_1 = create_rip_ipv4_route(Session=session_1)\n\n    # RIP协议会话2创建IPv4 Route\n\n    ipv4_route_2 = create_rip_ipv4_route(Session=session_2)\n\n    # 获取RIP协议绑定流端点对象\n\n    point_1 = get_rip_router_from_route(Route=ipv4_route_1)\n\n    point_2 = get_rip_router_from_route(Route=ipv4_route_2)\n\n    # 创建RIP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['RipSessionBlockStats', 'RipSessionStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待RIP协议会话达到Full状态\n\n    wait_rip_state(Sessions=[session_1, session_2])\n\n    advertise_rip(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    withdraw_rip(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    import pandas\n    result = get_rip_session_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    # 获取RIP会话1统计\n\n    result = get_rip_session_block_statistic(Session=session_1)\n    print(result)\n    TxAdvertised = result['TxAdvertised']\n    RxAdvertised = result['RxAdvertised']\n    print('TxAdvertised:', TxAdvertised)\n    print('RxAdvertised:', RxAdvertised)\n    TxWithdrawn = result['TxWithdrawn']\n    RxWithdrawn = result['RxWithdrawn']\n    print('TxWithdrawn:', TxWithdrawn)\n    print('RxWithdrawn:', RxWithdrawn)\n\n    # 获取RIP会话2统计\n\n    result = get_rip_session_block_statistic(Session=session_2)\n    print(result)\n    TxAdvertised = result['TxAdvertised']\n    RxAdvertised = result['RxAdvertised']\n    print('TxAdvertised:', TxAdvertised)\n    print('RxAdvertised:', RxAdvertised)\n    TxWithdrawn = result['TxWithdrawn']\n    RxWithdrawn = result['RxWithdrawn']\n    print('TxWithdrawn:', TxWithdrawn)\n    print('RxWithdrawn:', RxWithdrawn)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_rip:通告RIP协议路由;\ncreate_rip:创建RIP协议会话对象;\ncreate_rip_ipv4_route:创建RIP IPv4路由对象;\nget_rip_router_from_route:获取OSPF LSA对应的绑定流源或目的端点对象;\nget_rip_session_block_statistic:获取RIP协议会话统计结果;\nwait_rip_state:等待RIP协议会话达到指定状态;\nwithdraw_rip:撤销 RIP 协议通告路由;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/isis_lsp/isis_lsp_wizard.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查Isis Lsp向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Isis会话;\n                   测试步骤3: 创建Isis Lsp向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Isis Lsp向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='eth', Tops=['ipv4', 'ipv6'])\n    interfaces_2 = create_interface(Port=Port_2, Layers='eth', Tops=['ipv4', 'ipv6'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建Isis会话\n    Isis_1 = create_isis(Port=Port_1, IpVersion='IPV4IPV6')\n    Isis_2 = create_isis(Port=Port_2, IpVersion='IPV4IPV6')\n\n    select_interface(Session=Isis_1, Interface=interfaces_1)\n    select_interface(Session=Isis_2, Interface=interfaces_2)\n\n    # 创建Isis Lsp向导\n    wizard = create_isis_lsp_wizard(Sessions=[Isis_1, Isis_2])\n\n    # 配置组网拓扑\n    config_isis_lsp_wizard_network_topo(Wizards=wizard, Type='GRID',\n                                        GridNumberOfRows=10,\n                                        GridNumberOfColumns=20)\n\n    # 配置isis\n    config_isis_lsp_wizard_isis(Wizards=wizard,\n                                EnableTrafficEngine=True,\n                                EnableSegmentRouting=True,\n                                EnableSegmentRoutingIPv6=True,\n                                EnableFlexAlgo=True)\n    te = config_isis_lsp_wizard_isis_te(Wizards=wizard,\n                                        EnableTeGroup=True,\n                                        TeGroup=10)\n    sr = config_isis_lsp_wizard_isis_sr(Wizards=wizard,\n                                        ValueType='BIT32')\n    srv6 = config_isis_lsp_wizard_isis_srv6(Wizards=wizard,\n                                            MtId=10)\n    flex_algo = config_isis_lsp_wizard_isis_flex_algo(Wizards=wizard,\n                                                      FlexAlgo=255)\n\n    # 配置ipv4 internal route\n    config_isis_lsp_wizard_ipv4_internal_route(Wizards=wizard,\n                                               Ipv4InternalRoutesPrefixLenType='CUSTOM',\n                                               Ipv4InternalRoutesPrefixLenCustom=\n                                               [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 30, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                0.0, 0.0, 50]\n                                                )\n\n    # 配置ipv4 external route\n    config_isis_lsp_wizard_ipv4_external_route(Wizards=wizard,\n                                               Ipv4ExternalRoutesPrefixLenType='LINEAR',\n                                               Ipv4ExternalRoutesPrefixLenStart=10,\n                                               Ipv4ExternalRoutesPrefixLenEnd=20)\n\n    # 配置ipv6 internal route\n    config_isis_lsp_wizard_ipv6_internal_route(Wizards=wizard,\n                                               Ipv6InternalWideMetric=20)\n\n    # 配置ipv6 external route\n    config_isis_lsp_wizard_ipv6_external_route(Wizards=wizard,\n                                               Ipv6ExternalAdvEmulatedRouters=True\n                                               )\n\n    # 生成Isis Lsp向导配置\n    expand_isis_lsp_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "create_isis:创建ISIS协议会话对象"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个离线端口Port_1和Port_2，并获取端口对象。\",\n  \"子任务3\": \"在Port_1上创建以太网接口，配置IPv4地址192.168.1.2/网关192.168.1.3和IPv6地址2001::1/网关2001::2。\",\n  \"子任务4\": \"在Port_2上创建以太网接口，配置IPv4地址192.168.1.3/网关192.168.1.2和IPv6地址2001::2/网关2001::1。\",\n  \"子任务5\": \"在Port_1创建支持IPv4/IPv6的ISIS会话对象。\",\n  \"子任务6\": \"在Port_2创建支持IPv4/IPv6的ISIS会话对象。\",\n  \"子任务7\": \"将Port_1的接口绑定到其ISIS会话。\",\n  \"子任务8\": \"将Port_2的接口绑定到其ISIS会话。\",\n  \"子任务9\": \"创建ISIS LSP向导并关联两个ISIS会话对象。\",\n  \"子任务10\": \"配置向导网络拓扑为网格类型，设置行数和列数参数。\",\n  \"子任务11\": \"配置向导ISIS特性：启用流量工程、段路由、段路由IPv6和灵活算法。\",\n  \"子任务12\": \"配置向导流量工程参数：启用TE组并指定组号。\",\n  \"子任务13\": \"配置向导段路由参数：设置值类型为32位。\",\n  \"子任务14\": \"配置向导段路由IPv6参数：设置MT ID值。\",\n  \"子任务15\": \"配置向导灵活算法参数：指定灵活算法号。\",\n  \"子任务16\": \"配置向导IPv4内部路由参数：设置自定义前缀长度分布。\",\n  \"子任务17\": \"配置向导IPv4外部路由参数：设置线性变化的前缀长度范围。\",\n  \"子任务18\": \"配置向导IPv6内部路由参数：设置宽度量值。\",\n  \"子任务19\": \"配置向导IPv6外部路由参数：启用模拟路由器通告。\",\n  \"子任务20\": \"执行ISIS LSP向导配置生成操作。\",\n  \"子任务21\": \"验证配置生成过程无异常报错。\",\n  \"子任务22\": \"保存生成的测试配置文件到指定路径。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查Isis Lsp向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Isis会话;\n                   测试步骤3: 创建Isis Lsp向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Isis Lsp向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='eth', Tops=['ipv4', 'ipv6'])\n    interfaces_2 = create_interface(Port=Port_2, Layers='eth', Tops=['ipv4', 'ipv6'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建Isis会话\n    Isis_1 = create_isis(Port=Port_1, IpVersion='IPV4IPV6')\n    Isis_2 = create_isis(Port=Port_2, IpVersion='IPV4IPV6')\n\n    select_interface(Session=Isis_1, Interface=interfaces_1)\n    select_interface(Session=Isis_2, Interface=interfaces_2)\n\n    # 创建Isis Lsp向导\n    wizard = create_isis_lsp_wizard(Sessions=[Isis_1, Isis_2])\n\n    # 配置组网拓扑\n    config_isis_lsp_wizard_network_topo(Wizards=wizard, Type='GRID',\n                                        GridNumberOfRows=10,\n                                        GridNumberOfColumns=20)\n\n    # 配置isis\n    config_isis_lsp_wizard_isis(Wizards=wizard,\n                                EnableTrafficEngine=True,\n                                EnableSegmentRouting=True,\n                                EnableSegmentRoutingIPv6=True,\n                                EnableFlexAlgo=True)\n    te = config_isis_lsp_wizard_isis_te(Wizards=wizard,\n                                        EnableTeGroup=True,\n                                        TeGroup=10)\n    sr = config_isis_lsp_wizard_isis_sr(Wizards=wizard,\n                                        ValueType='BIT32')\n    srv6 = config_isis_lsp_wizard_isis_srv6(Wizards=wizard,\n                                            MtId=10)\n    flex_algo = config_isis_lsp_wizard_isis_flex_algo(Wizards=wizard,\n                                                      FlexAlgo=255)\n\n    # 配置ipv4 internal route\n    config_isis_lsp_wizard_ipv4_internal_route(Wizards=wizard,\n                                               Ipv4InternalRoutesPrefixLenType='CUSTOM',\n                                               Ipv4InternalRoutesPrefixLenCustom=\n                                               [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 30, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                0.0, 0.0, 50]\n                                                )\n\n    # 配置ipv4 external route\n    config_isis_lsp_wizard_ipv4_external_route(Wizards=wizard,\n                                               Ipv4ExternalRoutesPrefixLenType='LINEAR',\n                                               Ipv4ExternalRoutesPrefixLenStart=10,\n                                               Ipv4ExternalRoutesPrefixLenEnd=20)\n\n    # 配置ipv6 internal route\n    config_isis_lsp_wizard_ipv6_internal_route(Wizards=wizard,\n                                               Ipv6InternalWideMetric=20)\n\n    # 配置ipv6 external route\n    config_isis_lsp_wizard_ipv6_external_route(Wizards=wizard,\n                                               Ipv6ExternalAdvEmulatedRouters=True\n                                               )\n\n    # 生成Isis Lsp向导配置\n    expand_isis_lsp_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\ncreate_isis:创建ISIS协议会话对象\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/SAA/Saa.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查Saa协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建Saa协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='eth', Tops='ipv6')\n    interfaces_2 = create_interface(Port=Port_Down, Layers='eth', Tops='ipv6')\n    edit_interface(Interface=interfaces_1, Layer='IPv6Layer', Address='2022::2', Gateway='2022::3')\n    edit_interface(Interface=interfaces_2, Layer='IPv6Layer', Address='2022::3', Gateway='2022::2')\n\n    # 创建协议会话\n\n    session_1 = create_saa(Port=Port_UP)\n    session_2 = create_saa(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 订阅统计\n\n    subscribe_result(Types=['SaaPortStatistics', 'SaaSessionBlockStatistics', 'SaaSessionStatistics'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待协议会话达到状态\n\n    wait_saa_state(Sessions=[session_1, session_2], State='IDLE')\n\n    time.sleep(1)\n\n    # 获取统计\n    import pandas\n    result = get_saa_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_saa_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_saa_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_saa_session_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_saa_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_saa_session_block_statistic(Session=session_2)\n    print(result)\n\n    result = get_saa_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_saa_session_statistic(Session=session_1, SessionId=1)\n    print(result)\n    result = get_saa_session_statistic(Session=session_2, SessionId=1)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，并获取端口对象。\",\n  \"子任务3\": \"在Port_1端口上创建以太网和IPv6接口。\",\n  \"子任务4\": \"配置Port_1接口的IPv6层地址为2022::2，网关为2022::3。\",\n  \"子任务5\": \"在Port_2端口上创建以太网和IPv6接口。\",\n  \"子任务6\": \"配置Port_2接口的IPv6层地址为2022::3，网关为2022::2。\",\n  \"子任务7\": \"在Port_1端口上创建SAA协议会话。\",\n  \"子任务8\": \"在Port_2端口上创建SAA协议会话。\",\n  \"子任务9\": \"将Port_1接口绑定到Port_1的SAA协议会话。\",\n  \"子任务10\": \"将Port_2接口绑定到Port_2的SAA协议会话。\",\n  \"子任务11\": \"订阅SAA端口统计、会话块统计和会话统计视图。\",\n  \"子任务12\": \"保存当前测试配置到指定路径的配置文件。\",\n  \"子任务13\": \"启动所有协议。\",\n  \"子任务14\": \"等待两个SAA协议会话达到IDLE状态。\",\n  \"子任务15\": \"等待1秒确保统计稳定。\",\n  \"子任务16\": \"获取并验证整体SAA端口统计是否正确（返回DataFrame类型）。\",\n  \"子任务17\": \"获取Port_1端口SAA统计并输出。\",\n  \"子任务18\": \"获取Port_2端口SAA统计并输出。\",\n  \"子任务19\": \"获取并验证整体SAA会话块统计是否正确（返回DataFrame类型）。\",\n  \"子任务20\": \"获取Port_1会话块统计并输出。\",\n  \"子任务21\": \"获取Port_2会话块统计并输出。\",\n  \"子任务22\": \"获取并验证整体SAA会话统计是否正确（返回DataFrame类型）。\",\n  \"子任务23\": \"获取Port_1的会话ID=1统计并输出。\",\n  \"子任务24\": \"获取Port_2的会话ID=1统计并输出。\",\n  \"子任务25\": \"停止所有协议。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查Saa协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建Saa协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='eth', Tops='ipv6')\n    interfaces_2 = create_interface(Port=Port_Down, Layers='eth', Tops='ipv6')\n    edit_interface(Interface=interfaces_1, Layer='IPv6Layer', Address='2022::2', Gateway='2022::3')\n    edit_interface(Interface=interfaces_2, Layer='IPv6Layer', Address='2022::3', Gateway='2022::2')\n\n    # 创建协议会话\n\n    session_1 = create_saa(Port=Port_UP)\n    session_2 = create_saa(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 订阅统计\n\n    subscribe_result(Types=['SaaPortStatistics', 'SaaSessionBlockStatistics', 'SaaSessionStatistics'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待协议会话达到状态\n\n    wait_saa_state(Sessions=[session_1, session_2], State='IDLE')\n\n    time.sleep(1)\n\n    # 获取统计\n    import pandas\n    result = get_saa_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_saa_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_saa_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_saa_session_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_saa_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_saa_session_block_statistic(Session=session_2)\n    print(result)\n\n    result = get_saa_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_saa_session_statistic(Session=session_1, SessionId=1)\n    print(result)\n    result = get_saa_session_statistic(Session=session_2, SessionId=1)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/DHCP/DHCPv6_5000session.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查DHCPv6协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建DHCPv4协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Ports = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Ports[0], Layers=['ipv6'])\n    edit_interface(Interface=interfaces_1, Count=5000)\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='12:12:12::2',\n                   PrefixLength=64,\n                   Gateway='12:12:12::1')\n    interfaces_2 = create_interface(Port=Ports[1], Layers=['ipv6'])\n    # 保证MAC地址不冲突\n    edit_interface(Interface=interfaces_2,\n                   Layer='EthIILayer',\n                   Address='12:12:12:12:12:12')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='12:12:12::1',\n                   PrefixLength=64,\n                   Gateway='12:12:12::2')\n\n    # 创建DHCPv6协议会话\n    client = create_dhcpv6_client(Port=Ports[0])\n    server = create_dhcpv6_server(Port=Ports[1])\n    # DHCPv6协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_1)\n    select_interface(Session=server, Interface=interfaces_2)\n    # 获取DHCP Server地址池\n    pool = create_dhcpv6_server_address_pool(Sessions=server, StartAddress='12:12:12::2',PrefixLength=64,AddressCount=5100)\n    # 获取接口绑定流端点对象\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1,Layer='ipv6')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2,Layer='ipv6')\n    # 创建DHCPV6绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv6PortStatistics', 'Dhcpv6ClientBlockStatistics',\n                            'Dhcpv6ServerStatistics'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动协议\n    start_protocol()\n    # 等待DHCP协议协议会话状态正确\n    wait_dhcpv6_client_state(Sessions=client)\n    wait_dhcpv6_server_state(Sessions=server)\n    time.sleep(5)\n    # 发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取DHCP端口统计\n    result = get_dhcpv6_port_statistic(Port=Ports[0])\n    print(result)\n    CurrentBound = result['CurrentlyBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP客户端统计\n    result = get_dhcpv6_client_block_statistic(Session=client)\n    print(result)\n    CurrentBound = result['CurrentlyBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP服务器统计\n    result = get_dhcpv6_server_statistic(Session=server)\n    print(result)\n    CurrentBound = result['CurrentlyBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取流量1统计\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 获取流量2统计\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "create_dhcpv6_client:创建DHCPv6客户端会话对象",
      "create_dhcpv6_server:创建DHCPv6服务端会话对象",
      "create_dhcpv6_server_address_pool:创建DHCPv6 Server Address Pool对象",
      "get_dhcpv6_client_block_statistic:获取 Dhcpv6 Client Block Statistic 统计结果",
      "get_dhcpv6_port_statistic:获取Dhcpv6 Port Statistic统计结果",
      "get_dhcpv6_server_statistic:获取Dhcpv6 Server Statistic统计结果",
      "wait_dhcpv6_client_state:等待Dhcpv6客户端会话达到指定状态",
      "wait_dhcpv6_server_state:等待Dhcpv6服务端会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品型号为DarYu。\",\n  \"子任务2\": \"预约两个物理端口Port_1和Port_2，强制占用模式。\",\n  \"子任务3\": \"在Port_1创建IPv6接口，配置地址12:12:12::2/64，网关12:12:12::1，设置接口数量为5000。\",\n  \"子任务4\": \"在Port_2创建IPv6接口，配置MAC地址12:12:12:12:12:12，IPv6地址12:12:12::1/64，网关12:12:12::2。\",\n  \"子任务5\": \"在Port_1创建DHCPv6客户端会话对象。\",\n  \"子任务6\": \"在Port_2创建DHCPv6服务器会话对象。\",\n  \"子任务7\": \"将DHCPv6客户端会话绑定到Port_1的接口。\",\n  \"子任务8\": \"将DHCPv6服务器会话绑定到Port_2的接口。\",\n  \"子任务9\": \"在DHCPv6服务器创建地址池，起始地址12:12:12::2，前缀长度64，地址数量5100。\",\n  \"子任务10\": \"获取Port_1接口的IPv6层对象作为源端点。\",\n  \"子任务11\": \"获取Port_2接口的IPv6层对象作为目的端点。\",\n  \"子任务12\": \"创建双向绑定流量，源端点指向目的端点。\",\n  \"子任务13\": \"订阅StreamBlockStats、Dhcpv6PortStatistics等统计视图。\",\n  \"子任务14\": \"保存当前测试配置到文件。\",\n  \"子任务15\": \"启动DHCPv6协议会话。\",\n  \"子任务16\": \"等待DHCPv6客户端会话达到稳定状态。\",\n  \"子任务17\": \"等待DHCPv6服务器会话达到稳定状态。\",\n  \"子任务18\": \"开始发送所有绑定流量。\",\n  \"子任务19\": \"等待流量发送持续10秒。\",\n  \"子任务20\": \"停止所有流量发送。\",\n  \"子任务21\": \"验证Port_1的DHCPv6端口统计：CurrentlyBound和TotalBound均等于5000。\",\n  \"子任务22\": \"验证DHCPv6客户端统计：CurrentlyBound和TotalBound均等于5000。\",\n  \"子任务23\": \"验证DHCPv6服务器统计：CurrentlyBound和TotalBound均等于5000。\",\n  \"子任务24\": \"分别验证两个绑定流的StreamBlockStats统计：发送帧数等于接收帧数。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查DHCPv6协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建DHCPv4协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Ports = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Ports[0], Layers=['ipv6'])\n    edit_interface(Interface=interfaces_1, Count=5000)\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='12:12:12::2',\n                   PrefixLength=64,\n                   Gateway='12:12:12::1')\n    interfaces_2 = create_interface(Port=Ports[1], Layers=['ipv6'])\n    # 保证MAC地址不冲突\n    edit_interface(Interface=interfaces_2,\n                   Layer='EthIILayer',\n                   Address='12:12:12:12:12:12')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='12:12:12::1',\n                   PrefixLength=64,\n                   Gateway='12:12:12::2')\n\n    # 创建DHCPv6协议会话\n    client = create_dhcpv6_client(Port=Ports[0])\n    server = create_dhcpv6_server(Port=Ports[1])\n    # DHCPv6协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_1)\n    select_interface(Session=server, Interface=interfaces_2)\n    # 获取DHCP Server地址池\n    pool = create_dhcpv6_server_address_pool(Sessions=server, StartAddress='12:12:12::2',PrefixLength=64,AddressCount=5100)\n    # 获取接口绑定流端点对象\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1,Layer='ipv6')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2,Layer='ipv6')\n    # 创建DHCPV6绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv6PortStatistics', 'Dhcpv6ClientBlockStatistics',\n                            'Dhcpv6ServerStatistics'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动协议\n    start_protocol()\n    # 等待DHCP协议协议会话状态正确\n    wait_dhcpv6_client_state(Sessions=client)\n    wait_dhcpv6_server_state(Sessions=server)\n    time.sleep(5)\n    # 发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取DHCP端口统计\n    result = get_dhcpv6_port_statistic(Port=Ports[0])\n    print(result)\n    CurrentBound = result['CurrentlyBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP客户端统计\n    result = get_dhcpv6_client_block_statistic(Session=client)\n    print(result)\n    CurrentBound = result['CurrentlyBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP服务器统计\n    result = get_dhcpv6_server_statistic(Session=server)\n    print(result)\n    CurrentBound = result['CurrentlyBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取流量1统计\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 获取流量2统计\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\ncreate_dhcpv6_client:创建DHCPv6客户端会话对象;\ncreate_dhcpv6_server:创建DHCPv6服务端会话对象;\ncreate_dhcpv6_server_address_pool:创建DHCPv6 Server Address Pool对象;\nget_dhcpv6_client_block_statistic:获取 Dhcpv6 Client Block Statistic 统计结果;\nget_dhcpv6_port_statistic:获取Dhcpv6 Port Statistic统计结果;\nget_dhcpv6_server_statistic:获取Dhcpv6 Server Statistic统计结果;\nwait_dhcpv6_client_state:等待Dhcpv6客户端会话达到指定状态;\nwait_dhcpv6_server_state:等待Dhcpv6服务端会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc3918_MulticastLatency.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 得到DUT/SUT一个端口到多个出端口的一组时延数据\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项组播转发时延测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置组播转发时延;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成组播转发时延测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastLatency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed',\n                                   DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置组播转发时延* ===============\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='step', FixedGroup=10, MinGroup=10, MaxGroup=50,\n                                              StartGroup=10, EndGroup=20, StepGroup=10, CustomGroup=(10, 20, 100))\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True,\n                                    ResultFileName='Rfc3918MulticastLatency',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastLatency')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数",
      "edit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组",
      "edit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他",
      "edit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并预约指定端口。\",\n  \"子任务2\": \"创建RFC3918测试套件，选择组播转发时延测试项。\",\n  \"子任务3\": \"将预约端口关联到测试套件。\",\n  \"子任务4\": \"在端口上创建IPv4接口并配置IP地址与网关参数。\",\n  \"子任务5\": \"为测试套件创建IPv4流量流，指定源和目的端点及传输模式。\",\n  \"子任务6\": \"配置组播基础参数：IGMP版本、组播地址范围、加入/离开延迟及分配模式。\",\n  \"子任务7\": \"配置测试选项：地址学习策略、测试时长、帧长度范围、时延类型及结果存储路径。\",\n  \"子任务8\": \"配置组播转发时延参数：组播组数量循环模式、流量负载模式及自定义结果文件名。\",\n  \"子任务9\": \"生成智能测试脚本并保存配置文件。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 得到DUT/SUT一个端口到多个出端口的一组时延数据\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项组播转发时延测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置组播转发时延;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成组播转发时延测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastLatency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed',\n                                   DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置组播转发时延* ===============\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='step', FixedGroup=10, MinGroup=10, MaxGroup=50,\n                                              StartGroup=10, EndGroup=20, StepGroup=10, CustomGroup=(10, 20, 100))\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True,\n                                    ResultFileName='Rfc3918MulticastLatency',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastLatency')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数;\nedit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组;\nedit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他;\nedit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/Lacp/lacp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查lacp统计获取正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建lacp;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建协议会话\n\n    lacp_1 = create_lacp(Ports=Port_UP)\n    lacp_2 = create_lacp(Ports=Port_Down)\n\n    # 订阅统计\n\n    subscribe_result(Types=['LacpPortStats', 'LagPortStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_lacp_port(Ports=[Port_UP, Port_Down])\n    time.sleep(5)\n\n    # 获取统计\n    result = get_lacp_port_statistic(Port=Port_UP)\n    print(result)\n\n    result = get_lag_port_statistic(Lacp=lacp_1)\n    print(result)\n\n    stop_lacp_port(Ports=[Port_UP, Port_Down])\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1端口上创建LACP协议会话。\",\n  \"子任务4\": \"在Port_2端口上创建LACP协议会话。\",\n  \"子任务5\": \"订阅LACP端口统计(LacpPortStats)和LAG端口统计(LagPortStats)视图。\",\n  \"子任务6\": \"保存当前测试配置到配置文件。\",\n  \"子任务7\": \"在Port_1和Port_2端口上启动LACP协议。\",\n  \"子任务8\": \"等待5秒确保协议正常运行并生成统计。\",\n  \"子任务9\": \"获取Port_1端口的LACP端口统计信息。\",\n  \"子任务10\": \"获取Port_1端口对应的LAG端口统计信息。\",\n  \"子任务11\": \"获取Port_2端口的LACP端口统计信息。\",\n  \"子任务12\": \"获取Port_2端口对应的LAG端口统计信息。\",\n  \"子任务13\": \"验证所有获取的统计信息完整且符合预期（关键字段存在且非空）。\",\n  \"子任务14\": \"停止Port_1和Port_2端口上的LACP协议。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查lacp统计获取正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建lacp;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建协议会话\n\n    lacp_1 = create_lacp(Ports=Port_UP)\n    lacp_2 = create_lacp(Ports=Port_Down)\n\n    # 订阅统计\n\n    subscribe_result(Types=['LacpPortStats', 'LagPortStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_lacp_port(Ports=[Port_UP, Port_Down])\n    time.sleep(5)\n\n    # 获取统计\n    result = get_lacp_port_statistic(Port=Port_UP)\n    print(result)\n\n    result = get_lag_port_statistic(Lacp=lacp_1)\n    print(result)\n\n    stop_lacp_port(Ports=[Port_UP, Port_Down])\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/DHCP/DHCPv4_5000session.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查DHCPv4协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建DHCPv4协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Ports = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Ports[0], Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Count=5000)\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='12.12.12.2',\n                   PrefixLength=19,\n                   Gateway='12.12.12.1')\n    interfaces_2 = create_interface(Port=Ports[1], Layers=['ipv4'])\n    # 保证MAC地址不冲突\n    edit_interface(Interface=interfaces_2,\n                   Layer='EthIILayer',\n                   Address='12:12:12:12:12:12')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='12.12.12.1',\n                   PrefixLength=19,\n                   Gateway='12.12.12.2')\n\n    # 创建DHCPv4协议会话\n    client = create_dhcp_client(Port=Ports[0])\n    server = create_dhcp_server(Port=Ports[1])\n    # DHCPv4协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_1)\n    select_interface(Session=server, Interface=interfaces_2)\n    # 获取DHCP Server地址池\n    configDict = get_configs(Configs='Dhcpv4AddressPool')\n    dhcpv4AddressPool = list(configDict.values())[0]\n    edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='12.12.12.2', PrefixLength=19, PoolAddressCount=5100)\n    # 获取接口绑定流端点对象\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n    # 创建DHCPV4绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv4ServerStats', 'Dhcpv4ClientBlockStats',\n                            'Dhcpv4PortStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动协议\n    start_protocol()\n    # 等待DHCP协议协议会话状态正确\n    wait_dhcp_client_state(Sessions=client)\n    wait_dhcp_server_state(Sessions=server)\n    time.sleep(5)\n    # 发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取DHCP端口统计\n    result = get_dhcp_port_statistic(Port=Ports[0])\n    CurrentBound = result['CurrentBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP客户端统计\n    result = get_dhcp_client_block_statistic(Session=client)\n    CurrentBound = result['CurrentBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP服务器统计\n    result = get_dhcp_server_statistic(Session=server)\n    CurrentBound = result['CurrentBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取流量1统计\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 获取流量2统计\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "edit_configs:not_found",
      "get_configs:获取测试仪表指定对象",
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "create_dhcp_client:创建DHCPv4客户端协议会话对象",
      "create_dhcp_server:创建DHCP Server会话对象",
      "get_dhcp_client_block_statistic:获取Dhcp Client Block Statistic统计结果",
      "get_dhcp_port_statistic:获取Dhcp Port Statistic统计结果",
      "get_dhcp_server_statistic:获取 Dhcp Server Statistic 统计结果",
      "wait_dhcp_client_state:等待DHCP协议会话达到指定状态",
      "wait_dhcp_server_state:等待DHCP服务器协议会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建IPv4接口，配置IP地址12.12.12.2/19，网关12.12.12.1。\",\n  \"子任务4\": \"在Port_2上创建IPv4接口，配置MAC地址12:12:12:12:12:12和IP地址12.12.12.1/19，网关12.12.12.2。\",\n  \"子任务5\": \"在Port_1创建DHCPv4客户端会话。\",\n  \"子任务6\": \"在Port_2创建DHCPv4服务器会话。\",\n  \"子任务7\": \"将DHCP客户端会话绑定到Port_1接口。\",\n  \"子任务8\": \"将DHCP服务器会话绑定到Port_2接口。\",\n  \"子任务9\": \"获取并配置DHCPv4地址池：起始地址12.12.12.2，前缀长度19，地址数量5100。\",\n  \"子任务10\": \"从Port_1和Port_2接口获取封装层对象作为流端点。\",\n  \"子任务11\": \"创建双向绑定流，源端点为Port_1封装层，目的端点为Port_2封装层。\",\n  \"子任务12\": \"订阅StreamBlockStats、Dhcpv4ServerStats、Dhcpv4ClientBlockStats和Dhcpv4PortStats统计视图。\",\n  \"子任务13\": \"保存当前测试配置到文件。\",\n  \"子任务14\": \"启动DHCP协议会话。\",\n  \"子任务15\": \"等待DHCP客户端会话达到绑定状态。\",\n  \"子任务16\": \"等待DHCP服务器会话达到绑定状态。\",\n  \"子任务17\": \"开始发送所有绑定流量。\",\n  \"子任务18\": \"等待10秒流量发送时间。\",\n  \"子任务19\": \"停止所有流量发送。\",\n  \"子任务20\": \"获取Port_1的DHCP端口统计，验证CurrentBound和TotalBound等于5000。\",\n  \"子任务21\": \"获取DHCP客户端块统计，验证CurrentBound和TotalBound等于5000。\",\n  \"子任务22\": \"获取DHCP服务器统计，验证CurrentBound和TotalBound等于5000。\",\n  \"子任务23\": \"获取第一个流模板块统计，验证TxStreamFrames等于RxStreamFrames。\",\n  \"子任务24\": \"获取第二个流模板块统计，验证TxStreamFrames等于RxStreamFrames。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查DHCPv4协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建DHCPv4协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Ports = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Ports[0], Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Count=5000)\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='12.12.12.2',\n                   PrefixLength=19,\n                   Gateway='12.12.12.1')\n    interfaces_2 = create_interface(Port=Ports[1], Layers=['ipv4'])\n    # 保证MAC地址不冲突\n    edit_interface(Interface=interfaces_2,\n                   Layer='EthIILayer',\n                   Address='12:12:12:12:12:12')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='12.12.12.1',\n                   PrefixLength=19,\n                   Gateway='12.12.12.2')\n\n    # 创建DHCPv4协议会话\n    client = create_dhcp_client(Port=Ports[0])\n    server = create_dhcp_server(Port=Ports[1])\n    # DHCPv4协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_1)\n    select_interface(Session=server, Interface=interfaces_2)\n    # 获取DHCP Server地址池\n    configDict = get_configs(Configs='Dhcpv4AddressPool')\n    dhcpv4AddressPool = list(configDict.values())[0]\n    edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='12.12.12.2', PrefixLength=19, PoolAddressCount=5100)\n    # 获取接口绑定流端点对象\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n    # 创建DHCPV4绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv4ServerStats', 'Dhcpv4ClientBlockStats',\n                            'Dhcpv4PortStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动协议\n    start_protocol()\n    # 等待DHCP协议协议会话状态正确\n    wait_dhcp_client_state(Sessions=client)\n    wait_dhcp_server_state(Sessions=server)\n    time.sleep(5)\n    # 发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取DHCP端口统计\n    result = get_dhcp_port_statistic(Port=Ports[0])\n    CurrentBound = result['CurrentBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP客户端统计\n    result = get_dhcp_client_block_statistic(Session=client)\n    CurrentBound = result['CurrentBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP服务器统计\n    result = get_dhcp_server_statistic(Session=server)\n    CurrentBound = result['CurrentBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取流量1统计\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 获取流量2统计\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  edit_configs:not_found;\nget_configs:获取测试仪表指定对象;\ninit_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\ncreate_dhcp_client:创建DHCPv4客户端协议会话对象;\ncreate_dhcp_server:创建DHCP Server会话对象;\nget_dhcp_client_block_statistic:获取Dhcp Client Block Statistic统计结果;\nget_dhcp_port_statistic:获取Dhcp Port Statistic统计结果;\nget_dhcp_server_statistic:获取 Dhcp Server Statistic 统计结果;\nwait_dhcp_client_state:等待DHCP协议会话达到指定状态;\nwait_dhcp_server_state:等待DHCP服务器协议会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/TWAMP/twamp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查twamp统计获取正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建client / server;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建协议会话\n\n    client = create_twamp(Port=Port_UP,\n                          ActiveClient=True,\n                          PeerIpv4Address='1.1.1.2')\n    server = create_twamp(Port=Port_Down,\n                          ActiveServer=True)\n\n    select_interface(Session=client, Interface=interfaces_1)\n    select_interface(Session=server, Interface=interfaces_2)\n\n    # 创建test session\n    session_1 = edit_twamp_test_session(Twamps=client)\n    session_2 = edit_twamp_test_session(Twamps=client)\n\n    # 订阅统计\n\n    subscribe_result(Types=['TwampClientStats', 'TwampServerStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    twamp_start(Sessions=[client, server])\n    wait_twamp_state(Sessions=client)\n    wait_twamp_state(Sessions=server, State='STARTED')\n    time.sleep(2)\n\n    # 获取统计\n    result = get_twamp_client_statistic(Sessions=client)\n    print(result)\n\n    result = get_twamp_server_statistic(Sessions=server)\n    print(result)\n\n    twamp_stop(Sessions=[client, server])\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个测试仪表端口，分别标识为Port_UP和Port_Down。\",\n  \"子任务3\": \"在Port_UP端口上创建网络接口。\",\n  \"子任务4\": \"在Port_Down端口上创建网络接口。\",\n  \"子任务5\": \"配置Port_UP接口的IPv4参数：地址为1.1.1.1，网关为1.1.1.2。\",\n  \"子任务6\": \"配置Port_Down接口的IPv4参数：地址为1.1.1.2，网关为1.1.1.1。\",\n  \"子任务7\": \"在Port_UP端口创建TWAMP客户端会话，设置对端地址为1.1.1.2。\",\n  \"子任务8\": \"在Port_Down端口创建TWAMP服务器会话。\",\n  \"子任务9\": \"将TWAMP客户端会话绑定到Port_UP接口。\",\n  \"子任务10\": \"将TWAMP服务器会话绑定到Port_Down接口。\",\n  \"子任务11\": \"配置TWAMP客户端测试会话参数。\",\n  \"子任务12\": \"订阅TWAMP客户端和服务器统计视图。\",\n  \"子任务13\": \"保存当前测试配置到文件。\",\n  \"子任务14\": \"启动TWAMP客户端和服务器会话。\",\n  \"子任务15\": \"等待TWAMP客户端会话状态就绪。\",\n  \"子任务16\": \"等待TWAMP服务器会话状态变为STARTED。\",\n  \"子任务17\": \"获取TWAMP客户端会话统计信息。\",\n  \"子任务18\": \"获取TWAMP服务器会话统计信息。\",\n  \"子任务19\": \"验证TWAMP统计信息是否符合预期：数据完整且格式正确。\",\n  \"子任务20\": \"停止TWAMP客户端和服务器会话。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查twamp统计获取正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建client / server;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建协议会话\n\n    client = create_twamp(Port=Port_UP,\n                          ActiveClient=True,\n                          PeerIpv4Address='1.1.1.2')\n    server = create_twamp(Port=Port_Down,\n                          ActiveServer=True)\n\n    select_interface(Session=client, Interface=interfaces_1)\n    select_interface(Session=server, Interface=interfaces_2)\n\n    # 创建test session\n    session_1 = edit_twamp_test_session(Twamps=client)\n    session_2 = edit_twamp_test_session(Twamps=client)\n\n    # 订阅统计\n\n    subscribe_result(Types=['TwampClientStats', 'TwampServerStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    twamp_start(Sessions=[client, server])\n    wait_twamp_state(Sessions=client)\n    wait_twamp_state(Sessions=server, State='STARTED')\n    time.sleep(2)\n\n    # 获取统计\n    result = get_twamp_client_statistic(Sessions=client)\n    print(result)\n\n    result = get_twamp_server_statistic(Sessions=server)\n    print(result)\n\n    twamp_stop(Sessions=[client, server])\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/BGP/BGP.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查BGP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建BGP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建BGP协议会话\n    session_1 = create_bgp(Port=Port_UP)\n    session_2 = create_bgp(Port=Port_Down)\n\n    edit_bgp(Session=session_1, AsNumber=100, DutAsNumber=200)\n    edit_bgp(Session=session_2, AsNumber=200, DutAsNumber=100)\n\n    # BGP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # BGP协议会话1创建ipv4 route pool\n\n    ipv4_route_1 = create_bgp_ipv4_route_pool(Session=session_1, FirstRoute='100.0.0.1')\n    ipv4_route_2 = create_bgp_ipv4_route_pool(Session=session_2, FirstRoute='200.0.0.1')\n\n    component_type = ['Type1']\n    flow_specs = create_bgp_ipv4_flow_specs(Session=session_1, Origin='INCOMPLETE', ComponentType=component_type)\n    flow_spec_conponent_type = create_bgp_flow_spec_conponent_type(FlowSpec=flow_specs, Types=1, IpValue='71.2.0.0',\n                                                                   PrefixLength='32', Count='1000')\n    flow_specs_actions = create_bgp_flow_specs_actions(FlowSpec=flow_specs, EnableTrafficRate=True, TrafficRate=100000,\n                                                       EnableRedirectToIpNextHop=True, NextHop='13.21.4.2')\n\n    # 获取BGP协议绑定流端点对象\n\n    point_1 = get_bgp_router_from_route_pool(Configs=ipv4_route_1)\n    point_2 = get_bgp_router_from_route_pool(Configs=ipv4_route_2)\n\n    # 创建BGP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['BgpSessionStatistic', 'BgpSessionBlockStatistic', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待BGP协议会话达到Full状态\n\n    wait_bgp_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取流量1统计\n    result = get_bgp_session_statistic(Session=session_1, Id=1)\n    print(result)\n    result = get_bgp_session_statistic(Session=session_2, Id=1)\n    print(result)\n    result = get_bgp_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_bgp_session_block_statistic(Session=session_2)\n    print(result)\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "create_bgp:创建BGP协议会话对象",
      "create_bgp_flow_spec_conponent_type:创建Bgp Flow Specs Conponent Type对象, 类型为：object / list",
      "create_bgp_flow_specs_actions:创建Bgp Ipv4 Flow Specs Actions对象, 类型为：object / list",
      "create_bgp_ipv4_flow_specs:创建Bgp Ipv4 Flow Specs对象, 类型为：object / list",
      "create_bgp_ipv4_route_pool:创建BGP IPv4路由对象",
      "edit_bgp:编辑Bgp协议会话对象参数",
      "get_bgp_router_from_route_pool:获取 BGP Route Pool 对应的绑定流源或目的端点对象",
      "get_bgp_session_block_statistic:获取Bgp Session Block统计结果",
      "get_bgp_session_statistic:获取Bgp Session统计结果",
      "wait_bgp_state:等待BGP协议会话达到指定状态",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"预约两个自环端口 Port_1 和 Port_2\",\n  \"子任务2\": \"在 Port_1 和 Port_2 上分别创建 IPv4 接口\",\n  \"子任务3\": \"配置 Port_1 接口 IPv4 地址为 192.168.1.2，网关为 192.168.1.3\",\n  \"子任务4\": \"配置 Port_2 接口 IPv4 地址为 192.168.1.3，网关为 192.168.1.2\",\n  \"子任务5\": \"在 Port_1 上创建 BGP 会话，设置 AS 号为 100，DUT AS 号为 200\",\n  \"子任务6\": \"在 Port_2 上创建 BGP 会话，设置 AS 号为 200，DUT AS 号为 100\",\n  \"子任务7\": \"将 Port_1 的 BGP 会话绑定到 Port_1 接口\",\n  \"子任务8\": \"将 Port_2 的 BGP 会话绑定到 Port_2 接口\",\n  \"子任务9\": \"在 Port_1 的 BGP 会话上创建 IPv4 路由池，首路由为 100.0.0.1\",\n  \"子任务10\": \"在 Port_2 的 BGP 会话上创建 IPv4 路由池，首路由为 200.0.0.1\",\n  \"子任务11\": \"从 Port_1 路由池获取 BGP 路由器端点对象\",\n  \"子任务12\": \"从 Port_2 路由池获取 BGP 路由器端点对象\",\n  \"子任务13\": \"创建双向绑定流，源端点为 Port_1 路由器，目的端点为 Port_2 路由器\",\n  \"子任务14\": \"订阅 StreamBlockStats 统计视图\",\n  \"子任务15\": \"启动 BGP 协议\",\n  \"子任务16\": \"等待两个 BGP 会话达到 Full 状态\",\n  \"子任务17\": \"开始发送所有绑定流\",\n  \"子任务18\": \"持续发送流量 10 秒\",\n  \"子任务19\": \"停止所有流量发送\",\n  \"子任务20\": \"停止 BGP 协议\",\n  \"子任务21\": \"获取每个绑定流的 StreamBlockStats 统计信息\",\n  \"子任务22\": \"验证每个流的发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查BGP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建BGP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建BGP协议会话\n    session_1 = create_bgp(Port=Port_UP)\n    session_2 = create_bgp(Port=Port_Down)\n\n    edit_bgp(Session=session_1, AsNumber=100, DutAsNumber=200)\n    edit_bgp(Session=session_2, AsNumber=200, DutAsNumber=100)\n\n    # BGP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # BGP协议会话1创建ipv4 route pool\n\n    ipv4_route_1 = create_bgp_ipv4_route_pool(Session=session_1, FirstRoute='100.0.0.1')\n    ipv4_route_2 = create_bgp_ipv4_route_pool(Session=session_2, FirstRoute='200.0.0.1')\n\n    component_type = ['Type1']\n    flow_specs = create_bgp_ipv4_flow_specs(Session=session_1, Origin='INCOMPLETE', ComponentType=component_type)\n    flow_spec_conponent_type = create_bgp_flow_spec_conponent_type(FlowSpec=flow_specs, Types=1, IpValue='71.2.0.0',\n                                                                   PrefixLength='32', Count='1000')\n    flow_specs_actions = create_bgp_flow_specs_actions(FlowSpec=flow_specs, EnableTrafficRate=True, TrafficRate=100000,\n                                                       EnableRedirectToIpNextHop=True, NextHop='13.21.4.2')\n\n    # 获取BGP协议绑定流端点对象\n\n    point_1 = get_bgp_router_from_route_pool(Configs=ipv4_route_1)\n    point_2 = get_bgp_router_from_route_pool(Configs=ipv4_route_2)\n\n    # 创建BGP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['BgpSessionStatistic', 'BgpSessionBlockStatistic', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待BGP协议会话达到Full状态\n\n    wait_bgp_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取流量1统计\n    result = get_bgp_session_statistic(Session=session_1, Id=1)\n    print(result)\n    result = get_bgp_session_statistic(Session=session_2, Id=1)\n    print(result)\n    result = get_bgp_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_bgp_session_block_statistic(Session=session_2)\n    print(result)\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\ncreate_bgp:创建BGP协议会话对象;\ncreate_bgp_flow_spec_conponent_type:创建Bgp Flow Specs Conponent Type对象, 类型为：object / list;\ncreate_bgp_flow_specs_actions:创建Bgp Ipv4 Flow Specs Actions对象, 类型为：object / list;\ncreate_bgp_ipv4_flow_specs:创建Bgp Ipv4 Flow Specs对象, 类型为：object / list;\ncreate_bgp_ipv4_route_pool:创建BGP IPv4路由对象;\nedit_bgp:编辑Bgp协议会话对象参数;\nget_bgp_router_from_route_pool:获取 BGP Route Pool 对应的绑定流源或目的端点对象;\nget_bgp_session_block_statistic:获取Bgp Session Block统计结果;\nget_bgp_session_statistic:获取Bgp Session统计结果;\nwait_bgp_state:等待BGP协议会话达到指定状态;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/BFD/BFD.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查BFD与ISIS协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建ISIS协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建BFD协议会话\n\n    bfd_1 = create_bfd(Port=Port_UP)\n    bfd_2 = create_bfd(Port=Port_Down, RouterRole='PASSIVE')\n\n    select_interface(Session=bfd_1, Interface=interfaces_1)\n    select_interface(Session=bfd_2, Interface=interfaces_2)\n\n    # 创建ISIS协议会话及Tlv\n    isis_1 = create_isis(Port=Port_UP, EnableBFD=True)\n    isis_2 = create_isis(Port=Port_Down, EnableBFD=True)\n\n    select_interface(Session=isis_1, Interface=interfaces_1)\n    select_interface(Session=isis_2, Interface=interfaces_2)\n\n    ipv4_lsp_1 = create_isis_lsp(Session=isis_1, Level='L1')\n    ipv4_lsp_2 = create_isis_lsp(Session=isis_2, Level='L1')\n\n    ipv4_tlv_1 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_1, RouteCount=10, StartIpv4Prefix='2.0.0.1')\n    ipv4_tlv_2 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_2, RouteCount=10, StartIpv4Prefix='3.0.0.1')\n\n\n    # 获取接口绑定流端点对象\n    point_1 = get_isis_router_from_tlv(Configs=ipv4_tlv_1)\n    point_2 = get_isis_router_from_tlv(Configs=ipv4_tlv_2)\n\n\n    # 创建数据流量\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IsisBfdSessionResult'])\n\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待ISIS协议协议会话状态正确\n\n    wait_isis_state(Sessions=[isis_1, isis_2], State='UP')\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取BFD ISIS统计\n\n    bfd_isis_ipv4_result_1 = get_bfd_isis_session_result(BfdSession=bfd_1, IsisSession=isis_1, SessionId=1)\n    print(bfd_isis_ipv4_result_1)\n    bfd_isis_ipv4_result_2 = get_bfd_isis_session_result(BfdSession=bfd_2, IsisSession=isis_2, SessionId=1)\n    print(bfd_isis_ipv4_result_2)\n\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "create_bfd:创建BFD协议会话对象",
      "get_bfd_isis_session_result:获取ISIS BFD会话统计结果",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_isis:创建ISIS协议会话对象",
      "create_isis_ipv4_tlv:创建ISIS IPv4 TLV对象",
      "create_isis_lsp:创建ISIS LSP对象",
      "get_isis_router_from_tlv:获取 ISIS TLV 对应的绑定流源或目的端点对象",
      "wait_isis_state:等待ISIS协议会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建接口并配置IPv4地址和网关。\",\n  \"子任务4\": \"在Port_2上创建接口并配置IPv4地址和网关。\",\n  \"子任务5\": \"在Port_1上创建主动模式BFD会话并绑定接口。\",\n  \"子任务6\": \"在Port_2上创建被动模式BFD会话并绑定接口。\",\n  \"子任务7\": \"在Port_1上创建启用BFD的ISIS会话并绑定接口。\",\n  \"子任务8\": \"在Port_2上创建启用BFD的ISIS会话并绑定接口。\",\n  \"子任务9\": \"在Port_1的ISIS会话上创建L1级别LSP。\",\n  \"子任务10\": \"在Port_2的ISIS会话上创建L1级别LSP。\",\n  \"子任务11\": \"在Port_1的LSP上创建IPv4 TLV并指定路由参数。\",\n  \"子任务12\": \"在Port_2的LSP上创建IPv4 TLV并指定路由参数。\",\n  \"子任务13\": \"从IPv4 TLV获取源和目的端点对象。\",\n  \"子任务14\": \"创建双向绑定流量并关联源和目的端点。\",\n  \"子任务15\": \"订阅StreamBlockStats和ISIS BFD会话结果统计。\",\n  \"子任务16\": \"保存当前测试配置文件。\",\n  \"子任务17\": \"启动所有协议会话。\",\n  \"子任务18\": \"等待ISIS会话状态达到UP。\",\n  \"子任务19\": \"开始发送所有流量。\",\n  \"子任务20\": \"等待10秒流量发送时间。\",\n  \"子任务21\": \"停止所有流量发送。\",\n  \"子任务22\": \"停止所有协议会话。\",\n  \"子任务23\": \"获取BFD ISIS会话统计结果。\",\n  \"子任务24\": \"获取第一个流量的发送和接收帧数统计。\",\n  \"子任务25\": \"获取第二个流量的发送和接收帧数统计。\",\n  \"子任务26\": \"验证第一个流量发送帧数等于接收帧数。\",\n  \"子任务27\": \"验证第二个流量发送帧数等于接收帧数。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查BFD与ISIS协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建ISIS协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建BFD协议会话\n\n    bfd_1 = create_bfd(Port=Port_UP)\n    bfd_2 = create_bfd(Port=Port_Down, RouterRole='PASSIVE')\n\n    select_interface(Session=bfd_1, Interface=interfaces_1)\n    select_interface(Session=bfd_2, Interface=interfaces_2)\n\n    # 创建ISIS协议会话及Tlv\n    isis_1 = create_isis(Port=Port_UP, EnableBFD=True)\n    isis_2 = create_isis(Port=Port_Down, EnableBFD=True)\n\n    select_interface(Session=isis_1, Interface=interfaces_1)\n    select_interface(Session=isis_2, Interface=interfaces_2)\n\n    ipv4_lsp_1 = create_isis_lsp(Session=isis_1, Level='L1')\n    ipv4_lsp_2 = create_isis_lsp(Session=isis_2, Level='L1')\n\n    ipv4_tlv_1 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_1, RouteCount=10, StartIpv4Prefix='2.0.0.1')\n    ipv4_tlv_2 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_2, RouteCount=10, StartIpv4Prefix='3.0.0.1')\n\n\n    # 获取接口绑定流端点对象\n    point_1 = get_isis_router_from_tlv(Configs=ipv4_tlv_1)\n    point_2 = get_isis_router_from_tlv(Configs=ipv4_tlv_2)\n\n\n    # 创建数据流量\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IsisBfdSessionResult'])\n\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待ISIS协议协议会话状态正确\n\n    wait_isis_state(Sessions=[isis_1, isis_2], State='UP')\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取BFD ISIS统计\n\n    bfd_isis_ipv4_result_1 = get_bfd_isis_session_result(BfdSession=bfd_1, IsisSession=isis_1, SessionId=1)\n    print(bfd_isis_ipv4_result_1)\n    bfd_isis_ipv4_result_2 = get_bfd_isis_session_result(BfdSession=bfd_2, IsisSession=isis_2, SessionId=1)\n    print(bfd_isis_ipv4_result_2)\n\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\ncreate_bfd:创建BFD协议会话对象;\nget_bfd_isis_session_result:获取ISIS BFD会话统计结果;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_isis:创建ISIS协议会话对象;\ncreate_isis_ipv4_tlv:创建ISIS IPv4 TLV对象;\ncreate_isis_lsp:创建ISIS LSP对象;\nget_isis_router_from_tlv:获取 ISIS TLV 对应的绑定流源或目的端点对象;\nwait_isis_state:等待ISIS协议会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/PPPoE/PPPoE.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查PPPoe协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建PPPoe协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    # 修改接口类型\n\n    edit_interface_stack(Interfaces=[interfaces_1, interfaces_2], Layers=['eth', 'pppoe'], Tops=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建PPPoe协议会话\n\n    session_1 = create_pppoe(Port=Port_UP, EmulationMode='client')\n\n    session_2 = create_pppoe(Port=Port_Down, EmulationMode='server')\n\n    # PPPoe协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 获取接口绑定流端点对象\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    # 创建接口绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['PppoePortStatistic', 'PppoeServerBlockStatistic', 'PppoeServerStatistic', 'PppoeClientBlockStatistic', 'PppoeClientStatistic', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PPPoE协议会话达到CONNECTED状态\n\n    wait_pppoe_ipcp_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取PPPOE会话1统计\n    import pandas\n    result = get_pppoe_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pppoe_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_pppoe_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_pppoe_client_block_statistic()\n    print(result)\n\n    result = get_pppoe_client_block_statistic(Session=session_1)\n    print(result)\n\n    result = get_pppoe_client_statistic()\n    print(result)\n\n    result = get_pppoe_client_statistic(Session=session_1)\n    print(result)\n\n    result = get_pppoe_server_block_statistic()\n    print(result)\n\n    result = get_pppoe_server_block_statistic(Session=session_2)\n    print(result)\n\n    result = get_pppoe_server_statistic()\n    print(result)\n    result = get_pppoe_server_statistic(Session=session_2)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                      RxStreamFrames)\n\n    # 释放端口资源\n    result = release_port(Locations=locations)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "edit_interface_stack:修改测试仪表接口的结构",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_pppoe:创建PPPoE协议会话对象",
      "get_pppoe_client_block_statistic:获取PPPoE Server Block Statistic统计结果",
      "get_pppoe_client_statistic:获取PPPoE Client Statistic统计结果",
      "get_pppoe_port_statistic:获取PPPoE Port Statistic统计结果",
      "get_pppoe_server_block_statistic:获取PPPoE Server Block Statistic统计结果",
      "get_pppoe_server_statistic:获取PPPoE Server Statistic统计结果",
      "wait_pppoe_ipcp_state:等待PPPoE IPCP达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型。\",\n  \"子任务2\": \"预约两个自环端口 Port_UP 和 Port_Down。\",\n  \"子任务3\": \"在两个端口分别创建初始协议栈为 IPv4 的接口。\",\n  \"子任务4\": \"修改接口协议栈为 ETH-PPPoE-IPv4 三层结构。\",\n  \"子任务5\": \"配置 Port_UP 接口的 IPv4 地址为 192.168.1.2，网关为 192.168.1.3。\",\n  \"子任务6\": \"配置 Port_Down 接口的 IPv4 地址为 192.168.1.3，网关为 192.168.1.2。\",\n  \"子任务7\": \"在 Port_UP 创建 PPPoE 客户端会话。\",\n  \"子任务8\": \"在 Port_Down 创建 PPPoE 服务器会话。\",\n  \"子任务9\": \"将 PPPoE 客户端会话绑定到 Port_UP 接口。\",\n  \"子任务10\": \"将 PPPoE 服务器会话绑定到 Port_Down 接口。\",\n  \"子任务11\": \"获取两个接口的流端点对象作为流量端点。\",\n  \"子任务12\": \"创建双向绑定流，源端点为 Port_UP，目的端点为 Port_Down。\",\n  \"子任务13\": \"订阅 PPPoE 端口统计、服务端/客户端块统计及流模板块统计视图。\",\n  \"子任务14\": \"保存当前测试配置到文件。\",\n  \"子任务15\": \"启动 PPPoE 协议会话。\",\n  \"子任务16\": \"等待两个 PPPoE 会话 IPCP 状态达到 CONNECTED。\",\n  \"子任务17\": \"开始发送所有绑定流量。\",\n  \"子任务18\": \"持续发送流量 10 秒。\",\n  \"子任务19\": \"停止所有流量发送。\",\n  \"子任务20\": \"停止 PPPoE 协议会话。\",\n  \"子任务21\": \"获取流模板块统计信息。\",\n  \"子任务22\": \"验证每个流的 TxStreamFrames 等于 RxStreamFrames。\",\n  \"子任务23\": \"释放预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查PPPoe协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建PPPoe协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    # 修改接口类型\n\n    edit_interface_stack(Interfaces=[interfaces_1, interfaces_2], Layers=['eth', 'pppoe'], Tops=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建PPPoe协议会话\n\n    session_1 = create_pppoe(Port=Port_UP, EmulationMode='client')\n\n    session_2 = create_pppoe(Port=Port_Down, EmulationMode='server')\n\n    # PPPoe协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 获取接口绑定流端点对象\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    # 创建接口绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['PppoePortStatistic', 'PppoeServerBlockStatistic', 'PppoeServerStatistic', 'PppoeClientBlockStatistic', 'PppoeClientStatistic', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PPPoE协议会话达到CONNECTED状态\n\n    wait_pppoe_ipcp_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取PPPOE会话1统计\n    import pandas\n    result = get_pppoe_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pppoe_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_pppoe_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_pppoe_client_block_statistic()\n    print(result)\n\n    result = get_pppoe_client_block_statistic(Session=session_1)\n    print(result)\n\n    result = get_pppoe_client_statistic()\n    print(result)\n\n    result = get_pppoe_client_statistic(Session=session_1)\n    print(result)\n\n    result = get_pppoe_server_block_statistic()\n    print(result)\n\n    result = get_pppoe_server_block_statistic(Session=session_2)\n    print(result)\n\n    result = get_pppoe_server_statistic()\n    print(result)\n    result = get_pppoe_server_statistic(Session=session_2)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                      RxStreamFrames)\n\n    # 释放端口资源\n    result = release_port(Locations=locations)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nedit_interface_stack:修改测试仪表接口的结构;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_pppoe:创建PPPoE协议会话对象;\nget_pppoe_client_block_statistic:获取PPPoE Server Block Statistic统计结果;\nget_pppoe_client_statistic:获取PPPoE Client Statistic统计结果;\nget_pppoe_port_statistic:获取PPPoE Port Statistic统计结果;\nget_pppoe_server_block_statistic:获取PPPoE Server Block Statistic统计结果;\nget_pppoe_server_statistic:获取PPPoE Server Statistic统计结果;\nwait_pppoe_ipcp_state:等待PPPoE IPCP达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/OSPF/OSPFv3.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查OSPFv3协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建OSPFv3协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建OSPFv3协议会话\n\n    session_1 = create_ospfv3(Port=Port_UP, Priority=1)\n\n    session_2 = create_ospfv3(Port=Port_Down, Priority=2)\n\n    # OSPFv3协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # OSPFv3协议会话1创建Summary Lsa\n\n    inter_lsa_1 = create_ospfv3_inter_area_prefix_lsa(Session=session_1)\n\n    # OSPFv3协议会话2创建External Lsa\n\n    inter_lsa_2 = create_ospfv3_inter_area_prefix_lsa(Session=session_2)\n\n    # 获取OSPFv3协议绑定流端点对象\n\n    point_1 = get_ospf_router_from_lsa(Lsa=inter_lsa_1)\n\n    point_2 = get_ospf_router_from_lsa(Lsa=inter_lsa_2)\n\n    # 创建OSPFv3绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv3SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待OSPFv3协议会话达到Full状态\n\n    wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n\n    advertise_ospf_lsa(Lsa=[inter_lsa_1, inter_lsa_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    withdraw_ospf_lsa(Lsa=[inter_lsa_1, inter_lsa_2])\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取OSPFv3会话1统计\n    import pandas\n    result = get_ospfv3_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ospfv3_statistic(Session=session_1)\n    print(result)\n    Tx = result['TxInterAreaPrefixLsa']\n    Rx = result['RxInterAreaPrefixLsa']\n    print('TxInterAreaPrefixLsa:', Tx)\n    print('RxInterAreaPrefixLsa:', Rx)\n\n    # 获取OSPFv3会话2统计\n\n    result = get_ospfv3_statistic(Session=session_2)\n    print(result)\n    Tx = result['TxInterAreaPrefixLsa']\n    Rx = result['RxInterAreaPrefixLsa']\n    print('TxInterAreaPrefixLsa:', Tx)\n    print('RxInterAreaPrefixLsa:', Rx)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_ospf_lsa:通告 OSPFv2 协议会话 lsa",
      "get_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象",
      "wait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态",
      "withdraw_ospf_lsa:撤销OSPFv2协议会话lsa",
      "create_ospfv3:创建OSPFv3协议会话对象",
      "create_ospfv3_inter_area_prefix_lsa:创建OSPFv3 Inter Area Prefix LSA对象",
      "get_ospfv3_statistic:获取OSPFv3协议会话统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个物理端口 Port_UP 和 Port_Down。\",\n  \"子任务3\": \"在 Port_UP 上创建 IPv6 接口，配置地址为 2001::1，网关为 2001::2。\",\n  \"子任务4\": \"在 Port_Down 上创建 IPv6 接口，配置地址为 2001::2，网关为 2001::1。\",\n  \"子任务5\": \"在 Port_UP 上创建 OSPFv3 协议会话，优先级设置为 1。\",\n  \"子任务6\": \"在 Port_Down 上创建 OSPFv3 协议会话，优先级设置为 2。\",\n  \"子任务7\": \"将 Port_UP 的 OSPFv3 会话绑定到其 IPv6 接口。\",\n  \"子任务8\": \"将 Port_Down 的 OSPFv3 会话绑定到其 IPv6 接口。\",\n  \"子任务9\": \"在 Port_UP 的 OSPFv3 会话上创建 Inter Area Prefix LSA。\",\n  \"子任务10\": \"在 Port_Down 的 OSPFv3 会话上创建 Inter Area Prefix LSA。\",\n  \"子任务11\": \"从 Port_UP 的 LSA 获取绑定流源端点对象。\",\n  \"子任务12\": \"从 Port_Down 的 LSA 获取绑定流目的端点对象。\",\n  \"子任务13\": \"创建双向绑定流量，源端点为 Port_UP 端点，目的端点为 Port_Down 端点。\",\n  \"子任务14\": \"订阅 OSPFv3 会话统计和流模板块统计视图。\",\n  \"子任务15\": \"保存当前测试配置文件。\",\n  \"子任务16\": \"启动所有 OSPFv3 协议会话。\",\n  \"子任务17\": \"等待两个 OSPFv3 会话达到 Full 邻接状态。\",\n  \"子任务18\": \"通告两个端口的 LSA。\",\n  \"子任务19\": \"等待 5 秒确保 LSA 传播完成。\",\n  \"子任务20\": \"开始发送所有绑定流量。\",\n  \"子任务21\": \"等待 10 秒流量发送时间。\",\n  \"子任务22\": \"停止所有绑定流量发送。\",\n  \"子任务23\": \"撤销两个端口的 LSA。\",\n  \"子任务24\": \"等待 5 秒确保 LSA 撤销完成。\",\n  \"子任务25\": \"停止所有 OSPFv3 协议会话。\",\n  \"子任务26\": \"等待 3 秒确保协议完全停止。\",\n  \"子任务27\": \"获取第一个绑定流的统计信息（TxStreamFrames 和 RxStreamFrames）。\",\n  \"子任务28\": \"获取第二个绑定流的统计信息（TxStreamFrames 和 RxStreamFrames）。\",\n  \"子任务29\": \"验证第一个绑定流的发送帧数等于接收帧数。\",\n  \"子任务30\": \"验证第二个绑定流的发送帧数等于接收帧数。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查OSPFv3协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建OSPFv3协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建OSPFv3协议会话\n\n    session_1 = create_ospfv3(Port=Port_UP, Priority=1)\n\n    session_2 = create_ospfv3(Port=Port_Down, Priority=2)\n\n    # OSPFv3协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # OSPFv3协议会话1创建Summary Lsa\n\n    inter_lsa_1 = create_ospfv3_inter_area_prefix_lsa(Session=session_1)\n\n    # OSPFv3协议会话2创建External Lsa\n\n    inter_lsa_2 = create_ospfv3_inter_area_prefix_lsa(Session=session_2)\n\n    # 获取OSPFv3协议绑定流端点对象\n\n    point_1 = get_ospf_router_from_lsa(Lsa=inter_lsa_1)\n\n    point_2 = get_ospf_router_from_lsa(Lsa=inter_lsa_2)\n\n    # 创建OSPFv3绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv3SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待OSPFv3协议会话达到Full状态\n\n    wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n\n    advertise_ospf_lsa(Lsa=[inter_lsa_1, inter_lsa_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    withdraw_ospf_lsa(Lsa=[inter_lsa_1, inter_lsa_2])\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取OSPFv3会话1统计\n    import pandas\n    result = get_ospfv3_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ospfv3_statistic(Session=session_1)\n    print(result)\n    Tx = result['TxInterAreaPrefixLsa']\n    Rx = result['RxInterAreaPrefixLsa']\n    print('TxInterAreaPrefixLsa:', Tx)\n    print('RxInterAreaPrefixLsa:', Rx)\n\n    # 获取OSPFv3会话2统计\n\n    result = get_ospfv3_statistic(Session=session_2)\n    print(result)\n    Tx = result['TxInterAreaPrefixLsa']\n    Rx = result['RxInterAreaPrefixLsa']\n    print('TxInterAreaPrefixLsa:', Tx)\n    print('RxInterAreaPrefixLsa:', Rx)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_ospf_lsa:通告 OSPFv2 协议会话 lsa;\nget_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象;\nwait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态;\nwithdraw_ospf_lsa:撤销OSPFv2协议会话lsa;\ncreate_ospfv3:创建OSPFv3协议会话对象;\ncreate_ospfv3_inter_area_prefix_lsa:创建OSPFv3 Inter Area Prefix LSA对象;\nget_ospfv3_statistic:获取OSPFv3协议会话统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/DHCP/DHCPv6.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查DHCPv6协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建DHCPv6协议;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2011::2',\n                   Gateway='2011::1')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2011::1',\n                   Gateway='2011::2')\n\n    # 创建DHCPv6协议会话\n\n    client = create_dhcpv6_client(Port=Port_UP, Name='Client')\n\n    server = create_dhcpv6_server(Port=Port_Down, Name='Server')\n\n    # DHCPv6协议会话与接口绑定\n\n    select_interface(Session=client, Interface=interfaces_1)\n\n    select_interface(Session=server, Interface=interfaces_2)\n\n    # 获取DHCP Server地址池\n    pool = create_dhcpv6_server_address_pool(Sessions=server, StartAddress='2011::2')\n\n    # 获取接口绑定流端点对象\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv6')\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv6')\n\n    # 创建DHCP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv6PortStatistics', 'Dhcpv6ClientBlockStatistics',\n                            'Dhcpv6ServerStatistics', 'Dhcpv6LeaseStatistics'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待DHCP协议协议会话状态正确\n\n    wait_dhcpv6_client_state(Sessions=client)\n    wait_dhcpv6_server_state(Sessions=server)\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取DHCP端口统计\n    import pandas\n    result = get_dhcpv6_port_statistic()\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dhcpv6_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_dhcpv6_port_statistic(Port=Port_Down)\n    print(result)\n\n    # 获取DHCP客户端统计\n    result = get_dhcpv6_client_block_statistic()\n    print(result)\n    result = get_dhcpv6_client_block_statistic(Session=client)\n    print(result)\n\n    # 获取DHCP服务器统计\n    result = get_dhcpv6_server_statistic()\n    print(result)\n    result = get_dhcpv6_server_statistic(Session=server)\n    print(result)\n\n    result = get_dhcpv6_server_lease_statistic()\n    print(result)\n    result = get_dhcpv6_server_lease_statistic(Session=server, Pool=pool)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_dhcpv6_client:创建DHCPv6客户端会话对象",
      "create_dhcpv6_server:创建DHCPv6服务端会话对象",
      "create_dhcpv6_server_address_pool:创建DHCPv6 Server Address Pool对象",
      "get_dhcpv6_client_block_statistic:获取 Dhcpv6 Client Block Statistic 统计结果",
      "get_dhcpv6_port_statistic:获取Dhcpv6 Port Statistic统计结果",
      "get_dhcpv6_server_lease_statistic:获取Dhcpv6 Server Lease Statistic统计结果",
      "get_dhcpv6_server_statistic:获取Dhcpv6 Server Statistic统计结果",
      "wait_dhcpv6_client_state:等待Dhcpv6客户端会话达到指定状态",
      "wait_dhcpv6_server_state:等待Dhcpv6服务端会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建IPv6接口并配置地址(2011::2)和网关(2011::1)。\",\n  \"子任务4\": \"在Port_2上创建IPv6接口并配置地址(2011::1)和网关(2011::2)。\",\n  \"子任务5\": \"在Port_1上创建DHCPv6客户端会话。\",\n  \"子任务6\": \"在Port_2上创建DHCPv6服务器会话。\",\n  \"子任务7\": \"将DHCPv6客户端会话绑定到Port_1的IPv6接口。\",\n  \"子任务8\": \"将DHCPv6服务器会话绑定到Port_2的IPv6接口。\",\n  \"子任务9\": \"为DHCPv6服务器创建地址池(起始地址2011::2)。\",\n  \"子任务10\": \"获取Port_1接口的IPv6层对象。\",\n  \"子任务11\": \"获取Port_2接口的IPv6层对象。\",\n  \"子任务12\": \"创建双向绑定流量(源Port_1 IPv6层，目的Port_2 IPv6层)。\",\n  \"子任务13\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务14\": \"保存当前测试配置文件。\",\n  \"子任务15\": \"启动DHCPv6客户端和服务器协议。\",\n  \"子任务16\": \"等待DHCPv6客户端会话达到稳定状态。\",\n  \"子任务17\": \"等待DHCPv6服务器会话达到稳定状态。\",\n  \"子任务18\": \"开始发送所有绑定流量。\",\n  \"子任务19\": \"等待10秒流量发送持续时间。\",\n  \"子任务20\": \"停止所有流量发送。\",\n  \"子任务21\": \"停止DHCPv6协议会话。\",\n  \"子任务22\": \"获取每个绑定流的StreamBlockStats统计信息。\",\n  \"子任务23\": \"验证每个流的TxStreamFrames等于RxStreamFrames。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查DHCPv6协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建DHCPv6协议;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2011::2',\n                   Gateway='2011::1')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2011::1',\n                   Gateway='2011::2')\n\n    # 创建DHCPv6协议会话\n\n    client = create_dhcpv6_client(Port=Port_UP, Name='Client')\n\n    server = create_dhcpv6_server(Port=Port_Down, Name='Server')\n\n    # DHCPv6协议会话与接口绑定\n\n    select_interface(Session=client, Interface=interfaces_1)\n\n    select_interface(Session=server, Interface=interfaces_2)\n\n    # 获取DHCP Server地址池\n    pool = create_dhcpv6_server_address_pool(Sessions=server, StartAddress='2011::2')\n\n    # 获取接口绑定流端点对象\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv6')\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv6')\n\n    # 创建DHCP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv6PortStatistics', 'Dhcpv6ClientBlockStatistics',\n                            'Dhcpv6ServerStatistics', 'Dhcpv6LeaseStatistics'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待DHCP协议协议会话状态正确\n\n    wait_dhcpv6_client_state(Sessions=client)\n    wait_dhcpv6_server_state(Sessions=server)\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取DHCP端口统计\n    import pandas\n    result = get_dhcpv6_port_statistic()\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dhcpv6_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_dhcpv6_port_statistic(Port=Port_Down)\n    print(result)\n\n    # 获取DHCP客户端统计\n    result = get_dhcpv6_client_block_statistic()\n    print(result)\n    result = get_dhcpv6_client_block_statistic(Session=client)\n    print(result)\n\n    # 获取DHCP服务器统计\n    result = get_dhcpv6_server_statistic()\n    print(result)\n    result = get_dhcpv6_server_statistic(Session=server)\n    print(result)\n\n    result = get_dhcpv6_server_lease_statistic()\n    print(result)\n    result = get_dhcpv6_server_lease_statistic(Session=server, Pool=pool)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_dhcpv6_client:创建DHCPv6客户端会话对象;\ncreate_dhcpv6_server:创建DHCPv6服务端会话对象;\ncreate_dhcpv6_server_address_pool:创建DHCPv6 Server Address Pool对象;\nget_dhcpv6_client_block_statistic:获取 Dhcpv6 Client Block Statistic 统计结果;\nget_dhcpv6_port_statistic:获取Dhcpv6 Port Statistic统计结果;\nget_dhcpv6_server_lease_statistic:获取Dhcpv6 Server Lease Statistic统计结果;\nget_dhcpv6_server_statistic:获取Dhcpv6 Server Statistic统计结果;\nwait_dhcpv6_client_state:等待Dhcpv6客户端会话达到指定状态;\nwait_dhcpv6_server_state:等待Dhcpv6服务端会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/PIM/PIM.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查PIM协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 创建PIM协议及组播组;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建pim协议会话\n\n    pim_1 = create_pim(Port=Port_UP)\n\n    pim_2 = create_pim(Port=Port_Down)\n\n    pim_group_1 = create_pim_group(Session=pim_1, GroupAddr='225.0.0.1')\n\n    pim_group_2 = create_pim_group(Session=pim_2, GroupAddr='225.0.0.2')\n\n\n    # DHCPv6协议会话与接口绑定\n\n    select_interface(Session=pim_1, Interface=interfaces_1)\n\n    select_interface(Session=pim_2, Interface=interfaces_2)\n\n    # 创建组播组\n\n    multicast_group_1 = create_multicast_group(Start='225.0.0.1')\n\n    multicast_group_2 = create_multicast_group(Start='225.0.0.2')\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 创建DHCP绑定流\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=multicast_group_1)\n\n    stream = add_stream(Type='binding', SrcPoints=point_2, DstPoints=multicast_group_2)\n    streams.extend(stream)\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'PimSessionStats', 'PimGroupStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待DHCP协议协议会话状态正确\n\n    wait_pim_state(Sessions=[pim_1, pim_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取PIM会话统计\n    import pandas\n    result = get_pim_session_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pim_session_stats(Session=pim_1)\n    print(result)\n\n    result = get_pim_session_stats(Session=pim_2)\n    print(result)\n\n    # 获取PIM Group统计\n    result = get_pim_group_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pim_group_stats(Session=pim_1, Group=pim_group_1)\n    print(result)\n\n    result = get_pim_group_stats(Session=pim_2, Group=pim_group_2)\n    print(result)\n\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_multicast_group:创建全局组播组对象",
      "create_pim:创建PIM协议会话对象",
      "create_pim_group:创建PIM Group对象",
      "get_pim_group_stats:获取Pim Group Stats统计结果",
      "get_pim_session_stats:获取Pim Session Stats统计结果",
      "wait_pim_state:等待PIM协议会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个测试端口（Port_UP和Port_Down）。\",\n  \"子任务3\": \"在Port_UP端口上创建网络接口。\",\n  \"子任务4\": \"在Port_Down端口上创建网络接口。\",\n  \"子任务5\": \"配置Port_UP接口的IPv4层参数：地址1.1.1.1，网关1.1.1.2。\",\n  \"子任务6\": \"配置Port_Down接口的IPv4层参数：地址1.1.1.2，网关1.1.1.1。\",\n  \"子任务7\": \"在Port_UP端口上创建PIM协议会话。\",\n  \"子任务8\": \"在Port_Down端口上创建PIM协议会话。\",\n  \"子任务9\": \"在Port_UP的PIM会话上创建组播组（地址225.0.0.1）。\",\n  \"子任务10\": \"在Port_Down的PIM会话上创建组播组（地址225.0.0.2）。\",\n  \"子任务11\": \"将Port_UP的PIM会话绑定到对应接口。\",\n  \"子任务12\": \"将Port_Down的PIM会话绑定到对应接口。\",\n  \"子任务13\": \"创建全局组播组对象（起始地址225.0.0.1）。\",\n  \"子任务14\": \"创建全局组播组对象（起始地址225.0.0.2）。\",\n  \"子任务15\": \"保存当前测试配置到文件。\",\n  \"子任务16\": \"获取Port_UP接口的封装层对象。\",\n  \"子任务17\": \"获取Port_Down接口的封装层对象。\",\n  \"子任务18\": \"创建绑定流量1：源为Port_UP接口层，目的为第一个组播组。\",\n  \"子任务19\": \"创建绑定流量2：源为Port_Down接口层，目的为第二个组播组。\",\n  \"子任务20\": \"订阅统计视图：流模板块统计、PIM会话统计、PIM组统计。\",\n  \"子任务21\": \"再次保存更新后的测试配置到文件。\",\n  \"子任务22\": \"启动所有配置的协议会话。\",\n  \"子任务23\": \"等待两个PIM会话达到预期运行状态。\",\n  \"子任务24\": \"开始发送所有绑定流量。\",\n  \"子任务25\": \"持续发送流量10秒。\",\n  \"子任务26\": \"停止所有流量发送。\",\n  \"子任务27\": \"停止所有协议会话。\",\n  \"子任务28\": \"获取第一条绑定流的统计信息（发送帧数和接收帧数）。\",\n  \"子任务29\": \"获取第二条绑定流的统计信息（发送帧数和接收帧数）。\",\n  \"子任务30\": \"验证第一条绑定流的发送帧数等于接收帧数。\",\n  \"子任务31\": \"验证第二条绑定流的发送帧数等于接收帧数。\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查PIM协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 创建PIM协议及组播组;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建pim协议会话\n\n    pim_1 = create_pim(Port=Port_UP)\n\n    pim_2 = create_pim(Port=Port_Down)\n\n    pim_group_1 = create_pim_group(Session=pim_1, GroupAddr='225.0.0.1')\n\n    pim_group_2 = create_pim_group(Session=pim_2, GroupAddr='225.0.0.2')\n\n\n    # DHCPv6协议会话与接口绑定\n\n    select_interface(Session=pim_1, Interface=interfaces_1)\n\n    select_interface(Session=pim_2, Interface=interfaces_2)\n\n    # 创建组播组\n\n    multicast_group_1 = create_multicast_group(Start='225.0.0.1')\n\n    multicast_group_2 = create_multicast_group(Start='225.0.0.2')\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 创建DHCP绑定流\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=multicast_group_1)\n\n    stream = add_stream(Type='binding', SrcPoints=point_2, DstPoints=multicast_group_2)\n    streams.extend(stream)\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'PimSessionStats', 'PimGroupStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待DHCP协议协议会话状态正确\n\n    wait_pim_state(Sessions=[pim_1, pim_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取PIM会话统计\n    import pandas\n    result = get_pim_session_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pim_session_stats(Session=pim_1)\n    print(result)\n\n    result = get_pim_session_stats(Session=pim_2)\n    print(result)\n\n    # 获取PIM Group统计\n    result = get_pim_group_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pim_group_stats(Session=pim_1, Group=pim_group_1)\n    print(result)\n\n    result = get_pim_group_stats(Session=pim_2, Group=pim_group_2)\n    print(result)\n\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_multicast_group:创建全局组播组对象;\ncreate_pim:创建PIM协议会话对象;\ncreate_pim_group:创建PIM Group对象;\nget_pim_group_stats:获取Pim Group Stats统计结果;\nget_pim_session_stats:获取Pim Session Stats统计结果;\nwait_pim_state:等待PIM协议会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/DHCP/DHCPv4.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查DHCPv4协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建DHCPv4协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='2.1.1.2',\n                   Gateway='2.1.1.1')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='2.1.2.2',\n                   Gateway='2.1.1.1')\n\n    # 创建DHCPv4协议会话\n\n    client = create_dhcp_client(Port=Port_UP)\n\n    server = create_dhcp_server(Port=Port_Down)\n\n    # DHCPv4协议会话与接口绑定\n\n    select_interface(Session=client, Interface=interfaces_1)\n\n    select_interface(Session=server, Interface=interfaces_2)\n\n    # 获取DHCP Server地址池\n    configDict = get_configs(Configs='Dhcpv4AddressPool')\n    dhcpv4AddressPool = list(configDict.values())[0]\n    edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='2.1.2.3')\n\n    # 获取接口绑定流端点对象\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    # 创建OSPFv2绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv4ServerStats', 'Dhcpv4ClientBlockStats', 'Dhcpv4ClientStats',\n                            'Dhcpv4PortStats', 'Dhcpv4LeaseStats', ])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待DHCP协议协议会话状态正确\n\n    wait_dhcp_client_state(Sessions=client)\n    wait_dhcp_server_state(Sessions=server)\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取DHCP端口统计\n    import pandas\n    result = get_dhcp_port_statistic()\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dhcp_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_dhcp_port_statistic(Port=Port_Down)\n    print(result)\n\n    # 获取DHCP客户端统计\n    result = get_dhcp_client_statistic()\n    print(result)\n    result = get_dhcp_client_statistic(Session=client)\n    print(result)\n\n    result = get_dhcp_client_block_statistic(Session=client)\n    print(result)\n\n    # 获取DHCP服务器统计\n    result = get_dhcp_server_statistic()\n    print(result)\n    result = get_dhcp_server_statistic(Session=server)\n    print(result)\n\n    result = get_dhcp_server_lease_statistic(Session=server, ClientId='00:00:02:01:01:02')\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "edit_configs:not_found",
      "get_configs:获取测试仪表指定对象",
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_dhcp_client:创建DHCPv4客户端协议会话对象",
      "create_dhcp_server:创建DHCP Server会话对象",
      "get_dhcp_client_block_statistic:获取Dhcp Client Block Statistic统计结果",
      "get_dhcp_client_statistic:获取Dhcp Client Statistic统计结果",
      "get_dhcp_port_statistic:获取Dhcp Port Statistic统计结果",
      "get_dhcp_server_lease_statistic:获取Dhcp Server Lease Statistic统计结果",
      "get_dhcp_server_statistic:获取 Dhcp Server Statistic 统计结果",
      "wait_dhcp_client_state:等待DHCP协议会话达到指定状态",
      "wait_dhcp_server_state:等待DHCP服务器协议会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表平台。\",\n  \"子任务2\": \"预约两个端口（Port_UP和Port_Down）。\",\n  \"子任务3\": \"在Port_UP端口创建IPv4接口，配置地址为2.1.1.2，网关为2.1.1.1。\",\n  \"子任务4\": \"在Port_Down端口创建IPv4接口，配置地址为2.1.2.2，网关为2.1.1.1。\",\n  \"子任务5\": \"在Port_UP端口创建DHCPv4客户端协议会话。\",\n  \"子任务6\": \"在Port_Down端口创建DHCPv4服务器协议会话。\",\n  \"子任务7\": \"将DHCPv4客户端会话绑定到Port_UP端口的接口。\",\n  \"子任务8\": \"将DHCPv4服务器会话绑定到Port_Down端口的接口。\",\n  \"子任务9\": \"配置DHCPv4服务器地址池起始地址为2.1.2.3。\",\n  \"子任务10\": \"从两个接口获取封装层对象作为流端点。\",\n  \"子任务11\": \"创建双向绑定流量，源端点为Port_UP接口层，目的端点为Port_Down接口层。\",\n  \"子任务12\": \"订阅流模板块统计（StreamBlockStats）等性能指标。\",\n  \"子任务13\": \"保存当前测试配置到文件。\",\n  \"子任务14\": \"启动所有协议会话。\",\n  \"子任务15\": \"等待DHCPv4客户端会话达到稳定状态。\",\n  \"子任务16\": \"等待DHCPv4服务器会话达到稳定状态。\",\n  \"子任务17\": \"开始发送所有绑定流量。\",\n  \"子任务18\": \"持续发送流量10秒。\",\n  \"子任务19\": \"停止所有流量发送。\",\n  \"子任务20\": \"停止所有协议会话。\",\n  \"子任务21\": \"获取第一个绑定流的统计信息。\",\n  \"子任务22\": \"验证第一个流的发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\",\n  \"子任务23\": \"获取第二个绑定流的统计信息。\",\n  \"子任务24\": \"验证第二个流的发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查DHCPv4协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建DHCPv4协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='2.1.1.2',\n                   Gateway='2.1.1.1')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='2.1.2.2',\n                   Gateway='2.1.1.1')\n\n    # 创建DHCPv4协议会话\n\n    client = create_dhcp_client(Port=Port_UP)\n\n    server = create_dhcp_server(Port=Port_Down)\n\n    # DHCPv4协议会话与接口绑定\n\n    select_interface(Session=client, Interface=interfaces_1)\n\n    select_interface(Session=server, Interface=interfaces_2)\n\n    # 获取DHCP Server地址池\n    configDict = get_configs(Configs='Dhcpv4AddressPool')\n    dhcpv4AddressPool = list(configDict.values())[0]\n    edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='2.1.2.3')\n\n    # 获取接口绑定流端点对象\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    # 创建OSPFv2绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv4ServerStats', 'Dhcpv4ClientBlockStats', 'Dhcpv4ClientStats',\n                            'Dhcpv4PortStats', 'Dhcpv4LeaseStats', ])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待DHCP协议协议会话状态正确\n\n    wait_dhcp_client_state(Sessions=client)\n    wait_dhcp_server_state(Sessions=server)\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取DHCP端口统计\n    import pandas\n    result = get_dhcp_port_statistic()\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dhcp_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_dhcp_port_statistic(Port=Port_Down)\n    print(result)\n\n    # 获取DHCP客户端统计\n    result = get_dhcp_client_statistic()\n    print(result)\n    result = get_dhcp_client_statistic(Session=client)\n    print(result)\n\n    result = get_dhcp_client_block_statistic(Session=client)\n    print(result)\n\n    # 获取DHCP服务器统计\n    result = get_dhcp_server_statistic()\n    print(result)\n    result = get_dhcp_server_statistic(Session=server)\n    print(result)\n\n    result = get_dhcp_server_lease_statistic(Session=server, ClientId='00:00:02:01:01:02')\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  edit_configs:not_found;\nget_configs:获取测试仪表指定对象;\ninit_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_dhcp_client:创建DHCPv4客户端协议会话对象;\ncreate_dhcp_server:创建DHCP Server会话对象;\nget_dhcp_client_block_statistic:获取Dhcp Client Block Statistic统计结果;\nget_dhcp_client_statistic:获取Dhcp Client Statistic统计结果;\nget_dhcp_port_statistic:获取Dhcp Port Statistic统计结果;\nget_dhcp_server_lease_statistic:获取Dhcp Server Lease Statistic统计结果;\nget_dhcp_server_statistic:获取 Dhcp Server Statistic 统计结果;\nwait_dhcp_client_state:等待DHCP协议会话达到指定状态;\nwait_dhcp_server_state:等待DHCP服务器协议会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/MLD/MLDv1.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查MLD协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建MLD协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2000::3',\n                   Gateway='2000::2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2000::2',\n                   Gateway='2000::3')\n\n    # 创建MLD协议会话\n\n    mld = create_mld(Port=Port_UP)\n\n    edit_mld(Session=mld, Version='MLDV1', InitialJoin=True)\n\n    # MLD协议会话与接口绑定\n\n    select_interface(Session=mld, Interface=interfaces_1)\n\n    # MLD协议会话1创建Summary Lsa\n\n    multicast_group = create_multicast_group(Start='ff1e::2', Version=\"IPv6\")\n\n    # MLD协议会话2创建External Lsa\n\n    memberships = create_memberships(Session=mld, DeviceGroupMapping='ROUNDROBIN')\n\n    # 获取MLD协议绑定流端点对象\n\n    binding_multicast_group(Session=mld, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建MLD Querier协议会话\n\n    mld_querier = create_mld_querier(Port=Port_Down, Version='MLDV1')\n\n    edit_mld_querier(Session=mld_querier, RobustnessVariable=3)\n\n    # MLD Querier协议会话与接口绑定\n\n    select_interface(Session=mld_querier, Interface=interfaces_2)\n\n    # 创建MLD绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv6')\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'MldHostResults', 'MldPortAggregatedResults', 'MldQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待MLD协议会话稳定状态\n\n    wait_mld_state(Sessions=[mld])\n    wait_mld_querier_state(Sessions=[mld_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取MLD Host统计\n    result = get_mld_host_statistic()\n    print(result)\n\n    result = get_mld_host_statistic(Session=mld)\n    print(result)\n\n    # 获取MLD Port统计\n    result = get_mld_port_statistic()\n    print(result)\n\n    result = get_mld_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取MLD Querier统计\n    result = get_mld_querier_statistic()\n    print(result)\n\n    result = get_mld_querier_statistic(Session=mld_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_mld:创建MLD协议会话对象",
      "create_mld_querier:创建MLD Querier协议会话对象",
      "edit_mld:创建MLD协议会话对象",
      "edit_mld_querier:编辑MLD Querier协议会话对象",
      "get_mld_host_statistic:获取Mld协议会话统计结果",
      "get_mld_port_statistic:获取Mld Port统计结果",
      "get_mld_querier_statistic:获取Mld Querier协议会话统计结果",
      "wait_mld_querier_state:等待Mld Querier协议会话达到指定状态",
      "wait_mld_state:等待Mld协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个物理端口（Port_1和Port_2）作为测试端口。\",\n  \"子任务3\": \"在Port_1上创建IPv6接口，配置IPv6地址和网关。\",\n  \"子任务4\": \"在Port_2上创建IPv6接口，配置IPv6地址和网关。\",\n  \"子任务5\": \"在Port_1创建MLD协议会话，设置版本为MLDV1并启用初始加入。\",\n  \"子任务6\": \"将Port_1的MLD协议会话绑定到其IPv6接口。\",\n  \"子任务7\": \"创建全局IPv6组播组（起始地址ff1e::2）。\",\n  \"子任务8\": \"为MLD协议创建成员关系，采用轮询方式绑定组播组。\",\n  \"子任务9\": \"在Port_2创建MLD Querier协议会话，设置健壮性变量为3。\",\n  \"子任务10\": \"将Port_2的MLD Querier协议会话绑定到其IPv6接口。\",\n  \"子任务11\": \"获取Port_2接口的IPv6层对象作为流量源端点。\",\n  \"子任务12\": \"创建绑定流量：源点为Port_2 IPv6层，目的点为组播组，单向传输。\",\n  \"子任务13\": \"订阅流统计视图（StreamBlockStats）用于后续结果验证。\",\n  \"子任务14\": \"保存当前测试配置到文件。\",\n  \"子任务15\": \"启动所有协议会话（MLD和MLD Querier）。\",\n  \"子任务16\": \"等待MLD协议会话达到稳定状态。\",\n  \"子任务17\": \"等待MLD Querier协议会话达到稳定状态。\",\n  \"子任务18\": \"启动所有绑定流量发送。\",\n  \"子任务19\": \"持续发送流量60秒。\",\n  \"子任务20\": \"停止所有流量发送。\",\n  \"子任务21\": \"停止所有协议会话。\",\n  \"子任务22\": \"获取绑定流量的统计信息（StreamBlockStats）。\",\n  \"子任务23\": \"验证流量统计结果：发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查MLD协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建MLD协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2000::3',\n                   Gateway='2000::2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2000::2',\n                   Gateway='2000::3')\n\n    # 创建MLD协议会话\n\n    mld = create_mld(Port=Port_UP)\n\n    edit_mld(Session=mld, Version='MLDV1', InitialJoin=True)\n\n    # MLD协议会话与接口绑定\n\n    select_interface(Session=mld, Interface=interfaces_1)\n\n    # MLD协议会话1创建Summary Lsa\n\n    multicast_group = create_multicast_group(Start='ff1e::2', Version=\"IPv6\")\n\n    # MLD协议会话2创建External Lsa\n\n    memberships = create_memberships(Session=mld, DeviceGroupMapping='ROUNDROBIN')\n\n    # 获取MLD协议绑定流端点对象\n\n    binding_multicast_group(Session=mld, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建MLD Querier协议会话\n\n    mld_querier = create_mld_querier(Port=Port_Down, Version='MLDV1')\n\n    edit_mld_querier(Session=mld_querier, RobustnessVariable=3)\n\n    # MLD Querier协议会话与接口绑定\n\n    select_interface(Session=mld_querier, Interface=interfaces_2)\n\n    # 创建MLD绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv6')\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'MldHostResults', 'MldPortAggregatedResults', 'MldQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待MLD协议会话稳定状态\n\n    wait_mld_state(Sessions=[mld])\n    wait_mld_querier_state(Sessions=[mld_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取MLD Host统计\n    result = get_mld_host_statistic()\n    print(result)\n\n    result = get_mld_host_statistic(Session=mld)\n    print(result)\n\n    # 获取MLD Port统计\n    result = get_mld_port_statistic()\n    print(result)\n\n    result = get_mld_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取MLD Querier统计\n    result = get_mld_querier_statistic()\n    print(result)\n\n    result = get_mld_querier_statistic(Session=mld_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_mld:创建MLD协议会话对象;\ncreate_mld_querier:创建MLD Querier协议会话对象;\nedit_mld:创建MLD协议会话对象;\nedit_mld_querier:编辑MLD Querier协议会话对象;\nget_mld_host_statistic:获取Mld协议会话统计结果;\nget_mld_port_statistic:获取Mld Port统计结果;\nget_mld_querier_statistic:获取Mld Querier协议会话统计结果;\nwait_mld_querier_state:等待Mld Querier协议会话达到指定状态;\nwait_mld_state:等待Mld协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/MLD/MLDv2.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查MLD协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建MLD协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2000::3',\n                   Gateway='2000::2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2000::2',\n                   Gateway='2000::3')\n\n    # 创建MLD协议会话\n\n    mld = create_mld(Port=Port_UP)\n\n    edit_mld(Session=mld, Version='MLDV2')\n\n    # MLD协议会话与接口绑定\n\n    select_interface(Session=mld, Interface=interfaces_1)\n\n    # MLD协议会话1创建Summary Lsa\n\n    multicast_group = create_multicast_group(Start='ff1e::2', Version=\"IPv6\")\n\n    # MLD协议会话2创建External Lsa\n\n    memberships = create_memberships(Session=mld,\n                                     DeviceGroupMapping='ROUNDROBIN',\n                                     UserDefinedSources=False)\n\n    # 获取MLD协议绑定流端点对象\n\n    binding_multicast_group(Session=mld, Memberships=memberships, MulticastGroup=multicast_group)\n\n    select_source_interface(Session=mld, Memberships=memberships, Interface=interfaces_2)\n\n    # 创建MLD Querier协议会话\n\n    mld_querier = create_mld_querier(Port=Port_Down, Version='MLDV1')\n\n    edit_mld_querier(Session=mld_querier, RobustnessVariable=3)\n\n    # MLD Querier协议会话与接口绑定\n\n    select_interface(Session=mld_querier, Interface=interfaces_2)\n\n    # 创建MLD绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv6')\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'MldHostResults', 'MldPortAggregatedResults', 'MldQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待MLD协议会话稳定状态\n\n    wait_mld_state(Sessions=[mld])\n    wait_mld_querier_state(Sessions=[mld_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取MLD Host统计\n\n    result = get_mld_host_statistic(Session=mld)\n    print(result)\n\n    # 获取MLD Port统计\n\n    result = get_mld_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取MLD Querier统计\n\n    result = get_mld_querier_statistic(Session=mld_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "select_source_interface:将协议会话组播组过滤源地址绑定到指定接口",
      "create_mld:创建MLD协议会话对象",
      "create_mld_querier:创建MLD Querier协议会话对象",
      "edit_mld:创建MLD协议会话对象",
      "edit_mld_querier:编辑MLD Querier协议会话对象",
      "get_mld_host_statistic:获取Mld协议会话统计结果",
      "get_mld_port_statistic:获取Mld Port统计结果",
      "get_mld_querier_statistic:获取Mld Querier协议会话统计结果",
      "wait_mld_querier_state:等待Mld Querier协议会话达到指定状态",
      "wait_mld_state:等待Mld协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品型号为DarYu。\",\n  \"子任务2\": \"预约两个端口，分别命名为Port_UP和Port_Down。\",\n  \"子任务3\": \"在Port_UP端口创建IPv6接口，配置地址2000::3，网关2000::2。\",\n  \"子任务4\": \"在Port_Down端口创建IPv6接口，配置地址2000::2，网关2000::3。\",\n  \"子任务5\": \"在Port_UP端口创建MLD协议会话，设置版本为MLDV2。\",\n  \"子任务6\": \"将Port_UP端口的MLD协议绑定到该端口的IPv6接口。\",\n  \"子任务7\": \"创建全局组播组，起始地址为ff1e::2，版本IPv6。\",\n  \"子任务8\": \"为Port_UP端口的MLD会话创建成员关系，采用轮询映射模式。\",\n  \"子任务9\": \"将全局组播组绑定到MLD会话的成员关系。\",\n  \"子任务10\": \"将MLD成员关系的源接口绑定到Port_Down端口的IPv6接口。\",\n  \"子任务11\": \"在Port_Down端口创建MLD Querier协议会话，设置健壮变量为3。\",\n  \"子任务12\": \"将Port_Down端口的MLD Querier协议绑定到该端口的IPv6接口。\",\n  \"子任务13\": \"获取Port_Down端口IPv6接口的协议层对象。\",\n  \"子任务14\": \"创建绑定流：源点为Port_Down的IPv6层，目的点为全局组播组，非双向模式。\",\n  \"子任务15\": \"订阅流统计、MLD主机统计、MLD端口聚合统计和MLD查询器统计视图。\",\n  \"子任务16\": \"启动所有协议（MLD和MLD Querier）。\",\n  \"子任务17\": \"等待Port_UP端口的MLD协议达到稳定状态。\",\n  \"子任务18\": \"等待Port_Down端口的MLD Querier协议达到稳定状态。\",\n  \"子任务19\": \"启动所有流量发送。\",\n  \"子任务20\": \"持续发送流量60秒。\",\n  \"子任务21\": \"停止所有流量发送。\",\n  \"子任务22\": \"停止所有协议。\",\n  \"子任务23\": \"获取流统计信息，记录发送帧数(TxStreamFrames)和接收帧数(RxStreamFrames)。\",\n  \"子任务24\": \"验证发送帧数与接收帧数是否相等。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查MLD协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建MLD协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2000::3',\n                   Gateway='2000::2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2000::2',\n                   Gateway='2000::3')\n\n    # 创建MLD协议会话\n\n    mld = create_mld(Port=Port_UP)\n\n    edit_mld(Session=mld, Version='MLDV2')\n\n    # MLD协议会话与接口绑定\n\n    select_interface(Session=mld, Interface=interfaces_1)\n\n    # MLD协议会话1创建Summary Lsa\n\n    multicast_group = create_multicast_group(Start='ff1e::2', Version=\"IPv6\")\n\n    # MLD协议会话2创建External Lsa\n\n    memberships = create_memberships(Session=mld,\n                                     DeviceGroupMapping='ROUNDROBIN',\n                                     UserDefinedSources=False)\n\n    # 获取MLD协议绑定流端点对象\n\n    binding_multicast_group(Session=mld, Memberships=memberships, MulticastGroup=multicast_group)\n\n    select_source_interface(Session=mld, Memberships=memberships, Interface=interfaces_2)\n\n    # 创建MLD Querier协议会话\n\n    mld_querier = create_mld_querier(Port=Port_Down, Version='MLDV1')\n\n    edit_mld_querier(Session=mld_querier, RobustnessVariable=3)\n\n    # MLD Querier协议会话与接口绑定\n\n    select_interface(Session=mld_querier, Interface=interfaces_2)\n\n    # 创建MLD绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv6')\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'MldHostResults', 'MldPortAggregatedResults', 'MldQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待MLD协议会话稳定状态\n\n    wait_mld_state(Sessions=[mld])\n    wait_mld_querier_state(Sessions=[mld_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取MLD Host统计\n\n    result = get_mld_host_statistic(Session=mld)\n    print(result)\n\n    # 获取MLD Port统计\n\n    result = get_mld_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取MLD Querier统计\n\n    result = get_mld_querier_statistic(Session=mld_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nselect_source_interface:将协议会话组播组过滤源地址绑定到指定接口;\ncreate_mld:创建MLD协议会话对象;\ncreate_mld_querier:创建MLD Querier协议会话对象;\nedit_mld:创建MLD协议会话对象;\nedit_mld_querier:编辑MLD Querier协议会话对象;\nget_mld_host_statistic:获取Mld协议会话统计结果;\nget_mld_port_statistic:获取Mld Port统计结果;\nget_mld_querier_statistic:获取Mld Querier协议会话统计结果;\nwait_mld_querier_state:等待Mld Querier协议会话达到指定状态;\nwait_mld_state:等待Mld协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/PCEP/PCEP.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 配置PCEP协议，检查统计\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建PCEP协议;\n                   测试步骤4: 订阅PCEP相关统计;\n                   测试步骤5: 启动协议;\n                   测试步骤6: 查看统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中统计获取正常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建PCEP协议会话\n\n    session_1 = create_pcep(Port=Port_UP, Role='PCC', Negotiation=True)\n\n    session_2 = create_pcep(Port=Port_Down, Role='PCE', Negotiation=False)\n\n    # PCEP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建LSP\n\n    lsp_1 = create_pcep_pcc_lsp(Sessions=session_1)\n\n    lsp_2 = create_pcep_pce_lsp(Sessions=session_2)\n\n    # 订阅统计\n\n    subscribe_result(Types=['PcepLspStatistic', 'PcepLspBlockStatistic', 'PcepPortStatistic',\n                            'PcepSessionStatistic', 'PcepSessionBlockStatistic'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PCEP协议协议会话状态正确\n\n    wait_pcep_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取PCEP端口统计\n    import pandas\n    result = get_pcep_lsp_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_lsp_statistic(Session=session_1, SessionId=1, Lsp=lsp_1, LspId=1)\n    print(result)\n    result = get_pcep_lsp_statistic(Session=session_2, SessionId=1, Lsp=lsp_2, LspId=1)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_lsp_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_lsp_block_statistic(Session=session_1, SessionId=1, Lsp=lsp_1)\n    print(result)\n    result = get_pcep_lsp_block_statistic(Session=session_2, SessionId=1, Lsp=lsp_2)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_pcep_port_statistic(Port=Port_Down)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_session_statistic(Session=session_1, SessionId=1)\n    print(result)\n    result = get_pcep_session_statistic(Session=session_2, SessionId=1)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_session_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_pcep_session_block_statistic(Session=session_2)\n    print(result)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_pcep:创建PCEP协议会话对象",
      "create_pcep_pcc_lsp:创建PCEP PCC LSP对象",
      "create_pcep_pce_lsp:创建PCEP PCE LSP对象",
      "get_pcep_lsp_block_statistic:获取PCEP LSP BLOCK统计结果",
      "get_pcep_lsp_statistic:获取PCEP LSP统计结果",
      "get_pcep_port_statistic:获取PCEP Port统计结果",
      "get_pcep_session_block_statistic:获取PCEP session block统计结果",
      "get_pcep_session_statistic:获取PCEP session统计结果",
      "wait_pcep_state:等待PCEP协议会话达到指定状态",
      "subscribe_result:订阅测试仪表统计视图",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个指定位置的自环端口Port_UP和Port_Down。\",\n  \"子任务3\": \"在Port_UP端口上创建接口并配置IPv4地址和网关。\",\n  \"子任务4\": \"在Port_Down端口上创建接口并配置IPv4地址和网关。\",\n  \"子任务5\": \"在Port_UP端口创建PCEP协议会话（角色为PCC，启用协商）。\",\n  \"子任务6\": \"在Port_Down端口创建PCEP协议会话（角色为PCE，禁用协商）。\",\n  \"子任务7\": \"将Port_UP的PCEP会话绑定到其IPv4接口。\",\n  \"子任务8\": \"将Port_Down的PCEP会话绑定到其IPv4接口。\",\n  \"子任务9\": \"为PCC会话创建LSP对象。\",\n  \"子任务10\": \"为PCE会话创建LSP对象。\",\n  \"子任务11\": \"订阅PCEP统计类型（LSP/LSP块/端口/会话/会话块统计）。\",\n  \"子任务12\": \"保存当前测试配置到文件。\",\n  \"子任务13\": \"启动所有已配置协议。\",\n  \"子任务14\": \"等待两个PCEP会话达到预期状态。\",\n  \"子任务15\": \"开始发送数据流并持续10秒。\",\n  \"子任务16\": \"停止数据流发送并停止所有协议。\",\n  \"子任务17\": \"获取并验证全局PCEP LSP统计结果是否为有效数据帧。\",\n  \"子任务18\": \"获取并验证Port_UP端口的PCEP LSP统计结果。\",\n  \"子任务19\": \"获取并验证Port_Down端口的PCEP LSP统计结果。\",\n  \"子任务20\": \"获取并验证全局PCEP LSP块统计结果是否为有效数据帧。\",\n  \"子任务21\": \"获取并验证Port_UP端口的PCEP LSP块统计结果。\",\n  \"子任务22\": \"获取并验证Port_Down端口的PCEP LSP块统计结果。\",\n  \"子任务23\": \"获取并验证全局PCEP端口统计结果是否为有效数据帧。\",\n  \"子任务24\": \"获取并验证Port_UP端口的PCEP端口统计结果。\",\n  \"子任务25\": \"获取并验证Port_Down端口的PCEP端口统计结果。\",\n  \"子任务26\": \"获取并验证全局PCEP会话统计结果是否为有效数据帧。\",\n  \"子任务27\": \"获取并验证Port_UP端口的PCEP会话统计结果。\",\n  \"子任务28\": \"获取并验证Port_Down端口的PCEP会话统计结果。\",\n  \"子任务29\": \"获取并验证全局PCEP会话块统计结果是否为有效数据帧。\",\n  \"子任务30\": \"获取并验证Port_UP端口的PCEP会话块统计结果。\",\n  \"子任务31\": \"获取并验证Port_Down端口的PCEP会话块统计结果。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 配置PCEP协议，检查统计\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建PCEP协议;\n                   测试步骤4: 订阅PCEP相关统计;\n                   测试步骤5: 启动协议;\n                   测试步骤6: 查看统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中统计获取正常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建PCEP协议会话\n\n    session_1 = create_pcep(Port=Port_UP, Role='PCC', Negotiation=True)\n\n    session_2 = create_pcep(Port=Port_Down, Role='PCE', Negotiation=False)\n\n    # PCEP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建LSP\n\n    lsp_1 = create_pcep_pcc_lsp(Sessions=session_1)\n\n    lsp_2 = create_pcep_pce_lsp(Sessions=session_2)\n\n    # 订阅统计\n\n    subscribe_result(Types=['PcepLspStatistic', 'PcepLspBlockStatistic', 'PcepPortStatistic',\n                            'PcepSessionStatistic', 'PcepSessionBlockStatistic'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PCEP协议协议会话状态正确\n\n    wait_pcep_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取PCEP端口统计\n    import pandas\n    result = get_pcep_lsp_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_lsp_statistic(Session=session_1, SessionId=1, Lsp=lsp_1, LspId=1)\n    print(result)\n    result = get_pcep_lsp_statistic(Session=session_2, SessionId=1, Lsp=lsp_2, LspId=1)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_lsp_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_lsp_block_statistic(Session=session_1, SessionId=1, Lsp=lsp_1)\n    print(result)\n    result = get_pcep_lsp_block_statistic(Session=session_2, SessionId=1, Lsp=lsp_2)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_pcep_port_statistic(Port=Port_Down)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_session_statistic(Session=session_1, SessionId=1)\n    print(result)\n    result = get_pcep_session_statistic(Session=session_2, SessionId=1)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_session_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_pcep_session_block_statistic(Session=session_2)\n    print(result)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_pcep:创建PCEP协议会话对象;\ncreate_pcep_pcc_lsp:创建PCEP PCC LSP对象;\ncreate_pcep_pce_lsp:创建PCEP PCE LSP对象;\nget_pcep_lsp_block_statistic:获取PCEP LSP BLOCK统计结果;\nget_pcep_lsp_statistic:获取PCEP LSP统计结果;\nget_pcep_port_statistic:获取PCEP Port统计结果;\nget_pcep_session_block_statistic:获取PCEP session block统计结果;\nget_pcep_session_statistic:获取PCEP session统计结果;\nwait_pcep_state:等待PCEP协议会话达到指定状态;\nsubscribe_result:订阅测试仪表统计视图;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Overall/smart_scripter_control_loop.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 使用智能脚本控制命令loop\n\n Step\t\t\t:\t测试步骤1: 创建端口;\n                   测试步骤2: 创建流量;\n                   测试步骤3: 检查统计;\n\n Criteria    \t:   预期结果1: 步骤3 判断端口发送报文数量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.192/1/1', '//10.0.11.192/1/2'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'BigTao' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2 = reserve_port(Locations=locations[:2])\n\n    # 创建raw stream\n    stream_1 = add_stream(Ports=port_1)\n    stream_2 = add_stream(Ports=port_2)\n    edit_port_load_profile(Ports=[port_1, port_2],\n                           TransmitMode='BURST',\n                           BurstSize=100)\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats'])\n\n    ggroup = smart_scripter_global_group()\n\n    # 使用智能脚本的loop命令\n    loopcommand = smart_scripter_command(ParentGroup=ggroup,\n                                         Command='LoopCommand',\n                                         LoopCount=2)\n    stream_handle_1 = get_object_attrs(stream_1)\n    start_stream_1 = smart_scripter_command(ParentGroup=loopcommand,\n                                            Command='StartStreamCommand',\n                                            StreamList=stream_handle_1)\n    stream_handle_2 = get_object_attrs(stream_2)\n    start_stream_2 = smart_scripter_command(ParentGroup=loopcommand,\n                                            Command='StartStreamCommand',\n                                            StreamList=stream_handle_2)\n    run_benchmark()\n    result = get_port_statistic()\n    print(result)\n    assert result['TxStreamFrames'][0] == 100\n    assert result['TxStreamFrames'][1] == 100\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为BigTao。\",\n  \"子任务2\": \"预约两个测试仪表端口（//10.0.11.192/1/1和//10.0.11.192/1/2）。\",\n  \"子任务3\": \"创建两个流量流（stream_1和stream_2），分别绑定到预约的端口。\",\n  \"子任务4\": \"配置端口负载参数：设置传输模式为BURST，突发大小为100帧。\",\n  \"子任务5\": \"订阅端口统计视图（PortStats）用于结果监控。\",\n  \"子任务6\": \"创建智能脚本全局命令组作为操作容器。\",\n  \"子任务7\": \"在全局组下创建循环命令（LoopCommand），设置循环次数为2。\",\n  \"子任务8\": \"在循环命令组下创建启动stream_1的命令（StartStreamCommand）。\",\n  \"子任务9\": \"在循环命令组下创建启动stream_2的命令（StartStreamCommand）。\",\n  \"子任务10\": \"执行基准测试套件（run_benchmark）启动流量发送。\",\n  \"子任务11\": \"获取端口统计结果数据（get_port_statistic）。\",\n  \"子任务12\": \"验证端口1发送帧数（TxStreamFrames[0]）等于100。\",\n  \"子任务13\": \"验证端口2发送帧数（TxStreamFrames[1]）等于100。\",\n  \"子任务14\": \"保存当前测试配置到.xcfg格式文件。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 使用智能脚本控制命令loop\n\n Step\t\t\t:\t测试步骤1: 创建端口;\n                   测试步骤2: 创建流量;\n                   测试步骤3: 检查统计;\n\n Criteria    \t:   预期结果1: 步骤3 判断端口发送报文数量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.192/1/1', '//10.0.11.192/1/2'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'BigTao' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2 = reserve_port(Locations=locations[:2])\n\n    # 创建raw stream\n    stream_1 = add_stream(Ports=port_1)\n    stream_2 = add_stream(Ports=port_2)\n    edit_port_load_profile(Ports=[port_1, port_2],\n                           TransmitMode='BURST',\n                           BurstSize=100)\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats'])\n\n    ggroup = smart_scripter_global_group()\n\n    # 使用智能脚本的loop命令\n    loopcommand = smart_scripter_command(ParentGroup=ggroup,\n                                         Command='LoopCommand',\n                                         LoopCount=2)\n    stream_handle_1 = get_object_attrs(stream_1)\n    start_stream_1 = smart_scripter_command(ParentGroup=loopcommand,\n                                            Command='StartStreamCommand',\n                                            StreamList=stream_handle_1)\n    stream_handle_2 = get_object_attrs(stream_2)\n    start_stream_2 = smart_scripter_command(ParentGroup=loopcommand,\n                                            Command='StartStreamCommand',\n                                            StreamList=stream_handle_2)\n    run_benchmark()\n    result = get_port_statistic()\n    print(result)\n    assert result['TxStreamFrames'][0] == 100\n    assert result['TxStreamFrames'][1] == 100\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/Dot1x/Dot1x.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查802.1x协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建802.1x协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface_stack(Interfaces=interfaces_1)\n    edit_interface_stack(Interfaces=interfaces_2)\n\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建802.1x协议会话\n\n    session_1 = create_dot1x(Port=Port_UP, Name='Dot1x_1')\n    session_2 = create_dot1x(Port=Port_Down, Name='Dot1x_2')\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n\n    # 订阅统计\n\n    subscribe_result(Types=['Dot1xBlockStatistics', 'Dot1xPortStatistics', 'Dot1xStatistics'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PPPoE协议会话达到CONNECTED状态\n\n    wait_dot1x_state(Sessions=[session_1, session_2], State='AUTHENTICATING')\n\n    time.sleep(5)\n\n    # 获取802.1x会话1统计\n    import pandas\n    result = get_dot1x_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dot1x_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_dot1x_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_dot1x_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dot1x_block_statistic(Session=session_1)\n    print(result)\n    result = get_dot1x_block_statistic(Session=session_2)\n    print(result)\n\n    result = get_dot1x_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dot1x_statistic(Session=session_1, Index=1)\n    print(result)\n    result = get_dot1x_statistic(Session=session_2, Index=1)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "edit_interface_stack:修改测试仪表接口的结构",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_dot1x:创建802.1x会话对象",
      "get_dot1x_block_statistic:获取802.1x session block统计结果",
      "get_dot1x_port_statistic:获取802.1x port block统计结果",
      "get_dot1x_statistic:获取802.1x统计结果",
      "wait_dot1x_state:等待802.1x会话达到指定状态",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_UP和Port_Down。\",\n  \"子任务3\": \"在Port_UP和Port_Down端口上分别创建网络接口。\",\n  \"子任务4\": \"修改两个接口的协议栈结构。\",\n  \"子任务5\": \"配置两个接口的IPv4地址和网关参数。\",\n  \"子任务6\": \"在Port_UP和Port_Down端口上分别创建802.1x协议会话。\",\n  \"子任务7\": \"将创建的接口绑定到对应的802.1x协议会话。\",\n  \"子任务8\": \"订阅802.1x的端口统计、会话块统计和全局统计视图。\",\n  \"子任务9\": \"保存当前测试配置到文件。\",\n  \"子任务10\": \"启动所有协议会话。\",\n  \"子任务11\": \"等待两个802.1x会话达到AUTHENTICATING状态。\",\n  \"子任务12\": \"等待5秒确保协议稳定运行。\",\n  \"子任务13\": \"获取并验证Port_UP端口的802.1x端口统计结果是否为有效数据。\",\n  \"子任务14\": \"获取并验证Port_Down端口的802.1x端口统计结果是否为有效数据。\",\n  \"子任务15\": \"获取并验证802.1x会话块统计结果是否为有效数据。\",\n  \"子任务16\": \"获取并验证session_1的802.1x会话统计结果是否为有效数据。\",\n  \"子任务17\": \"获取并验证session_2的802.1x会话统计结果是否为有效数据。\",\n  \"子任务18\": \"比较所有流量统计结果，验证接收包数与发送包数是否相等。\",\n  \"子任务19\": \"停止所有运行中的协议会话。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查802.1x协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建802.1x协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface_stack(Interfaces=interfaces_1)\n    edit_interface_stack(Interfaces=interfaces_2)\n\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建802.1x协议会话\n\n    session_1 = create_dot1x(Port=Port_UP, Name='Dot1x_1')\n    session_2 = create_dot1x(Port=Port_Down, Name='Dot1x_2')\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n\n    # 订阅统计\n\n    subscribe_result(Types=['Dot1xBlockStatistics', 'Dot1xPortStatistics', 'Dot1xStatistics'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PPPoE协议会话达到CONNECTED状态\n\n    wait_dot1x_state(Sessions=[session_1, session_2], State='AUTHENTICATING')\n\n    time.sleep(5)\n\n    # 获取802.1x会话1统计\n    import pandas\n    result = get_dot1x_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dot1x_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_dot1x_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_dot1x_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dot1x_block_statistic(Session=session_1)\n    print(result)\n    result = get_dot1x_block_statistic(Session=session_2)\n    print(result)\n\n    result = get_dot1x_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dot1x_statistic(Session=session_1, Index=1)\n    print(result)\n    result = get_dot1x_statistic(Session=session_2, Index=1)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nedit_interface_stack:修改测试仪表接口的结构;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_dot1x:创建802.1x会话对象;\nget_dot1x_block_statistic:获取802.1x session block统计结果;\nget_dot1x_port_statistic:获取802.1x port block统计结果;\nget_dot1x_statistic:获取802.1x统计结果;\nwait_dot1x_state:等待802.1x会话达到指定状态;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/IGMP/IGMPv3.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查IGMP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建IGMP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IGMP协议会话\n\n    igmp = create_igmp(Port=Port_UP)\n\n    edit_igmp(Session=igmp, Version='IGMPV3')\n\n    # IGMP协议会话与接口绑定\n\n    select_interface(Session=igmp, Interface=interfaces_1)\n\n    # IGMP协议会话1创建Summary Lsa\n\n    multicast_group = create_multicast_group(Start='225.0.1.2')\n\n    # IGMP协议会话2创建External Lsa\n\n    memberships = create_memberships(Session=igmp,\n                                     DeviceGroupMapping='ROUNDROBIN',\n                                     UserDefinedSources=False)\n\n    # 获取IGMP协议绑定流端点对象\n\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    select_source_interface(Session=igmp, Memberships=memberships, Interface=interfaces_2)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=Port_Down, Version='IGMPV3')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_2)\n\n    # 创建IGMP绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待IGMP协议会话稳定状态\n\n    wait_igmp_state(Sessions=[igmp])\n    wait_igmp_querier_state(Sessions=[igmp_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取IGMP Host统计\n\n    result = get_igmp_host_statistic(Session=igmp)\n    print(result)\n\n    # 获取IGMP Port统计\n\n    result = get_igmp_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取IGMP Querier统计\n\n    result = get_igmp_querier_statistic(Session=igmp_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_igmp:创建IGMP协议会话对象",
      "create_igmp_querier:创建IGMP Querier协议会话对象",
      "edit_igmp:编辑IGMP协议会话对象",
      "edit_igmp_querier:编辑IGMP Querier协议会话对象",
      "get_igmp_host_statistic:获取Igmp协议会话统计结果",
      "get_igmp_port_statistic:获取Igmp Port统计结果",
      "get_igmp_querier_statistic:获取Igmp Querier协议会话统计结果",
      "select_source_interface:将协议会话组播组过滤源地址绑定到指定接口",
      "wait_igmp_querier_state:等待Igmp Querier协议会话达到指定状态",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表，指定测试平台类型\",\n  \"子任务2\": \"预约两个自环端口Port_UP和Port_Down\",\n  \"子任务3\": \"在Port_UP端口创建IPv4接口并配置地址192.168.1.2/网关192.168.1.3\",\n  \"子任务4\": \"在Port_Down端口创建IPv4接口并配置地址192.168.1.3/网关192.168.1.2\",\n  \"子任务5\": \"在Port_UP端口创建IGMP协议会话\",\n  \"子任务6\": \"配置IGMP协议版本为IGMPV3\",\n  \"子任务7\": \"将IGMP协议会话绑定到Port_UP端口的接口\",\n  \"子任务8\": \"创建全局组播组地址225.0.1.2\",\n  \"子任务9\": \"为IGMP会话创建成员关系，设置设备组映射为ROUNDROBIN\",\n  \"子任务10\": \"将组播组绑定到IGMP会话的成员关系\",\n  \"子任务11\": \"为成员关系指定源接口为Port_Down端口的接口\",\n  \"子任务12\": \"在Port_Down端口创建IGMP Querier协议会话\",\n  \"子任务13\": \"配置IGMP Querier的健壮性变量为3\",\n  \"子任务14\": \"将IGMP Querier协议会话绑定到Port_Down端口的接口\",\n  \"子任务15\": \"获取Port_Down端口接口的封装层对象\",\n  \"子任务16\": \"创建绑定类型流量流，源点为Port_Down接口层，目的点为组播组，非双向\",\n  \"子任务17\": \"订阅StreamBlockStats统计视图\",\n  \"子任务18\": \"保存当前测试配置到文件\",\n  \"子任务19\": \"启动所有协议会话\",\n  \"子任务20\": \"等待IGMP会话达到稳定状态\",\n  \"子任务21\": \"等待IGMP Querier会话达到稳定状态\",\n  \"子任务22\": \"开始发送所有流量流\",\n  \"子任务23\": \"持续发送流量60秒\",\n  \"子任务24\": \"停止所有流量发送\",\n  \"子任务25\": \"停止所有协议会话\",\n  \"子任务26\": \"获取流量流的StreamBlockStats统计信息\",\n  \"子任务27\": \"验证流量统计中TxStreamFrames等于RxStreamFrames\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查IGMP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建IGMP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IGMP协议会话\n\n    igmp = create_igmp(Port=Port_UP)\n\n    edit_igmp(Session=igmp, Version='IGMPV3')\n\n    # IGMP协议会话与接口绑定\n\n    select_interface(Session=igmp, Interface=interfaces_1)\n\n    # IGMP协议会话1创建Summary Lsa\n\n    multicast_group = create_multicast_group(Start='225.0.1.2')\n\n    # IGMP协议会话2创建External Lsa\n\n    memberships = create_memberships(Session=igmp,\n                                     DeviceGroupMapping='ROUNDROBIN',\n                                     UserDefinedSources=False)\n\n    # 获取IGMP协议绑定流端点对象\n\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    select_source_interface(Session=igmp, Memberships=memberships, Interface=interfaces_2)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=Port_Down, Version='IGMPV3')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_2)\n\n    # 创建IGMP绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待IGMP协议会话稳定状态\n\n    wait_igmp_state(Sessions=[igmp])\n    wait_igmp_querier_state(Sessions=[igmp_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取IGMP Host统计\n\n    result = get_igmp_host_statistic(Session=igmp)\n    print(result)\n\n    # 获取IGMP Port统计\n\n    result = get_igmp_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取IGMP Querier统计\n\n    result = get_igmp_querier_statistic(Session=igmp_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_igmp:创建IGMP协议会话对象;\ncreate_igmp_querier:创建IGMP Querier协议会话对象;\nedit_igmp:编辑IGMP协议会话对象;\nedit_igmp_querier:编辑IGMP Querier协议会话对象;\nget_igmp_host_statistic:获取Igmp协议会话统计结果;\nget_igmp_port_statistic:获取Igmp Port统计结果;\nget_igmp_querier_statistic:获取Igmp Querier协议会话统计结果;\nselect_source_interface:将协议会话组播组过滤源地址绑定到指定接口;\nwait_igmp_querier_state:等待Igmp Querier协议会话达到指定状态;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/IGMP/IGMPv2.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查IGMP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建IGMP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IGMP协议会话\n\n    igmp = create_igmp(Port=Port_UP)\n\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n\n    select_interface(Session=igmp, Interface=interfaces_1)\n\n    # 创建组播组\n\n    multicast_group = create_multicast_group(Start='225.0.1.2')\n\n    # IGMP协议会话创建组成员关系\n\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # 将组播组和IGMP组成员关系绑定\n\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=Port_Down, Version='IGMPV2')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_2)\n\n    # 创建IGMP绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待IGMP协议会话稳定状态\n\n    wait_igmp_state(Sessions=[igmp])\n    wait_igmp_querier_state(Sessions=[igmp_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取IGMP Host统计\n\n    result = get_igmp_host_statistic(Session=igmp)\n    print(result)\n\n    # 获取IGMP Port统计\n\n    result = get_igmp_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取IGMP Querier统计\n\n    result = get_igmp_querier_statistic(Session=igmp_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_igmp:创建IGMP协议会话对象",
      "create_igmp_querier:创建IGMP Querier协议会话对象",
      "edit_igmp:编辑IGMP协议会话对象",
      "edit_igmp_querier:编辑IGMP Querier协议会话对象",
      "get_igmp_host_statistic:获取Igmp协议会话统计结果",
      "get_igmp_port_statistic:获取Igmp Port统计结果",
      "get_igmp_querier_statistic:获取Igmp Querier协议会话统计结果",
      "wait_igmp_querier_state:等待Igmp Querier协议会话达到指定状态",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口，分别标识为Port_UP和Port_Down。\",\n  \"子任务3\": \"在Port_UP端口创建IPv4接口，配置IP地址为192.168.1.2，网关为192.168.1.3。\",\n  \"子任务4\": \"在Port_Down端口创建IPv4接口，配置IP地址为192.168.1.3，网关为192.168.1.2。\",\n  \"子任务5\": \"在Port_UP端口创建IGMP协议会话对象。\",\n  \"子任务6\": \"编辑IGMP会话参数，设置InitialJoin=True。\",\n  \"子任务7\": \"将IGMP会话绑定到Port_UP端口的IPv4接口。\",\n  \"子任务8\": \"创建全局组播组，起始地址为225.0.1.2。\",\n  \"子任务9\": \"创建IGMP组成员关系对象，采用轮询(ROUNDROBIN)映射策略。\",\n  \"子任务10\": \"将组播组绑定到IGMP会话的组成员关系。\",\n  \"子任务11\": \"在Port_Down端口创建IGMP Querier协议会话，版本为IGMPV2。\",\n  \"子任务12\": \"编辑IGMP Querier会话，设置RobustnessVariable=3。\",\n  \"子任务13\": \"将IGMP Querier会话绑定到Port_Down端口的IPv4接口。\",\n  \"子任务14\": \"获取Port_Down端口接口的封装层对象。\",\n  \"子任务15\": \"创建绑定流量：源为Port_Down封装层，目的为组播组，非双向模式。\",\n  \"子任务16\": \"订阅统计视图，包括StreamBlockStats流统计。\",\n  \"子任务17\": \"保存当前测试配置文件。\",\n  \"子任务18\": \"启动所有协议会话(IGMP和IGMP Querier)。\",\n  \"子任务19\": \"等待IGMP会话达到稳定状态。\",\n  \"子任务20\": \"等待IGMP Querier会话达到稳定状态。\",\n  \"子任务21\": \"等待5秒确保协议状态稳定。\",\n  \"子任务22\": \"开始发送绑定流量。\",\n  \"子任务23\": \"持续发送流量60秒。\",\n  \"子任务24\": \"停止所有流量发送。\",\n  \"子任务25\": \"停止所有协议会话。\",\n  \"子任务26\": \"等待3秒确保统计结果收集完成。\",\n  \"子任务27\": \"获取流模板块(StreamBlock)统计信息。\",\n  \"子任务28\": \"验证流统计中TxStreamFrames发送帧数等于RxStreamFrames接收帧数。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查IGMP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建IGMP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IGMP协议会话\n\n    igmp = create_igmp(Port=Port_UP)\n\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n\n    select_interface(Session=igmp, Interface=interfaces_1)\n\n    # 创建组播组\n\n    multicast_group = create_multicast_group(Start='225.0.1.2')\n\n    # IGMP协议会话创建组成员关系\n\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # 将组播组和IGMP组成员关系绑定\n\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=Port_Down, Version='IGMPV2')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_2)\n\n    # 创建IGMP绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待IGMP协议会话稳定状态\n\n    wait_igmp_state(Sessions=[igmp])\n    wait_igmp_querier_state(Sessions=[igmp_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取IGMP Host统计\n\n    result = get_igmp_host_statistic(Session=igmp)\n    print(result)\n\n    # 获取IGMP Port统计\n\n    result = get_igmp_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取IGMP Querier统计\n\n    result = get_igmp_querier_statistic(Session=igmp_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_igmp:创建IGMP协议会话对象;\ncreate_igmp_querier:创建IGMP Querier协议会话对象;\nedit_igmp:编辑IGMP协议会话对象;\nedit_igmp_querier:编辑IGMP Querier协议会话对象;\nget_igmp_host_statistic:获取Igmp协议会话统计结果;\nget_igmp_port_statistic:获取Igmp Port统计结果;\nget_igmp_querier_statistic:获取Igmp Querier协议会话统计结果;\nwait_igmp_querier_state:等待Igmp Querier协议会话达到指定状态;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Overall/smart_scripter_control_while_if_break.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 使用智能脚本控制命令while if elseif else break\n\n Step\t\t\t:\t测试步骤1: 创建端口;\n                   测试步骤2: 创建bgp会话及路由;\n                   测试步骤3: 启动协议发送流量;\n                   测试步骤4: 检查统计;\n\n Criteria    \t:   预期结果1: 步骤4 判断端口发送报文数量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.192/1/1', '//10.0.11.192/1/2', '//10.0.11.192/1/3'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'BigTao' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_3 = reserve_port(Locations=locations[:3])\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_1, Layers='ipv4')\n    interfaces_2 = create_interface(Port=port_2, Layers='ipv4')\n    interfaces_3 = create_interface(Port=port_3, Layers='ipv4')\n\n    # 创建BGP协议会话\n    session_1 = create_bgp(Port=port_1)\n    session_2 = create_bgp(Port=port_2)\n    session_3 = create_bgp(Port=port_3)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n    select_interface(Session=session_3, Interface=interfaces_3)\n\n    # BGP协议会话1创建ipv4 route pool\n    ipv4_route_1 = create_bgp_ipv4_route_pool(Session=session_1, FirstRoute='1.0.0.1')\n    ipv4_route_2 = create_bgp_ipv4_route_pool(Session=session_2, FirstRoute='2.0.0.1')\n    ipv4_route_3 = create_bgp_ipv4_route_pool(Session=session_3, FirstRoute='3.0.0.1')\n\n    # 创建raw stream\n    stream_1 = add_stream(Ports=port_1)\n    stream_2 = add_stream(Ports=port_2)\n    stream_3 = add_stream(Ports=port_3)\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats'])\n\n    # 使用智能脚本的while if elseif else break命令\n    ggroup = smart_scripter_global_group()\n\n    whilecommand = smart_scripter_command(ParentGroup=ggroup,\n                                          Command='WhileCommand')\n    bgp_handles = get_object_attrs([session_1, session_2, session_3])\n    whilecontrol = smart_scripter_control_condition(ControlCommand=whilecommand,\n                                                    ControlConditionName='StartProtocolCommand',\n                                                    ConditionResult='PASS',\n                                                    ProtocolList=bgp_handles)\n\n    ifcommand = smart_scripter_command(ParentGroup=whilecommand,\n                                       Command='IfCommand')\n    stream_handle_1 = get_object_attrs(stream_1)\n    startstreamcommand_1 = smart_scripter_command(ParentGroup=ifcommand,\n                                                  Command='StartStreamCommand',\n                                                  StreamList=stream_handle_1)\n\n    bgp_route_1 = get_object_attrs(ipv4_route_1)\n    ifcontrol = smart_scripter_control_condition(ControlCommand=ifcommand,\n                                                 ControlConditionName='AdvertiseBgpRouteBlockCommand',\n                                                 ConditionResult='PASS',\n                                                 BgpRouteBlockHandles=bgp_route_1)\n    breakcommand = smart_scripter_command(ParentGroup=ifcommand,\n                                          Command='BreakCommand')\n\n    elseifcommand = smart_scripter_command(ParentGroup=whilecommand,\n                                           Command='ElseIfCommand')\n    stream_handle_2 = get_object_attrs(stream_2)\n    startstreamcommand_2 = smart_scripter_command(ParentGroup=elseifcommand,\n                                                  Command='StartStreamCommand',\n                                                  StreamList=stream_handle_2)\n    bgp_route_2 = get_object_attrs(ipv4_route_2)\n    elseifcontrol = smart_scripter_control_condition(ControlCommand=elseifcommand,\n                                                     ControlConditionName='AdvertiseBgpRouteBlockCommand',\n                                                     ConditionResult='PASS',\n                                                     BgpRouteBlockHandles=bgp_route_2)\n\n    elsecommand = smart_scripter_command(ParentGroup=whilecommand,\n                                         Command='ElseCommand')\n    stream_handle_3 = get_object_attrs(stream_3)\n    startstreamcommand_3 = smart_scripter_command(ParentGroup=elsecommand,\n                                                  Command='StartStreamCommand',\n                                                  StreamList=stream_handle_3)\n\n    run_benchmark()\n    # 获取统计\n    time.sleep(5)\n    result = get_port_statistic()\n    print(result)\n    assert result['TxStreamFrames'][0] > 0\n    stop_stream()\n    clear_result()\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "create_bgp:创建BGP协议会话对象",
      "create_bgp_ipv4_route_pool:创建BGP IPv4路由对象",
      "select_interface:协议绑定测试仪表接口",
      "clear_result:清除测试仪表统计",
      "get_port_statistic:获取测试仪表端口统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "stop_stream:测试仪表停止发送数据流",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为BigTao。\",\n  \"子任务2\": \"预约三个测试仪表端口并获取端口对象。\",\n  \"子任务3\": \"在每个端口上创建IPv4接口层。\",\n  \"子任务4\": \"在每个端口上创建BGP协议会话对象。\",\n  \"子任务5\": \"将BGP会话绑定到对应端口的IPv4接口。\",\n  \"子任务6\": \"为每个BGP会话创建IPv4路由池，分别设置不同起始路由地址。\",\n  \"子任务7\": \"在每个端口上创建原始流量流对象。\",\n  \"子任务8\": \"订阅端口统计视图以收集测试数据。\",\n  \"子任务9\": \"构建智能脚本控制结构：创建全局命令组。\",\n  \"子任务10\": \"在全局组下添加While循环命令，循环条件为BGP会话的StartProtocolCommand操作结果为PASS。\",\n  \"子任务11\": \"在While循环内添加If条件分支：当第一个BGP路由池的AdvertiseBgpRouteBlockCommand结果为PASS时，启动端口1的流量流并执行Break跳出循环。\",\n  \"子任务12\": \"在While循环内添加ElseIf条件分支：当第二个BGP路由池的AdvertiseBgpRouteBlockCommand结果为PASS时，启动端口2的流量流。\",\n  \"子任务13\": \"在While循环内添加Else分支：当以上条件均不满足时，启动端口3的流量流。\",\n  \"子任务14\": \"执行测试套件运行智能脚本控制逻辑。\",\n  \"子任务15\": \"等待5秒确保流量统计稳定。\",\n  \"子任务16\": \"获取端口统计结果数据。\",\n  \"子任务17\": \"验证端口1的发送报文数量(TxStreamFrames)大于0。\",\n  \"子任务18\": \"停止所有端口的流量发送。\",\n  \"子任务19\": \"清除测试仪表的统计结果数据。\",\n  \"子任务20\": \"保存当前测试配置文件到指定路径。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 使用智能脚本控制命令while if elseif else break\n\n Step\t\t\t:\t测试步骤1: 创建端口;\n                   测试步骤2: 创建bgp会话及路由;\n                   测试步骤3: 启动协议发送流量;\n                   测试步骤4: 检查统计;\n\n Criteria    \t:   预期结果1: 步骤4 判断端口发送报文数量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.192/1/1', '//10.0.11.192/1/2', '//10.0.11.192/1/3'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'BigTao' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_3 = reserve_port(Locations=locations[:3])\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_1, Layers='ipv4')\n    interfaces_2 = create_interface(Port=port_2, Layers='ipv4')\n    interfaces_3 = create_interface(Port=port_3, Layers='ipv4')\n\n    # 创建BGP协议会话\n    session_1 = create_bgp(Port=port_1)\n    session_2 = create_bgp(Port=port_2)\n    session_3 = create_bgp(Port=port_3)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n    select_interface(Session=session_3, Interface=interfaces_3)\n\n    # BGP协议会话1创建ipv4 route pool\n    ipv4_route_1 = create_bgp_ipv4_route_pool(Session=session_1, FirstRoute='1.0.0.1')\n    ipv4_route_2 = create_bgp_ipv4_route_pool(Session=session_2, FirstRoute='2.0.0.1')\n    ipv4_route_3 = create_bgp_ipv4_route_pool(Session=session_3, FirstRoute='3.0.0.1')\n\n    # 创建raw stream\n    stream_1 = add_stream(Ports=port_1)\n    stream_2 = add_stream(Ports=port_2)\n    stream_3 = add_stream(Ports=port_3)\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats'])\n\n    # 使用智能脚本的while if elseif else break命令\n    ggroup = smart_scripter_global_group()\n\n    whilecommand = smart_scripter_command(ParentGroup=ggroup,\n                                          Command='WhileCommand')\n    bgp_handles = get_object_attrs([session_1, session_2, session_3])\n    whilecontrol = smart_scripter_control_condition(ControlCommand=whilecommand,\n                                                    ControlConditionName='StartProtocolCommand',\n                                                    ConditionResult='PASS',\n                                                    ProtocolList=bgp_handles)\n\n    ifcommand = smart_scripter_command(ParentGroup=whilecommand,\n                                       Command='IfCommand')\n    stream_handle_1 = get_object_attrs(stream_1)\n    startstreamcommand_1 = smart_scripter_command(ParentGroup=ifcommand,\n                                                  Command='StartStreamCommand',\n                                                  StreamList=stream_handle_1)\n\n    bgp_route_1 = get_object_attrs(ipv4_route_1)\n    ifcontrol = smart_scripter_control_condition(ControlCommand=ifcommand,\n                                                 ControlConditionName='AdvertiseBgpRouteBlockCommand',\n                                                 ConditionResult='PASS',\n                                                 BgpRouteBlockHandles=bgp_route_1)\n    breakcommand = smart_scripter_command(ParentGroup=ifcommand,\n                                          Command='BreakCommand')\n\n    elseifcommand = smart_scripter_command(ParentGroup=whilecommand,\n                                           Command='ElseIfCommand')\n    stream_handle_2 = get_object_attrs(stream_2)\n    startstreamcommand_2 = smart_scripter_command(ParentGroup=elseifcommand,\n                                                  Command='StartStreamCommand',\n                                                  StreamList=stream_handle_2)\n    bgp_route_2 = get_object_attrs(ipv4_route_2)\n    elseifcontrol = smart_scripter_control_condition(ControlCommand=elseifcommand,\n                                                     ControlConditionName='AdvertiseBgpRouteBlockCommand',\n                                                     ConditionResult='PASS',\n                                                     BgpRouteBlockHandles=bgp_route_2)\n\n    elsecommand = smart_scripter_command(ParentGroup=whilecommand,\n                                         Command='ElseCommand')\n    stream_handle_3 = get_object_attrs(stream_3)\n    startstreamcommand_3 = smart_scripter_command(ParentGroup=elsecommand,\n                                                  Command='StartStreamCommand',\n                                                  StreamList=stream_handle_3)\n\n    run_benchmark()\n    # 获取统计\n    time.sleep(5)\n    result = get_port_statistic()\n    print(result)\n    assert result['TxStreamFrames'][0] > 0\n    stop_stream()\n    clear_result()\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\ncreate_bgp:创建BGP协议会话对象;\ncreate_bgp_ipv4_route_pool:创建BGP IPv4路由对象;\nselect_interface:协议绑定测试仪表接口;\nclear_result:清除测试仪表统计;\nget_port_statistic:获取测试仪表端口统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstop_stream:测试仪表停止发送数据流;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/add_stream_from_pcap.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamBlockStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamBlockStats统计;\n                   测试步骤4: 发送所有流量，查看StreamBlockStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 设置端口发送模式为突发包\n    BurstCount = 3\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包\n    start_capture()\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    stop_stream()\n    # 停止抓包\n    stop_capture()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    result = get_streamblock_statistic()\n    print(result)\n\n    # 下载报文\n    result = download_packages(Port=Port_Down, FileDir=f'{dirname}/xcfg', FileName=f'{filename}.pcap')\n\n    # 导入PCAP流量\n    stream_pcap = add_stream(Ports=Port_Down, Type='pcap', FilePath=result)\n\n    # 修改EthernetII头部\n    attribute_dict = edit_header_ethernet(Stream=stream_pcap[0], Level=0, DestMacAdd='00:00:00:00:00:01',\n                                          SourceMacAdd='00:00:00:00:00:02')\n    print(attribute_dict)\n\n    # EthernetII头部目的Mac地址字段添加跳变\n    edit_modifier(Stream=stream_pcap[0], Level=0, HeaderType='ethernetii', Attribute=attribute_dict['DestMacAdd'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 保存配置文件\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n\n\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，强制占用端口资源。\",\n  \"子任务3\": \"在Port_1端口创建流量StreamTemplate_1。\",\n  \"子任务4\": \"在Port_1端口创建流量StreamTemplate_2。\",\n  \"子任务5\": \"在Port_2端口创建流量StreamTemplate_3。\",\n  \"子任务6\": \"在Port_2端口创建流量StreamTemplate_4。\",\n  \"子任务7\": \"订阅StreamBlockStats统计视图类型。\",\n  \"子任务8\": \"启动所有流量发送。\",\n  \"子任务9\": \"等待10秒获取稳定的发送中统计信息。\",\n  \"子任务10\": \"获取发送中的StreamBlockStats统计结果。\",\n  \"子任务11\": \"停止所有流量发送。\",\n  \"子任务12\": \"等待3秒获取稳定的停止后统计信息。\",\n  \"子任务13\": \"获取停止后的StreamBlockStats统计结果。\",\n  \"子任务14\": \"校验两次获取的StreamBlockStats统计信息是否符合预期正确性。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamBlockStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamBlockStats统计;\n                   测试步骤4: 发送所有流量，查看StreamBlockStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 设置端口发送模式为突发包\n    BurstCount = 3\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包\n    start_capture()\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    stop_stream()\n    # 停止抓包\n    stop_capture()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    result = get_streamblock_statistic()\n    print(result)\n\n    # 下载报文\n    result = download_packages(Port=Port_Down, FileDir=f'{dirname}/xcfg', FileName=f'{filename}.pcap')\n\n    # 导入PCAP流量\n    stream_pcap = add_stream(Ports=Port_Down, Type='pcap', FilePath=result)\n\n    # 修改EthernetII头部\n    attribute_dict = edit_header_ethernet(Stream=stream_pcap[0], Level=0, DestMacAdd='00:00:00:00:00:01',\n                                          SourceMacAdd='00:00:00:00:00:02')\n    print(attribute_dict)\n\n    # EthernetII头部目的Mac地址字段添加跳变\n    edit_modifier(Stream=stream_pcap[0], Level=0, HeaderType='ethernetii', Attribute=attribute_dict['DestMacAdd'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 保存配置文件\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n\n\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Overall/RTSM/use_rtsm.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查RTSM服务器启动CL测试发流StreamBlockStats统计正确\n\n Step\t\t\t:\t测试步骤1: 连接RTSM服务器，启动CL，断开RTSM连接并连接刚启动的CL;\n                   测试步骤2: 预约两个自环端口Port_1、Port_2;\n                   测试步骤3: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤4: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤5: 订阅StreamBlockStats统计;\n                   测试步骤6: 发送所有流量，查看StreamBlockStats统计信息，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n                   测试步骤8: 连接RTSM服务器，关闭CL，断开RTSM连接;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import signal\n\nfrom TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DARYU' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # host = locations[0].split('/')[2]\n    host = '127.0.0.1'\n    print(f'CL host:{host}')\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Rtsm=host)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockStats所有统计结果:\n    # get_streamblock_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    release_port(Ports=[Port_UP, Port_Down])\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    # 关闭仪表测试进程\n    shutdown_tester()\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，连接RTSM服务器并启动CL\",\n  \"子任务2\": \"预约两个自环测试端口(Port_1和Port_2)\",\n  \"子任务3\": \"在Port_1端口创建两条流量模板(StreamTemplate_1和StreamTemplate_2)\",\n  \"子任务4\": \"在Port_2端口创建两条流量模板(StreamTemplate_3和StreamTemplate_4)\",\n  \"子任务5\": \"订阅流模板块统计视图(StreamBlockStats)\",\n  \"子任务6\": \"保存当前测试配置文件\",\n  \"子任务7\": \"启动所有流量发送\",\n  \"子任务8\": \"等待10秒确保统计信息稳定\",\n  \"子任务9\": \"获取所有流模板块统计信息，验证第一条流的发送/接收帧速率均不为零\",\n  \"子任务10\": \"停止所有流量发送\",\n  \"子任务11\": \"等待3秒确保统计信息稳定\",\n  \"子任务12\": \"获取指定流的统计信息(包含TxStreamFrames/RxStreamFrames等关键指标)\",\n  \"子任务13\": \"释放所有已预约的测试端口\",\n  \"子任务14\": \"关闭测试仪表并断开连接\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查RTSM服务器启动CL测试发流StreamBlockStats统计正确\n\n Step\t\t\t:\t测试步骤1: 连接RTSM服务器，启动CL，断开RTSM连接并连接刚启动的CL;\n                   测试步骤2: 预约两个自环端口Port_1、Port_2;\n                   测试步骤3: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤4: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤5: 订阅StreamBlockStats统计;\n                   测试步骤6: 发送所有流量，查看StreamBlockStats统计信息，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n                   测试步骤8: 连接RTSM服务器，关闭CL，断开RTSM连接;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import signal\n\nfrom TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DARYU' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # host = locations[0].split('/')[2]\n    host = '127.0.0.1'\n    print(f'CL host:{host}')\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Rtsm=host)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockStats所有统计结果:\n    # get_streamblock_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    release_port(Ports=[Port_UP, Port_Down])\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    # 关闭仪表测试进程\n    shutdown_tester()\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Overall/RTSM/not_use_rtsm.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查连接远端CL测试发流StreamBlockStats统计正确\n\n Step\t\t\t:\t测试步骤1: 连接远端CL;\n                   测试步骤2: 预约两个自环端口Port_1、Port_2;\n                   测试步骤3: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤4: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤5: 订阅StreamBlockStats统计;\n                   测试步骤6: 发送所有流量，查看StreamBlockStats统计信息，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n                   测试步骤8: 断开远端CL;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DARYU' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    host = locations[0].split('/')[2]\n    print(f'CL host:{host}')\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, CL=host)\n    reset_tester()\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockStats所有统计结果:\n    # get_streamblock_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    release_port(Ports=[Port_UP, Port_Down])\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    reset_tester()\n    # 断开仪表测试进程\n    shutdown_tester()\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "reset_tester:清空测试仪表所有配置",
      "save_case:测试仪表保存配置文件",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"连接远端CL测试仪表，初始化测试环境。\",\n  \"子任务2\": \"预约两个自环测试端口，分别命名为Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1端口创建两条流量模板（StreamTemplate_1和StreamTemplate_2）。\",\n  \"子任务4\": \"在Port_2端口创建两条流量模板（StreamTemplate_3和StreamTemplate_4）。\",\n  \"子任务5\": \"订阅StreamBlockStats统计视图以监控流量数据。\",\n  \"子任务6\": \"启动所有流量模板的数据发送。\",\n  \"子任务7\": \"等待10秒确保流量统计稳定后，获取StreamBlockStats统计信息。\",\n  \"子任务8\": \"验证发送过程中StreamTemplate_1的TxFrameRate和RxFrameRate均不为0。\",\n  \"子任务9\": \"停止所有流量发送。\",\n  \"子任务10\": \"等待3秒确保停止后的统计稳定，再次获取StreamBlockStats统计信息。\",\n  \"子任务11\": \"验证停止后StreamBlockStats统计信息符合预期（如速率归零）。\",\n  \"子任务12\": \"释放所有预约端口（Port_1和Port_2）。\",\n  \"子任务13\": \"断开与远端CL测试仪表的连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查连接远端CL测试发流StreamBlockStats统计正确\n\n Step\t\t\t:\t测试步骤1: 连接远端CL;\n                   测试步骤2: 预约两个自环端口Port_1、Port_2;\n                   测试步骤3: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤4: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤5: 订阅StreamBlockStats统计;\n                   测试步骤6: 发送所有流量，查看StreamBlockStats统计信息，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n                   测试步骤8: 断开远端CL;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DARYU' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    host = locations[0].split('/')[2]\n    print(f'CL host:{host}')\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, CL=host)\n    reset_tester()\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockStats所有统计结果:\n    # get_streamblock_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    release_port(Ports=[Port_UP, Port_Down])\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    reset_tester()\n    # 断开仪表测试进程\n    shutdown_tester()\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nreset_tester:清空测试仪表所有配置;\nsave_case:测试仪表保存配置文件;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Overall/smart_scripter.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 使用智能脚本创建bgp协议并通告路由\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建bgp会话及路由;\n                   测试步骤3: 启动协议通告路由;\n                   测试步骤4: 检查统计;\n\n Criteria    \t:   预期结果1: 步骤4 获取通告路由数量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2])\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='ipv4')\n    interfaces_2 = create_interface(Port=Port_2, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建BGP协议会话\n    session_1 = create_bgp(Port=Port_1)\n    session_2 = create_bgp(Port=Port_2)\n\n    edit_bgp(Session=session_1, AsNumber=100, DutAsNumber=200)\n    edit_bgp(Session=session_2, AsNumber=200, DutAsNumber=100)\n\n    # BGP协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # BGP协议会话1创建ipv4 route pool\n    ipv4_route_1 = create_bgp_ipv4_route_pool(Session=session_1, FirstRoute='100.0.0.1')\n    ipv4_route_2 = create_bgp_ipv4_route_pool(Session=session_2, FirstRoute='200.0.0.1')\n\n    # 订阅统计\n    subscribe_result(Types=['BgpSessionBlockStatistic'])\n\n    # 使用智能脚本启动协议\n    ggroup = smart_scripter_global_group()\n    group = smart_scripter_command(ggroup, 'GroupCommand', 'start')\n#    start = smart_scripter_command(group, 'StartProtocolCommand', ProtocolList=[session_1.handle, session_2.handle])\n    bgp = get_object_attrs([session_1, session_2])\n    start = smart_scripter_command(group, 'StartProtocolCommand', ProtocolList=bgp)\n    run_benchmark()\n    #StartSmartScripterCommand().execute()\n    wait_bgp_state(Sessions=[session_1, session_2])\n    # 获取统计\n    result = get_bgp_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_bgp_session_block_statistic(Session=session_2)\n    print(result)\n\n    # 使用智能脚本停止协议\n    group = smart_scripter_command(ggroup, 'GroupCommand', 'stop')\n    stop = smart_scripter_command(group, 'StopProtocolCommand', ProtocolList=[session_1.handle, session_2.handle])\n    run_benchmark()\n    #StartSmartScripterCommand().execute()\n    wait_bgp_state(Sessions=[session_1, session_2], State=['NOT_START'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "create_bgp:创建BGP协议会话对象",
      "create_bgp_ipv4_route_pool:创建BGP IPv4路由对象",
      "edit_bgp:编辑Bgp协议会话对象参数",
      "get_bgp_session_block_statistic:获取Bgp Session Block统计结果",
      "wait_bgp_state:等待BGP协议会话达到指定状态",
      "select_interface:协议绑定测试仪表接口",
      "subscribe_result:订阅测试仪表统计视图",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个测试仪表端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建IPv4接口并配置地址192.168.1.2，网关192.168.1.3。\",\n  \"子任务4\": \"在Port_2上创建IPv4接口并配置地址192.168.1.3，网关192.168.1.2。\",\n  \"子任务5\": \"在Port_1上创建BGP会话对象，设置AS号为100，DUT AS号为200。\",\n  \"子任务6\": \"在Port_2上创建BGP会话对象，设置AS号为200，DUT AS号为100。\",\n  \"子任务7\": \"将Port_1的BGP会话绑定到Port_1的IPv4接口。\",\n  \"子任务8\": \"将Port_2的BGP会话绑定到Port_2的IPv4接口。\",\n  \"子任务9\": \"为Port_1的BGP会话创建IPv4路由池，设置首路由为100.0.0.1。\",\n  \"子任务10\": \"为Port_2的BGP会话创建IPv4路由池，设置首路由为200.0.0.1。\",\n  \"子任务11\": \"订阅BGP会话块统计视图。\",\n  \"子任务12\": \"使用智能脚本启动所有BGP协议会话。\",\n  \"子任务13\": \"等待所有BGP会话达到稳定运行状态。\",\n  \"子任务14\": \"获取Port_1的BGP会话块统计信息，检查通告路由数量。\",\n  \"子任务15\": \"获取Port_2的BGP会话块统计信息，检查通告路由数量。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 使用智能脚本创建bgp协议并通告路由\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建bgp会话及路由;\n                   测试步骤3: 启动协议通告路由;\n                   测试步骤4: 检查统计;\n\n Criteria    \t:   预期结果1: 步骤4 获取通告路由数量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2])\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='ipv4')\n    interfaces_2 = create_interface(Port=Port_2, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建BGP协议会话\n    session_1 = create_bgp(Port=Port_1)\n    session_2 = create_bgp(Port=Port_2)\n\n    edit_bgp(Session=session_1, AsNumber=100, DutAsNumber=200)\n    edit_bgp(Session=session_2, AsNumber=200, DutAsNumber=100)\n\n    # BGP协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # BGP协议会话1创建ipv4 route pool\n    ipv4_route_1 = create_bgp_ipv4_route_pool(Session=session_1, FirstRoute='100.0.0.1')\n    ipv4_route_2 = create_bgp_ipv4_route_pool(Session=session_2, FirstRoute='200.0.0.1')\n\n    # 订阅统计\n    subscribe_result(Types=['BgpSessionBlockStatistic'])\n\n    # 使用智能脚本启动协议\n    ggroup = smart_scripter_global_group()\n    group = smart_scripter_command(ggroup, 'GroupCommand', 'start')\n#    start = smart_scripter_command(group, 'StartProtocolCommand', ProtocolList=[session_1.handle, session_2.handle])\n    bgp = get_object_attrs([session_1, session_2])\n    start = smart_scripter_command(group, 'StartProtocolCommand', ProtocolList=bgp)\n    run_benchmark()\n    #StartSmartScripterCommand().execute()\n    wait_bgp_state(Sessions=[session_1, session_2])\n    # 获取统计\n    result = get_bgp_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_bgp_session_block_statistic(Session=session_2)\n    print(result)\n\n    # 使用智能脚本停止协议\n    group = smart_scripter_command(ggroup, 'GroupCommand', 'stop')\n    stop = smart_scripter_command(group, 'StopProtocolCommand', ProtocolList=[session_1.handle, session_2.handle])\n    run_benchmark()\n    #StartSmartScripterCommand().execute()\n    wait_bgp_state(Sessions=[session_1, session_2], State=['NOT_START'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\ncreate_bgp:创建BGP协议会话对象;\ncreate_bgp_ipv4_route_pool:创建BGP IPv4路由对象;\nedit_bgp:编辑Bgp协议会话对象参数;\nget_bgp_session_block_statistic:获取Bgp Session Block统计结果;\nwait_bgp_state:等待BGP协议会话达到指定状态;\nselect_interface:协议绑定测试仪表接口;\nsubscribe_result:订阅测试仪表统计视图;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/Y1731/y1731.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查y.1731协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建y1731协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.3')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.3', Gateway='1.1.1.2')\n\n    # 创建协议会话\n\n    session_1 = create_y1731(Port=Port_UP)\n    session_2 = create_y1731(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    mp_1 = create_y1731_mp(Sessions=session_1)\n    mp_2 = create_y1731_mp(Sessions=session_2)\n\n    meg = create_y1731_meg()\n\n    edit_y1731_mp(mp_1, Meg=meg)\n    edit_y1731_mp(mp_2, Meg=meg)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Y1731MegStats', 'Y1731MpStats', 'Y1731PortStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待协议会话达到状态\n\n    wait_y1731_state(Sessions=[session_1, session_2])\n\n    time.sleep(1)\n\n    # 获取统计\n    import pandas\n    result = get_y1731_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_y1731_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_y1731_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_y1731_meg_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_y1731_meg_statistic(Meg=meg, Port=Port_UP)\n    print(result)\n    result = get_y1731_meg_statistic(Meg=meg, Port=Port_Down)\n    print(result)\n\n    result = get_y1731_mp_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_y1731_mp_statistic(Mp=mp_1)\n    print(result)\n    result = get_y1731_mp_statistic(Mp=mp_2)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务3\": \"在 Port_1 上创建网络接口并配置 IPv4 地址与网关。\",\n  \"子任务4\": \"在 Port_2 上创建网络接口并配置 IPv4 地址与网关。\",\n  \"子任务5\": \"在 Port_1 上创建 Y.1731 协议会话。\",\n  \"子任务6\": \"在 Port_2 上创建 Y.1731 协议会话。\",\n  \"子任务7\": \"将 Y.1731 会话分别绑定到对应端口的网络接口。\",\n  \"子任务8\": \"创建 Y.1731 维护点(MP)并关联到维护组(MEG)。\",\n  \"子任务9\": \"订阅 Y.1731 协议统计视图（端口统计/MEG统计/MP统计）。\",\n  \"子任务10\": \"保存当前测试配置到文件。\",\n  \"子任务11\": \"启动 Y.1731 协议会话。\",\n  \"子任务12\": \"等待协议会话达到稳定运行状态。\",\n  \"子任务13\": \"获取 Port_1 和 Port_2 的 Y.1731 端口级统计信息。\",\n  \"子任务14\": \"获取 MEG 维护组级统计信息。\",\n  \"子任务15\": \"获取 MP 维护点级统计信息。\",\n  \"子任务16\": \"验证所有统计信息数据结构正确且不为空。\",\n  \"子任务17\": \"停止 Y.1731 协议会话。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查y.1731协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建y1731协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.3')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.3', Gateway='1.1.1.2')\n\n    # 创建协议会话\n\n    session_1 = create_y1731(Port=Port_UP)\n    session_2 = create_y1731(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    mp_1 = create_y1731_mp(Sessions=session_1)\n    mp_2 = create_y1731_mp(Sessions=session_2)\n\n    meg = create_y1731_meg()\n\n    edit_y1731_mp(mp_1, Meg=meg)\n    edit_y1731_mp(mp_2, Meg=meg)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Y1731MegStats', 'Y1731MpStats', 'Y1731PortStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待协议会话达到状态\n\n    wait_y1731_state(Sessions=[session_1, session_2])\n\n    time.sleep(1)\n\n    # 获取统计\n    import pandas\n    result = get_y1731_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_y1731_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_y1731_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_y1731_meg_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_y1731_meg_statistic(Meg=meg, Port=Port_UP)\n    print(result)\n    result = get_y1731_meg_statistic(Meg=meg, Port=Port_Down)\n    print(result)\n\n    result = get_y1731_mp_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_y1731_mp_statistic(Mp=mp_1)\n    print(result)\n    result = get_y1731_mp_statistic(Mp=mp_2)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStreamBlockRxStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamBlockRxStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamBlockRxStats统计;\n                   测试步骤4: 发送所有流量，查看StreamBlockRxStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamBlockRxStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockRxStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockRxStats统计视图\n    subscribe_result(Types=['StreamBlockRxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockRxStats所有统计结果:\n    # get_streamblock_rx_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1收端口为Port_Down的RxFrameRate和RxByteRate\n    df = result[(result['StreamBlockID'] == streams[0].Name) & (result['PortID'] == Port_Down.handle)][['RxFrameRate', 'RxByteRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['RxFrameRate'] == 0 or data['RxByteRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} RxFrameRate or RxByteRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量和端口的统计:\n    # get_streamblock_rx_statistic传Stream和Port参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_rx_statistic(Stream=streams[-1], Port=Port_UP)\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计:\n    # get_streamblock_rx_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式4 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_rx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[:1], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计:\n    # get_streamblock_rx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_rx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[:3], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_rx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_rx_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，强制占用物理位置。\",\n  \"子任务3\": \"在Port_1创建两条流量StreamTemplate_1和StreamTemplate_2，在Port_2创建两条流量StreamTemplate_3和StreamTemplate_4。\",\n  \"子任务4\": \"订阅StreamBlockRxStats统计视图用于结果采集。\",\n  \"子任务5\": \"保存当前测试配置到指定路径的配置文件。\",\n  \"子任务6\": \"启动所有流量发送并等待10秒使统计稳定。\",\n  \"子任务7\": \"获取StreamBlockRxStats所有统计结果，验证StreamTemplate_1在Port_2的RxFrameRate和RxByteRate均不为0。\",\n  \"子任务8\": \"停止所有流量发送并等待3秒使最终统计稳定。\",\n  \"子任务9\": \"通过多种参数组合获取StreamBlockRxStats统计信息（包括单流单端口/多流多端口/指定统计项等场景），验证统计结果完整性。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamBlockRxStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamBlockRxStats统计;\n                   测试步骤4: 发送所有流量，查看StreamBlockRxStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamBlockRxStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockRxStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockRxStats统计视图\n    subscribe_result(Types=['StreamBlockRxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockRxStats所有统计结果:\n    # get_streamblock_rx_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1收端口为Port_Down的RxFrameRate和RxByteRate\n    df = result[(result['StreamBlockID'] == streams[0].Name) & (result['PortID'] == Port_Down.handle)][['RxFrameRate', 'RxByteRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['RxFrameRate'] == 0 or data['RxByteRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} RxFrameRate or RxByteRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量和端口的统计:\n    # get_streamblock_rx_statistic传Stream和Port参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_rx_statistic(Stream=streams[-1], Port=Port_UP)\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计:\n    # get_streamblock_rx_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式4 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_rx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[:1], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计:\n    # get_streamblock_rx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_rx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[:3], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_rx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_streamblock_rx_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStreamBlockTxStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamBlockTxStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamBlockTxStats统计;\n                   测试步骤4: 发送所有流量，查看StreamBlockTxStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamBlockTxStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockTxStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockTxStats统计视图\n    subscribe_result(Types=['StreamBlockTxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockTxStats所有统计结果:\n    # get_streamblock_tx_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_tx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'TxBitRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['TxBitRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or TxBitRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_tx_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_tx_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量和端口的统计:\n    # get_streamblock_tx_statistic传Stream和Port参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_tx_statistic(Stream=streams[-1], Port=Port_Down)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_tx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_tx_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print(result)\n\n    # 统计获取方式5 -- 获取指定多条流量的统计:\n    # get_streamblock_tx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_tx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_tx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_tx_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_tx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_tx_statistic(StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_tx_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，强制占用指定位置\",\n  \"子任务3\": \"在Port_1和Port_2端口上各创建两条流量，共生成四条流量模板StreamTemplate_1-4\",\n  \"子任务4\": \"订阅StreamBlockTxStats统计视图\",\n  \"子任务5\": \"保存当前测试配置到文件系统\",\n  \"子任务6\": \"启动所有流量发送\",\n  \"子任务7\": \"等待10秒使流量统计稳定\",\n  \"子任务8\": \"获取StreamBlockTxStats所有统计结果并验证数据格式\",\n  \"子任务9\": \"检查各流量模板的TxFrameRate和TxBitRate是否非零\",\n  \"子任务10\": \"停止所有流量发送\",\n  \"子任务11\": \"等待3秒使停止后统计稳定\",\n  \"子任务12\": \"再次获取StreamBlockTxStats统计结果\",\n  \"子任务13\": \"验证发送中和停止后的统计信息获取正确性\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamBlockTxStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamBlockTxStats统计;\n                   测试步骤4: 发送所有流量，查看StreamBlockTxStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamBlockTxStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockTxStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockTxStats统计视图\n    subscribe_result(Types=['StreamBlockTxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockTxStats所有统计结果:\n    # get_streamblock_tx_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_tx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'TxBitRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['TxBitRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or TxBitRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_tx_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_tx_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量和端口的统计:\n    # get_streamblock_tx_statistic传Stream和Port参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_tx_statistic(Stream=streams[-1], Port=Port_Down)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_tx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_tx_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print(result)\n\n    # 统计获取方式5 -- 获取指定多条流量的统计:\n    # get_streamblock_tx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_tx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_tx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_tx_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_tx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_tx_statistic(StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_streamblock_tx_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStreamBlockStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamBlockStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamBlockStats统计;\n                   测试步骤4: 发送所有流量，查看StreamBlockStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockStats所有统计结果:\n    # get_streamblock_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，强制占用端口资源。\",\n  \"子任务3\": \"在Port_1创建两条流量模板StreamTemplate_1和StreamTemplate_2，在Port_2创建两条流量模板StreamTemplate_3和StreamTemplate_4。\",\n  \"子任务4\": \"订阅StreamBlockStats统计视图以监控流量统计信息。\",\n  \"子任务5\": \"开始发送所有流量模板的数据流。\",\n  \"子任务6\": \"等待10秒确保获取稳定的StreamBlockStats统计数据。\",\n  \"子任务7\": \"获取所有流量模板的StreamBlockStats统计信息，包括TxFrameRate和RxFrameRate等关键指标。\",\n  \"子任务8\": \"验证第一条流量(StreamTemplate_1)的TxFrameRate和RxFrameRate均不为0。\",\n  \"子任务9\": \"停止所有流量模板的数据流发送。\",\n  \"子任务10\": \"等待3秒确保获取停止后的稳定StreamBlockStats统计数据。\",\n  \"子任务11\": \"再次获取所有流量模板的StreamBlockStats统计信息，包括TxStreamFrames和RxStreamFrames等指标。\",\n  \"子任务12\": \"对比发送中和停止后的统计信息，确认StreamBlockStats统计结果正确无误。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamBlockStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamBlockStats统计;\n                   测试步骤4: 发送所有流量，查看StreamBlockStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockStats所有统计结果:\n    # get_streamblock_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetPortStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流PortStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 订阅PortStats统计;\n                   测试步骤4: 发送所有流量，查看PortStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看PortStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中PortStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 订阅PortStats统计视图\n    subscribe_result(Types=['PortStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取PortStats所有统计结果: get_port_statistic不传参数，返回值为DataFrame数据\n    result = get_port_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出Port_UP的TxFrameRate\n    df = result[(result['PortID'] == Port_UP.Name)][['TxFrameRate']]\n    dict_1 = df.to_dict('records')[0]\n    # 根据DataFrame数据筛选出Port_Down的RxFrameRate\n    df = result[(result['PortID'] == Port_Down.Name)][['RxFrameRate']]\n    dict_2 = df.to_dict('records')[0]\n    # 判断收发包速率不为0\n    if dict_1['TxFrameRate'] == 0 or dict_2['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{Port_UP.Name} TxFrameRate or {Port_Down.Name} RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一个端口的统计: get_port_statistic传Port参数,实参只有一个元素，返回值为字典\n    result = get_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_statistic传Port参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_port_statistic(Port=Port_UP, StaItems=['TxTotalFrames', 'RxTotalFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多个端口的统计: get_port_statistic传Port参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_port_statistic(Port=[Port_UP, Port_Down])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_statistic传Port参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_statistic(Port=[Port_UP, Port_Down], StaItems=['TxTotalFrames', 'RxTotalFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有端口的统计,并且StaItems参数指定统计项目:\n    # get_port_statistic不传Port参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_statistic(StaItems=['TxTotalFrames', 'RxTotalFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表环境，指定测试平台为DarYu\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，使用强制占用模式\",\n  \"子任务3\": \"在端口Port_1上创建流量模板StreamTemplate_1\",\n  \"子任务4\": \"订阅PortStats统计视图类型\",\n  \"子任务5\": \"开始发送所有流量\",\n  \"子任务6\": \"等待10秒确保获取稳定统计\",\n  \"子任务7\": \"获取所有端口PortStats统计结果并验证：发送端口TxFrameRate >0 且接收端口RxFrameRate >0\",\n  \"子任务8\": \"停止所有流量发送\",\n  \"子任务9\": \"等待3秒确保获取停止后的稳定统计\",\n  \"子任务10\": \"获取指定端口Port_1的PortStats统计结果\",\n  \"子任务11\": \"获取指定端口Port_1的关键统计项(TxTotalFrames/RxTotalFrames/TxTotalBytes/RxTotalBytes)\",\n  \"子任务12\": \"获取多个端口(Port_1和Port_2)的PortStats统计结果\",\n  \"子任务13\": \"获取多个端口的关键统计项(TxTotalFrames/RxTotalFrames/TxTotalBytes/RxTotalBytes)\",\n  \"子任务14\": \"获取所有端口的关键统计项(TxTotalFrames/RxTotalFrames/TxTotalBytes/RxTotalBytes)\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流PortStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 订阅PortStats统计;\n                   测试步骤4: 发送所有流量，查看PortStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看PortStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中PortStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 订阅PortStats统计视图\n    subscribe_result(Types=['PortStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取PortStats所有统计结果: get_port_statistic不传参数，返回值为DataFrame数据\n    result = get_port_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出Port_UP的TxFrameRate\n    df = result[(result['PortID'] == Port_UP.Name)][['TxFrameRate']]\n    dict_1 = df.to_dict('records')[0]\n    # 根据DataFrame数据筛选出Port_Down的RxFrameRate\n    df = result[(result['PortID'] == Port_Down.Name)][['RxFrameRate']]\n    dict_2 = df.to_dict('records')[0]\n    # 判断收发包速率不为0\n    if dict_1['TxFrameRate'] == 0 or dict_2['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{Port_UP.Name} TxFrameRate or {Port_Down.Name} RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一个端口的统计: get_port_statistic传Port参数,实参只有一个元素，返回值为字典\n    result = get_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_statistic传Port参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_port_statistic(Port=Port_UP, StaItems=['TxTotalFrames', 'RxTotalFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多个端口的统计: get_port_statistic传Port参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_port_statistic(Port=[Port_UP, Port_Down])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_statistic传Port参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_statistic(Port=[Port_UP, Port_Down], StaItems=['TxTotalFrames', 'RxTotalFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有端口的统计,并且StaItems参数指定统计项目:\n    # get_port_statistic不传Port参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_statistic(StaItems=['TxTotalFrames', 'RxTotalFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStatistics.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # NOTE: add_stream函数返回值是list\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n\n    # 修改流量报文内容\n\n    # 修改ethernet头部\n    edit_header_ethernet(Stream=stream, SourceMacAdd='00:01:01:a0:00:01')\n    # 修改ipv4头部， Option添加EndOfOption和RouterAlert\n    edit_header_ipv4(Stream=stream, Destination='10.10.0.1', HeaderOption=['EndOfOption', 'RouterAlert'])\n    # 修改ipv4头部中RouterAlert的参数\n    edit_header_ipv4_option(Stream=stream, Index=1, Option=['RouterAlert'], routerAlertValue=1)\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=1, Attribute='source',\n                  Start='192.168.1.1',\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_types = [\n        'PortStats',\n        'PortAvgLatencyStats',\n        'StreamStats',\n        'StreamTxStats',\n        'StreamRxStats',\n        'StreamBlockStats',\n        'StreamBlockTxStats',\n        'StreamBlockRxStats',\n    ]\n    subscribe_result(Types=subscribe_types)\n\n    # 发送流量\n    start_stream()\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # NOTE: 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 获取流量PortStats返回DataFrame数据\n    result = get_port_statistic(StaItems=['TxFrameRate', 'RxFrameRate'])\n    print('端口PortStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 停止流量\n    stop_stream()\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats返回Dict数据\n    result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n    print(f'StreamBlockStats流量{stream[0].Name}统计数据:\\n{result}')\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n\n    # 判断流量收发包是否相等\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'Test fail: {stream[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n    else:\n        print(f'Test pass: {stream[0].Name} TxStreamFrames({TxStreamFrames}) is equal to RxStreamFrames({RxStreamFrames})\\n')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "edit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"预约测试仪的两个自环端口，指定端口标识为Port_1和Port_2。\",\n  \"子任务2\": \"在端口Port_1上创建流量模板StreamTemplate_1。\",\n  \"子任务3\": \"为流量模板StreamTemplate_1添加EthernetII和IPv4报文头部结构。\",\n  \"子任务4\": \"修改流量模板StreamTemplate_1的Ethernet头部源MAC地址为'00:01:01:a0:00:01'。\",\n  \"子任务5\": \"修改流量模板StreamTemplate_1的IPv4头部，设置目的地址为'10.10.0.1'并添加EndOfOption和RouterAlert选项。\",\n  \"子任务6\": \"修改流量模板StreamTemplate_1的IPv4头部RouterAlert选项参数值为1。\",\n  \"子任务7\": \"为流量模板StreamTemplate_1的IPv4源地址添加Modifier跳变域，设置起始值'192.168.1.1'、类型为Increment、数量5、步长1。\",\n  \"子任务8\": \"保存当前测试配置至指定路径的配置文件。\",\n  \"子任务9\": \"订阅测试仪的StreamBlockStats统计视图。\",\n  \"子任务10\": \"启动所有流量模板的流量发送。\",\n  \"子任务11\": \"等待10秒流量发送持续时间。\",\n  \"子任务12\": \"停止所有流量发送。\",\n  \"子任务13\": \"获取流量模板StreamTemplate_1的StreamBlockStats统计信息，包含TxStreamFrames和RxStreamFrames计数。\",\n  \"子任务14\": \"验证流量模板StreamTemplate_1的TxStreamFrames与RxStreamFrames统计值是否相等。\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # NOTE: add_stream函数返回值是list\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n\n    # 修改流量报文内容\n\n    # 修改ethernet头部\n    edit_header_ethernet(Stream=stream, SourceMacAdd='00:01:01:a0:00:01')\n    # 修改ipv4头部， Option添加EndOfOption和RouterAlert\n    edit_header_ipv4(Stream=stream, Destination='10.10.0.1', HeaderOption=['EndOfOption', 'RouterAlert'])\n    # 修改ipv4头部中RouterAlert的参数\n    edit_header_ipv4_option(Stream=stream, Index=1, Option=['RouterAlert'], routerAlertValue=1)\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=1, Attribute='source',\n                  Start='192.168.1.1',\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_types = [\n        'PortStats',\n        'PortAvgLatencyStats',\n        'StreamStats',\n        'StreamTxStats',\n        'StreamRxStats',\n        'StreamBlockStats',\n        'StreamBlockTxStats',\n        'StreamBlockRxStats',\n    ]\n    subscribe_result(Types=subscribe_types)\n\n    # 发送流量\n    start_stream()\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # NOTE: 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 获取流量PortStats返回DataFrame数据\n    result = get_port_statistic(StaItems=['TxFrameRate', 'RxFrameRate'])\n    print('端口PortStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 停止流量\n    stop_stream()\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats返回Dict数据\n    result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n    print(f'StreamBlockStats流量{stream[0].Name}统计数据:\\n{result}')\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n\n    # 判断流量收发包是否相等\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'Test fail: {stream[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n    else:\n        print(f'Test pass: {stream[0].Name} TxStreamFrames({TxStreamFrames}) is equal to RxStreamFrames({RxStreamFrames})\\n')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nedit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/IGMP/IGMPv1.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查IGMP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建IGMP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IGMP协议会话\n\n    igmp = create_igmp(Port=Port_UP, Version='IGMPV1')\n\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n\n    select_interface(Session=igmp, Interface=interfaces_1)\n\n    # 创建组播组\n\n    multicast_group = create_multicast_group(Start='225.0.1.2')\n\n    # IGMP协议会话创建组成员关系\n\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # IGMP协议会话组成员关系与组播组绑定\n\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=Port_Down, Version='IGMPV1')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_2)\n\n    # 创建IGMP绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待IGMP协议会话稳定状态\n\n    wait_igmp_state(Sessions=[igmp])\n    wait_igmp_querier_state(Sessions=[igmp_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取IGMP Host统计\n    result = get_igmp_host_statistic()\n    print(result)\n\n    result = get_igmp_host_statistic(Session=igmp)\n    print(result)\n\n    # 获取IGMP Port统计\n    result = get_igmp_port_statistic()\n    print(result)\n\n    result = get_igmp_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取IGMP Querier统计\n    result = get_igmp_querier_statistic()\n    print(result)\n\n    result = get_igmp_querier_statistic(Session=igmp_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_igmp:创建IGMP协议会话对象",
      "create_igmp_querier:创建IGMP Querier协议会话对象",
      "edit_igmp:编辑IGMP协议会话对象",
      "edit_igmp_querier:编辑IGMP Querier协议会话对象",
      "get_igmp_host_statistic:获取Igmp协议会话统计结果",
      "get_igmp_port_statistic:获取Igmp Port统计结果",
      "get_igmp_querier_statistic:获取Igmp Querier协议会话统计结果",
      "wait_igmp_querier_state:等待Igmp Querier协议会话达到指定状态",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型为DarYu。\",\n  \"子任务2\": \"预约两个端口Port_UP和Port_Down作为自环测试端口。\",\n  \"子任务3\": \"在Port_UP端口创建IPv4接口，配置IP地址为192.168.1.2，网关为192.168.1.3。\",\n  \"子任务4\": \"在Port_Down端口创建IPv4接口，配置IP地址为192.168.1.3，网关为192.168.1.2。\",\n  \"子任务5\": \"在Port_UP端口创建IGMPV1协议会话，启用InitialJoin功能。\",\n  \"子任务6\": \"将Port_UP的IGMP协议会话绑定到其IPv4接口。\",\n  \"子任务7\": \"创建全局组播组，起始地址为225.0.1.2。\",\n  \"子任务8\": \"在IGMP会话上创建ROUNDROBIN模式的组成员关系。\",\n  \"子任务9\": \"将组播组绑定到IGMP会话的组成员关系。\",\n  \"子任务10\": \"在Port_Down端口创建IGMPV1 Querier协议会话，设置RobustnessVariable为3。\",\n  \"子任务11\": \"将Port_Down的IGMP Querier协议会话绑定到其IPv4接口。\",\n  \"子任务12\": \"从Port_Down接口获取封装层对象作为流量源点。\",\n  \"子任务13\": \"创建绑定流量：源点为Port_Down接口层，目的点为组播组，单向传输。\",\n  \"子任务14\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务15\": \"启动所有协议会话（IGMP和IGMP Querier）。\",\n  \"子任务16\": \"等待IGMP协议会话达到稳定状态。\",\n  \"子任务17\": \"等待IGMP Querier协议会话达到稳定状态。\",\n  \"子任务18\": \"等待5秒确保协议完全稳定。\",\n  \"子任务19\": \"开始发送所有绑定流量。\",\n  \"子任务20\": \"等待60秒持续发送流量。\",\n  \"子任务21\": \"停止所有流量发送。\",\n  \"子任务22\": \"停止所有协议会话。\",\n  \"子任务23\": \"等待3秒确保完全停止。\",\n  \"子任务24\": \"获取绑定流量的StreamBlockStats统计信息。\",\n  \"子任务25\": \"验证流量统计结果：发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查IGMP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建IGMP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IGMP协议会话\n\n    igmp = create_igmp(Port=Port_UP, Version='IGMPV1')\n\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n\n    select_interface(Session=igmp, Interface=interfaces_1)\n\n    # 创建组播组\n\n    multicast_group = create_multicast_group(Start='225.0.1.2')\n\n    # IGMP协议会话创建组成员关系\n\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # IGMP协议会话组成员关系与组播组绑定\n\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=Port_Down, Version='IGMPV1')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_2)\n\n    # 创建IGMP绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待IGMP协议会话稳定状态\n\n    wait_igmp_state(Sessions=[igmp])\n    wait_igmp_querier_state(Sessions=[igmp_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取IGMP Host统计\n    result = get_igmp_host_statistic()\n    print(result)\n\n    result = get_igmp_host_statistic(Session=igmp)\n    print(result)\n\n    # 获取IGMP Port统计\n    result = get_igmp_port_statistic()\n    print(result)\n\n    result = get_igmp_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取IGMP Querier统计\n    result = get_igmp_querier_statistic()\n    print(result)\n\n    result = get_igmp_querier_statistic(Session=igmp_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_igmp:创建IGMP协议会话对象;\ncreate_igmp_querier:创建IGMP Querier协议会话对象;\nedit_igmp:编辑IGMP协议会话对象;\nedit_igmp_querier:编辑IGMP Querier协议会话对象;\nget_igmp_host_statistic:获取Igmp协议会话统计结果;\nget_igmp_port_statistic:获取Igmp Port统计结果;\nget_igmp_querier_statistic:获取Igmp Querier协议会话统计结果;\nwait_igmp_querier_state:等待Igmp Querier协议会话达到指定状态;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStreamTxStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamTxStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamTxStats统计;\n                   测试步骤4: 发送所有流量，查看StreamTxStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamTxStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamTxStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    for stream in streams:\n        edit_modifier(Stream=stream, Level=1, Attribute='source', Start='192.168.1.1', Type='Increment', Count=5,\n                      Step=1, StreamType='InterModifier')\n\n    # 订阅StreamTxStats统计视图\n    subscribe_result(Types=['StreamTxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamTxStats所有统计结果:\n    # get_stream_tx_statistic不传参数，返回值为DataFrame数据\n    result = get_stream_tx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name) & (result['StreamID'] == 1)][['TxFrameRate', 'TxBitRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['TxBitRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or TxBitRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_stream_tx_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式3 -- 获取指定一条流量的统计:\n    # get_stream_tx_statistic传Stream参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_tx_statistic(Stream=streams[-1], StreamID=1)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量和端口的统计:\n    # get_stream_tx_statistic传Stream和Port参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[-1], Port=Port_Down)\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定一条流量和端口的统计:\n    # get_stream_tx_statistic传Stream和Port参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_tx_statistic(Stream=streams[-1], Port=Port_Down, StreamID=1)\n    print(result)\n\n    # 统计获取方式6 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_tx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定多条流量的统计: get_stream_tx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式8 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_tx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式9 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_tx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_tx_statistic(StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_stream_tx_statistic:获取测试仪表流模板统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1端口创建两条流量StreamTemplate_1和StreamTemplate_2。\",\n  \"子任务4\": \"在Port_2端口创建两条流量StreamTemplate_3和StreamTemplate_4。\",\n  \"子任务5\": \"订阅StreamTxStats统计视图。\",\n  \"子任务6\": \"开始发送所有流量。\",\n  \"子任务7\": \"等待10秒获取稳定统计状态。\",\n  \"子任务8\": \"获取StreamTxStats所有流量的统计信息。\",\n  \"子任务9\": \"验证每条流的TxFrameRate和TxBitRate均大于0（发送状态）。\",\n  \"子任务10\": \"停止所有流量发送。\",\n  \"子任务11\": \"等待3秒获取停止后的稳定统计状态。\",\n  \"子任务12\": \"获取StreamTxStats所有流量的统计信息。\",\n  \"子任务13\": \"验证每条流的TxFrameRate和TxBitRate均为0（停止状态）。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamTxStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamTxStats统计;\n                   测试步骤4: 发送所有流量，查看StreamTxStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamTxStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamTxStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    for stream in streams:\n        edit_modifier(Stream=stream, Level=1, Attribute='source', Start='192.168.1.1', Type='Increment', Count=5,\n                      Step=1, StreamType='InterModifier')\n\n    # 订阅StreamTxStats统计视图\n    subscribe_result(Types=['StreamTxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamTxStats所有统计结果:\n    # get_stream_tx_statistic不传参数，返回值为DataFrame数据\n    result = get_stream_tx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name) & (result['StreamID'] == 1)][['TxFrameRate', 'TxBitRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['TxBitRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or TxBitRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_stream_tx_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式3 -- 获取指定一条流量的统计:\n    # get_stream_tx_statistic传Stream参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_tx_statistic(Stream=streams[-1], StreamID=1)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量和端口的统计:\n    # get_stream_tx_statistic传Stream和Port参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[-1], Port=Port_Down)\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定一条流量和端口的统计:\n    # get_stream_tx_statistic传Stream和Port参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_tx_statistic(Stream=streams[-1], Port=Port_Down, StreamID=1)\n    print(result)\n\n    # 统计获取方式6 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_tx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定多条流量的统计: get_stream_tx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式8 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_tx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式9 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_tx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_tx_statistic(StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_stream_tx_statistic:获取测试仪表流模板统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStreamRxStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamRxStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 每条流量添加跳变;\n                   测试步骤4: 订阅StreamRxStats统计;\n                   测试步骤5: 发送所有流量，查看StreamRxStats统计信息，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamRxStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤5,6中StreamRxStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    for stream in streams:\n        edit_modifier(Stream=stream, Level=1, Attribute='source', Start='192.168.1.1', Type='Increment', Count=5,\n                      Step=1, StreamType='InterModifier')\n\n    # 订阅StreamRxStats统计视图\n    subscribe_result(Types=['StreamRxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamRxStats所有统计结果:\n    # get_stream_rx_statistic不传参数，返回值为DataFrame数据\n    result = get_stream_rx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1收端口为Port_Down的RxFrameRate和RxByteRate\n    df = result[(result['StreamBlockID'] == streams[0].Name) & (result['PortID'] == Port_Down.handle) & (result['StreamID'] == 1)][['RxFrameRate', 'RxByteRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['RxFrameRate'] == 0 or data['RxByteRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} RxFrameRate or RxByteRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量和端口的统计:\n    # get_stream_rx_statistic传Stream和Port参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[-1], Port=Port_UP)\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式3 -- 获取指定一条流量和端口的统计:\n    # get_stream_rx_statistic传Stream和Port参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_rx_statistic(Stream=streams[-1], Port=Port_UP, StreamID=1)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量的统计: get_stream_rx_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_rx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[:1], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定多条流量的统计: get_stream_rx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_rx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[:3], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式8 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_rx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_rx_statistic(StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_stream_rx_statistic:获取测试仪表流模板统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试平台类型。\",\n  \"子任务2\": \"预约两个自环端口（Port_1 和 Port_2），强制占用端口资源。\",\n  \"子任务3\": \"在 Port_1 上创建两条流量模板（StreamTemplate_1 和 StreamTemplate_2），在 Port_2 上创建两条流量模板（StreamTemplate_3 和 StreamTemplate_4）。\",\n  \"子任务4\": \"为所有流量模板添加 IPv4 源地址字段的跳变规则，设置起始值、增量类型和步长。\",\n  \"子任务5\": \"订阅流接收统计视图（StreamRxStats）。\",\n  \"子任务6\": \"开始发送所有流量，等待 10 秒使统计稳定。\",\n  \"子任务7\": \"获取 StreamRxStats 所有统计结果，验证速率值非零。\",\n  \"子任务8\": \"停止所有流量发送，等待 3 秒使最终统计稳定。\",\n  \"子任务9\": \"按指定条件获取 StreamRxStats 统计结果（包括单条流量、指定端口、特定统计项等多维度查询）。\",\n  \"子任务10\": \"验证各场景下统计信息获取的正确性（包括数据格式转换和关键值校验）。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamRxStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 每条流量添加跳变;\n                   测试步骤4: 订阅StreamRxStats统计;\n                   测试步骤5: 发送所有流量，查看StreamRxStats统计信息，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamRxStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤5,6中StreamRxStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    for stream in streams:\n        edit_modifier(Stream=stream, Level=1, Attribute='source', Start='192.168.1.1', Type='Increment', Count=5,\n                      Step=1, StreamType='InterModifier')\n\n    # 订阅StreamRxStats统计视图\n    subscribe_result(Types=['StreamRxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamRxStats所有统计结果:\n    # get_stream_rx_statistic不传参数，返回值为DataFrame数据\n    result = get_stream_rx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1收端口为Port_Down的RxFrameRate和RxByteRate\n    df = result[(result['StreamBlockID'] == streams[0].Name) & (result['PortID'] == Port_Down.handle) & (result['StreamID'] == 1)][['RxFrameRate', 'RxByteRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['RxFrameRate'] == 0 or data['RxByteRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} RxFrameRate or RxByteRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量和端口的统计:\n    # get_stream_rx_statistic传Stream和Port参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[-1], Port=Port_UP)\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式3 -- 获取指定一条流量和端口的统计:\n    # get_stream_rx_statistic传Stream和Port参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_rx_statistic(Stream=streams[-1], Port=Port_UP, StreamID=1)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量的统计: get_stream_rx_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_rx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[:1], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定多条流量的统计: get_stream_rx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_rx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[:3], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式8 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_rx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_rx_statistic(StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_stream_rx_statistic:获取测试仪表流模板统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Imix/StreamImix.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Imix模板;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tCSR-10199\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=78, Max=178, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=206, Max=306, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=462, Max=562, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=974, Max=1074, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1230, Max=1330, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1468, Max=1568, Weight=50)\n    bind_stream_imix(Stream=stream, IMix=imix)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "add_stream:测试仪表创建流量",
      "add_imix_distribution_frame:在Imix模板添加自定义帧长",
      "bind_stream_imix:将Imix模板和流量模板绑定",
      "create_imix:创建流量Imix模板"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口：Port_1（位置//10.0.11.191/1/15）和Port_2（位置//10.0.11.191/1/16）。\",\n  \"子任务3\": \"在端口Port_1上创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"创建IMix模板Imix_01用于定义流量特征。\",\n  \"子任务5\": \"向Imix_01模板添加6组帧长分布：随机长度范围[78-178]、[206-306]、[462-562]、[974-1074]、[1230-1330]、[1468-1568]，权重各50%。\",\n  \"子任务6\": \"将Imix_01模板绑定到流量StreamTemplate_1。\",\n  \"子任务7\": \"订阅流块统计StreamBlockStats监控。\",\n  \"子任务8\": \"启动所有流量发送并持续指定时间（如10秒）。\",\n  \"子任务9\": \"停止所有流量发送。\",\n  \"子任务10\": \"获取StreamBlockStats统计信息。\",\n  \"子任务11\": \"验证StreamTemplate_1的收包数量与发包数量相等。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Imix模板;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tCSR-10199\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=78, Max=178, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=206, Max=306, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=462, Max=562, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=974, Max=1074, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1230, Max=1330, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1468, Max=1568, Weight=50)\n    bind_stream_imix(Stream=stream, IMix=imix)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nadd_stream:测试仪表创建流量;\nadd_imix_distribution_frame:在Imix模板添加自定义帧长;\nbind_stream_imix:将Imix模板和流量模板绑定;\ncreate_imix:创建流量Imix模板\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStatisticsPre.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Mode='db')\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # NOTE: add_stream函数返回值是list\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n\n    # 修改流量报文内容\n\n    # 修改ethernet头部\n    edit_header_ethernet(Stream=stream, SourceMacAdd='00:01:01:a0:00:01')\n    # 修改ipv4头部， Option添加EndOfOption和RouterAlert\n    edit_header_ipv4(Stream=stream, Destination='10.10.0.1', HeaderOption=['EndOfOption', 'RouterAlert'])\n    # 修改ipv4头部中RouterAlert的参数\n    edit_header_ipv4_option(Stream=stream, Index=1, Option=['RouterAlert'], routerAlertValue=1)\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=1, Attribute='source',\n                  Start='192.168.1.1',\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_types = [\n        'PortStats',\n        'PortAvgLatencyStats',\n        'StreamStats',\n        'StreamTxStats',\n        'StreamRxStats',\n        'StreamBlockStats',\n        'StreamBlockTxStats',\n        'StreamBlockRxStats',\n    ]\n    subscribe_result(Types=subscribe_types)\n\n    # 发送流量\n    start_stream()\n    time.sleep(5)\n    # 停止流量\n    stop_stream()\n    time.sleep(3)\n\n    # 清空统计\n    clear_result()\n\n    # 发送流量\n    start_stream()\n    time.sleep(5)\n    # 停止流量\n    stop_stream()\n    time.sleep(3)\n\n    # 获取流量PortStats返回DataFrame数据\n    result = get_port_statistic(Mode=True)\n    print('端口PortStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    result = get_port_latency_statistic()\n    print('端口PortLatencyStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 获取流量PortStats返回DataFrame数据\n    result = get_port_statistic(Mode=True)\n    print('端口PortStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    result = get_port_latency_statistic()\n    print('端口PortLatencyStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "clear_result:清除测试仪表统计",
      "get_port_latency_statistic:获取测试仪表端口时延统计结果",
      "get_port_statistic:获取测试仪表端口统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "edit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约两个自环端口Port_1和Port_2，使用reserve_port API强制预约指定位置。\",\n  \"子任务2\": \"在端口Port_1上创建一条流量StreamTemplate_1，使用add_stream API生成流量模板。\",\n  \"子任务3\": \"为StreamTemplate_1创建报文头部，指定EthernetII和IPv4协议，使用create_stream_header API。\",\n  \"子任务4\": \"修改流量StreamTemplate_1的Ethernet头部，设置源MAC地址为00:01:01:a0:00:01，使用edit_header_ethernet API。\",\n  \"子任务5\": \"修改流量StreamTemplate_1的IPv4头部，设置目的IP为10.10.0.1并添加EndOfOption和RouterAlert选项，使用edit_header_ipv4 API。\",\n  \"子任务6\": \"修改流量StreamTemplate_1的IPv4头部RouterAlert选项值，设置routerAlertValue=1，使用edit_header_ipv4_option API。\",\n  \"子任务7\": \"修改流量StreamTemplate_1的IPv4源IP地址跳变规则，设置起始值192.168.1.1、增量类型、步长1和数量5，使用edit_modifier API。\",\n  \"子任务8\": \"订阅StreamBlockStats统计视图，使用subscribe_result API指定统计类型。\",\n  \"子任务9\": \"开始发送所有流量，使用start_stream API启动流量传输。\",\n  \"子任务10\": \"等待5秒使流量持续发送。\",\n  \"子任务11\": \"停止所有流量，使用stop_stream API终止流量传输。\",\n  \"子任务12\": \"获取StreamBlockStats统计信息，提取StreamTemplate_1的收发报文计数。\",\n  \"子任务13\": \"验证StreamTemplate_1收包数量与发包数量是否相等。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Mode='db')\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # NOTE: add_stream函数返回值是list\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n\n    # 修改流量报文内容\n\n    # 修改ethernet头部\n    edit_header_ethernet(Stream=stream, SourceMacAdd='00:01:01:a0:00:01')\n    # 修改ipv4头部， Option添加EndOfOption和RouterAlert\n    edit_header_ipv4(Stream=stream, Destination='10.10.0.1', HeaderOption=['EndOfOption', 'RouterAlert'])\n    # 修改ipv4头部中RouterAlert的参数\n    edit_header_ipv4_option(Stream=stream, Index=1, Option=['RouterAlert'], routerAlertValue=1)\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=1, Attribute='source',\n                  Start='192.168.1.1',\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_types = [\n        'PortStats',\n        'PortAvgLatencyStats',\n        'StreamStats',\n        'StreamTxStats',\n        'StreamRxStats',\n        'StreamBlockStats',\n        'StreamBlockTxStats',\n        'StreamBlockRxStats',\n    ]\n    subscribe_result(Types=subscribe_types)\n\n    # 发送流量\n    start_stream()\n    time.sleep(5)\n    # 停止流量\n    stop_stream()\n    time.sleep(3)\n\n    # 清空统计\n    clear_result()\n\n    # 发送流量\n    start_stream()\n    time.sleep(5)\n    # 停止流量\n    stop_stream()\n    time.sleep(3)\n\n    # 获取流量PortStats返回DataFrame数据\n    result = get_port_statistic(Mode=True)\n    print('端口PortStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    result = get_port_latency_statistic()\n    print('端口PortLatencyStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 获取流量PortStats返回DataFrame数据\n    result = get_port_statistic(Mode=True)\n    print('端口PortStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    result = get_port_latency_statistic()\n    print('端口PortLatencyStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nclear_result:清除测试仪表统计;\nget_port_latency_statistic:获取测试仪表端口时延统计结果;\nget_port_statistic:获取测试仪表端口统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nedit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6MLDv2Report.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv2 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv2 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv2report']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_mldv2_report(Stream=stream, Level=0,\n                          Type='143',Reserved='20',NumberOfGroupRecords='2')\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2report', Attribute=header['Reserved'],\n                  Type='Increment', Count=10)\n\n    group = edit_header_icmpv6_group_records(Stream=stream, Index=1,\n                                             SourceAddressList=['2001::1', '2002::2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2report', Attribute=group['SourceAddressList: 2002::2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Report_1.type',\n                                               Value='143', MaxValue='143')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Report_1.reserved2',\n                                               Value='20',\n                                               MaxValue='20')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Report_1.numberOfGroupRecords',\n                                               Value='2',\n                                               MaxValue='2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_group_records:修改测试仪表流量模板中ICMPv6 Mldv2 Report报文头部Group Records内容",
      "edit_header_icmpv6_mldv2_report:修改测试仪表流量模板中Icmpv6 Mldv2 Report报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约两个自环端口，位置参数为'//10.0.11.191/1/3'和'//10.0.11.191/1/4'。\",\n  \"子任务3\": \"在Port_1上创建流量，设置固定帧长为256字节。\",\n  \"子任务4\": \"为流量创建三层报文头部：EthernetII、IPv6和mldv2report。\",\n  \"子任务5\": \"修改ICMPv6 MLDv2报告头部：Type=143，Reserved=20，NumberOfGroupRecords=2。\",\n  \"子任务6\": \"配置Reserved字段的跳变规则：递增模式，计数10次。\",\n  \"子任务7\": \"编辑组记录源地址列表：索引1包含'2001::1'和'2002::2'。\",\n  \"子任务8\": \"配置源地址'2002::2'的跳变规则：递增模式，计数10次。\",\n  \"子任务9\": \"在Port_2创建三个PDU匹配模式：Type=143、Reserved=20、NumberOfGroupRecords=2。\",\n  \"子任务10\": \"设置Port_2的抓包过滤表达式：同时满足三个PDU匹配模式。\",\n  \"子任务11\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务12\": \"配置Port_1的发送模式：突发包模式，突发包数量=100。\",\n  \"子任务13\": \"保存当前测试配置文件。\",\n  \"子任务14\": \"启动Port_2的数据抓包。\",\n  \"子任务15\": \"开始发送流量。\",\n  \"子任务16\": \"等待10秒使流量稳定传输。\",\n  \"子任务17\": \"停止流量发送。\",\n  \"子任务18\": \"停止数据抓包。\",\n  \"子任务19\": \"等待3秒确保统计结果稳定。\",\n  \"子任务20\": \"下载Port_2捕获的报文数据包。\",\n  \"子任务21\": \"获取流量块的统计信息（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务22\": \"验证TxStreamFrames是否等于RxStreamFrames。\",\n  \"子任务23\": \"释放预约的测试端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv2 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv2 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv2report']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_mldv2_report(Stream=stream, Level=0,\n                          Type='143',Reserved='20',NumberOfGroupRecords='2')\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2report', Attribute=header['Reserved'],\n                  Type='Increment', Count=10)\n\n    group = edit_header_icmpv6_group_records(Stream=stream, Index=1,\n                                             SourceAddressList=['2001::1', '2002::2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2report', Attribute=group['SourceAddressList: 2002::2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Report_1.type',\n                                               Value='143', MaxValue='143')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Report_1.reserved2',\n                                               Value='20',\n                                               MaxValue='20')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Report_1.numberOfGroupRecords',\n                                               Value='2',\n                                               MaxValue='2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_group_records:修改测试仪表流量模板中ICMPv6 Mldv2 Report报文头部Group Records内容;\nedit_header_icmpv6_mldv2_report:修改测试仪表流量模板中Icmpv6 Mldv2 Report报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/OSPF/OSPFv2.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查OSPFv2协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建OSPFv2协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建OSPFv2协议会话\n\n    session_1 = create_ospf(Port=Port_UP, Priority=1)\n\n    session_2 = create_ospf(Port=Port_Down, Priority=2)\n\n    # OSPFv2协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # OSPFv2协议会话1创建Summary Lsa\n\n    summary_lsa = create_ospf_summary_lsa(Session=session_1)\n\n    # OSPFv2协议会话2创建External Lsa\n\n    external_lsa = create_ospf_external_lsa(Session=session_2)\n\n    # 获取OSPFv2协议绑定流端点对象\n\n    point_1 = get_ospf_router_from_lsa(Lsa=summary_lsa)\n\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa)\n\n    # 创建OSPFv2绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待OSPFv2协议会话达到Full状态\n\n    wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n\n    advertise_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    withdraw_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取OSPFv2会话1统计\n    import pandas\n    result = get_ospf_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ospf_statistic(Session=session_1)\n    print(result)\n    TxSummaryLsa = result['TxSummaryLsa']\n    RxAsExternalLsa = result['RxAsExternalLsa']\n    print('TxSummaryLsa: {}'.format(TxSummaryLsa))\n    print('RxAsExternalLsa: {}'.format(RxAsExternalLsa))\n\n    # 获取OSPFv2会话2统计\n\n    result = get_ospf_statistic(Session=session_2)\n    print(result)\n    RxSummaryLsa = result['RxSummaryLsa']\n    TxAsExternalLsa = result['TxAsExternalLsa']\n    print('RxSummaryLsa: {}'.format(RxSummaryLsa))\n    print('TxAsExternalLsa: {}'.format(TxAsExternalLsa))\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_ospf_lsa:通告 OSPFv2 协议会话 lsa",
      "create_ospf:创建OSPFv2协议会话对象",
      "create_ospf_external_lsa:创建OSPFv2 External LSA对象",
      "create_ospf_summary_lsa:创建OSPFv2 Summary LSA对象",
      "get_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象",
      "get_ospf_statistic:获取OSPFv2协议会话统计结果",
      "wait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态",
      "withdraw_ospf_lsa:撤销OSPFv2协议会话lsa",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品型号为DarYu。\",\n  \"子任务2\": \"预约两个自环测试端口Port_UP和Port_Down。\",\n  \"子任务3\": \"在Port_UP端口创建IPv4接口，配置IP地址192.168.1.2，网关192.168.1.3。\",\n  \"子任务4\": \"在Port_Down端口创建IPv4接口，配置IP地址192.168.1.3，网关192.168.1.2。\",\n  \"子任务5\": \"在Port_UP端口创建OSPFv2协议会话session_1，优先级为1。\",\n  \"子任务6\": \"在Port_Down端口创建OSPFv2协议会话session_2，优先级为2。\",\n  \"子任务7\": \"将session_1绑定到Port_UP接口。\",\n  \"子任务8\": \"将session_2绑定到Port_Down接口。\",\n  \"子任务9\": \"在session_1上创建OSPFv2 Summary LSA对象。\",\n  \"子任务10\": \"在session_2上创建OSPFv2 External LSA对象。\",\n  \"子任务11\": \"从Summary LSA获取绑定流源端点对象。\",\n  \"子任务12\": \"从External LSA获取绑定流目的端点对象。\",\n  \"子任务13\": \"创建双向绑定流，源端点指向Summary LSA端点，目的端点指向External LSA端点。\",\n  \"子任务14\": \"订阅流模板块统计(StreamBlockStats)和OSPF会话结果统计视图。\",\n  \"子任务15\": \"保存当前测试配置到文件。\",\n  \"子任务16\": \"启动所有协议会话。\",\n  \"子任务17\": \"等待两个OSPFv2会话达到Full邻接状态。\",\n  \"子任务18\": \"通告Summary LSA和External LSA，并等待5秒。\",\n  \"子任务19\": \"开始发送所有绑定流，持续10秒。\",\n  \"子任务20\": \"停止所有绑定流发送。\",\n  \"子任务21\": \"撤销通告的Summary LSA和External LSA，等待5秒。\",\n  \"子任务22\": \"停止所有协议会话。\",\n  \"子任务23\": \"获取并验证每个绑定流的统计信息：发送帧数(TxStreamFrames)与接收帧数(RxStreamFrames)。\",\n  \"子任务24\": \"确认所有绑定流的TxStreamFrames等于RxStreamFrames。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查OSPFv2协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建OSPFv2协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建OSPFv2协议会话\n\n    session_1 = create_ospf(Port=Port_UP, Priority=1)\n\n    session_2 = create_ospf(Port=Port_Down, Priority=2)\n\n    # OSPFv2协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # OSPFv2协议会话1创建Summary Lsa\n\n    summary_lsa = create_ospf_summary_lsa(Session=session_1)\n\n    # OSPFv2协议会话2创建External Lsa\n\n    external_lsa = create_ospf_external_lsa(Session=session_2)\n\n    # 获取OSPFv2协议绑定流端点对象\n\n    point_1 = get_ospf_router_from_lsa(Lsa=summary_lsa)\n\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa)\n\n    # 创建OSPFv2绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待OSPFv2协议会话达到Full状态\n\n    wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n\n    advertise_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    withdraw_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取OSPFv2会话1统计\n    import pandas\n    result = get_ospf_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ospf_statistic(Session=session_1)\n    print(result)\n    TxSummaryLsa = result['TxSummaryLsa']\n    RxAsExternalLsa = result['RxAsExternalLsa']\n    print('TxSummaryLsa: {}'.format(TxSummaryLsa))\n    print('RxAsExternalLsa: {}'.format(RxAsExternalLsa))\n\n    # 获取OSPFv2会话2统计\n\n    result = get_ospf_statistic(Session=session_2)\n    print(result)\n    RxSummaryLsa = result['RxSummaryLsa']\n    TxAsExternalLsa = result['TxAsExternalLsa']\n    print('RxSummaryLsa: {}'.format(RxSummaryLsa))\n    print('TxAsExternalLsa: {}'.format(TxAsExternalLsa))\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_ospf_lsa:通告 OSPFv2 协议会话 lsa;\ncreate_ospf:创建OSPFv2协议会话对象;\ncreate_ospf_external_lsa:创建OSPFv2 External LSA对象;\ncreate_ospf_summary_lsa:创建OSPFv2 Summary LSA对象;\nget_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象;\nget_ospf_statistic:获取OSPFv2协议会话统计结果;\nwait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态;\nwithdraw_ospf_lsa:撤销OSPFv2协议会话lsa;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2LinkStateRequestInstance.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发OSPFv2 Link State Request Instance报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的OSPFv2 Link State Request Instance头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstaterequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 database description头部\n    header = edit_header_ospfv2_request(Stream=stream, Level=0,\n                                        RouterID='2.2.2.2', AuthType='MD5')\n    lsa = edit_header_ospfv2_lsa(Stream=stream, HeaderType='Ospfv2LinkStateRequest',\n                                 LsTypeWide=10,\n                                 LinkStateId='3.3.3.3',\n                                 AdvertisingRouter='4.4.4.4')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstaterequest',\n                  Attribute=lsa['LinkStateId'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2LinkStateRequest_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_lsa:修改测试仪表流量模板中OSPFv2报文中Lsa头部内容",
      "edit_header_ospfv2_request:修改测试仪表流量模板中OSPFv2 Link State Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量模板StreamTemplate_1，设置固定帧长为256字节。\",\n  \"子任务4\": \"为流量模板创建三层协议头部：EthernetII、IPv4、OSPFv2 Link State Request。\",\n  \"子任务5\": \"修改OSPFv2 Link State Request报文头部：设置RouterID为'2.2.2.2'，认证类型为'MD5'。\",\n  \"子任务6\": \"修改OSPFv2 LSA头部：设置LsTypeWide为10，LinkStateId为'3.3.3.3'，AdvertisingRouter为'4.4.4.4'。\",\n  \"子任务7\": \"配置LinkStateId字段的跳变规则：增量模式，计数10次，步长2。\",\n  \"子任务8\": \"在Port_2创建PDU抓包过滤模式：基于routerID字段值'2.2.2.2'过滤OSPFv2报文。\",\n  \"子任务9\": \"在Port_2应用报文捕获过滤表达式。\",\n  \"子任务10\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务11\": \"设置Port_1发送模式为突发包，指定突发包数量为100。\",\n  \"子任务12\": \"启动Port_2的报文捕获功能。\",\n  \"子任务13\": \"启动Port_1的流量发送。\",\n  \"子任务14\": \"等待10秒确保流量发送完成。\",\n  \"子任务15\": \"停止Port_1的流量发送。\",\n  \"子任务16\": \"停止Port_2的报文捕获。\",\n  \"子任务17\": \"获取StreamTemplate_1的流量统计信息（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务18\": \"验证TxStreamFrames与RxStreamFrames统计值相等。\",\n  \"子任务19\": \"释放已预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发OSPFv2 Link State Request Instance报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的OSPFv2 Link State Request Instance头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstaterequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 database description头部\n    header = edit_header_ospfv2_request(Stream=stream, Level=0,\n                                        RouterID='2.2.2.2', AuthType='MD5')\n    lsa = edit_header_ospfv2_lsa(Stream=stream, HeaderType='Ospfv2LinkStateRequest',\n                                 LsTypeWide=10,\n                                 LinkStateId='3.3.3.3',\n                                 AdvertisingRouter='4.4.4.4')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstaterequest',\n                  Attribute=lsa['LinkStateId'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2LinkStateRequest_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_lsa:修改测试仪表流量模板中OSPFv2报文中Lsa头部内容;\nedit_header_ospfv2_request:修改测试仪表流量模板中OSPFv2 Link State Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4_EchoReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 echo reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 echo reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4EchoReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改Icmpv4EchoReply头部\n    header = edit_header_icmp_echo_reply(Stream=stream, Level=0, Type='2',\n                                Code='4', Identifier='100', SequenceNumber='200')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4EchoReply', Attribute=header['Code'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoReply_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoReply_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_echo_reply:修改测试仪表流量模板中Icmp Echo Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务2\": \"在 Port_1 上创建流量 StreamTemplate_1 并设置固定帧长为 256 字节。\",\n  \"子任务3\": \"为 StreamTemplate_1 配置三层协议头：EthernetII -> IPv4 -> ICMPv4 Echo Reply。\",\n  \"子任务4\": \"修改 StreamTemplate_1 的 ICMPv4 Echo Reply 头部：Type=2, Code=4, Identifier=100, SequenceNumber=200。\",\n  \"子任务5\": \"为 StreamTemplate_1 的 ICMPv4 Echo Reply Code 字段配置递增跳变规则：起始值4，步长1，计数10。\",\n  \"子任务6\": \"在 Port_2 创建 PDU Pattern_1：匹配 ICMPv4 Echo Reply Identifier 字段值等于100。\",\n  \"子任务7\": \"在 Port_2 创建 PDU Pattern_2：匹配 ICMPv4 Echo Reply SequenceNumber 字段值等于200。\",\n  \"子任务8\": \"在 Port_2 设置抓包过滤条件：PDU Pattern_1 && PDU Pattern_2。\",\n  \"子任务9\": \"订阅 StreamBlockStats 统计视图。\",\n  \"子任务10\": \"配置 Port_1 发送模式为突发包，突发包数量为100。\",\n  \"子任务11\": \"启动 Port_2 抓包功能。\",\n  \"子任务12\": \"启动 Port_1 流量发送。\",\n  \"子任务13\": \"等待10秒确保流量发送完成。\",\n  \"子任务14\": \"停止 Port_1 流量发送。\",\n  \"子任务15\": \"停止 Port_2 抓包功能。\",\n  \"子任务16\": \"获取 StreamTemplate_1 的 StreamBlockStats 统计结果。\",\n  \"子任务17\": \"验证 StreamTemplate_1 的 TxStreamFrames 等于 RxStreamFrames。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 echo reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 echo reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4EchoReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改Icmpv4EchoReply头部\n    header = edit_header_icmp_echo_reply(Stream=stream, Level=0, Type='2',\n                                Code='4', Identifier='100', SequenceNumber='200')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4EchoReply', Attribute=header['Code'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoReply_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoReply_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_echo_reply:修改测试仪表流量模板中Icmp Echo Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStreamStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 每条流量添加跳变;\n                   测试步骤4: 订阅StreamStats统计;\n                   测试步骤5: 发送所有流量，查看StreamStats统计信息，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤5,6中StreamStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Mode='DB')\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    for stream in streams:\n        edit_modifier(Stream=stream, Level=1, Attribute='source', Start='192.168.1.1', Type='Increment', Count=5,\n                      Step=1, StreamType='InterModifier')\n\n    # 订阅StreamStats统计视图\n    subscribe_result(Types=['StreamStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamStats所有统计结果:\n    # get_stream_statistic不传参数，返回值DataFrame数据\n    result = get_stream_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_stream_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式3 -- 获取指定一条流量的统计:\n    # get_stream_statistic传Stream参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_statistic(Stream=streams[-1], StreamID=1)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_stream_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic传Stream参数,实参只有一个元素并指定StreamID，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_stream_statistic(Stream=streams[:1], StreamID=1, StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式6 -- 获取指定多条流量的统计: get_stream_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_stream_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式8 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_stream_statistic:获取测试仪表流模板统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品型号为'DarYu'，模式为'DB'。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，强制占用指定物理位置。\",\n  \"子任务3\": \"在Port_1端口创建两条流量StreamTemplate_1和StreamTemplate_2。\",\n  \"子任务4\": \"在Port_2端口创建两条流量StreamTemplate_3和StreamTemplate_4。\",\n  \"子任务5\": \"为每条流量添加IPv4源地址跳变：起始值'192.168.1.1'，类型'Increment'，步长1，计数5。\",\n  \"子任务6\": \"订阅StreamStats统计视图以监控流量指标。\",\n  \"子任务7\": \"开始发送所有流量。\",\n  \"子任务8\": \"等待10秒获取稳定统计。\",\n  \"子任务9\": \"获取所有流的StreamStats统计信息并转换为结构化数据。\",\n  \"子任务10\": \"验证发送期间每条流的TxFrameRate和RxFrameRate均不为零。\",\n  \"子任务11\": \"停止所有流量发送。\",\n  \"子任务12\": \"等待3秒获取停止后稳定统计。\",\n  \"子任务13\": \"获取停止后所有流的StreamStats统计信息。\",\n  \"子任务14\": \"验证停止后每条流的TxFrameRate和RxFrameRate均为零。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 每条流量添加跳变;\n                   测试步骤4: 订阅StreamStats统计;\n                   测试步骤5: 发送所有流量，查看StreamStats统计信息，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤5,6中StreamStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Mode='DB')\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    for stream in streams:\n        edit_modifier(Stream=stream, Level=1, Attribute='source', Start='192.168.1.1', Type='Increment', Count=5,\n                      Step=1, StreamType='InterModifier')\n\n    # 订阅StreamStats统计视图\n    subscribe_result(Types=['StreamStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamStats所有统计结果:\n    # get_stream_statistic不传参数，返回值DataFrame数据\n    result = get_stream_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_stream_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式3 -- 获取指定一条流量的统计:\n    # get_stream_statistic传Stream参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_statistic(Stream=streams[-1], StreamID=1)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_stream_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic传Stream参数,实参只有一个元素并指定StreamID，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_stream_statistic(Stream=streams[:1], StreamID=1, StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式6 -- 获取指定多条流量的统计: get_stream_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_stream_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式8 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_stream_statistic:获取测试仪表流模板统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2UnknownInstance.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发OSPFv2 Unknown报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量Stream的OSPFv2 Unknown头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2unknown']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改ospfv2 database description头部\n    edit_header_ospfv2_unknown(Stream=stream, Level=0,\n                          RouterID='2.2.2.2', AuthType='MD5',\n                          AuthValue1=111)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Unknown_1.ospfHeader.authSelect.hdrAuthSelectNone.authValue1',\n                                               Value='111', MaxValue='111')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_unknown:修改测试仪表流量模板中OSPFv2 Unknown报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表\",\n  \"子任务2\": \"预约两个自环端口（Port_1作为发送端口，Port_2作为接收端口）\",\n  \"子任务3\": \"在发送端口创建流量模板，设置固定帧长度\",\n  \"子任务4\": \"为流量模板创建报文头部，包含EthernetII、IPv4和OSPFv2 Unknown三层协议\",\n  \"子任务5\": \"修改OSPFv2 Unknown报文头部内容（包括RouterID、AuthType和AuthValue1）\",\n  \"子任务6\": \"在接收端口创建PDU匹配模式，指定过滤字段为OSPFv2认证值\",\n  \"子任务7\": \"在接收端口配置抓包过滤表达式\",\n  \"子任务8\": \"订阅StreamBlockStats统计视图\",\n  \"子任务9\": \"配置发送端口为突发包模式，设置突发包数量\",\n  \"子任务10\": \"保存当前测试配置文件\",\n  \"子任务11\": \"启动接收端口抓包\",\n  \"子任务12\": \"开始发送流量\",\n  \"子任务13\": \"等待指定时间（10秒）\",\n  \"子任务14\": \"停止发送流量\",\n  \"子任务15\": \"停止抓包\",\n  \"子任务16\": \"下载捕获的数据包文件\",\n  \"子任务17\": \"获取流模板块统计信息\",\n  \"子任务18\": \"验证发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）\",\n  \"子任务19\": \"释放所有预约端口资源\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发OSPFv2 Unknown报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量Stream的OSPFv2 Unknown头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2unknown']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改ospfv2 database description头部\n    edit_header_ospfv2_unknown(Stream=stream, Level=0,\n                          RouterID='2.2.2.2', AuthType='MD5',\n                          AuthValue1=111)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Unknown_1.ospfHeader.authSelect.hdrAuthSelectNone.authValue1',\n                                               Value='111', MaxValue='111')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_unknown:修改测试仪表流量模板中OSPFv2 Unknown报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/FibreChannel.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的fc头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['fc', 'elsflogi'])\n\n    # 修改fc头部\n    attr = edit_header_fibre_channel(Stream=stream, Level=0,\n                                     DestAddr='102030')\n    edit_modifier(Stream=stream, Attribute=attr['DestAddr'],\n                  Type='Increment', Count=10, HeaderType='fc')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，指定端口物理位置。\",\n  \"子任务3\": \"在端口Port_1上创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"修改流量模板参数，设置帧长度类型为自动(AUTO)。\",\n  \"子任务5\": \"为流量模板添加报文头部，指定头部类型为fc和elsflogi。\",\n  \"子任务6\": \"修改fc头部字段，设置DestAddr初始值为'102030'。\",\n  \"子任务7\": \"配置DestAddr字段的修改器，设置为增量模式(Increment)，步长为10。\",\n  \"子任务8\": \"订阅流模板块统计视图(StreamBlockStats)。\",\n  \"子任务9\": \"配置端口发送模式为突发包(BURST)，设置突发包数量为100。\",\n  \"子任务10\": \"保存当前测试配置文件到指定路径。\",\n  \"子任务11\": \"开始发送所有流量。\",\n  \"子任务12\": \"等待流量完全停止传输。\",\n  \"子任务13\": \"等待3秒确保统计结果稳定。\",\n  \"子任务14\": \"获取流量StreamTemplate_1的流模板块统计结果。\",\n  \"子任务15\": \"验证发送帧数(TxStreamFrames)与接收帧数(RxStreamFrames)是否相等。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的fc头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['fc', 'elsflogi'])\n\n    # 修改fc头部\n    attr = edit_header_fibre_channel(Stream=stream, Level=0,\n                                     DestAddr='102030')\n    edit_modifier(Stream=stream, Attribute=attr['DestAddr'],\n                  Type='Increment', Count=10, HeaderType='fc')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetPortLatencyStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流PortAvgLatencyStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 订阅PortAvgLatencyStats统计;\n                   测试步骤4: 发送所有流量，查看PortAvgLatencyStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看PortAvgLatencyStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中PortAvgLatencyStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 订阅PortAvgLatencyStats统计视图\n    subscribe_result(Types=['PortAvgLatencyStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取PortStats所有统计结果: get_port_latency_statistic不传参数，返回值为DataFrame数据\n    result = get_port_latency_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出Port_UP的MinLatency\n    df = result[(result['PortID'] == Port_UP.Name)][['MinLatency']]\n    dict_1 = df.to_dict('records')[0]\n    # 根据DataFrame数据筛选出Port_Down的MaxLatency\n    df = result[(result['PortID'] == Port_Down.Name)][['MaxLatency']]\n    dict_2 = df.to_dict('records')[0]\n    # 判断收发包速率不为0\n    if dict_1['MinLatency'] != 0 or dict_2['MaxLatency'] != 0:\n        verdict = 'fail'\n        errInfo += f'{Port_UP.Name} MinLatency or {Port_Down.Name} MaxLatency is not equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一个端口的统计: get_port_latency_statistic传Port参数,实参只有一个元素，返回值为字典\n    result = get_port_latency_statistic(Port=Port_UP)\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_latency_statistic传Port参数, 实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_port_latency_statistic(Port=Port_UP, StaItems=['MinLatency', 'MaxLatency'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多个端口的统计:\n    # get_port_latency_statistic传Port参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_port_latency_statistic(Port=[Port_UP, Port_Down])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_latency_statistic传Port参数, 实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_latency_statistic(Port=[Port_UP, Port_Down], StaItems=['MinLatency', 'MaxLatency'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有端口的统计,并且StaItems参数指定统计项目:\n    # get_port_latency_statistic不传Port参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_latency_statistic(StaItems=['MinLatency', 'MaxLatency'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_port_latency_statistic:获取测试仪表端口时延统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试平台类型。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在端口Port_1上创建一条流量模板StreamTemplate_1。\",\n  \"子任务4\": \"订阅PortAvgLatencyStats统计视图。\",\n  \"子任务5\": \"开始发送所有流量。\",\n  \"子任务6\": \"等待10秒使统计信息稳定。\",\n  \"子任务7\": \"获取所有端口的PortAvgLatencyStats统计信息。\",\n  \"子任务8\": \"验证发送流量期间Port_1的MinLatency不为0且Port_2的MaxLatency不为0。\",\n  \"子任务9\": \"停止所有流量发送。\",\n  \"子任务10\": \"等待3秒使最终统计信息稳定。\",\n  \"子任务11\": \"获取所有端口的PortAvgLatencyStats统计信息。\",\n  \"子任务12\": \"验证停止流量后Port_1的MinLatency不为0且Port_2的MaxLatency不为0。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流PortAvgLatencyStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 订阅PortAvgLatencyStats统计;\n                   测试步骤4: 发送所有流量，查看PortAvgLatencyStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看PortAvgLatencyStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中PortAvgLatencyStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 订阅PortAvgLatencyStats统计视图\n    subscribe_result(Types=['PortAvgLatencyStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取PortStats所有统计结果: get_port_latency_statistic不传参数，返回值为DataFrame数据\n    result = get_port_latency_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出Port_UP的MinLatency\n    df = result[(result['PortID'] == Port_UP.Name)][['MinLatency']]\n    dict_1 = df.to_dict('records')[0]\n    # 根据DataFrame数据筛选出Port_Down的MaxLatency\n    df = result[(result['PortID'] == Port_Down.Name)][['MaxLatency']]\n    dict_2 = df.to_dict('records')[0]\n    # 判断收发包速率不为0\n    if dict_1['MinLatency'] != 0 or dict_2['MaxLatency'] != 0:\n        verdict = 'fail'\n        errInfo += f'{Port_UP.Name} MinLatency or {Port_Down.Name} MaxLatency is not equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一个端口的统计: get_port_latency_statistic传Port参数,实参只有一个元素，返回值为字典\n    result = get_port_latency_statistic(Port=Port_UP)\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_latency_statistic传Port参数, 实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_port_latency_statistic(Port=Port_UP, StaItems=['MinLatency', 'MaxLatency'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多个端口的统计:\n    # get_port_latency_statistic传Port参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_port_latency_statistic(Port=[Port_UP, Port_Down])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_latency_statistic传Port参数, 实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_latency_statistic(Port=[Port_UP, Port_Down], StaItems=['MinLatency', 'MaxLatency'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有端口的统计,并且StaItems参数指定统计项目:\n    # get_port_latency_statistic不传Port参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_latency_statistic(StaItems=['MinLatency', 'MaxLatency'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_port_latency_statistic:获取测试仪表端口时延统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Sctp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的sctp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'sctp'])\n\n    # 修改sctp头部\n    attr = edit_header_sctp(Stream=stream, Level=0,\n                            SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Attribute=attr['SourcePort'],\n                  Type='Increment', Count=10, HeaderType='sctp')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试平台类型。\",\n  \"子任务2\": \"预约两个自环端口（Port_1 和 Port_2），强制占用端口资源。\",\n  \"子任务3\": \"在端口 Port_1 上创建一条流量模板（StreamTemplate_1）。\",\n  \"子任务4\": \"为流量模板 StreamTemplate_1 创建报文头部，包含以太网II、IPv4 和 SCTP 协议层。\",\n  \"子任务5\": \"修改流量模板 StreamTemplate_1 的 SCTP 头部：设置源端口=1000，目的端口=2000，并配置源端口以步长10递增。\",\n  \"子任务6\": \"订阅统计视图，包括流模板块统计（StreamBlockStats）和端口统计。\",\n  \"子任务7\": \"配置端口 Port_1 的发送模式为突发包（BURST），设置突发包数量为100。\",\n  \"子任务8\": \"保存当前测试配置到指定路径的配置文件。\",\n  \"子任务9\": \"开始发送所有流量。\",\n  \"子任务10\": \"等待所有流量停止发送。\",\n  \"子任务11\": \"等待3秒确保统计结果稳定。\",\n  \"子任务12\": \"获取流量模板 StreamTemplate_1 的流模板块统计信息。\",\n  \"子任务13\": \"验证流量模板 StreamTemplate_1 的发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）且都等于100。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的sctp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'sctp'])\n\n    # 修改sctp头部\n    attr = edit_header_sctp(Stream=stream, Level=0,\n                            SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Attribute=attr['SourcePort'],\n                  Type='Increment', Count=10, HeaderType='sctp')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2TPv3DataOverIp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Data Over Ip头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3DataOverIp'])\n\n    # 修改icmpv4 echo reply头部\n    edit_header_l2tpv3_data_over_ip(Stream=stream, Level=0,\n                                    SessionId=1,\n                                    Cookie4Byte='00000001',\n                                    L2specificsublayer={'xbit': 1, 'sbit': 1, 'xbits': '000001', 'sequence': 1},)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3DataOverIp'],\n                                             FieldName='l2tpv3DataOverIp_1.sessionId',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量StreamTemplate_1，固定帧长度为512字节。\",\n  \"子任务4\": \"为流量StreamTemplate_1创建报文头部，包含EthernetII、IPv4和L2TPv3 Data Over IP三层协议。\",\n  \"子任务5\": \"修改流量StreamTemplate_1的L2TPv3头部参数：设置SessionId=1，Cookie4Byte='00000001'，L2specificsublayer的xbit=1、sbit=1、xbits='000001'、sequence=1。\",\n  \"子任务6\": \"在Port_2上创建PDU Pattern过滤规则：基于L2TPv3的SessionId字段等于1进行过滤。\",\n  \"子任务7\": \"在Port_2上应用报文过滤逻辑表达式。\",\n  \"子任务8\": \"订阅统计视图：PortStats和StreamBlockStats。\",\n  \"子任务9\": \"配置Port_1发送模式为突发包，设置突发包数量为100。\",\n  \"子任务10\": \"保存当前测试配置文件。\",\n  \"子任务11\": \"启动Port_2的数据抓包功能。\",\n  \"子任务12\": \"开始发送Port_1上的所有流量。\",\n  \"子任务13\": \"等待流量发送完成。\",\n  \"子任务14\": \"停止Port_2的数据抓包。\",\n  \"子任务15\": \"等待3秒确保统计结果稳定。\",\n  \"子任务16\": \"下载Port_2捕获的报文数据。\",\n  \"子任务17\": \"获取Port_2的捕获报文信息。\",\n  \"子任务18\": \"获取流量StreamTemplate_1的StreamBlockStats统计结果。\",\n  \"子任务19\": \"验证捕获报文数量等于发送的突发包数量(100)。\",\n  \"子任务20\": \"验证流量StreamTemplate_1的TxStreamFrames等于RxStreamFrames且都等于100。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Data Over Ip头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3DataOverIp'])\n\n    # 修改icmpv4 echo reply头部\n    edit_header_l2tpv3_data_over_ip(Stream=stream, Level=0,\n                                    SessionId=1,\n                                    Cookie4Byte='00000001',\n                                    L2specificsublayer={'xbit': 1, 'sbit': 1, 'xbits': '000001', 'sequence': 1},)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3DataOverIp'],\n                                             FieldName='l2tpv3DataOverIp_1.sessionId',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahEncapsulatedCustomerEthernet.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['mac-in-mac', 'itag', 'encapCustomerEth'])\n\n    # 修改Encapsulated Customer Ethernet头部\n    attr = edit_header_8021ah_EncapsulatedCustomerEthernet(Stream=stream, Level=0,\n                                                           EtherType='ffff')\n    edit_modifier(Stream=stream, Attribute=attr['EtherType'],\n                  Type='Increment', Count=10, HeaderType='encapCustomerEth')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口，分别命名为Port_1和Port_2。\",\n  \"子任务3\": \"在端口Port_1上创建一条流量模板StreamTemplate_1。\",\n  \"子任务4\": \"为StreamTemplate_1创建802.1ah报文头部，包含mac-in-mac、itag和encapCustomerEth三层封装。\",\n  \"子任务5\": \"修改encapCustomerEth头部的EtherType字段为0xffff，并配置该字段的跳变规则为递增模式，跳变数量为10。\",\n  \"子任务6\": \"订阅流模板块统计视图StreamBlockStats。\",\n  \"子任务7\": \"配置Port_1的发送模式为突发包模式，设置突发包数量为100。\",\n  \"子任务8\": \"保存当前测试配置到本地文件。\",\n  \"子任务9\": \"启动所有流量发送。\",\n  \"子任务10\": \"等待流量自动停止发送。\",\n  \"子任务11\": \"等待3秒确保统计结果稳定。\",\n  \"子任务12\": \"获取StreamTemplate_1的流模板块统计信息，提取发送帧数(TxStreamFrames)和接收帧数(RxStreamFrames)。\",\n  \"子任务13\": \"验证TxStreamFrames等于RxStreamFrames且都等于突发包数量(100)。\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['mac-in-mac', 'itag', 'encapCustomerEth'])\n\n    # 修改Encapsulated Customer Ethernet头部\n    attr = edit_header_8021ah_EncapsulatedCustomerEthernet(Stream=stream, Level=0,\n                                                           EtherType='ffff')\n    edit_modifier(Stream=stream, Attribute=attr['EtherType'],\n                  Type='Increment', Count=10, HeaderType='encapCustomerEth')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv2DataOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发L2TPv2 Data Over UDP报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的L2TPv2 Data Over UDP头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=272)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv2Data']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv2Data头部\n    header = edit_header_l2tpv2_data(Stream=stream, LengthOption=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Data', Attribute=header['LengthOption'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv2Data头部Sequence Number和Offset Padding节点\n    header_option = edit_header_l2tpv2_data_option(Stream=stream, Ns=1, Nr=2, Value='102030')\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Data', Attribute=header_option['Ns'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Data', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv2Data_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_l2tpv2_data:修改测试仪表流量模板中L2tpv2 Data报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量模板StreamTemplate_1，设置固定帧长272字节。\",\n  \"子任务4\": \"为流量配置报文头部协议栈：EthernetII, IPv4, UDP, L2TPv2 Data。\",\n  \"子任务5\": \"修改L2TPv2 Data头部的长度选项。\",\n  \"子任务6\": \"为L2TPv2 Data头部的长度选项配置增量跳变（Increment类型，计数10）。\",\n  \"子任务7\": \"修改L2TPv2 Data头部的Ns、Nr和Offset Padding选项值。\",\n  \"子任务8\": \"为L2TPv2 Data头部的Ns选项配置增量跳变（Increment类型，计数10）。\",\n  \"子任务9\": \"为L2TPv2 Data头部的Offset Padding选项配置增量跳变（Increment类型，计数10）。\",\n  \"子任务10\": \"在Port_2上创建抓包过滤规则：基于L2TPv2 Data头部type字段=1的PDU匹配模式。\",\n  \"子任务11\": \"在Port_2应用报文过滤逻辑表达式。\",\n  \"子任务12\": \"订阅流模板块统计视图StreamBlockStats。\",\n  \"子任务13\": \"设置Port_1的发送模式为突发包（BURST模式），突发包数量100。\",\n  \"子任务14\": \"保存当前测试配置文件。\",\n  \"子任务15\": \"启动Port_2的数据抓包功能。\",\n  \"子任务16\": \"开始发送StreamTemplate_1流量。\",\n  \"子任务17\": \"等待10秒确保流量发送完成。\",\n  \"子任务18\": \"停止所有流量发送。\",\n  \"子任务19\": \"停止Port_2的数据抓包。\",\n  \"子任务20\": \"下载Port_2捕获的报文数据包。\",\n  \"子任务21\": \"获取StreamTemplate_1的流模板块统计信息（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务22\": \"验证TxStreamFrames与RxStreamFrames统计值相等。\",\n  \"子任务23\": \"释放所有预约的仪表端口资源。\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发L2TPv2 Data Over UDP报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的L2TPv2 Data Over UDP头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=272)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv2Data']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv2Data头部\n    header = edit_header_l2tpv2_data(Stream=stream, LengthOption=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Data', Attribute=header['LengthOption'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv2Data头部Sequence Number和Offset Padding节点\n    header_option = edit_header_l2tpv2_data_option(Stream=stream, Ns=1, Nr=2, Value='102030')\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Data', Attribute=header_option['Ns'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Data', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv2Data_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_l2tpv2_data:修改测试仪表流量模板中L2tpv2 Data报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/LldpTtl.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的lldp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv', 'ttltlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_ttl_tlv(Stream=stream, Level=0, Ttl=10)\n    edit_modifier(Stream=stream, Attribute=attr['Ttl'],\n                  Type='Increment', Count=10, HeaderType='ttltlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，设置仪表平台为指定值（如DarYu）。\",\n  \"子任务2\": \"预约两个自环端口，使用指定位置信息（如//10.0.11.191/1/5和//10.0.11.191/1/6）。\",\n  \"子任务3\": \"在预约的第一个端口上创建一条流量模板。\",\n  \"子任务4\": \"修改流量模板参数，设置帧长度类型为自动（AUTO）。\",\n  \"子任务5\": \"创建流量模板的报文头部，包含以太网II、端口ID TLV和TTL TLV。\",\n  \"子任务6\": \"修改流量模板的LLDP TTL TLV，设置初始TTL值为10并配置递增跳变规则（类型Increment，计数10）。\",\n  \"子任务7\": \"订阅流模板块统计（StreamBlockStats）。\",\n  \"子任务8\": \"配置端口发送模式为突发包（BURST），设置突发包数量为100。\",\n  \"子任务9\": \"开始发送所有流量。\",\n  \"子任务10\": \"等待流量停止发送。\",\n  \"子任务11\": \"流量停止后等待3秒以确保统计结果稳定。\",\n  \"子任务12\": \"获取流量模板的流模板块统计信息。\",\n  \"子任务13\": \"验证统计信息中发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的lldp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv', 'ttltlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_ttl_tlv(Stream=stream, Level=0, Ttl=10)\n    edit_modifier(Stream=stream, Attribute=attr['Ttl'],\n                  Type='Increment', Count=10, HeaderType='ttltlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv3Query.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发IGMPv3_Query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的IGMPv3_Query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv3query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    header = edit_header_igmpv3_query(Stream=stream, Level=0,\n                                      Type=99,MaxResponseTime=255,\n                                      Checksum='ffff',GroupAddress='10.1.1.1',\n                                      SuppressFlag=1,Qrv='111',Qqic=255,NumberOfSources=65535,\n                                      SourceAddressList=['1.1.1.1', '2.2.2.2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3query', Attribute=header['SourceAddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Query_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Query_1.MaxResponseTime',\n                                               Value='255',\n                                               MaxValue='255')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Query_1.groupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv3_query:修改测试仪表流量模板中IGMPv3 Query报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表。\",\n  \"子任务2\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务3\": \"在端口 Port_1 上创建流量，并设置固定帧长度为 256 字节。\",\n  \"子任务4\": \"创建流量报文头部，包括 EthernetII、IPv4 和 IGMPv3 Query。\",\n  \"子任务5\": \"修改流量模板的 IGMPv3 Query 头部内容：设置 Type=99, MaxResponseTime=255, Checksum='ffff', GroupAddress='10.1.1.1', SuppressFlag=1, Qrv='111', Qqic=255, NumberOfSources=65535, SourceAddressList=['1.1.1.1', '2.2.2.2']。\",\n  \"子任务6\": \"修改修饰器，设置 SourceAddressList 字段为增量类型，计数为 10。\",\n  \"子任务7\": \"在端口 Port_2 上创建 PDU pattern，用于过滤 IGMPv3 Query Type 字段，值=99。\",\n  \"子任务8\": \"在端口 Port_2 上创建 PDU pattern，用于过滤 IGMPv3 Query MaxResponseTime 字段，值=255。\",\n  \"子任务9\": \"在端口 Port_2 上创建 PDU pattern，用于过滤 IGMPv3 Query GroupAddress 字段，值='10.1.1.1'。\",\n  \"子任务10\": \"在端口 Port_2 上设置抓包过滤表达式，组合所有创建的 PDU pattern。\",\n  \"子任务11\": \"订阅 StreamBlockStats 统计视图。\",\n  \"子任务12\": \"设置端口 Port_1 发送模式为突发包，突发计数为 100。\",\n  \"子任务13\": \"保存配置文件到指定路径。\",\n  \"子任务14\": \"启动抓包在端口 Port_2。\",\n  \"子任务15\": \"开始发送所有流量。\",\n  \"子任务16\": \"等待 10 秒。\",\n  \"子任务17\": \"停止发送所有流量。\",\n  \"子任务18\": \"停止抓包。\",\n  \"子任务19\": \"下载端口 Port_2 捕获的报文到本地目录。\",\n  \"子任务20\": \"获取流模板块统计信息。\",\n  \"子任务21\": \"验证流量发送帧数（TxStreamFrames）和接收帧数（RxStreamFrames）是否相等。\",\n  \"子任务22\": \"释放端口 Port_1 和 Port_2。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发IGMPv3_Query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的IGMPv3_Query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv3query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    header = edit_header_igmpv3_query(Stream=stream, Level=0,\n                                      Type=99,MaxResponseTime=255,\n                                      Checksum='ffff',GroupAddress='10.1.1.1',\n                                      SuppressFlag=1,Qrv='111',Qqic=255,NumberOfSources=65535,\n                                      SourceAddressList=['1.1.1.1', '2.2.2.2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3query', Attribute=header['SourceAddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Query_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Query_1.MaxResponseTime',\n                                               Value='255',\n                                               MaxValue='255')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Query_1.groupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv3_query:修改测试仪表流量模板中IGMPv3 Query报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4ParameterProblem.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 parameter problem报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 parameter problem头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4ParameterProblem']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 parameter problem头部\n    header = edit_header_icmp_parameter_problem(Stream=stream, Level=0, Pointer='1',\n                                       Ipv4HeaderFlags='111',\n                                       Ipv4HeaderSource='10.1.1.2',\n                                       Ipv4HeaderDestination='11.1.1.2',\n                                       Data='0000000000000001',\n                                       Ipv4HeaderDiffserveCodePointPrecedence='101010')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4ParameterProblem', Attribute=header['Data'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4ParameterProblem', Attribute=header['Ipv4HeaderDiffserveCodePointPrecedence'],\n                  Type='Increment', Count=5)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4ParameterProblem_1.pointer',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4ParameterProblem_1.headerData.ipv4Header.flags',\n                                               Value='111',\n                                               MaxValue='111')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4ParameterProblem_1.headerData.ipv4Header.destination',\n                                               Value='11.1.1.2',\n                                               MaxValue='11.1.1.2')\n    # pdu_pattern_4 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='Icmpv4ParameterProblem_1.headerData.data',\n    #                                            Value='0000000000000001',\n    #                                            MaxValue='0000000000000001')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_parameter_problem:修改测试仪表流量模板中Icmp Parameter Problem报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表平台，指定仪表型号为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，指定端口位置为//10.0.11.191/1/3和//10.0.11.191/1/4。\",\n  \"子任务3\": \"在Port_1创建流量模板，设置帧长度类型为AUTO。\",\n  \"子任务4\": \"为流量添加报文头部结构，包含EthernetII、IPv4和Icmpv4ParameterProblem三层协议。\",\n  \"子任务5\": \"修改ICMPv4 Parameter Problem头部参数：设置Level=0、Pointer='1'、Ipv4HeaderFlags='111'、源地址10.1.1.2、目的地址11.1.1.2、Data='0000000000000001'、服务类型字段'101010'。\",\n  \"子任务6\": \"为Data字段配置增量跳变规则：Type='Increment'、Count=10。\",\n  \"子任务7\": \"为服务类型字段配置增量跳变规则：Type='Increment'、Count=5。\",\n  \"子任务8\": \"在Port_2创建三个PDU匹配模式：匹配Pointer值'1'、匹配Flags值'111'、匹配目的地址'11.1.1.2'。\",\n  \"子任务9\": \"在Port_2配置抓包过滤表达式，组合三个PDU模式为逻辑与条件。\",\n  \"子任务10\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务11\": \"配置Port_1发送模式为BURST，设置突发包数量为100。\",\n  \"子任务12\": \"保存当前测试配置文件。\",\n  \"子任务13\": \"在Port_2启动抓包。\",\n  \"子任务14\": \"从Port_1开始发送所有流量。\",\n  \"子任务15\": \"等待10秒传输时间。\",\n  \"子任务16\": \"停止Port_1流量发送。\",\n  \"子任务17\": \"停止Port_2抓包。\",\n  \"子任务18\": \"下载Port_2捕获的数据包到本地目录。\",\n  \"子任务19\": \"获取流量模板的StreamBlockStats统计信息。\",\n  \"子任务20\": \"验证发送帧数(TxStreamFrames)与接收帧数(RxStreamFrames)是否相等。\",\n  \"子任务21\": \"释放所有预约的仪表端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 parameter problem报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 parameter problem头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4ParameterProblem']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 parameter problem头部\n    header = edit_header_icmp_parameter_problem(Stream=stream, Level=0, Pointer='1',\n                                       Ipv4HeaderFlags='111',\n                                       Ipv4HeaderSource='10.1.1.2',\n                                       Ipv4HeaderDestination='11.1.1.2',\n                                       Data='0000000000000001',\n                                       Ipv4HeaderDiffserveCodePointPrecedence='101010')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4ParameterProblem', Attribute=header['Data'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4ParameterProblem', Attribute=header['Ipv4HeaderDiffserveCodePointPrecedence'],\n                  Type='Increment', Count=5)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4ParameterProblem_1.pointer',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4ParameterProblem_1.headerData.ipv4Header.flags',\n                                               Value='111',\n                                               MaxValue='111')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4ParameterProblem_1.headerData.ipv4Header.destination',\n                                               Value='11.1.1.2',\n                                               MaxValue='11.1.1.2')\n    # pdu_pattern_4 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='Icmpv4ParameterProblem_1.headerData.data',\n    #                                            Value='0000000000000001',\n    #                                            MaxValue='0000000000000001')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_parameter_problem:修改测试仪表流量模板中Icmp Parameter Problem报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4EchoRequest.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 echo requset报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 echo requset头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4EchoRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改Icmpv4EchoRequest头部\n    header = edit_header_icmp_echo_request(Stream=stream, Level=0, Type='2',\n                                  Code='4', Identifier='65535', SequenceNumber='65535')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4EchoRequest', Attribute=header['Type'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoRequest_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoRequest_1.sequenceNumber',\n                                               Value='65535',\n                                               MaxValue='65535')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_echo_request:修改测试仪表流量模板中Icmp Echo Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约两个测试仪表端口：Port_1 和 Port_2。\",\n  \"子任务2\": \"创建流量模板 StreamTemplate_1 并绑定到 Port_1。\",\n  \"子任务3\": \"为 StreamTemplate_1 配置三层协议头部：EthernetII → IPv4 → Icmpv4EchoRequest。\",\n  \"子任务4\": \"修改 StreamTemplate_1 的 Icmpv4EchoRequest 头部参数：Type=2, Code=4, Identifier=65535, SequenceNumber=65535。\",\n  \"子任务5\": \"为 StreamTemplate_1 的 Icmpv4EchoRequest Type 字段配置递增跳变规则：增量步长=1, 跳变次数=10。\",\n  \"子任务6\": \"在 Port_2 创建两个 PDU 过滤模式：匹配 Icmpv4EchoRequest.identifier=65535 和 Icmpv4EchoRequest.sequenceNumber=65535。\",\n  \"子任务7\": \"为 Port_2 设置抓包过滤表达式：逻辑与组合两个 PDU 过滤模式。\",\n  \"子任务8\": \"订阅 StreamBlockStats 统计视图用于流量监控。\",\n  \"子任务9\": \"配置 Port_1 发送模式为突发包模式，设置突发包数量=100。\",\n  \"子任务10\": \"启动 Port_2 抓包功能。\",\n  \"子任务11\": \"启动 Port_1 流量发送。\",\n  \"子任务12\": \"等待 10 秒确保流量发送完成。\",\n  \"子任务13\": \"停止 Port_1 流量发送。\",\n  \"子任务14\": \"停止 Port_2 抓包功能。\",\n  \"子任务15\": \"获取 StreamTemplate_1 的 StreamBlockStats 统计数据。\",\n  \"子任务16\": \"验证 TxStreamFrames 等于 RxStreamFrames（收发包数量相等）。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 echo requset报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 echo requset头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4EchoRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改Icmpv4EchoRequest头部\n    header = edit_header_icmp_echo_request(Stream=stream, Level=0, Type='2',\n                                  Code='4', Identifier='65535', SequenceNumber='65535')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4EchoRequest', Attribute=header['Type'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoRequest_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoRequest_1.sequenceNumber',\n                                               Value='65535',\n                                               MaxValue='65535')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_echo_request:修改测试仪表流量模板中Icmp Echo Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ppp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ppp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ppp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ppp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ppp头部\n    header_dict = edit_header_ppp(Stream=stream, Level=0, Protocol='0001', Controls='11', Addresses='22')\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='ppp', Attribute=header_dict['Protocol'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=1,\n                                               Attribute=header_dict['Protocol'],\n                                               Value='0001', MaxValue='000A')\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ppp_1.protocol',\n    #                                            Value='0001', MaxValue='0001')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ppp:修改测试仪表流量模板中PPP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型\",\n  \"子任务2\": \"预约两个自环端口，使用输入参数指定端口位置\",\n  \"子任务3\": \"在第一个预约端口上创建流量，设置固定帧长度为256字节\",\n  \"子任务4\": \"为流量添加以太网和PPP报文头部\",\n  \"子任务5\": \"修改PPP报文头部：设置协议字段为'0001'，控制字段为'11'，地址字段为'22'\",\n  \"子任务6\": \"配置PPP协议字段的跳变：类型为递增，跳变数量为10\",\n  \"子任务7\": \"在第二个端口创建PDU抓包模式：匹配PPP协议字段，值范围从'0001'到'000A'\",\n  \"子任务8\": \"在第二个端口设置报文过滤逻辑表达式\",\n  \"子任务9\": \"订阅StreamBlockStats统计视图\",\n  \"子任务10\": \"设置第一个端口的发送模式为突发包，突发包数量为100\",\n  \"子任务11\": \"保存当前测试配置文件\",\n  \"子任务12\": \"启动第二个端口的数据抓包\",\n  \"子任务13\": \"开始发送流量\",\n  \"子任务14\": \"等待10秒\",\n  \"子任务15\": \"停止发送流量\",\n  \"子任务16\": \"停止数据抓包\",\n  \"子任务17\": \"获取流量的StreamBlockStats统计结果\",\n  \"子任务18\": \"验证流量发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)\",\n  \"子任务19\": \"释放所有预约的端口资源\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ppp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ppp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ppp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ppp头部\n    header_dict = edit_header_ppp(Stream=stream, Level=0, Protocol='0001', Controls='11', Addresses='22')\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='ppp', Attribute=header_dict['Protocol'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=1,\n                                               Attribute=header_dict['Protocol'],\n                                               Value='0001', MaxValue='000A')\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ppp_1.protocol',\n    #                                            Value='0001', MaxValue='0001')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ppp:修改测试仪表流量模板中PPP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv1Query.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发IGMPv1_Query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的IGMPv1_Query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IGMPv1Query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    header = edit_header_igmpv1_query(Stream=stream, Level=0, Type=99, Unused=255, Checksum='ffff',\n                             GroupAddress='10.1.1.1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IGMPv1Query', Attribute=header['GroupAddress'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1Query_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1Query_1.unused',\n                                               Value='255',\n                                               MaxValue='255')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv1_query:修改测试仪表流量模板中IGMPv1 Query报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约测试仪表的两个自环端口Port_1和Port_2。\",\n  \"子任务2\": \"在Port_1上创建流量模板StreamTemplate_1，设置固定帧长度为256字节。\",\n  \"子任务3\": \"为StreamTemplate_1配置报文头部结构：EthernetII > IPv4 > IGMPv1Query。\",\n  \"子任务4\": \"修改StreamTemplate_1的IGMPv1Query头部：Type=99, Unused=255, Checksum='ffff', GroupAddress='10.1.1.1'。\",\n  \"子任务5\": \"配置StreamTemplate_1的GroupAddress字段跳变规则：增量递增，计数10次。\",\n  \"子任务6\": \"在Port_2创建两个PDU匹配模式：1) IGMPv1Query.Type=99 2) IGMPv1Query.Unused=255。\",\n  \"子任务7\": \"在Port_2设置抓包过滤条件：同时满足Type=99和Unused=255的报文。\",\n  \"子任务8\": \"订阅StreamBlockStats统计视图用于流量监控。\",\n  \"子任务9\": \"配置Port_1的发送模式为突发包模式，突发包数量设置为100。\",\n  \"子任务10\": \"保存当前测试仪表配置文件。\",\n  \"子任务11\": \"启动Port_2的抓包功能。\",\n  \"子任务12\": \"启动Port_1的流量发送。\",\n  \"子任务13\": \"等待10秒确保流量发送完成。\",\n  \"子任务14\": \"停止Port_1的流量发送。\",\n  \"子任务15\": \"停止Port_2的抓包功能。\",\n  \"子任务16\": \"下载Port_2捕获的报文数据。\",\n  \"子任务17\": \"获取StreamTemplate_1的流量统计结果（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务18\": \"验证StreamTemplate_1的收发包数量相等：TxStreamFrames == RxStreamFrames。\",\n  \"子任务19\": \"释放预约的端口Port_1和Port_2。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发IGMPv1_Query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的IGMPv1_Query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IGMPv1Query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    header = edit_header_igmpv1_query(Stream=stream, Level=0, Type=99, Unused=255, Checksum='ffff',\n                             GroupAddress='10.1.1.1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IGMPv1Query', Attribute=header['GroupAddress'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1Query_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1Query_1.unused',\n                                               Value='255',\n                                               MaxValue='255')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv1_query:修改测试仪表流量模板中IGMPv1 Query报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Fragment.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Fragment头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6fragmentheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_fragment(Stream=stream, Ident=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6fragmentheader', Attribute=attr['Ident'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约两个端口资源，位置为'//10.0.11.191/1/5'和'//10.0.11.191/1/6'。\",\n  \"子任务3\": \"在Port_1创建流量模板StreamTemplate_1，设置固定帧长为256字节。\",\n  \"子任务4\": \"为流量配置三层报文头部：EthernetII → IPv6 → IPv6分片头部。\",\n  \"子任务5\": \"编辑IPv6分片头部标识符(Ident)初始值为10。\",\n  \"子任务6\": \"配置IPv6分片头部标识符的跳变规则：增量(Increment)模式，计数10次，步长2。\",\n  \"子任务7\": \"订阅流模板块统计视图(StreamBlockStats)用于结果采集。\",\n  \"子任务8\": \"配置Port_1发送模式为突发包(BURST)，设置突发包数量为100。\",\n  \"子任务9\": \"保存当前测试配置文件到指定路径。\",\n  \"子任务10\": \"启动流量发送。\",\n  \"子任务11\": \"等待10秒确保流量持续发送。\",\n  \"子任务12\": \"停止所有流量发送。\",\n  \"子任务13\": \"获取StreamTemplate_1的流模板块统计结果。\",\n  \"子任务14\": \"验证统计结果中发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\",\n  \"子任务15\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Fragment头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6fragmentheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_fragment(Stream=stream, Ident=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6fragmentheader', Attribute=attr['Ident'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl2lspHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, )\n    edit_stream(Stream=stream, FrameLengthType='Auto')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2lspheader'])\n\n    header = edit_header_isis_lsp(Stream=stream,\n                                  LengthIndicator=10,\n                                  LspisIsTlvOptionSet=['IsIsAreaAddress', 'IsIsReachability', 'ExtendedReachability',\n                                    'IsIsIpInterReachability', 'IsIsProtocolsSupported', 'IsIsIPExternalReachability',\n                                    'IpInterfaceAddress', 'Ipv6InterfaceAddress', 'IsIsIpv6Reachability'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2lspheader', Attribute=header['LengthIndicator'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsAreaAddress', AreaAddressEntries=2)\n    edit_header_isis_area_address_entry(Stream=stream, TlvLength=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsReachability', Index=1, MetricEntries=1)\n    edit_header_isis_metric_entry(Stream=stream, TlvIndex=1, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='extendedReachability', Index=2,\n                                IisNeighborSubTlv=['AdGroupSubtlv', 'Ipv4InterfaceAddressSubtlv', 'Ipv4NeighborAddressSubtlv',\n                                      'MaxLinkBandwidthSubtlv', 'ReservableLinkBandwidthSubtlv', 'UnReservedBandwidthSubtlv',\n                                      'InterfaceIpv6Subtlv', 'NeigbhorIpv6Subtlv'])\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='AdGroupSubtlv', TlvIndex=2, SubTlvIndex=0, TlvCode=20)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4InterfaceAddressSubtlv', TlvIndex=2, SubTlvIndex=1, Ipv4InterfaceAddressValue='1.1.1.1')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4NeighborAddressSubtlv', TlvIndex=2, SubTlvIndex=2, Ipv4NeighborAddressValue='2.2.2.2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='MaxLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=3, MaxBandwidthValue=30)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='ReservableLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=4, ReservableLinkBandwidthValue=40)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='UnReservedBandwidthSubtlv', TlvIndex=2, SubTlvIndex=5, ResBandwidth0Value=50)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='InterfaceIpv6Subtlv', TlvIndex=2, SubTlvIndex=6, InterfaceIpv6Value='2022::2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='NeigbhorIpv6Subtlv', TlvIndex=2, SubTlvIndex=7, Neighboripv6Value='2033::3')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsIpInterReachability', Index=3, InternalmetricEntries=1)\n    edit_header_isis_internal_metric_entry(Stream=stream, TlvIndex=3, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IpInterfaceAddress', Index=6, Ipv4InterfaceAddress=['1.1.1.1', '2.2.2.2'])\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Ipv6InterfaceAddress', Index=7, Ipv6InterfaceAddress=['2022::2', '2033::3'])\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    # start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容",
      "edit_header_isis_internal_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容",
      "edit_header_isis_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容",
      "edit_header_isis_sub_tlv:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Sub Tlv内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约测试仪表的两个自环端口 Port_1 和 Port_2。\",\n  \"子任务2\": \"在端口 Port_1 上创建流量 StreamTemplate_1。\",\n  \"子任务3\": \"修改流量 StreamTemplate_1 的 ISIS LSP 报文头部内容，包括设置长度指示器和配置 TLV 选项集。\",\n  \"子任务4\": \"配置 ISIS TLV 头部参数：Area Address 条目数量、Metric 条目参数、Extended Reachability 子 TLV 参数等。\",\n  \"子任务5\": \"订阅 StreamBlockStats 统计视图以监控流量统计。\",\n  \"子任务6\": \"设置端口 Port_1 的发送模式为突发模式，指定突发包数量。\",\n  \"子任务7\": \"启动所有流量发送。\",\n  \"子任务8\": \"等待流量发送完成并进入停止状态。\",\n  \"子任务9\": \"停止所有流量发送。\",\n  \"子任务10\": \"获取流量 StreamTemplate_1 的 StreamBlockStats 统计信息，包括发送帧数(TxStreamFrames)和接收帧数(RxStreamFrames)。\",\n  \"子任务11\": \"验证流量 StreamTemplate_1 的收发包数量相等：TxStreamFrames 等于 RxStreamFrames。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, )\n    edit_stream(Stream=stream, FrameLengthType='Auto')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2lspheader'])\n\n    header = edit_header_isis_lsp(Stream=stream,\n                                  LengthIndicator=10,\n                                  LspisIsTlvOptionSet=['IsIsAreaAddress', 'IsIsReachability', 'ExtendedReachability',\n                                    'IsIsIpInterReachability', 'IsIsProtocolsSupported', 'IsIsIPExternalReachability',\n                                    'IpInterfaceAddress', 'Ipv6InterfaceAddress', 'IsIsIpv6Reachability'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2lspheader', Attribute=header['LengthIndicator'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsAreaAddress', AreaAddressEntries=2)\n    edit_header_isis_area_address_entry(Stream=stream, TlvLength=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsReachability', Index=1, MetricEntries=1)\n    edit_header_isis_metric_entry(Stream=stream, TlvIndex=1, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='extendedReachability', Index=2,\n                                IisNeighborSubTlv=['AdGroupSubtlv', 'Ipv4InterfaceAddressSubtlv', 'Ipv4NeighborAddressSubtlv',\n                                      'MaxLinkBandwidthSubtlv', 'ReservableLinkBandwidthSubtlv', 'UnReservedBandwidthSubtlv',\n                                      'InterfaceIpv6Subtlv', 'NeigbhorIpv6Subtlv'])\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='AdGroupSubtlv', TlvIndex=2, SubTlvIndex=0, TlvCode=20)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4InterfaceAddressSubtlv', TlvIndex=2, SubTlvIndex=1, Ipv4InterfaceAddressValue='1.1.1.1')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4NeighborAddressSubtlv', TlvIndex=2, SubTlvIndex=2, Ipv4NeighborAddressValue='2.2.2.2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='MaxLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=3, MaxBandwidthValue=30)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='ReservableLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=4, ReservableLinkBandwidthValue=40)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='UnReservedBandwidthSubtlv', TlvIndex=2, SubTlvIndex=5, ResBandwidth0Value=50)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='InterfaceIpv6Subtlv', TlvIndex=2, SubTlvIndex=6, InterfaceIpv6Value='2022::2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='NeigbhorIpv6Subtlv', TlvIndex=2, SubTlvIndex=7, Neighboripv6Value='2033::3')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsIpInterReachability', Index=3, InternalmetricEntries=1)\n    edit_header_isis_internal_metric_entry(Stream=stream, TlvIndex=3, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IpInterfaceAddress', Index=6, Ipv4InterfaceAddress=['1.1.1.1', '2.2.2.2'])\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Ipv6InterfaceAddress', Index=7, Ipv6InterfaceAddress=['2022::2', '2033::3'])\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    # start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容;\nedit_header_isis_internal_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容;\nedit_header_isis_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容;\nedit_header_isis_sub_tlv:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Sub Tlv内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Gre.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的GRE头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'gre'])\n\n    # 修改gre头部\n    edit_header_gre(Stream=stream, Level=0,\n                    ChecksumPresent=1,\n                    Routing=1,\n                    Protocol=6558,\n                    Checksum=123,\n                    ChecksumReserved=123,\n                    SequenceNumber=2,\n                    Key=1)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'gre'],\n                                             FieldName='gre_1.routing',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_gre:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约两个自环端口，使用给定的位置信息。\",\n  \"子任务3\": \"在端口Port_1上创建一条流量。\",\n  \"子任务4\": \"为创建的流量添加EthernetII、IPv4和GRE报文头部。\",\n  \"子任务5\": \"修改流量的GRE头部参数（包括ChecksumPresent、Routing、Protocol等）。\",\n  \"子任务6\": \"在端口Port_2上创建PDU捕获模式，指定过滤条件为GRE头部的routing字段值为1。\",\n  \"子任务7\": \"在端口Port_2上配置报文过滤逻辑表达式。\",\n  \"子任务8\": \"订阅PortStats和StreamBlockStats统计视图。\",\n  \"子任务9\": \"配置端口Port_1的负载为突发模式，设置突发包数量。\",\n  \"子任务10\": \"保存当前测试配置文件。\",\n  \"子任务11\": \"启动端口Port_2的数据抓包功能。\",\n  \"子任务12\": \"开始发送所有流量。\",\n  \"子任务13\": \"等待流量发送完成。\",\n  \"子任务14\": \"停止端口Port_2的数据抓包。\",\n  \"子任务15\": \"等待3秒确保统计结果稳定。\",\n  \"子任务16\": \"下载端口Port_2捕获的报文数据。\",\n  \"子任务17\": \"获取端口Port_2的捕获报文信息。\",\n  \"子任务18\": \"验证捕获报文数量与突发包数量相等。\",\n  \"子任务19\": \"获取流量StreamBlockStats统计信息。\",\n  \"子任务20\": \"验证流量统计中发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)且等于突发包数量。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的GRE头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'gre'])\n\n    # 修改gre头部\n    edit_header_gre(Stream=stream, Level=0,\n                    ChecksumPresent=1,\n                    Routing=1,\n                    Protocol=6558,\n                    Checksum=123,\n                    ChecksumReserved=123,\n                    SequenceNumber=2,\n                    Key=1)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'gre'],\n                                             FieldName='gre_1.routing',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_gre:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2LinkStateAcknowledgeInstance.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 link state acknowledge报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ospfv2 link state acknowledge头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstateacknowledge']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改ospfv2 database description头部\n    edit_header_ospfv2_ack(Stream=stream, Level=0,\n                          RouterID='2.2.2.2', AuthType='MD5')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2LinkStateAcknowledge_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_ack:修改测试仪表流量模板中OSPFv2 Link State Acknowledge报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型。\",\n  \"子任务2\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务3\": \"在 Port_1 上创建流量流，设置固定帧长度为 256 字节。\",\n  \"子任务4\": \"为流量流添加报文头部：EthernetII、IPv4、OSPFv2 Link State Acknowledge。\",\n  \"子任务5\": \"修改 OSPFv2 Link State Acknowledge 头部，设置 Router ID 为 '2.2.2.2'，认证类型为 'MD5'。\",\n  \"子任务6\": \"在 Port_2 创建捕获 PDU 模式，过滤条件为 OSPFv2 Link State Acknowledge 报文中 Router ID 等于 '2.2.2.2'。\",\n  \"子任务7\": \"在 Port_2 设置报文捕获过滤器，应用步骤6创建的 PDU 模式。\",\n  \"子任务8\": \"订阅 StreamBlockStats 统计视图。\",\n  \"子任务9\": \"配置 Port_1 的发送模式为突发包，设置突发包数量为 100。\",\n  \"子任务10\": \"启动 Port_2 的报文捕获功能。\",\n  \"子任务11\": \"从 Port_1 开始发送流量流。\",\n  \"子任务12\": \"等待 10 秒以确保流量传输完成。\",\n  \"子任务13\": \"停止 Port_1 的流量发送。\",\n  \"子任务14\": \"停止 Port_2 的报文捕获。\",\n  \"子任务15\": \"等待 3 秒确保统计信息稳定。\",\n  \"子任务16\": \"获取流量流的 StreamBlockStats 统计结果。\",\n  \"子任务17\": \"验证统计结果中发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\",\n  \"子任务18\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 link state acknowledge报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ospfv2 link state acknowledge头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstateacknowledge']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改ospfv2 database description头部\n    edit_header_ospfv2_ack(Stream=stream, Level=0,\n                          RouterID='2.2.2.2', AuthType='MD5')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2LinkStateAcknowledge_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_ack:修改测试仪表流量模板中OSPFv2 Link State Acknowledge报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4DestUnreach.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 dest unreach报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 dest unreach头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'DestUnreach']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 dest unreach头部\n    header = edit_header_icmp_dest_unreach(Stream=stream, Level=0, Unused='0',\n                                  Ipv4HeaderTosPrecedence='000', Ipv4HeaderTosDelay='0',\n                                  Ipv4HeaderTosThroughput='1', Ipv4HeaderTosReliability='0',\n                                  Ipv4HeaderTosMonetaryCost='0', Ipv4HeaderTosReserved='0',\n                                  Ipv4HeaderFlags='001', Ipv4HeaderOffset='0', Ipv4HeaderTTL='200',\n                                  Ipv4HeaderSource='10.1.1.2', Ipv4HeaderDestination='20.1.1.2',\n                                  Ipv4HeaderGateway='10.1.1.1', Ipv4HeaderHeaderOption='LooseSourceRoute')\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=header['Unused'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=header['Ipv4HeaderSource'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=header['Ipv4HeaderTosPrecedence'],\n                  Type='Increment', Count=5)\n\n    option = edit_header_ipv4_option(Stream=stream, Index=0, Option='LooseSourceRoute', Header='destunreach',\n                            Pointer=1, Optiontype=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=option['Pointer'],\n                  Type='Increment', Count=5)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destUnreach_1.headerData.ipv4Header.tos.tos.throughput',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destUnreach_1.headerData.ipv4Header.source',\n                                               Value='10.1.1.2',\n                                               MaxValue='10.1.1.2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destUnreach_1.headerData.ipv4Header.destination',\n                                               Value='20.1.1.2 ',\n                                               MaxValue='20.1.1.2 ')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容",
      "edit_header_icmp_dest_unreach:修改测试仪表流量模板中Icmp Dest Unreach报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"创建流量模板StreamTemplate_1，设置固定帧长为256字节。\",\n  \"子任务4\": \"为流量模板创建报文头部：EthernetII、IPv4和ICMPv4 Destination Unreachable。\",\n  \"子任务5\": \"修改ICMPv4 Destination Unreachable报文头部参数：Level=0, Unused=0, TOS参数(Throughput=1), Flags=001, TTL=200, 源地址=10.1.1.2, 目的地址=20.1.1.2, 网关=10.1.1.1, 选项=LooseSourceRoute。\",\n  \"子任务6\": \"设置报文头部跳变域：Unused字段递增10次，IPv4源地址递增10次，TOS Precedence递增5次，IPv4选项Pointer递增5次。\",\n  \"子任务7\": \"在Port_2配置抓包过滤条件：IPv4 TOS Throughput=1 && 源地址=10.1.1.2 && 目的地址=20.1.1.2。\",\n  \"子任务8\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务9\": \"设置Port_1发送模式为突发包模式，突发包数量=100。\",\n  \"子任务10\": \"启动Port_2抓包功能。\",\n  \"子任务11\": \"开始发送所有流量。\",\n  \"子任务12\": \"等待10秒传输时间。\",\n  \"子任务13\": \"停止所有流量发送。\",\n  \"子任务14\": \"停止Port_2抓包功能。\",\n  \"子任务15\": \"获取StreamTemplate_1的StreamBlockStats统计信息。\",\n  \"子任务16\": \"验证发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\",\n  \"子任务17\": \"释放所有预约端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 dest unreach报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 dest unreach头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'DestUnreach']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 dest unreach头部\n    header = edit_header_icmp_dest_unreach(Stream=stream, Level=0, Unused='0',\n                                  Ipv4HeaderTosPrecedence='000', Ipv4HeaderTosDelay='0',\n                                  Ipv4HeaderTosThroughput='1', Ipv4HeaderTosReliability='0',\n                                  Ipv4HeaderTosMonetaryCost='0', Ipv4HeaderTosReserved='0',\n                                  Ipv4HeaderFlags='001', Ipv4HeaderOffset='0', Ipv4HeaderTTL='200',\n                                  Ipv4HeaderSource='10.1.1.2', Ipv4HeaderDestination='20.1.1.2',\n                                  Ipv4HeaderGateway='10.1.1.1', Ipv4HeaderHeaderOption='LooseSourceRoute')\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=header['Unused'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=header['Ipv4HeaderSource'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=header['Ipv4HeaderTosPrecedence'],\n                  Type='Increment', Count=5)\n\n    option = edit_header_ipv4_option(Stream=stream, Index=0, Option='LooseSourceRoute', Header='destunreach',\n                            Pointer=1, Optiontype=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=option['Pointer'],\n                  Type='Increment', Count=5)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destUnreach_1.headerData.ipv4Header.tos.tos.throughput',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destUnreach_1.headerData.ipv4Header.source',\n                                               Value='10.1.1.2',\n                                               MaxValue='10.1.1.2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destUnreach_1.headerData.ipv4Header.destination',\n                                               Value='20.1.1.2 ',\n                                               MaxValue='20.1.1.2 ')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容;\nedit_header_icmp_dest_unreach:修改测试仪表流量模板中Icmp Dest Unreach报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/vxlan.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的vxlan头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4', 'udp', 'vxlan'])\n\n    # 修改vxlan头部\n    attr = edit_header_vxlan(Stream=stream, Vni=1000)\n    edit_modifier(Stream=stream, Attribute=attr['Vni'],\n                  Type='Increment', Count=10, HeaderType='vxlan')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口（Port_1和Port_2），建立物理连接。\",\n  \"子任务3\": \"在Port_1端口上创建一条流量模板StreamTemplate_1。\",\n  \"子任务4\": \"配置流量StreamTemplate_1的帧长度类型为自动（AUTO）。\",\n  \"子任务5\": \"为流量StreamTemplate_1构建报文头部结构，包括以太网II、VLAN、IPv4、UDP和VXLAN协议层。\",\n  \"子任务6\": \"修改流量StreamTemplate_1的VXLAN头部：设置VNI初始值为1000，并配置VNI字段的增量修改器（步长为1，计数10次）。\",\n  \"子任务7\": \"订阅流模板块统计（StreamBlockStats）视图以捕获统计信息。\",\n  \"子任务8\": \"配置Port_1端口的发送模式为突发（BURST），设置突发包数量为100。\",\n  \"子任务9\": \"启动所有流量发送。\",\n  \"子任务10\": \"等待流量自动停止（发送完成状态检测）。\",\n  \"子任务11\": \"流量停止后等待3秒确保统计结果稳定。\",\n  \"子任务12\": \"获取流量StreamTemplate_1的流模板块统计信息，提取发送帧数（TxStreamFrames）和接收帧数（RxStreamFrames）。\",\n  \"子任务13\": \"验证统计结果：TxStreamFrames等于RxStreamFrames。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的vxlan头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4', 'udp', 'vxlan'])\n\n    # 修改vxlan头部\n    attr = edit_header_vxlan(Stream=stream, Vni=1000)\n    edit_modifier(Stream=stream, Attribute=attr['Vni'],\n                  Type='Increment', Count=10, HeaderType='vxlan')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6EchoRequest.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 echo request报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 echo request头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'icmpv6echorequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv6echorequest头部\n    edit_header_icmpv6_echo_request(Stream=stream, Level=0,\n                          Identifier='65535',SequenceNumber='65535')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoRequest_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoRequest_1.sequenceNumber',\n                                               Value='65535',\n                                               MaxValue='65535')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_echo_request:修改测试仪表流量模板中Icmpv6 Echo Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务3\": \"在 Port_1 创建基础流量模板，设置固定帧长度 256 字节。\",\n  \"子任务4\": \"为流量模板创建三层协议头部：EthernetII + IPv6 + icmpv6echorequest。\",\n  \"子任务5\": \"修改 icmpv6 echo request 头部参数：Identifier=65535, SequenceNumber=65535。\",\n  \"子任务6\": \"在 Port_2 创建基于 Identifier 的 PDU 匹配模式。\",\n  \"子任务7\": \"在 Port_2 创建基于 SequenceNumber 的 PDU 匹配模式。\",\n  \"子任务8\": \"在 Port_2 设置逻辑与（&&）的抓包过滤表达式组合两个匹配模式。\",\n  \"子任务9\": \"订阅 StreamBlockStats 统计视图。\",\n  \"子任务10\": \"配置 Port_1 发送模式为突发包（BURST），突发包数 100。\",\n  \"子任务11\": \"保存当前测试配置文件。\",\n  \"子任务12\": \"启动 Port_2 抓包功能。\",\n  \"子任务13\": \"开始从 Port_1 发送流量。\",\n  \"子任务14\": \"等待 10 秒传输时间。\",\n  \"子任务15\": \"停止 Port_1 流量发送。\",\n  \"子任务16\": \"停止 Port_2 抓包功能。\",\n  \"子任务17\": \"下载 Port_2 捕获的报文数据包到本地存储。\",\n  \"子任务18\": \"获取流量模板的 StreamBlockStats 统计信息。\",\n  \"子任务19\": \"验证发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\",\n  \"子任务20\": \"释放所有预约的仪表端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 echo request报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 echo request头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'icmpv6echorequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv6echorequest头部\n    edit_header_icmpv6_echo_request(Stream=stream, Level=0,\n                          Identifier='65535',SequenceNumber='65535')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoRequest_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoRequest_1.sequenceNumber',\n                                               Value='65535',\n                                               MaxValue='65535')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_echo_request:修改测试仪表流量模板中Icmpv6 Echo Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Custom.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发custom报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的custom头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'custom']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改custom头部\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='1212121212', Checksum='Auto')\n    print(attribute_dict)\n    result = edit_header_custom(Stream=stream, Level=0, Pattern='0343434343', Checksum='Auto')\n    print(attribute_dict)\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='2323232323', Checksum='Auto')\n    print(attribute_dict)\n\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='0565656565', Index=0)\n    print(attribute_dict)\n    edit_modifier(Stream=stream, Level=0, HeaderType='custom', Attribute=attribute_dict['Pattern'], Type='Increment', Count=10, Step=2)\n\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='0787878787', Index=2)\n    print(attribute_dict)\n    edit_modifier(Stream=stream, Level=0, HeaderType='custom', Attribute=attribute_dict['Pattern'], Type='Random', Range='1787878787')\n\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='5656565656', Index=4)\n    print(attribute_dict)\n    edit_modifier(Stream=stream, Level=0, HeaderType='custom', Attribute=attribute_dict['Pattern'], Type='List', List=['5656565657', '5656565658', '5656565659'])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_custom:修改测试仪表流量模板中Custom报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口（Port_1和Port_2）。\",\n  \"子任务3\": \"创建流量模板并构建报文头部（包含EthernetII、IPv4和custom三层头部）。\",\n  \"子任务4\": \"修改流量模板的custom头部内容，包括设置特定Pattern值并配置三种跳变域（递增、随机和列表类型）。\",\n  \"子任务5\": \"订阅StreamBlockStats统计视图用于后续结果采集。\",\n  \"子任务6\": \"设置端口发送模式为突发包模式，并指定突发包数量。\",\n  \"子任务7\": \"启动端口抓包功能准备捕获流量。\",\n  \"子任务8\": \"开始发送流量并持续指定时间（10秒）。\",\n  \"子任务9\": \"停止流量发送并终止抓包过程。\",\n  \"子任务10\": \"获取流量模板的StreamBlockStats统计信息。\",\n  \"子任务11\": \"验证流量收发包数量相等（TxStreamFrames等于RxStreamFrames）。\",\n  \"子任务12\": \"释放已预约的两个自环端口资源。\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发custom报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的custom头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'custom']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改custom头部\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='1212121212', Checksum='Auto')\n    print(attribute_dict)\n    result = edit_header_custom(Stream=stream, Level=0, Pattern='0343434343', Checksum='Auto')\n    print(attribute_dict)\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='2323232323', Checksum='Auto')\n    print(attribute_dict)\n\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='0565656565', Index=0)\n    print(attribute_dict)\n    edit_modifier(Stream=stream, Level=0, HeaderType='custom', Attribute=attribute_dict['Pattern'], Type='Increment', Count=10, Step=2)\n\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='0787878787', Index=2)\n    print(attribute_dict)\n    edit_modifier(Stream=stream, Level=0, HeaderType='custom', Attribute=attribute_dict['Pattern'], Type='Random', Range='1787878787')\n\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='5656565656', Index=4)\n    print(attribute_dict)\n    edit_modifier(Stream=stream, Level=0, HeaderType='custom', Attribute=attribute_dict['Pattern'], Type='List', List=['5656565657', '5656565658', '5656565659'])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_custom:修改测试仪表流量模板中Custom报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4TimeExceeded.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 time exceeded报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 time exceeded头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimeExceeded']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 time exceeded头部\n    edit_header_icmp_time_exceeded(Stream=stream, Level=0,\n                                   Ipv4HeaderTosPrecedence='001', Ipv4HeaderID='100',\n                                   Ipv4HeaderProtocol='1', Ipv4HeaderPadding='11')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceeded_1.headerData.ipv4Header.tos.tos.precedence',\n                                               Value='001', MaxValue='001')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceeded_1.headerData.ipv4Header.id',\n                                               Value='100',\n                                               MaxValue='100')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceeded_1.headerData.ipv4Header.protocol',\n                                               Value='1',\n                                               MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_time_exceeded:修改测试仪表流量模板中Icmp Time Exceeded报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口（Port_1和Port_2）。\",\n  \"子任务3\": \"在发送端口（Port_1）上创建流量模板（StreamTemplate_1），指定固定帧长度。\",\n  \"子任务4\": \"为流量模板创建三层协议头部：EthernetII、IPv4、ICMPv4 Time Exceeded。\",\n  \"子任务5\": \"修改流量模板的ICMPv4 Time Exceeded头部参数：设置IP TOS precedence、ID、Protocol和Padding字段。\",\n  \"子任务6\": \"在接收端口（Port_2）上创建PDU匹配模式，定义IPv4头部字段过滤条件（TOS precedence、ID、Protocol）。\",\n  \"子任务7\": \"在接收端口配置报文过滤逻辑表达式，组合多个PDU匹配模式。\",\n  \"子任务8\": \"订阅流模板块统计视图（StreamBlockStats）用于结果收集。\",\n  \"子任务9\": \"配置发送端口负载参数：设置发送模式为突发包，指定突发包数量。\",\n  \"子任务10\": \"启动接收端口的抓包功能。\",\n  \"子任务11\": \"启动流量发送（从Port_1发送StreamTemplate_1）。\",\n  \"子任务12\": \"等待指定时间使流量发送完成。\",\n  \"子任务13\": \"停止所有流量发送。\",\n  \"子任务14\": \"停止端口抓包。\",\n  \"子任务15\": \"获取流模板块统计结果，提取发送帧数（TxStreamFrames）和接收帧数（RxStreamFrames）。\",\n  \"子任务16\": \"验证统计结果：判断StreamTemplate_1的发送帧数与接收帧数是否相等。\",\n  \"子任务17\": \"释放所有预约的测试仪表端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 time exceeded报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 time exceeded头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimeExceeded']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 time exceeded头部\n    edit_header_icmp_time_exceeded(Stream=stream, Level=0,\n                                   Ipv4HeaderTosPrecedence='001', Ipv4HeaderID='100',\n                                   Ipv4HeaderProtocol='1', Ipv4HeaderPadding='11')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceeded_1.headerData.ipv4Header.tos.tos.precedence',\n                                               Value='001', MaxValue='001')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceeded_1.headerData.ipv4Header.id',\n                                               Value='100',\n                                               MaxValue='100')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceeded_1.headerData.ipv4Header.protocol',\n                                               Value='1',\n                                               MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_time_exceeded:修改测试仪表流量模板中Icmp Time Exceeded报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Rtag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的r tag头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['rtag', 'ipv4'])\n\n    # 修改rtag头部\n    attr = edit_header_r_tag(Stream=stream, Level=0,\n                             Reserved=4095)\n    edit_modifier(Stream=stream, Attribute=attr['Reserved'],\n                  Type='Increment', Count=10, HeaderType='rtag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型（如DarYu）。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，指定端口物理位置。\",\n  \"子任务3\": \"在端口Port_1上创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"为流量StreamTemplate_1添加报文头部，指定头部类型为rtag和ipv4。\",\n  \"子任务5\": \"修改流量StreamTemplate_1的rtag头部字段，配置Reserved属性值并设置跳变规则（如递增类型、步长和计数）。\",\n  \"子任务6\": \"订阅流模板块统计视图StreamBlockStats。\",\n  \"子任务7\": \"配置端口Port_1的流量发送模式为突发模式，指定突发包数量。\",\n  \"子任务8\": \"开始发送所有流量。\",\n  \"子任务9\": \"等待流量完全停止发送。\",\n  \"子任务10\": \"等待至少3秒确保统计结果稳定。\",\n  \"子任务11\": \"获取流量StreamTemplate_1的流模板块统计信息。\",\n  \"子任务12\": \"验证流量StreamTemplate_1的发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的r tag头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['rtag', 'ipv4'])\n\n    # 修改rtag头部\n    attr = edit_header_r_tag(Stream=stream, Level=0,\n                             Reserved=4095)\n    edit_modifier(Stream=stream, Attribute=attr['Reserved'],\n                  Type='Increment', Count=10, HeaderType='rtag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ripng.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发Ripng报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的Ripng头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripng']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripng(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripng', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripng_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripng_entry(Stream=stream, Level=0, Index=0, Ipaddr='2001::1:f1:22', RouteTag=1, PrefixLen=1, Metric=1)\n    edit_header_ripng_entry(Stream=stream, Level=0, Index=1, Ipaddr='2001::1:f1:33', RouteTag=2, PrefixLen=2, Metric=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务3\": \"创建流量模板，设置固定帧长度为256字节。\",\n  \"子任务4\": \"为流量添加三层协议头部：EthernetII → IPv4 → Ripng。\",\n  \"子任务5\": \"修改Ripng头部参数：Command=2, Version=1, Reserved=2。\",\n  \"子任务6\": \"配置Ripng Reserved字段为递增跳变域，步长为1，计数为3。\",\n  \"子任务7\": \"在Ripng头部插入两个路由条目。\",\n  \"子任务8\": \"修改第一个Ripng条目参数：Ipaddr='2001::1:f1:22', RouteTag=1, PrefixLen=1, Metric=1。\",\n  \"子任务9\": \"修改第二个Ripng条目参数：Ipaddr='2001::1:f1:33', RouteTag=2, PrefixLen=2, Metric=2。\",\n  \"子任务10\": \"在Port_2创建PDU匹配模式1：过滤Ripng Reserved字段值在1-2范围的报文。\",\n  \"子任务11\": \"在Port_2创建PDU匹配模式2：过滤Ripng Version字段值=1的报文。\",\n  \"子任务12\": \"设置Port_2抓包过滤逻辑：同时满足模式1和模式2的报文。\",\n  \"子任务13\": \"订阅流模板块统计视图StreamBlockStats。\",\n  \"子任务14\": \"配置Port_1发送模式为突发包，突发包数量100。\",\n  \"子任务15\": \"保存当前测试配置文件。\",\n  \"子任务16\": \"启动Port_2抓包功能。\",\n  \"子任务17\": \"开始发送流量。\",\n  \"子任务18\": \"等待10秒流量发送时间。\",\n  \"子任务19\": \"停止流量发送。\",\n  \"子任务20\": \"停止抓包。\",\n  \"子任务21\": \"下载Port_2捕获的报文到本地存储。\",\n  \"子任务22\": \"获取流量统计信息TxStreamFrames和RxStreamFrames。\",\n  \"子任务23\": \"验证流量统计结果：TxStreamFrames == RxStreamFrames。\",\n  \"子任务24\": \"释放所有预约的仪表端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发Ripng报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的Ripng头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripng']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripng(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripng', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripng_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripng_entry(Stream=stream, Level=0, Index=0, Ipaddr='2001::1:f1:22', RouteTag=1, PrefixLen=1, Metric=1)\n    edit_header_ripng_entry(Stream=stream, Level=0, Index=1, Ipaddr='2001::1:f1:33', RouteTag=2, PrefixLen=2, Metric=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv2Query.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发IGMPv2_Query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的IGMPv2_Query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IGMPv2Query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv2_query(Stream=stream, Level=0, Type=99, MaxResponseTime=255, Checksum='ffff',\n                             GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.maxResponseTime',\n                                               Value='255',\n                                               MaxValue='255')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.groupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv2_query:修改测试仪表流量模板中IGMPv2 Query报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量模板，设置固定帧长为256字节。\",\n  \"子任务4\": \"为流量模板配置报文头部结构：EthernetII、IPv4、IGMPv2Query。\",\n  \"子任务5\": \"修改流量模板的IGMPv2Query头部参数：Type=99, MaxResponseTime=255, GroupAddress='10.1.1.1'。\",\n  \"子任务6\": \"在Port_2上创建三个PDU匹配模式：匹配IGMPv2Query的Type=99、MaxResponseTime=255、GroupAddress='10.1.1.1'。\",\n  \"子任务7\": \"在Port_2上设置报文过滤逻辑表达式，组合三个PDU匹配模式为'&&'关系。\",\n  \"子任务8\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务9\": \"配置Port_1的发送模式为突发包，设置突发包数量为100。\",\n  \"子任务10\": \"保存当前测试配置文件。\",\n  \"子任务11\": \"启动Port_2的抓包功能。\",\n  \"子任务12\": \"开始发送Port_1的流量。\",\n  \"子任务13\": \"等待10秒传输时间。\",\n  \"子任务14\": \"停止发送流量。\",\n  \"子任务15\": \"停止Port_2的抓包。\",\n  \"子任务16\": \"下载Port_2捕获的报文数据。\",\n  \"子任务17\": \"获取流量模板的StreamBlockStats统计结果。\",\n  \"子任务18\": \"验证流量模板的发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\",\n  \"子任务19\": \"释放所有预约端口。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发IGMPv2_Query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的IGMPv2_Query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IGMPv2Query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv2_query(Stream=stream, Level=0, Type=99, MaxResponseTime=255, Checksum='ffff',\n                             GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.maxResponseTime',\n                                               Value='255',\n                                               MaxValue='255')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.groupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv2_query:修改测试仪表流量模板中IGMPv2 Query报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6MLDv1Report.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv1 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv1 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'mldv1report']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改mldv1report头部\n    edit_header_icmpv6_mldv1_report(Stream=stream, Level=0,\n                          Code='2',Reserved='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Report_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Report_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Report_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_mldv1_report:修改测试仪表流量模板中Icmpv6 Mldv1 Report报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品平台为'DarYu'。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建固定长度为256字节的流量。\",\n  \"子任务4\": \"为流量配置报文头部：EthernetII、IPv4和mldv1report。\",\n  \"子任务5\": \"修改流量的ICMPv6 MLDv1 Report头部：设置Code=2、Reserved=10、MulticastAddress=FF1E::1。\",\n  \"子任务6\": \"在Port_2上创建PDU Pattern：匹配mldv1Report_1.code字段值为2。\",\n  \"子任务7\": \"在Port_2上创建PDU Pattern：匹配mldv1Report_1.reserved字段值为10。\",\n  \"子任务8\": \"在Port_2上创建PDU Pattern：匹配mldv1Report_1.multicastAddress字段值为FF1E::1。\",\n  \"子任务9\": \"在Port_2设置报文过滤逻辑表达式：组合三个PDU Pattern为逻辑与关系。\",\n  \"子任务10\": \"订阅流模板块统计视图StreamBlockStats。\",\n  \"子任务11\": \"设置Port_1的发送模式为突发包，指定突发包数量为100。\",\n  \"子任务12\": \"启动Port_2的数据抓包。\",\n  \"子任务13\": \"开始发送流量并持续10秒。\",\n  \"子任务14\": \"停止流量发送。\",\n  \"子任务15\": \"停止数据抓包。\",\n  \"子任务16\": \"获取流模板块统计信息。\",\n  \"子任务17\": \"验证发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\",\n  \"子任务18\": \"释放预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv1 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv1 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'mldv1report']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改mldv1report头部\n    edit_header_icmpv6_mldv1_report(Stream=stream, Level=0,\n                          Code='2',Reserved='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Report_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Report_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Report_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_mldv1_report:修改测试仪表流量模板中Icmpv6 Mldv1 Report报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/LldpPortId.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的lldp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_port_id_tlv(Stream=stream, Level=0, PortId='22:22:22:22:22:22')\n    edit_modifier(Stream=stream, Attribute=attr['PortId'],\n                  Type='Increment', Count=10, HeaderType='portidtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型为'DarYu'。\",\n  \"子任务2\": \"预约两个自环端口，使用提供的端口位置信息。\",\n  \"子任务3\": \"在第一个端口创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"修改流量模板的帧长度类型为自动模式(AUTO)。\",\n  \"子任务5\": \"为流量模板添加以太网II和LLDP Port ID TLV报文头部。\",\n  \"子任务6\": \"修改LLDP头部PortId字段值为'22:22:22:22:22:22'。\",\n  \"子任务7\": \"配置PortId字段的跳变规则：类型为递增(Increment)，跳变次数为10。\",\n  \"子任务8\": \"订阅端口统计(PortStats)和流模板块统计(StreamBlockStats)视图。\",\n  \"子任务9\": \"配置端口发送模式为突发包(BURST)，设置突发包数量为100。\",\n  \"子任务10\": \"保存当前测试配置文件到指定路径。\",\n  \"子任务11\": \"开始发送所有流量。\",\n  \"子任务12\": \"等待流量完全停止。\",\n  \"子任务13\": \"等待3秒确保统计结果稳定。\",\n  \"子任务14\": \"获取流量模板StreamTemplate_1的流模板块统计信息。\",\n  \"子任务15\": \"验证发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)且都等于100。\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的lldp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_port_id_tlv(Stream=stream, Level=0, PortId='22:22:22:22:22:22')\n    edit_modifier(Stream=stream, Attribute=attr['PortId'],\n                  Type='Increment', Count=10, HeaderType='portidtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl2helloHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'isisl2helloheader'])\n\n    header = edit_header_isis_l1l2_hello(Stream=stream,\n                                         VersionIdExtend=10,\n                                         IsIsTlv=['AreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                  'IpInterfaceAddress', 'Neighbor', 'RestartSignal', 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl2helloheader', Attribute=header['VersionIdExtend'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AreaAddress', AreaAddressEntries=2)\n\n    edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, NlPIDEntriesField=2)\n\n    edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容",
      "edit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务2\": \"在端口 Port_1 上创建流量 StreamTemplate_1。\",\n  \"子任务3\": \"修改流量 StreamTemplate_1 的 ISIS 头部内容，包括版本扩展、区域地址条目、填充字段、认证信息和协议支持等TLV字段。\",\n  \"子任务4\": \"订阅流模板块统计视图 StreamBlockStats。\",\n  \"子任务5\": \"配置端口 Port_1 的发送模式为突发包，设置突发包数量。\",\n  \"子任务6\": \"启动流量发送。\",\n  \"子任务7\": \"等待流量发送完成。\",\n  \"子任务8\": \"停止流量发送后等待3秒确保统计结果稳定。\",\n  \"子任务9\": \"获取流量 StreamTemplate_1 的流模板块统计结果。\",\n  \"子任务10\": \"验证流量 StreamTemplate_1 的发送帧数(TxStreamFrames)与接收帧数(RxStreamFrames)是否相等。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'isisl2helloheader'])\n\n    header = edit_header_isis_l1l2_hello(Stream=stream,\n                                         VersionIdExtend=10,\n                                         IsIsTlv=['AreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                  'IpInterfaceAddress', 'Neighbor', 'RestartSignal', 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl2helloheader', Attribute=header['VersionIdExtend'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AreaAddress', AreaAddressEntries=2)\n\n    edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, NlPIDEntriesField=2)\n\n    edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容;\nedit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Pppoe.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发pppoe报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的pppoe头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'pppoe']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改pppoe头部\n    header_dict = edit_header_pppoe(Stream=stream, Level=0, Code=11, SessionId=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='pppoe', Attribute=header_dict['SessionId'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='pppoe_1.code',\n                                               Value='11', MaxValue='11')\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='pppoe_1.sessionId',\n    #                                            Value='2',\n    #                                            MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=1,\n                                               Attribute=header_dict['SessionId'],\n                                               Value='2', MaxValue='11')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_pppoe:修改测试仪表流量模板中PPPoE报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表环境\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2\",\n  \"子任务3\": \"在Port_1上创建流量StreamTemplate_1并设置固定帧长256字节\",\n  \"子任务4\": \"为流量StreamTemplate_1创建以太网和PPPoE报文头部\",\n  \"子任务5\": \"修改流量StreamTemplate_1的PPPoE头部：设置Code为11，SessionId为2\",\n  \"子任务6\": \"配置PPPoE头部SessionId字段的跳变规则：类型为递增(Increment)，数量为10\",\n  \"子任务7\": \"在Port_2上创建第一个PDU模式：匹配PPPoE头部Code字段等于11\",\n  \"子任务8\": \"在Port_2上创建第二个PDU模式：匹配PPPoE头部SessionId字段范围2到11\",\n  \"子任务9\": \"在Port_2上设置抓包过滤表达式：组合两个PDU模式进行逻辑与(&&)过滤\",\n  \"子任务10\": \"订阅StreamBlockStats统计视图\",\n  \"子任务11\": \"设置Port_1发送模式为突发包(BURST)，指定突发包数量为100\",\n  \"子任务12\": \"保存当前测试配置到文件\",\n  \"子任务13\": \"启动Port_2的数据抓包功能\",\n  \"子任务14\": \"在Port_1上开始发送流量StreamTemplate_1\",\n  \"子任务15\": \"等待10秒使流量充分发送\",\n  \"子任务16\": \"停止Port_1的流量发送\",\n  \"子任务17\": \"停止Port_2的数据抓包\",\n  \"子任务18\": \"下载Port_2捕获的报文数据到本地存储\",\n  \"子任务19\": \"获取流量StreamTemplate_1的统计信息\",\n  \"子任务20\": \"验证流量StreamTemplate_1的发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)\",\n  \"子任务21\": \"释放所有预约的仪表端口资源\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发pppoe报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的pppoe头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'pppoe']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改pppoe头部\n    header_dict = edit_header_pppoe(Stream=stream, Level=0, Code=11, SessionId=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='pppoe', Attribute=header_dict['SessionId'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='pppoe_1.code',\n                                               Value='11', MaxValue='11')\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='pppoe_1.sessionId',\n    #                                            Value='2',\n    #                                            MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=1,\n                                               Attribute=header_dict['SessionId'],\n                                               Value='2', MaxValue='11')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_pppoe:修改测试仪表流量模板中PPPoE报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl1helloHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'isisl1helloheader'])\n\n    header = edit_header_isis_l1l2_hello(Stream=stream,\n                                         Version=1,\n                                         FixedReserve1=10,\n                                         IsIsTlv=['IsIsAreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                'IpInterfaceAddress', 'Neighbor', 'RestartSignal', 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=header['FixedReserve1'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsAreaAddress',\n                                      TlvCode=10,\n                                      AreaAddressEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n\n    addr = edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=addr['AreaAddress'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['TlvLength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['AuthenticationLength'],\n    #               Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, TlvCode=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['TlvCode'],\n    #               Type='Increment', Count=10)\n\n    entry = edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=entry['TlvLength'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容",
      "edit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约测试仪表的两个自环端口 Port_1 和 Port_2\",\n  \"子任务2\": \"在端口 Port_1 上创建一条流量 StreamTemplate_1\",\n  \"子任务3\": \"修改流量 StreamTemplate_1 的 ISIS L1 Hello 报文头部内容\",\n  \"子任务4\": \"订阅 StreamBlockStats 统计视图\",\n  \"子任务5\": \"配置端口负载为突发模式并设置突发包数量\",\n  \"子任务6\": \"启动流量发送并等待流量发送完成\",\n  \"子任务7\": \"等待统计信息稳定（≥3秒）\",\n  \"子任务8\": \"获取流量 StreamTemplate_1 的 StreamBlockStats 统计信息\",\n  \"子任务9\": \"验证 StreamTemplate_1 的收包数（RxStreamFrames）等于发包数（TxStreamFrames）\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'isisl1helloheader'])\n\n    header = edit_header_isis_l1l2_hello(Stream=stream,\n                                         Version=1,\n                                         FixedReserve1=10,\n                                         IsIsTlv=['IsIsAreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                'IpInterfaceAddress', 'Neighbor', 'RestartSignal', 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=header['FixedReserve1'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsAreaAddress',\n                                      TlvCode=10,\n                                      AreaAddressEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n\n    addr = edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=addr['AreaAddress'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['TlvLength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['AuthenticationLength'],\n    #               Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, TlvCode=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['TlvCode'],\n    #               Type='Increment', Count=10)\n\n    entry = edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=entry['TlvLength'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容;\nedit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/pfc.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的pfc头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'pfc'])\n\n    # 修改pause头部\n    attr = edit_header_pfc(Stream=stream, Level=0,\n                             OpCode='FFFF')\n    edit_modifier(Stream=stream, Attribute=attr['OpCode'],\n                  Type='Increment', Count=10, HeaderType='pfc')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在端口Port_1上创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"配置流量模板StreamTemplate_1的帧长度类型为自动模式。\",\n  \"子任务5\": \"为流量模板添加以太网和PFC报文头部。\",\n  \"子任务6\": \"修改PFC头部的Level和OpCode字段内容。\",\n  \"子任务7\": \"为PFC头部的OpCode字段配置递增跳变域，设置跳变次数为10。\",\n  \"子任务8\": \"订阅端口统计和流模板块统计视图。\",\n  \"子任务9\": \"配置端口Port_1的发送模式为突发包，设置突发包数量为100。\",\n  \"子任务10\": \"保存当前测试配置文件。\",\n  \"子任务11\": \"开始发送所有流量。\",\n  \"子任务12\": \"等待流量发送完成并停止。\",\n  \"子任务13\": \"等待3秒确保统计结果稳定。\",\n  \"子任务14\": \"获取流量模板StreamTemplate_1的流模板块统计信息。\",\n  \"子任务15\": \"验证流量模板StreamTemplate_1的发送帧数(TxStreamFrames)和接收帧数(RxStreamFrames)是否相等且等于突发包数量(100)。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的pfc头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'pfc'])\n\n    # 修改pause头部\n    attr = edit_header_pfc(Stream=stream, Level=0,\n                             OpCode='FFFF')\n    edit_modifier(Stream=stream, Attribute=attr['OpCode'],\n                  Type='Increment', Count=10, HeaderType='pfc')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahCustomerStagEthernet.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['sTag', 'ipv4'])\n\n    # 修改Customer Stag Ethernet头部\n    attr = edit_header_8021ah_CustomerStagEthernet(Stream=stream, Level=0,\n                                                   Vid='101010101010')\n    edit_modifier(Stream=stream, Attribute=attr['Vid'],\n                  Type='Increment', Count=10, HeaderType='sTag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在端口Port_1上创建一条流量StreamTemplate_1。\",\n  \"子任务4\": \"为流量StreamTemplate_1创建报文头部，包含sTag和ipv4类型。\",\n  \"子任务5\": \"修改流量模板中802.1ah头部的Vid字段，设置递增跳变规则（起始值101010101010，步长10）。\",\n  \"子任务6\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务7\": \"配置端口发送模式为突发包模式，设置突发包数量为100。\",\n  \"子任务8\": \"开始发送所有流量。\",\n  \"子任务9\": \"等待流量自动停止发送。\",\n  \"子任务10\": \"等待3秒确保统计结果稳定。\",\n  \"子任务11\": \"获取流量StreamTemplate_1的StreamBlockStats统计结果。\",\n  \"子任务12\": \"验证流量收发包数量相等（TxStreamFrames等于RxStreamFrames）。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['sTag', 'ipv4'])\n\n    # 修改Customer Stag Ethernet头部\n    attr = edit_header_8021ah_CustomerStagEthernet(Stream=stream, Level=0,\n                                                   Vid='101010101010')\n    edit_modifier(Stream=stream, Attribute=attr['Vid'],\n                  Type='Increment', Count=10, HeaderType='sTag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Routing.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Routing头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6routingheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_routing(Stream=stream, Nodes=['2022::2', '2033::3'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6routingheader', Attribute=attr['Nodes_2022::2'],\n                  Type='Increment', Count=10, Step=2)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"创建流量模板StreamTemplate_1，设置固定帧长为256字节。\",\n  \"子任务4\": \"配置流量报文头部结构：包含EthernetII、IPv6和ipv6routingheader三层协议头。\",\n  \"子任务5\": \"修改IPv6路由头部内容，设置节点地址为2022::2和2033::3。\",\n  \"子任务6\": \"配置IPv6路由头部的跳变域：设置递增模式，步长为2，计数为10次。\",\n  \"子任务7\": \"订阅StreamBlockStats统计视图用于监控流量结果。\",\n  \"子任务8\": \"设置端口发送模式为突发包模式，突发包数量为100。\",\n  \"子任务9\": \"保存当前测试配置文件。\",\n  \"子任务10\": \"启动流量发送并抓包，持续10秒。\",\n  \"子任务11\": \"停止流量发送并等待3秒确保统计稳定。\",\n  \"子任务12\": \"获取StreamBlockStats统计结果中的TxStreamFrames和RxStreamFrames值。\",\n  \"子任务13\": \"验证流量统计结果：TxStreamFrames等于RxStreamFrames。\",\n  \"子任务14\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Routing头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6routingheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_routing(Stream=stream, Nodes=['2022::2', '2033::3'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6routingheader', Attribute=attr['Nodes_2022::2'],\n                  Type='Increment', Count=10, Step=2)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/vntag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的vntag头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vntag', 'ipv4'])\n\n    # 修改vntag头部\n    attr = edit_header_vntag(Stream=stream, Level=0,\n                             Ver='11')\n    edit_modifier(Stream=stream, Attribute=attr['Ver'],\n                  Type='Increment', Count=10, HeaderType='vntag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，使用给定位置信息。\",\n  \"子任务3\": \"在端口Port_1上创建流量StreamTemplate_1。\",\n  \"子任务4\": \"配置流量StreamTemplate_1的帧长度类型为AUTO模式。\",\n  \"子任务5\": \"为流量StreamTemplate_1创建报文头部，包含ethernetii、vntag和ipv4协议层。\",\n  \"子任务6\": \"修改vntag头部中的Ver字段值为'11'。\",\n  \"子任务7\": \"配置vntag头部Ver字段的跳变规则为增量模式，步长为10，变化次数为10。\",\n  \"子任务8\": \"订阅流模板块统计StreamBlockStats视图。\",\n  \"子任务9\": \"设置端口Port_1的发送模式为突发包模式，突发包数量为100。\",\n  \"子任务10\": \"保存当前测试配置到指定路径的配置文件。\",\n  \"子任务11\": \"启动所有流量发送。\",\n  \"子任务12\": \"等待流量完全停止发送。\",\n  \"子任务13\": \"等待3秒确保统计结果稳定。\",\n  \"子任务14\": \"获取流量StreamTemplate_1的流模板块统计信息。\",\n  \"子任务15\": \"验证发送帧数TxStreamFrames和接收帧数RxStreamFrames是否相等且均为100。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的vntag头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vntag', 'ipv4'])\n\n    # 修改vntag头部\n    attr = edit_header_vntag(Stream=stream, Level=0,\n                             Ver='11')\n    edit_modifier(Stream=stream, Attribute=attr['Ver'],\n                  Type='Increment', Count=10, HeaderType='vntag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/LldpChassisId.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的lldp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'chassisidtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_chassis_id_tlv(Stream=stream, Level=0, ChassisId='1.1.1.1')\n    edit_modifier(Stream=stream, Attribute=attr['ChassisId'],\n                  Type='Increment', Count=10, HeaderType='chassisidtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，指定端口物理位置。\",\n  \"子任务3\": \"在端口Port_1上创建一条流量StreamTemplate_1。\",\n  \"子任务4\": \"设置流量StreamTemplate_1的帧长度类型为自动模式。\",\n  \"子任务5\": \"为流量添加以太网和LLDP Chassis ID TLV报文头部。\",\n  \"子任务6\": \"修改LLDP头部ChassisId字段初始值为'1.1.1.1'。\",\n  \"子任务7\": \"配置ChassisId字段的跳变规则为递增模式，步长1，循环次数10。\",\n  \"子任务8\": \"订阅端口统计和流模板块统计视图。\",\n  \"子任务9\": \"设置端口Port_1发送模式为突发包，指定突发包数量为100。\",\n  \"子任务10\": \"保存当前测试配置到本地文件。\",\n  \"子任务11\": \"启动所有流量发送。\",\n  \"子任务12\": \"等待流量完全停止发送。\",\n  \"子任务13\": \"等待3秒确保统计结果稳定。\",\n  \"子任务14\": \"获取流量StreamTemplate_1的流模板块统计信息。\",\n  \"子任务15\": \"验证发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的lldp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'chassisidtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_chassis_id_tlv(Stream=stream, Level=0, ChassisId='1.1.1.1')\n    edit_modifier(Stream=stream, Attribute=attr['ChassisId'],\n                  Type='Increment', Count=10, HeaderType='chassisidtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4Redirect.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 redirect报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 redirect头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4Redirect']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 redirect头部\n    edit_header_icmp_redirect(Stream=stream, Level=0,\n                              GatewayAddress='10.1.1.1', Ipv4HeaderTosDelay='1',\n                              Ipv4HeaderTTL='200', Ipv4HeaderDestination='20.1.1.2', Data='0000000000000002')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.gatewayAddress',\n                                               Value='10.1.1.1', MaxValue='10.1.1.1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.headerData.ipv4Header.tos.tos.delay',\n                                               Value='1',\n                                               MaxValue='1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.headerData.ipv4Header.ttl',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_4 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.headerData.ipv4Header.destination',\n                                               Value='20.1.1.2',\n                                               MaxValue='20.1.1.2')\n    edit_capture_filter(Port=Ports[1],Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3} && {pdu_pattern_4}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_redirect:修改测试仪表流量模板中Icmp Redirect报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建固定长度为256字节的流量StreamTemplate_1。\",\n  \"子任务4\": \"为StreamTemplate_1创建报文头部，协议层次为EthernetII/IPv4/Icmpv4Redirect。\",\n  \"子任务5\": \"修改StreamTemplate_1的ICMP重定向头部：设置网关地址为10.1.1.1、TOS延迟为1、TTL为200、目的IPv4地址为20.1.1.2。\",\n  \"子任务6\": \"在Port_2配置抓包过滤：创建匹配网关地址/TOS延迟/TTL/目的地址的PDU模式并组合过滤表达式。\",\n  \"子任务7\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务8\": \"设置Port_1的发送模式为BURST（突发包），突发包数量为100。\",\n  \"子任务9\": \"保存当前测试配置到文件。\",\n  \"子任务10\": \"启动Port_2的抓包功能。\",\n  \"子任务11\": \"启动Port_1的流量发送。\",\n  \"子任务12\": \"等待10秒确保流量发送完成。\",\n  \"子任务13\": \"停止Port_1的流量发送。\",\n  \"子任务14\": \"停止Port_2的抓包功能。\",\n  \"子任务15\": \"下载Port_2捕获的报文到本地存储。\",\n  \"子任务16\": \"获取StreamTemplate_1的流模板块统计信息（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务17\": \"验证TxStreamFrames与RxStreamFrames统计值相等。\",\n  \"子任务18\": \"释放所有预约的测试仪表端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 redirect报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 redirect头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4Redirect']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 redirect头部\n    edit_header_icmp_redirect(Stream=stream, Level=0,\n                              GatewayAddress='10.1.1.1', Ipv4HeaderTosDelay='1',\n                              Ipv4HeaderTTL='200', Ipv4HeaderDestination='20.1.1.2', Data='0000000000000002')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.gatewayAddress',\n                                               Value='10.1.1.1', MaxValue='10.1.1.1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.headerData.ipv4Header.tos.tos.delay',\n                                               Value='1',\n                                               MaxValue='1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.headerData.ipv4Header.ttl',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_4 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.headerData.ipv4Header.destination',\n                                               Value='20.1.1.2',\n                                               MaxValue='20.1.1.2')\n    edit_capture_filter(Port=Ports[1],Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3} && {pdu_pattern_4}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_redirect:修改测试仪表流量模板中Icmp Redirect报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2TPv3ControlOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Control Over Udp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp'])\n\n    # 修改l2tpv3 control over udp头部\n    edit_header_l2tpv3_control_over_udp(Stream=stream, Level=0,\n                                        Type=1,\n                                        UseLength=1,\n                                        Length=1,\n                                        )\n\n    # 修改l2tpv3 control over udp头部，添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='circuitError',\n                                      AlignmentOverruns=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='routeId',\n                                      RouteId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='assignedConnection',\n                                      ConnectionId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='localSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='remoteSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='assignedCookie',\n                                      Cookie4Byte='00000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='pwType',\n                                      PwType=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='l2SpecificSub',\n                                      L2SpecificSublayer=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='dataSequencing',\n                                      DataSequencing=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='txConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='rxConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='circuitStatus',\n                                      Nbit=1,\n                                      Abit=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp'],\n                                             FieldName='l2tpv3ControlOverUdp_1.type',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，使用给定的位置信息。\",\n  \"子任务3\": \"在指定端口上创建流量，设置固定帧长度为512字节。\",\n  \"子任务4\": \"为流量创建报文头部，包含EthernetII、IPv4、UDP和L2TPv3 Control Over UDP协议层。\",\n  \"子任务5\": \"修改流量的L2TPv3 Control Over UDP主头部，设置Type=1, UseLength=1, Length=1。\",\n  \"子任务6\": \"修改流量的L2TPv3 Control Over UDP头部，添加多个Option头部（包括generalTLV、messageType等18种类型），并设置各参数值。\",\n  \"子任务7\": \"在接收端口配置抓包过滤，创建PDU Pattern匹配L2TPv3 Control Over UDP的type字段值为1。\",\n  \"子任务8\": \"订阅统计视图，包括PortStats和StreamBlockStats类型。\",\n  \"子任务9\": \"设置端口发送模式为突发包模式，指定突发包数量为100。\",\n  \"子任务10\": \"保存当前测试配置文件。\",\n  \"子任务11\": \"启动端口抓包功能。\",\n  \"子任务12\": \"开始发送流量。\",\n  \"子任务13\": \"等待流量发送完成。\",\n  \"子任务14\": \"停止端口抓包功能。\",\n  \"子任务15\": \"等待3秒确保统计结果稳定。\",\n  \"子任务16\": \"下载捕获的报文到本地存储。\",\n  \"子任务17\": \"获取抓包信息，验证捕获报文数量等于发送的突发包数量（100）。\",\n  \"子任务18\": \"获取流模板块统计信息，验证发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)且等于100。\",\n  \"子任务19\": \"获取端口过滤统计信息，验证过滤结果。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Control Over Udp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp'])\n\n    # 修改l2tpv3 control over udp头部\n    edit_header_l2tpv3_control_over_udp(Stream=stream, Level=0,\n                                        Type=1,\n                                        UseLength=1,\n                                        Length=1,\n                                        )\n\n    # 修改l2tpv3 control over udp头部，添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='circuitError',\n                                      AlignmentOverruns=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='routeId',\n                                      RouteId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='assignedConnection',\n                                      ConnectionId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='localSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='remoteSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='assignedCookie',\n                                      Cookie4Byte='00000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='pwType',\n                                      PwType=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='l2SpecificSub',\n                                      L2SpecificSublayer=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='dataSequencing',\n                                      DataSequencing=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='txConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='rxConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='circuitStatus',\n                                      Nbit=1,\n                                      Abit=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp'],\n                                             FieldName='l2tpv3ControlOverUdp_1.type',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv3Report.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发igmpv3 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的igmpv3 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv3report']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    header = edit_header_igmpv3_report(Stream=stream, Level=0,\n                                       Type=99, Reserved1='ff', Checksum='ffff',\n                                       NumGroupRecords=2)\n    group = edit_header_igmpv3_group_records(Stream=stream, Level=0, Index=1,\n                                             SourceAddressList=['1.1.1.1', '2.2.2.2'],\n                                             ExceedauxDataList=['10203040', '50607080'],\n                                             MulticastAddress='224.0.0.1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3report',\n                  Attribute=group['SourceAddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3report',\n                  Attribute=group['ExceedauxDataList: 50607080'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3report',\n                  Attribute=group['MulticastAddress'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Report_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Report_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Report_1.Reserved1',\n                                               Value='ff',\n                                               MaxValue='ff')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv3_group_records:修改测试仪表流量模板中IGMPv3 Report报文头部Group Records内容",
      "edit_header_igmpv3_report:修改测试仪表流量模板中IGMPv2 Report报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，位置由输入参数或默认值指定。\",\n  \"子任务3\": \"在第一个端口创建流量，设置固定帧长度为256字节。\",\n  \"子任务4\": \"配置流量头部协议栈为EthernetII/IPv4/IGMPv3 Report。\",\n  \"子任务5\": \"编辑IGMPv3 Report头部：Type=99, Reserved1=ff, Checksum=ffff, NumGroupRecords=2。\",\n  \"子任务6\": \"编辑IGMPv3 Group Records：源地址列表=[1.1.1.1,2.2.2.2], 附加数据列表=[10203040,50607080], 组播地址=224.0.0.1。\",\n  \"子任务7\": \"设置源地址2.2.2.2的跳变规则：递增模式，计数10。\",\n  \"子任务8\": \"设置附加数据50607080的跳变规则：递增模式，计数10。\",\n  \"子任务9\": \"设置组播地址的跳变规则：递增模式，计数10。\",\n  \"子任务10\": \"在第二个端口创建PDU匹配规则：IGMPv3 Type=99, Checksum=ffff, Reserved1=ff。\",\n  \"子任务11\": \"配置端口抓包过滤器：组合三个PDU匹配规则为逻辑与条件。\",\n  \"子任务12\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务13\": \"设置第一个端口发送模式为突发模式，突发包数100。\",\n  \"子任务14\": \"保存当前测试配置到指定路径。\",\n  \"子任务15\": \"启动第二个端口抓包。\",\n  \"子任务16\": \"启动第一个端口流量发送。\",\n  \"子任务17\": \"等待10秒。\",\n  \"子任务18\": \"停止流量发送。\",\n  \"子任务19\": \"停止抓包。\",\n  \"子任务20\": \"下载捕获报文到本地目录。\",\n  \"子任务21\": \"获取流量的StreamBlockStats统计结果。\",\n  \"子任务22\": \"验证发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\",\n  \"子任务23\": \"释放预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发igmpv3 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的igmpv3 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv3report']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    header = edit_header_igmpv3_report(Stream=stream, Level=0,\n                                       Type=99, Reserved1='ff', Checksum='ffff',\n                                       NumGroupRecords=2)\n    group = edit_header_igmpv3_group_records(Stream=stream, Level=0, Index=1,\n                                             SourceAddressList=['1.1.1.1', '2.2.2.2'],\n                                             ExceedauxDataList=['10203040', '50607080'],\n                                             MulticastAddress='224.0.0.1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3report',\n                  Attribute=group['SourceAddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3report',\n                  Attribute=group['ExceedauxDataList: 50607080'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3report',\n                  Attribute=group['MulticastAddress'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Report_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Report_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Report_1.Reserved1',\n                                               Value='ff',\n                                               MaxValue='ff')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv3_group_records:修改测试仪表流量模板中IGMPv3 Report报文头部Group Records内容;\nedit_header_igmpv3_report:修改测试仪表流量模板中IGMPv2 Report报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Authentication.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Authentication头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6authenticationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_authentication(Stream=stream, AuthData='abcd')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6authenticationheader', Attribute=attr['AuthData'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表。\",\n  \"子任务2\": \"预约测试仪表的端口Port_1和Port_2。\",\n  \"子任务3\": \"测试仪表创建流量StreamTemplate_1。\",\n  \"子任务4\": \"创建流量报文头部，指定头部类型为EthernetII、IPv6和ipv6authenticationheader。\",\n  \"子任务5\": \"修改测试仪表流量模板中指定报文字段的跳变域，针对IPv6 Authentication头部的AuthData字段，设置类型为递增。\",\n  \"子任务6\": \"订阅测试仪表统计视图，类型为StreamBlockStats。\",\n  \"子任务7\": \"编辑测试仪表负载配置文件参数，设置端口发送模式为突发包。\",\n  \"子任务8\": \"测试仪表开始发送数据流并等待一段时间。\",\n  \"子任务9\": \"测试仪表停止发送数据流。\",\n  \"子任务10\": \"获取测试仪表流模板块统计结果。\",\n  \"子任务11\": \"验证流量StreamTemplate_1的收发包数量相等。\",\n  \"子任务12\": \"释放测试仪表的端口。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Authentication头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6authenticationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_authentication(Stream=stream, AuthData='abcd')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6authenticationheader', Attribute=attr['AuthData'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Arp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发arp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的arp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ARP']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改arp头部\n    attribute_dict = edit_header_arp(Stream=stream, Level=0, SendMac='00:00:00:00:00:01',\n                                     SendIpv4='192.168.0.2', TargetIpv4='192.168.0.1')\n    # arp头部SendMac字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='arp', Attribute=attribute_dict['SendMac'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # arp头部目SendIpv4字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='arp', Attribute=attribute_dict['SendIpv4'],\n                  Type='List',\n                  List=['192.168.0.2', '192.168.0.5', '192.168.0.3'])\n    # arp头部目TargetIpv4字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='arp', Attribute=attribute_dict['TargetIpv4'],\n                  Type='Random',\n                  Range='200.168.0.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='arp_1.sendIpv4',\n                                               Value='192.168.0.2', MaxValue='192.168.0.2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='arp_1.sendMac',\n                                               Value='00:00:00:00:00:01',\n                                               MaxValue='00:00:00:00:00:01')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_arp:修改测试仪表流量模板中ARP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台。\",\n  \"子任务2\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务3\": \"创建流量模板 StreamTemplate_1，指定固定帧长度。\",\n  \"子任务4\": \"为流量模板创建报文头部，指定类型为 EthernetII 和 ARP。\",\n  \"子任务5\": \"修改流量模板的 ARP 头部内容：设置 SendMac、SendIpv4 和 TargetIpv4 字段值。\",\n  \"子任务6\": \"修改 SendMac 字段的跳变域为 Increment 类型，指定计数和步长。\",\n  \"子任务7\": \"修改 SendIpv4 字段的跳变域为 List 类型，指定列表值。\",\n  \"子任务8\": \"修改 TargetIpv4 字段的跳变域为 Random 类型，指定范围。\",\n  \"子任务9\": \"在端口 Port_2 上创建抓包 PDU 模式，基于 ARP 头部字段（如 sendIpv4 和 sendMac）设置过滤条件。\",\n  \"子任务10\": \"在端口 Port_2 上设置抓包过滤表达式，组合多个 PDU 模式。\",\n  \"子任务11\": \"订阅 StreamBlockStats 统计视图。\",\n  \"子任务12\": \"设置端口 Port_1 的发送模式为突发包，指定突发计数。\",\n  \"子任务13\": \"保存测试配置文件。\",\n  \"子任务14\": \"启动端口 Port_2 的抓包。\",\n  \"子任务15\": \"开始发送所有流量。\",\n  \"子任务16\": \"等待 10 秒。\",\n  \"子任务17\": \"停止发送流量。\",\n  \"子任务18\": \"停止抓包。\",\n  \"子任务19\": \"下载端口 Port_2 捕获到的数据包到指定目录。\",\n  \"子任务20\": \"获取流量 StreamTemplate_1 的统计信息，包括发送帧数和接收帧数。\",\n  \"子任务21\": \"验证发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\",\n  \"子任务22\": \"释放预约的端口。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发arp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的arp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ARP']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改arp头部\n    attribute_dict = edit_header_arp(Stream=stream, Level=0, SendMac='00:00:00:00:00:01',\n                                     SendIpv4='192.168.0.2', TargetIpv4='192.168.0.1')\n    # arp头部SendMac字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='arp', Attribute=attribute_dict['SendMac'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # arp头部目SendIpv4字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='arp', Attribute=attribute_dict['SendIpv4'],\n                  Type='List',\n                  List=['192.168.0.2', '192.168.0.5', '192.168.0.3'])\n    # arp头部目TargetIpv4字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='arp', Attribute=attribute_dict['TargetIpv4'],\n                  Type='Random',\n                  Range='200.168.0.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='arp_1.sendIpv4',\n                                               Value='192.168.0.2', MaxValue='192.168.0.2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='arp_1.sendMac',\n                                               Value='00:00:00:00:00:01',\n                                               MaxValue='00:00:00:00:00:01')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_arp:修改测试仪表流量模板中ARP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/PppoeDiscovery.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Pppoe头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['pppoediscovery'])\n\n    # 修改Pppoe头部\n    attr = edit_header_pppoe_discovery(Stream=stream, Level=0,\n                                       SessionId=10,\n                                       EndOfListTag=1,\n                                       RelaySessionIdTag=1)\n    edit_modifier(Stream=stream, Attribute=attr['SessionId'],\n                  Type='Increment', Count=10, HeaderType='pppoediscovery')\n\n    end_of_list_attr = edit_header_pppoe_discovery_end_of_list_tag(Stream=stream,\n                                                                   Length=10)\n    edit_modifier(Stream=stream, Attribute=end_of_list_attr['Length'],\n                  Type='Increment', Count=10, HeaderType='pppoediscovery')\n\n    relay_session_id_attr = edit_header_pppoe_discovery_relay_session_id_tag(Stream=stream,\n                                                                             TagIndex=1,\n                                                                             Value='102030')\n    edit_modifier(Stream=stream, Attribute=relay_session_id_attr['Value'],\n                  Type='Increment', Count=10, HeaderType='pppoediscovery')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，使用给定位置信息（如//10.0.11.191/1/5和//10.0.11.191/1/6）。\",\n  \"子任务3\": \"在预约端口上创建一条流量模板StreamTemplate_1。\",\n  \"子任务4\": \"为流量添加PPPoE Discovery报文头部结构。\",\n  \"子任务5\": \"修改PPPoE头部Session ID字段，配置起始值10并设置递增模式（步长10）。\",\n  \"子任务6\": \"修改PPPoE头部End of List Tag的Length字段，配置起始值10并设置递增模式（步长10）。\",\n  \"子任务7\": \"修改PPPoE头部Relay Session ID Tag的Value字段，配置起始值'102030'并设置递增模式（步长10）。\",\n  \"子任务8\": \"订阅统计视图，包含PortStats和StreamBlockStats类型。\",\n  \"子任务9\": \"配置端口发送模式为突发包（BURST），设置突发包数量为100。\",\n  \"子任务10\": \"保存当前测试配置到指定路径的.xcfg文件。\",\n  \"子任务11\": \"开始发送所有流量。\",\n  \"子任务12\": \"等待流量发送完成（仪表状态变为停止）。\",\n  \"子任务13\": \"流量停止后等待3秒以确保统计结果就绪。\",\n  \"子任务14\": \"获取流量StreamTemplate_1的StreamBlockStats统计结果。\",\n  \"子任务15\": \"验证发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）且都等于突发包数量100。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Pppoe头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['pppoediscovery'])\n\n    # 修改Pppoe头部\n    attr = edit_header_pppoe_discovery(Stream=stream, Level=0,\n                                       SessionId=10,\n                                       EndOfListTag=1,\n                                       RelaySessionIdTag=1)\n    edit_modifier(Stream=stream, Attribute=attr['SessionId'],\n                  Type='Increment', Count=10, HeaderType='pppoediscovery')\n\n    end_of_list_attr = edit_header_pppoe_discovery_end_of_list_tag(Stream=stream,\n                                                                   Length=10)\n    edit_modifier(Stream=stream, Attribute=end_of_list_attr['Length'],\n                  Type='Increment', Count=10, HeaderType='pppoediscovery')\n\n    relay_session_id_attr = edit_header_pppoe_discovery_relay_session_id_tag(Stream=stream,\n                                                                             TagIndex=1,\n                                                                             Value='102030')\n    edit_modifier(Stream=stream, Attribute=relay_session_id_attr['Value'],\n                  Type='Increment', Count=10, HeaderType='pppoediscovery')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ethernet8023Raw.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ethernetii报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ethernet raw 802.3头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Force=True)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['Raw']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ethernet raw 802.3头部\n    attribute_dict = edit_header_raw_8023(Stream=stream, Level=0, DestMacAdd='00:00:00:00:00:01',\n                                          SourceMacAdd='00:00:00:00:00:02')\n    print(attribute_dict)\n    # ethernet raw 802.3头部目的Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='raw', Attribute=attribute_dict['DestMacAdd'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # ethernet raw 802.3头部源Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='raw', Attribute=attribute_dict['SourceMacAdd'],\n                  Type='List',\n                  List=['00:00:00:00:00:02', '00:00:00:00:00:03', '00:00:00:00:00:04', '00:00:00:00:00:05'])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口（Port_1、Port_2），强制占用资源。\",\n  \"子任务3\": \"在Port_1上创建流量流，固定帧长为256字节。\",\n  \"子任务4\": \"为流量创建Raw类型报文头部。\",\n  \"子任务5\": \"修改ethernet raw 802.3头部目的MAC地址为'00:00:00:00:00:01'，源MAC地址为'00:00:00:00:00:02'。\",\n  \"子任务6\": \"配置目的MAC地址字段跳变规则：增量模式，步长2，数量10。\",\n  \"子任务7\": \"配置源MAC地址字段跳变规则：列表模式，指定四个预设MAC地址值。\",\n  \"子任务8\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务9\": \"设置Port_1发送模式为突发包（BURST），突发包数量为100。\",\n  \"子任务10\": \"保存当前测试配置文件到指定路径。\",\n  \"子任务11\": \"启动所有端口抓包功能。\",\n  \"子任务12\": \"开始发送流量流。\",\n  \"子任务13\": \"等待10秒传输时间。\",\n  \"子任务14\": \"停止所有流量发送。\",\n  \"子任务15\": \"停止端口抓包功能。\",\n  \"子任务16\": \"从Port_2下载捕获的数据包，保存到指定目录，限制最大包数100。\",\n  \"子任务17\": \"获取流量流统计信息（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务18\": \"验证TxStreamFrames与RxStreamFrames数值相等。\",\n  \"子任务19\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ethernetii报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ethernet raw 802.3头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Force=True)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['Raw']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ethernet raw 802.3头部\n    attribute_dict = edit_header_raw_8023(Stream=stream, Level=0, DestMacAdd='00:00:00:00:00:01',\n                                          SourceMacAdd='00:00:00:00:00:02')\n    print(attribute_dict)\n    # ethernet raw 802.3头部目的Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='raw', Attribute=attribute_dict['DestMacAdd'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # ethernet raw 802.3头部源Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='raw', Attribute=attribute_dict['SourceMacAdd'],\n                  Type='List',\n                  List=['00:00:00:00:00:02', '00:00:00:00:00:03', '00:00:00:00:00:04', '00:00:00:00:00:05'])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Hdlc.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Hdlc头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['chdlc', 'ipv4'])\n\n    # 修改Hdlc头部\n    attr = edit_header_hdlc(Stream=stream, Level=0,\n                            Address='FF')\n    edit_modifier(Stream=stream, Attribute=attr['Address'],\n                  Type='Increment', Count=10, HeaderType='chdlc')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在端口Port_1上创建一条流量StreamTemplate_1。\",\n  \"子任务4\": \"为流量StreamTemplate_1创建报文头部，指定头部类型为chdlc和ipv4。\",\n  \"子任务5\": \"修改流量StreamTemplate_1的Hdlc头部Address字段，设置初始值为'FF'并配置增量跳变规则（步长10次）。\",\n  \"子任务6\": \"设置端口Port_1的发送模式为突发包模式，突发包数量为100。\",\n  \"子任务7\": \"订阅流模板块统计信息StreamBlockStats。\",\n  \"子任务8\": \"保存当前测试配置文件。\",\n  \"子任务9\": \"启动所有流量发送。\",\n  \"子任务10\": \"等待流量自动停止发送。\",\n  \"子任务11\": \"等待3秒确保统计结果稳定。\",\n  \"子任务12\": \"获取流量StreamTemplate_1的流模板块统计信息。\",\n  \"子任务13\": \"验证流量StreamTemplate_1的发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)且都等于100。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Hdlc头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['chdlc', 'ipv4'])\n\n    # 修改Hdlc头部\n    attr = edit_header_hdlc(Stream=stream, Level=0,\n                            Address='FF')\n    edit_modifier(Stream=stream, Attribute=attr['Address'],\n                  Type='Increment', Count=10, HeaderType='chdlc')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6Neighboradvertise.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 neighbor advertise报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 neighbor advertise头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'NeighborAdvertise']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_neighbor_advertise(Stream=stream, Level=0,\n                                                   Type='143',Checksum='0000',\n                                                   HeaderOption=['OptionSourceLinkLayerAddress', 'OptionMTU'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='NeighborAdvertise', Attribute=header['Checksum'],\n                  Type='Increment', Count=10)\n\n    option = edit_header_icmpv6_header_option(Stream=stream, Header='neighboradvertise',\n                                              Option='OptionSourceLinkLayerAddress',\n                                              Address='22:22:22:22:22:22')\n    edit_modifier(Stream=stream, Level=0, HeaderType='NeighborAdvertise', Attribute=option['Address'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='neighborAdvertise_1.type',\n                                               Value='143', MaxValue='143')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='neighborAdvertise_1.checksum',\n                                               Value='0000', MaxValue='0000')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_header_option:修改测试仪表流量模板中ICMPv6报文头部Header Option内容",
      "edit_header_icmpv6_neighbor_advertise:修改测试仪表流量模板中Icmpv6 Neighbor Advertise报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量模板，设置固定帧长256字节。\",\n  \"子任务4\": \"为流量配置三层报文头部：EthernetII、IPv6、NeighborAdvertise。\",\n  \"子任务5\": \"修改NeighborAdvertise头部：设置Type=143、Checksum=0000，添加OptionSourceLinkLayerAddress和OptionMTU选项。\",\n  \"子任务6\": \"为Checksum字段配置增量跳变：起始值0000，步长1，计数10。\",\n  \"子任务7\": \"为OptionSourceLinkLayerAddress地址字段配置增量跳变：起始值22:22:22:22:22:22，步长1，计数10。\",\n  \"子任务8\": \"在Port_2创建抓包过滤条件：匹配NeighborAdvertise的Type=143且Checksum=0000的PDU Pattern。\",\n  \"子任务9\": \"订阅流模板块统计视图StreamBlockStats。\",\n  \"子任务10\": \"配置Port_1发送模式为BURST，突发包数量100。\",\n  \"子任务11\": \"保存当前测试配置文件。\",\n  \"子任务12\": \"启动Port_2抓包功能。\",\n  \"子任务13\": \"从Port_1开始发送流量。\",\n  \"子任务14\": \"等待10秒传输时间。\",\n  \"子任务15\": \"停止Port_1流量发送。\",\n  \"子任务16\": \"停止Port_2抓包功能。\",\n  \"子任务17\": \"下载Port_2捕获的报文数据。\",\n  \"子任务18\": \"获取流模板块统计信息。\",\n  \"子任务19\": \"验证流量统计结果：TxStreamFrames等于RxStreamFrames。\",\n  \"子任务20\": \"释放Port_1和Port_2端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 neighbor advertise报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 neighbor advertise头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'NeighborAdvertise']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_neighbor_advertise(Stream=stream, Level=0,\n                                                   Type='143',Checksum='0000',\n                                                   HeaderOption=['OptionSourceLinkLayerAddress', 'OptionMTU'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='NeighborAdvertise', Attribute=header['Checksum'],\n                  Type='Increment', Count=10)\n\n    option = edit_header_icmpv6_header_option(Stream=stream, Header='neighboradvertise',\n                                              Option='OptionSourceLinkLayerAddress',\n                                              Address='22:22:22:22:22:22')\n    edit_modifier(Stream=stream, Level=0, HeaderType='NeighborAdvertise', Attribute=option['Address'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='neighborAdvertise_1.type',\n                                               Value='143', MaxValue='143')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='neighborAdvertise_1.checksum',\n                                               Value='0000', MaxValue='0000')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_header_option:修改测试仪表流量模板中ICMPv6报文头部Header Option内容;\nedit_header_icmpv6_neighbor_advertise:修改测试仪表流量模板中Icmpv6 Neighbor Advertise报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6MLDv1Query.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv1 query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv1 query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv1query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv6 mldv1query头部\n    edit_header_icmpv6_mldv1_query(Stream=stream, Level=0,\n                          Code='2',Reserved='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Query_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Query_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Query_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_mldv1_query:修改测试仪表流量模板中Icmpv6 Mldv1 Query报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量StreamTemplate_1，设置固定帧长为256字节。\",\n  \"子任务4\": \"为StreamTemplate_1创建报文头部，指定层次结构为EthernetII、IPv6、mldv1query。\",\n  \"子任务5\": \"修改StreamTemplate_1的icmpv6 mldv1 query头部，设置Code=2、Reserved=10、MulticastAddress='FF1E::1'。\",\n  \"子任务6\": \"在Port_2上创建三个PDU Pattern：匹配mldv1query头部的code字段值=2、reserved字段值=10、multicastAddress字段值='FF1E::1'。\",\n  \"子任务7\": \"在Port_2上配置报文过滤逻辑表达式，将三个PDU Pattern以逻辑与(&&)组合。\",\n  \"子任务8\": \"订阅测试仪表的StreamBlockStats统计视图。\",\n  \"子任务9\": \"设置Port_1的发送模式为突发包(BURST)，指定突发包数量为100。\",\n  \"子任务10\": \"启动Port_2的数据抓包功能。\",\n  \"子任务11\": \"在Port_1上开始发送StreamTemplate_1流量。\",\n  \"子任务12\": \"等待10秒以确保流量发送完成。\",\n  \"子任务13\": \"停止Port_1上的所有流量发送。\",\n  \"子任务14\": \"停止Port_2的数据抓包功能。\",\n  \"子任务15\": \"获取StreamTemplate_1的StreamBlockStats统计结果，包括TxStreamFrames和RxStreamFrames。\",\n  \"子任务16\": \"验证TxStreamFrames与RxStreamFrames统计值相等。\",\n  \"子任务17\": \"释放Port_1和Port_2的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv1 query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv1 query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv1query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv6 mldv1query头部\n    edit_header_icmpv6_mldv1_query(Stream=stream, Level=0,\n                          Code='2',Reserved='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Query_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Query_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Query_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_mldv1_query:修改测试仪表流量模板中Icmpv6 Mldv1 Query报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4InformationRequest.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 information request报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 information request头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'InformationRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 InformationRequest头部\n    edit_header_icmp_information_request(Stream=stream, Level=0, Code='4',\n                                         Identifier='100', SequenceNumber='200')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationRequest_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationRequest_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_information_request:修改测试仪表流量模板中Icmp Information Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，位置为//10.0.11.191/1/3和//10.0.11.191/1/4。\",\n  \"子任务3\": \"在第一个端口创建流量，设置固定帧长度为256字节。\",\n  \"子任务4\": \"为流量配置报文头部：EthernetII、IPv4和InformationRequest三层协议。\",\n  \"子任务5\": \"修改ICMPv4 Information Request头部：设置Code为4、Identifier为100、SequenceNumber为200。\",\n  \"子任务6\": \"在第二个端口创建PDU匹配模式1：过滤字段informationRequest_1.identifier值为100。\",\n  \"子任务7\": \"在第二个端口创建PDU匹配模式2：过滤字段informationRequest_1.SequenceNumber值为200。\",\n  \"子任务8\": \"在第二个端口设置抓包过滤表达式：要求同时满足PDU模式1和PDU模式2（逻辑与）。\",\n  \"子任务9\": \"订阅StreamBlockStats统计视图用于后续结果采集。\",\n  \"子任务10\": \"配置第一个端口的发送模式为突发包（BURST），设置突发包数量为100。\",\n  \"子任务11\": \"保存当前测试配置到本地文件。\",\n  \"子任务12\": \"启动第二个端口的数据包捕获功能。\",\n  \"子任务13\": \"启动第一个端口的流量发送。\",\n  \"子任务14\": \"等待10秒确保流量发送完成。\",\n  \"子任务15\": \"停止第一个端口的流量发送。\",\n  \"子任务16\": \"停止第二个端口的数据包捕获。\",\n  \"子任务17\": \"下载第二个端口捕获的数据包到本地目录。\",\n  \"子任务18\": \"获取流量StreamTemplate_1的统计信息，包括TxStreamFrames和RxStreamFrames。\",\n  \"子任务19\": \"验证TxStreamFrames与RxStreamFrames统计值是否相等。\",\n  \"子任务20\": \"释放所有预约的测试仪表端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 information request报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 information request头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'InformationRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 InformationRequest头部\n    edit_header_icmp_information_request(Stream=stream, Level=0, Code='4',\n                                         Identifier='100', SequenceNumber='200')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationRequest_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationRequest_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_information_request:修改测试仪表流量模板中Icmp Information Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Fcoe.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的ELS FLOGI头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['elsflogi'])\n\n    # 修改ELS FLOGI头部\n    attr = edit_header_els_flogi(Stream=stream, Level=0,\n                                 Bbscn=255)\n    edit_modifier(Stream=stream, Attribute=attr['Bbscn'],\n                  Type='Increment', Count=10, HeaderType='elsflogi')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，指定端口位置。\",\n  \"子任务3\": \"在预约端口上创建流量流模板。\",\n  \"子任务4\": \"修改流量模板参数，设置帧长度类型为自动模式。\",\n  \"子任务5\": \"为流量流创建ELS FLOGI报文头部。\",\n  \"子任务6\": \"修改ELS FLOGI头部Bbscn字段的跳变规则，类型为递增，步长为10。\",\n  \"子任务7\": \"订阅流模板块统计视图StreamBlockStats。\",\n  \"子任务8\": \"配置端口负载参数：发送模式为突发包，突发包数量为100。\",\n  \"子任务9\": \"保存当前测试配置文件。\",\n  \"子任务10\": \"开始发送所有流量。\",\n  \"子任务11\": \"等待流量自动停止发送。\",\n  \"子任务12\": \"等待3秒确保统计结果稳定。\",\n  \"子任务13\": \"获取指定流量流的流模板块统计结果。\",\n  \"子任务14\": \"验证发送帧数(TxStreamFrames)与接收帧数(RxStreamFrames)相等且等于突发包数量(100)。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的ELS FLOGI头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['elsflogi'])\n\n    # 修改ELS FLOGI头部\n    attr = edit_header_els_flogi(Stream=stream, Level=0,\n                                 Bbscn=255)\n    edit_modifier(Stream=stream, Attribute=attr['Bbscn'],\n                  Type='Increment', Count=10, HeaderType='elsflogi')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Trill.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的trill头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'trill'])\n\n    # 修改trill头部\n    attr = edit_header_trill(Stream=stream, Level=0,\n                             EgressRBridge=1000, IngressBridge=2000)\n    edit_modifier(Stream=stream, Attribute=attr['IngressBridge'],\n                  Type='Increment', Count=10, HeaderType='trill')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约两个自环端口，指定端口位置并强制预约。\",\n  \"子任务3\": \"在预约端口Port_1上创建一条流量。\",\n  \"子任务4\": \"为流量创建以太网II和Trill报文头部。\",\n  \"子任务5\": \"修改流量Trill头部，设置Level=0, EgressRBridge=1000, IngressBridge=2000。\",\n  \"子任务6\": \"修改Trill头部IngressBridge字段的跳变域，设置为增量模式，计数为10。\",\n  \"子任务7\": \"订阅统计视图，包含StreamBlockStats统计类型。\",\n  \"子任务8\": \"配置端口负载为突发包模式，设置突发包数量为100。\",\n  \"子任务9\": \"保存当前测试配置文件到指定路径。\",\n  \"子任务10\": \"开始发送所有流量。\",\n  \"子任务11\": \"等待流量停止发送。\",\n  \"子任务12\": \"等待3秒确保统计结果准确。\",\n  \"子任务13\": \"获取流模板块统计结果，包含TxStreamFrames和RxStreamFrames。\",\n  \"子任务14\": \"验证统计结果：TxStreamFrames等于RxStreamFrames且都等于100。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的trill头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'trill'])\n\n    # 修改trill头部\n    attr = edit_header_trill(Stream=stream, Level=0,\n                             EgressRBridge=1000, IngressBridge=2000)\n    edit_modifier(Stream=stream, Attribute=attr['IngressBridge'],\n                  Type='Increment', Count=10, HeaderType='trill')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahEncapsulatedBackboneEthernet.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['encapbackboneeth', 'ipv4'])\n\n    # 修改Encapsulated Mac-in-Mac头部\n    attr = edit_header_8021ah_EncapsulatedBackboneEthernet(Stream=stream, Level=0,\n                                                           Vid=200)\n    edit_modifier(Stream=stream, Attribute=attr['Vid'],\n                  Type='Increment', Count=10, HeaderType='encapbackboneeth')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在端口Port_1上创建流量StreamTemplate_1。\",\n  \"子任务4\": \"为流量StreamTemplate_1创建报文头部，包含encapbackboneeth和ipv4类型。\",\n  \"子任务5\": \"修改流量StreamTemplate_1的802.1ah头部中Vid字段，设置起始值为200。\",\n  \"子任务6\": \"配置Vid字段的跳变规则为递增模式，步长为10。\",\n  \"子任务7\": \"设置端口Port_1的发送模式为突发包，指定突发包数量为100。\",\n  \"子任务8\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务9\": \"保存当前测试配置文件。\",\n  \"子任务10\": \"开始发送所有流量。\",\n  \"子任务11\": \"等待流量完全停止。\",\n  \"子任务12\": \"等待3秒确保统计结果稳定。\",\n  \"子任务13\": \"获取流量StreamTemplate_1的StreamBlockStats统计信息。\",\n  \"子任务14\": \"验证发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)且等于突发包数量(100)。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['encapbackboneeth', 'ipv4'])\n\n    # 修改Encapsulated Mac-in-Mac头部\n    attr = edit_header_8021ah_EncapsulatedBackboneEthernet(Stream=stream, Level=0,\n                                                           Vid=200)\n    edit_modifier(Stream=stream, Attribute=attr['Vid'],\n                  Type='Increment', Count=10, HeaderType='encapbackboneeth')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv2ControlOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发L2TPv2 Control Over UDP报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的L2TPv2 Control Over UDP头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv2Control头部\n    header = edit_header_l2tpv2_control(Stream=stream, Level=0, Reserved1=11, Ns=5, Nr=6)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header['Nr'],\n                  Type='Increment', Count=10)\n    # 修改l2tp control option\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=0, Types='GeneralTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=1, Types='MessageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=2, Types='ResultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ErrorMessage'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=3, Types='ProtocolVersion', Ver='1', Rev='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Ver'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=4, Types='FramingCapabilities', Abit='1', Sbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Abit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=5, Types='BearerCapabilities', Abit='1', Dbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Dbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=6, Types='TieBreaker', TieBreakerValue='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['TieBreakerValue'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=7, Types='FirmwareRevision', FirmwareRevision='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['FirmwareRevision'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=8, Types='AssignedTunnelId', TunnelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['TunnelId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=9, Types='ReceiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=10, Types='AssignedSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=11, Types='Response', ResponseValue='00000000000000000000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ResponseValue'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=12, Types='CallSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=13, Types='MinimumBps', MinimumBps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MinimumBps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=14, Types='MaximumBps', MaximumBps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MaximumBps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=15, Types='BearerType', Abit='1', Dbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Dbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=16, Types='FramingType', Abit='1', Sbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Sbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=17, Types='TxConnectSpeed', Bps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Bps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=18, Types='RxConnectSpeed', HighBPS='1', LowBPS='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['HighBPS'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=19, Types='PhysicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=20, Types='ProxyAuthenType', AuthenType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AuthenType'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=21, Types='ProxyAuthenId', AuthenId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AuthenId'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv2Control_1.ns',\n                                               Value='5', MaxValue='5')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表平台，指定产品型号为'DarYu'。\",\n  \"子任务2\": \"预约两个自环端口，端口地址为'//10.0.11.191/1/3'和'//10.0.11.191/1/4'。\",\n  \"子任务3\": \"在第一个端口上创建流量模板，设置帧长度类型为'AUTO'。\",\n  \"子任务4\": \"为流量创建报文头部协议栈，包含EthernetII、IPv4、UDP和L2TPv2 Control协议。\",\n  \"子任务5\": \"编辑L2TPv2 Control主头部字段，设置Ns=5, Nr=6等参数。\",\n  \"子任务6\": \"为L2TPv2 Control主头部的Nr字段配置递增跳变，步长为1，变化次数为10。\",\n  \"子任务7\": \"编辑L2TPv2 Control选项字段，配置GeneralTLV、MessageType、ResultCode等20种选项类型。\",\n  \"子任务8\": \"为选项字段中的AttributeValue、MessageType、ErrorCode等关键字段配置递增跳变。\",\n  \"子任务9\": \"在第二个端口上创建抓包过滤条件，基于L2TPv2 Control头部的Ns字段（值=5）设置过滤表达式。\",\n  \"子任务10\": \"订阅StreamBlockStats统计视图用于后续结果验证。\",\n  \"子任务11\": \"配置第一个端口的发送模式为突发包模式，设置突发包数量为100。\",\n  \"子任务12\": \"保存当前测试配置到本地xcfg文件。\",\n  \"子任务13\": \"启动第二个端口的抓包功能。\",\n  \"子任务14\": \"开始发送流量。\",\n  \"子任务15\": \"等待10秒确保流量发送完成。\",\n  \"子任务16\": \"停止流量发送。\",\n  \"子任务17\": \"停止抓包。\",\n  \"子任务18\": \"下载第二个端口捕获的报文到本地pcap文件。\",\n  \"子任务19\": \"获取流量统计信息，提取TxStreamFrames和RxStreamFrames值。\",\n  \"子任务20\": \"验证TxStreamFrames与RxStreamFrames是否相等。\",\n  \"子任务21\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发L2TPv2 Control Over UDP报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的L2TPv2 Control Over UDP头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv2Control头部\n    header = edit_header_l2tpv2_control(Stream=stream, Level=0, Reserved1=11, Ns=5, Nr=6)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header['Nr'],\n                  Type='Increment', Count=10)\n    # 修改l2tp control option\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=0, Types='GeneralTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=1, Types='MessageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=2, Types='ResultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ErrorMessage'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=3, Types='ProtocolVersion', Ver='1', Rev='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Ver'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=4, Types='FramingCapabilities', Abit='1', Sbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Abit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=5, Types='BearerCapabilities', Abit='1', Dbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Dbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=6, Types='TieBreaker', TieBreakerValue='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['TieBreakerValue'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=7, Types='FirmwareRevision', FirmwareRevision='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['FirmwareRevision'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=8, Types='AssignedTunnelId', TunnelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['TunnelId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=9, Types='ReceiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=10, Types='AssignedSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=11, Types='Response', ResponseValue='00000000000000000000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ResponseValue'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=12, Types='CallSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=13, Types='MinimumBps', MinimumBps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MinimumBps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=14, Types='MaximumBps', MaximumBps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MaximumBps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=15, Types='BearerType', Abit='1', Dbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Dbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=16, Types='FramingType', Abit='1', Sbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Sbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=17, Types='TxConnectSpeed', Bps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Bps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=18, Types='RxConnectSpeed', HighBPS='1', LowBPS='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['HighBPS'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=19, Types='PhysicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=20, Types='ProxyAuthenType', AuthenType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AuthenType'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=21, Types='ProxyAuthenId', AuthenId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AuthenId'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv2Control_1.ns',\n                                               Value='5', MaxValue='5')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Header_GRE.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发gre报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的gre头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'gre']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改gre头部\n    header = edit_header_gre(Stream=stream, Level=0, ChecksumPresent=1, Routing=1, Protocol='IPv4',\n                             Checksum=123, ChecksumReserved=123, SequenceNumber=2, Key=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gre', Attribute=header['Checksum'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gre', Attribute=header['Key'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gre', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='gre_1.routing ',\n                                               Value='1', MaxValue='1')\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='gre_1.checksum.GreChecksum_0.checksum',\n    #                                            Value='123',\n    #                                            MaxValue='123')\n    # pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='gre_1.sequenceNumber.GreSequenceNumber_0.sequenceNumber',\n    #                                            Value='2',\n    #                                            MaxValue='2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_gre:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试平台类型。\",\n  \"子任务2\": \"预约两个自环端口（Port_1和Port_2）。\",\n  \"子任务3\": \"在Port_1创建流量模板StreamTemplate_1，设置固定帧长256字节。\",\n  \"子任务4\": \"为流量模板添加报文头部结构（EthernetII/IPv4/GRE）。\",\n  \"子任务5\": \"修改GRE头部参数：设置ChecksumPresent=1, Routing=1, Protocol=IPv4, Checksum=123, ChecksumReserved=123, SequenceNumber=2, Key=1。\",\n  \"子任务6\": \"配置GRE头部的Checksum字段跳变域：增量类型，计数10，步长2。\",\n  \"子任务7\": \"配置GRE头部的Key字段跳变域：增量类型，计数10，步长2。\",\n  \"子任务8\": \"配置GRE头部的SequenceNumber字段跳变域：增量类型，计数10，步长2。\",\n  \"子任务9\": \"在Port_2创建抓包过滤规则：基于GRE头部routing字段值等于1。\",\n  \"子任务10\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务11\": \"设置Port_1发送模式为突发包，指定突发包数量。\",\n  \"子任务12\": \"启动Port_2抓包功能。\",\n  \"子任务13\": \"启动Port_1流量发送。\",\n  \"子任务14\": \"等待10秒流量发送时间。\",\n  \"子任务15\": \"停止Port_1流量发送。\",\n  \"子任务16\": \"停止Port_2抓包功能。\",\n  \"子任务17\": \"获取StreamTemplate_1流量统计信息（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务18\": \"验证流量统计结果：StreamTemplate_1收发包数量相等（TxStreamFrames == RxStreamFrames）。\",\n  \"子任务19\": \"释放两个预约端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发gre报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的gre头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'gre']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改gre头部\n    header = edit_header_gre(Stream=stream, Level=0, ChecksumPresent=1, Routing=1, Protocol='IPv4',\n                             Checksum=123, ChecksumReserved=123, SequenceNumber=2, Key=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gre', Attribute=header['Checksum'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gre', Attribute=header['Key'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gre', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='gre_1.routing ',\n                                               Value='1', MaxValue='1')\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='gre_1.checksum.GreChecksum_0.checksum',\n    #                                            Value='123',\n    #                                            MaxValue='123')\n    # pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='gre_1.sequenceNumber.GreSequenceNumber_0.sequenceNumber',\n    #                                            Value='2',\n    #                                            MaxValue='2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_gre:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6ParameterProblem.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 parameter problem报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 parameter problem头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'icmpv6parameterproblem']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    #  修改icmpv6 parameter problem头部\n    edit_header_icmpv6_parameter_problem(Stream=stream, Level=0,\n                                         Pointer='00000011', FlowLabel='1111', HopLimit='255', Source='2020::2',\n                                         Gateway='2020::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6ParameterProblem_1.headerData.ipv6Header.hopLimit',\n                                               Value='255', MaxValue='255')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6ParameterProblem_1.headerData.ipv6Header.source',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6ParameterProblem_1.pointer',\n                                               Value='00000011',\n                                               MaxValue='00000011')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_parameter_problem:修改测试仪表流量模板中Icmpv6 Parameter Problem报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务3\": \"在 Port_1 创建流量模板 StreamTemplate_1，设置固定帧长256字节。\",\n  \"子任务4\": \"为 StreamTemplate_1 配置报文头部结构：EthernetII + IPv4 + ICMPv6 Parameter Problem。\",\n  \"子任务5\": \"修改 ICMPv6 Parameter Problem 头部字段：指针=00000011、流标签=1111、跳数限制=255、源地址=2020::2、网关=2020::1。\",\n  \"子任务6\": \"在 Port_2 创建三个PDU匹配模式：跳数限制=255、源地址=2020::2、指针=00000011。\",\n  \"子任务7\": \"在 Port_2 设置抓包过滤表达式：三个PDU模式的逻辑与组合。\",\n  \"子任务8\": \"订阅流模板块统计视图 StreamBlockStats。\",\n  \"子任务9\": \"配置 Port_1 发送模式为突发包，设置突发包数量为100。\",\n  \"子任务10\": \"保存当前测试配置文件。\",\n  \"子任务11\": \"启动 Port_2 抓包功能。\",\n  \"子任务12\": \"从 Port_1 发送 StreamTemplate_1 流量。\",\n  \"子任务13\": \"等待10秒确保流量发送完成。\",\n  \"子任务14\": \"停止 Port_1 流量发送。\",\n  \"子任务15\": \"停止 Port_2 抓包功能。\",\n  \"子任务16\": \"下载 Port_2 捕获的数据包文件。\",\n  \"子任务17\": \"获取 StreamTemplate_1 的流统计信息：发送帧数和接收帧数。\",\n  \"子任务18\": \"验证发送帧数与接收帧数是否相等。\",\n  \"子任务19\": \"释放所有预约端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 parameter problem报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 parameter problem头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'icmpv6parameterproblem']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    #  修改icmpv6 parameter problem头部\n    edit_header_icmpv6_parameter_problem(Stream=stream, Level=0,\n                                         Pointer='00000011', FlowLabel='1111', HopLimit='255', Source='2020::2',\n                                         Gateway='2020::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6ParameterProblem_1.headerData.ipv6Header.hopLimit',\n                                               Value='255', MaxValue='255')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6ParameterProblem_1.headerData.ipv6Header.source',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6ParameterProblem_1.pointer',\n                                               Value='00000011',\n                                               MaxValue='00000011')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_parameter_problem:修改测试仪表流量模板中Icmpv6 Parameter Problem报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Eoam.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Eoam头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['CCM'])\n\n    # 修改Eoam头部\n    attr = edit_header_eoam(Stream=stream, Level=0,\n                            MDlevel=7,\n                            Tlvs=['SenderIDTLV', 'PortStatusTLV', 'InterfaceStatusTLV',\n                                  'OrgSpecTLV', 'EndTLV'])\n    edit_modifier(Stream=stream, Attribute=attr['MDlevel'],\n                  Type='Increment', Count=10, HeaderType='CCM')\n\n    sender_attr = edit_header_eoam_sender_id_tlv(Stream=stream,\n                                                 Type='FF',\n                                                 theChassisID='ChassisComponent',\n                                                 theManagementAddressDomain='MADtDU4')\n    edit_modifier(Stream=stream, Attribute=sender_attr['Type'],\n                  Type='Increment', Count=10, HeaderType='CCM')\n\n    chassis_attr = edit_header_eoam_sender_id_tlv_chassis_id(Stream=stream,\n                                                             Type='ChassisComponent',\n                                                             ChassisID='TEST')\n    management_attr = edit_header_eoam_sender_id_tlv_management_address_domain(Stream=stream,\n                                                                               Type='MADtDU4',\n                                                                               IPv4='1.1.1.1')\n    end_attr = edit_header_eoam_end_tlv(Stream=stream, Index=4, Type='FF')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口。\",\n  \"子任务3\": \"在指定端口创建一条流量。\",\n  \"子任务4\": \"创建流量的报文头部为CCM类型。\",\n  \"子任务5\": \"修改流量的Eoam头部内容，包括设置Level、MDlevel和Tlvs等参数。\",\n  \"子任务6\": \"设置流量修改器对Eoam字段进行跳变，如Increment类型和计数。\",\n  \"子任务7\": \"订阅统计视图，包括StreamBlockStats统计。\",\n  \"子任务8\": \"设置端口发送模式为突发包，指定突发计数。\",\n  \"子任务9\": \"保存测试配置文件。\",\n  \"子任务10\": \"开始发送所有流量。\",\n  \"子任务11\": \"等待流量停止。\",\n  \"子任务12\": \"等待额外时间（如3秒）以确保统计结果准确。\",\n  \"子任务13\": \"获取指定流量的StreamBlockStats统计信息，包括发送帧数和接收帧数。\",\n  \"子任务14\": \"验证发送帧数和接收帧数是否相等，且等于预期突发计数。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Eoam头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['CCM'])\n\n    # 修改Eoam头部\n    attr = edit_header_eoam(Stream=stream, Level=0,\n                            MDlevel=7,\n                            Tlvs=['SenderIDTLV', 'PortStatusTLV', 'InterfaceStatusTLV',\n                                  'OrgSpecTLV', 'EndTLV'])\n    edit_modifier(Stream=stream, Attribute=attr['MDlevel'],\n                  Type='Increment', Count=10, HeaderType='CCM')\n\n    sender_attr = edit_header_eoam_sender_id_tlv(Stream=stream,\n                                                 Type='FF',\n                                                 theChassisID='ChassisComponent',\n                                                 theManagementAddressDomain='MADtDU4')\n    edit_modifier(Stream=stream, Attribute=sender_attr['Type'],\n                  Type='Increment', Count=10, HeaderType='CCM')\n\n    chassis_attr = edit_header_eoam_sender_id_tlv_chassis_id(Stream=stream,\n                                                             Type='ChassisComponent',\n                                                             ChassisID='TEST')\n    management_attr = edit_header_eoam_sender_id_tlv_management_address_domain(Stream=stream,\n                                                                               Type='MADtDU4',\n                                                                               IPv4='1.1.1.1')\n    end_attr = edit_header_eoam_end_tlv(Stream=stream, Index=4, Type='FF')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6TimeExceed.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 timeexceed报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 timeexceed头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'timeexceed']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 timeexceed头部\n    edit_header_icmpv6_time_exceed(Stream=stream, Level=0, Code='1', Reserve='11')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceed_1.reserve',\n                                               Value='11', MaxValue='11')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceed_1.code',\n                                               Value='1',\n                                               MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_time_exceed:修改测试仪表流量模板中Icmpv6 Time Exceed报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"创建流量模板StreamTemplate_1并设置固定帧长256字节。\",\n  \"子任务4\": \"为流量模板创建报文头部结构：EthernetII, IPv4, timeexceed。\",\n  \"子任务5\": \"修改流量模板的ICMPv6 Time Exceed头部：Level=0, Code='1', Reserve='11'。\",\n  \"子任务6\": \"在Port_2创建两个PDU匹配模式：分别匹配timeExceed_1.reserve=11和timeExceed_1.code=1。\",\n  \"子任务7\": \"在Port_2配置报文过滤逻辑表达式：同时满足两个PDU匹配模式。\",\n  \"子任务8\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务9\": \"设置Port_1发送模式为突发包，指定突发包数量为100。\",\n  \"子任务10\": \"保存当前测试配置文件。\",\n  \"子任务11\": \"在Port_2启动数据包捕获。\",\n  \"子任务12\": \"启动流量发送。\",\n  \"子任务13\": \"等待10秒确保流量发送完成。\",\n  \"子任务14\": \"停止流量发送。\",\n  \"子任务15\": \"停止数据包捕获。\",\n  \"子任务16\": \"下载Port_2捕获的数据包到本地存储。\",\n  \"子任务17\": \"获取StreamTemplate_1的流统计结果。\",\n  \"子任务18\": \"验证流统计结果：TxStreamFrames等于RxStreamFrames。\",\n  \"子任务19\": \"释放所有预约的端口资源。\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 timeexceed报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 timeexceed头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'timeexceed']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 timeexceed头部\n    edit_header_icmpv6_time_exceed(Stream=stream, Level=0, Code='1', Reserve='11')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceed_1.reserve',\n                                               Value='11', MaxValue='11')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceed_1.code',\n                                               Value='1',\n                                               MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_time_exceed:修改测试仪表流量模板中Icmpv6 Time Exceed报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/PrpTag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的prp tag头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['prptag', 'ipv4'])\n\n    # 修改hsr头部\n    attr = edit_header_prp_tag(Stream=stream, Level=0,\n                               SequenceNumber=4095)\n    edit_modifier(Stream=stream, Attribute=attr['SequenceNumber'],\n                  Type='Increment', Count=10, HeaderType='prptag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，强制占用指定物理位置。\",\n  \"子任务3\": \"在端口Port_1上创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"为流量模板添加报文头部，指定头部类型为prptag和ipv4。\",\n  \"子任务5\": \"编辑prptag头部的SequenceNumber字段值为4095。\",\n  \"子任务6\": \"为SequenceNumber字段配置跳变规则：类型为递增，步长为10。\",\n  \"子任务7\": \"设置端口发送模式为突发包模式，指定突发包数量为100。\",\n  \"子任务8\": \"保存当前测试配置至指定路径的配置文件。\",\n  \"子任务9\": \"订阅流模板块统计信息StreamBlockStats。\",\n  \"子任务10\": \"开始发送所有流量。\",\n  \"子任务11\": \"等待流量自动停止发送。\",\n  \"子任务12\": \"流量停止后等待3秒确保统计结果稳定。\",\n  \"子任务13\": \"获取流量StreamTemplate_1的流模板块统计结果。\",\n  \"子任务14\": \"验证发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的prp tag头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['prptag', 'ipv4'])\n\n    # 修改hsr头部\n    attr = edit_header_prp_tag(Stream=stream, Level=0,\n                               SequenceNumber=4095)\n    edit_modifier(Stream=stream, Attribute=attr['SequenceNumber'],\n                  Type='Increment', Count=10, HeaderType='prptag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/pause.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的pause头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'pause'])\n\n    # 修改pause头部\n    attr = edit_header_pause(Stream=stream, Level=0,\n                             PauseCode='FFFF')\n    edit_modifier(Stream=stream, Attribute=attr['PauseCode'],\n                  Type='Increment', Count=10, HeaderType='pause')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口：Port_1和Port_2。\",\n  \"子任务3\": \"在端口Port_1上创建一条流量StreamTemplate_1。\",\n  \"子任务4\": \"为流量StreamTemplate_1创建pause报文头部。\",\n  \"子任务5\": \"修改流量StreamTemplate_1的pause头部中的PauseCode字段，并设置该字段的跳变规则（如递增）。\",\n  \"子任务6\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务7\": \"配置端口Port_1的发送模式为突发包（BURST），并设置突发包数量。\",\n  \"子任务8\": \"开始发送所有流量。\",\n  \"子任务9\": \"等待流量发送完成（流量停止状态）。\",\n  \"子任务10\": \"等待3秒以确保统计结果准确。\",\n  \"子任务11\": \"获取流量StreamTemplate_1的StreamBlockStats统计信息。\",\n  \"子任务12\": \"验证流量StreamTemplate_1的收包帧数（RxStreamFrames）是否等于发包帧数（TxStreamFrames）。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的pause头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'pause'])\n\n    # 修改pause头部\n    attr = edit_header_pause(Stream=stream, Level=0,\n                             PauseCode='FFFF')\n    edit_modifier(Stream=stream, Attribute=attr['PauseCode'],\n                  Type='Increment', Count=10, HeaderType='pause')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv3_ControlOverIp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 control over ip报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 control over ip头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'l2tpv3ControlOverIp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3 control over ip头部\n    header = edit_header_l2tpv3_control_over_ip(Stream=stream, Level=0, SessionId='1', Type='1',\n                                                UseLength='1', ExcludeSessionLength='1', SequenceNumberNs=1, SequenceNumberNr=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header['ExcludeSessionLength'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header['SequenceNumberNs'],\n                  Type='Increment', Count=10)\n\n    # 增加l2tpv3 control over ip选项并修改\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=0, Types='generalTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=1, Types='messageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=2, Types='resultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['ErrorMessage'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=3, Types='tieBreaker', TieBreakerValue='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['TieBreakerValue'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=4, Types='receiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=5, Types='callSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=6, Types='physicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=7, Types='circuitError', AlignmentOverruns='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['AlignmentOverruns'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=8, Types='routeId', RouteId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['RouteId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=9, Types='assignedConnection', ConnectionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['ConnectionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=10, Types='localSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=11, Types='remoteSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=12, Types='assignedCookie', Cookie4Byte='00000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['Cookie4Byte'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=13, Types='pwType', PwType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['PwType'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=14, Types='l2SpecificSub', L2SpecificSublayer='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['L2SpecificSublayer'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=15, Types='dataSequencing', DataSequencing='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['DataSequencing'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=16, Types='txConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=17, Types='rxConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=18, Types='circuitStatus', Nbit='1', Abit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['Nbit'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3ControlOverIp_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个端口资源（Port_1和Port_2）。\",\n  \"子任务3\": \"在Port_1创建流量流，设置帧长度类型为AUTO。\",\n  \"子任务4\": \"为流量流配置三层协议头部：EthernetII、IPv4、l2tpv3ControlOverIp。\",\n  \"子任务5\": \"修改l2tpv3ControlOverIp头部基础字段：SessionId、Type、UseLength等。\",\n  \"子任务6\": \"为l2tpv3ControlOverIp头部中的ExcludeSessionLength和SequenceNumberNs字段配置增量跳变。\",\n  \"子任务7\": \"添加并修改l2tpv3ControlOverIp的19个选项字段（包括generalTLV、messageType等）。\",\n  \"子任务8\": \"在Port_2创建PDU抓包模式，基于l2tpv3ControlOverIp.type=1过滤报文。\",\n  \"子任务9\": \"设置Port_2的抓包过滤表达式。\",\n  \"子任务10\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务11\": \"配置Port_1发送模式为BURST，设置突发包数量为100。\",\n  \"子任务12\": \"保存当前测试配置文件。\",\n  \"子任务13\": \"启动Port_2抓包功能。\",\n  \"子任务14\": \"开始发送流量流。\",\n  \"子任务15\": \"等待10秒传输时间。\",\n  \"子任务16\": \"停止流量发送。\",\n  \"子任务17\": \"停止抓包。\",\n  \"子任务18\": \"下载Port_2捕获的报文数据。\",\n  \"子任务19\": \"获取流量流的StreamBlockStats统计信息。\",\n  \"子任务20\": \"验证统计结果：TxStreamFrames等于RxStreamFrames。\",\n  \"子任务21\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 control over ip报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 control over ip头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'l2tpv3ControlOverIp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3 control over ip头部\n    header = edit_header_l2tpv3_control_over_ip(Stream=stream, Level=0, SessionId='1', Type='1',\n                                                UseLength='1', ExcludeSessionLength='1', SequenceNumberNs=1, SequenceNumberNr=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header['ExcludeSessionLength'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header['SequenceNumberNs'],\n                  Type='Increment', Count=10)\n\n    # 增加l2tpv3 control over ip选项并修改\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=0, Types='generalTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=1, Types='messageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=2, Types='resultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['ErrorMessage'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=3, Types='tieBreaker', TieBreakerValue='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['TieBreakerValue'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=4, Types='receiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=5, Types='callSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=6, Types='physicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=7, Types='circuitError', AlignmentOverruns='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['AlignmentOverruns'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=8, Types='routeId', RouteId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['RouteId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=9, Types='assignedConnection', ConnectionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['ConnectionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=10, Types='localSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=11, Types='remoteSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=12, Types='assignedCookie', Cookie4Byte='00000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['Cookie4Byte'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=13, Types='pwType', PwType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['PwType'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=14, Types='l2SpecificSub', L2SpecificSublayer='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['L2SpecificSublayer'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=15, Types='dataSequencing', DataSequencing='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['DataSequencing'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=16, Types='txConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=17, Types='rxConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=18, Types='circuitStatus', Nbit='1', Abit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['Nbit'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3ControlOverIp_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4InformationReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 information reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 information reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'InformationReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    #修改icmpv4 information reply头部\n    edit_header_icmp_information_reply(Stream=stream, Level=0,Code='4',\n                          Identifier='65535',SequenceNumber='65535')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationReply_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationReply_1.code',\n                                               Value='4',\n                                               MaxValue='4')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_information_reply:修改测试仪表流量模板中Icmp Information Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个端口资源，指定端口位置信息。\",\n  \"子任务3\": \"在发送端口创建流量，设置固定帧长为256字节。\",\n  \"子任务4\": \"为流量创建报文头部，指定类型为EthernetII, IPv4, InformationReply。\",\n  \"子任务5\": \"修改ICMPv4 Information Reply报文头部参数：设置Identifier为65535，SequenceNumber为65535，Code为4。\",\n  \"子任务6\": \"在接收端口创建第一个PDU模式，匹配ICMP Information Reply的identifier字段值为65535。\",\n  \"子任务7\": \"在接收端口创建第二个PDU模式，匹配ICMP Information Reply的code字段值为4。\",\n  \"子任务8\": \"在接收端口设置捕获过滤表达式，将两个PDU模式进行逻辑与(&&)组合。\",\n  \"子任务9\": \"订阅流模板块统计视图(StreamBlockStats)。\",\n  \"子任务10\": \"设置发送端口负载配置：发送模式为BURST，突发包数量为100。\",\n  \"子任务11\": \"保存当前测试配置文件到指定路径。\",\n  \"子任务12\": \"启动接收端口的数据包捕获功能。\",\n  \"子任务13\": \"开始发送流量。\",\n  \"子任务14\": \"等待10秒使流量充分发送。\",\n  \"子任务15\": \"停止发送流量。\",\n  \"子任务16\": \"停止数据包捕获。\",\n  \"子任务17\": \"下载接收端口捕获的数据包到本地存储。\",\n  \"子任务18\": \"获取流模板块统计信息，提取发送帧数(TxStreamFrames)和接收帧数(RxStreamFrames)。\",\n  \"子任务19\": \"验证发送帧数与接收帧数是否相等。\",\n  \"子任务20\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 information reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 information reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'InformationReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    #修改icmpv4 information reply头部\n    edit_header_icmp_information_reply(Stream=stream, Level=0,Code='4',\n                          Identifier='65535',SequenceNumber='65535')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationReply_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationReply_1.code',\n                                               Value='4',\n                                               MaxValue='4')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_information_reply:修改测试仪表流量模板中Icmp Information Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4SourceQuench.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 source quench报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 source quench头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'SourceQuench']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改SourceQuench头部\n    edit_header_icmp_source_quench(Stream=stream, Level=0,\n                          Code='2', Ipv4HeaderTosReserved='1',\n                          Ipv4HeaderOffset='1', Ipv4HeaderSource='10.1.1.2')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='sourceQuench_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='sourceQuench_1.headerData.ipv4Header.offset',\n                                               Value='1',\n                                               MaxValue='1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='sourceQuench_1.headerData.ipv4Header.source',\n                                               Value='10.1.1.2',\n                                               MaxValue='10.1.1.2')\n    edit_capture_filter(Port=Ports[1],Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_source_quench:修改测试仪表流量模板中Icmp Source Quench报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量模板，固定帧长度为256字节。\",\n  \"子任务4\": \"为流量模板创建三层报文头部：EthernetII、IPv4和SourceQuench。\",\n  \"子任务5\": \"修改ICMP Source Quench头部：设置Level=0, Code=2, Ipv4HeaderTosReserved=1, Ipv4HeaderOffset=1, Ipv4HeaderSource='10.1.1.2'。\",\n  \"子任务6\": \"在Port_2上创建三个PDU匹配模式：匹配code=2、ipv4Header.offset=1、ipv4Header.source='10.1.1.2'。\",\n  \"子任务7\": \"在Port_2配置抓包过滤规则：组合三个PDU模式形成逻辑与(&&)表达式。\",\n  \"子任务8\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务9\": \"配置Port_1发送模式为突发包(BURST)，设置突发包数量为100。\",\n  \"子任务10\": \"启动Port_2抓包功能。\",\n  \"子任务11\": \"开始发送Port_1上的所有流量。\",\n  \"子任务12\": \"等待10秒确保流量发送完成。\",\n  \"子任务13\": \"停止Port_1流量发送。\",\n  \"子任务14\": \"停止Port_2抓包功能。\",\n  \"子任务15\": \"下载Port_2捕获的报文数据。\",\n  \"子任务16\": \"获取流量模板的StreamBlock统计结果。\",\n  \"子任务17\": \"验证统计结果：发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\",\n  \"子任务18\": \"释放所有预约端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 source quench报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 source quench头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'SourceQuench']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改SourceQuench头部\n    edit_header_icmp_source_quench(Stream=stream, Level=0,\n                          Code='2', Ipv4HeaderTosReserved='1',\n                          Ipv4HeaderOffset='1', Ipv4HeaderSource='10.1.1.2')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='sourceQuench_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='sourceQuench_1.headerData.ipv4Header.offset',\n                                               Value='1',\n                                               MaxValue='1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='sourceQuench_1.headerData.ipv4Header.source',\n                                               Value='10.1.1.2',\n                                               MaxValue='10.1.1.2')\n    edit_capture_filter(Port=Ports[1],Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_source_quench:修改测试仪表流量模板中Icmp Source Quench报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/DHCPv4Server.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv4 Server头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Server'])\n\n    # 修改dhcpv4 server头部\n    edit_header_dhcpv4_server(Stream=stream, Level=0,\n                              MessageType=1,\n                              HardwareType=1,\n                              Hops=1,\n                              Bootpflags='0001',\n                              )\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='serverId',\n                                     ReqAddr='1.1.1.1',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ReqAddr'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='message',\n                                     Value='01',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='leaseTime',\n                                     LeaseTime=1,\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['LeaseTime'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='endOfOptions',\n                                     Type='01',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Type'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='messageSize',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='clientIdHW',\n                                     IdType='01',\n                                     ClientHWA='00:00:00:00:00:01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ClientHWA'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='clientIdNoneHW',\n                                     IdType='01',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='hostName',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='paramReqList',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reqAddr',\n                                     ReqAddr='1.1.1.1',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ReqAddr'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='optionOverload',\n                                     Overload=1,\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Overload='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Server'],\n                                             FieldName='dhcpv4Server_1.hops',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约两个自环端口Port_1和Port_2\",\n  \"子任务2\": \"在Port_1上创建流量StreamTemplate_1\",\n  \"子任务3\": \"修改StreamTemplate_1的DHCPv4 Server头部内容\",\n  \"子任务4\": \"订阅StreamBlockStats统计视图\",\n  \"子任务5\": \"配置端口发送模式为突发模式并设置突发包数量\",\n  \"子任务6\": \"启动流量发送\",\n  \"子任务7\": \"等待流量发送完成\",\n  \"子任务8\": \"等待3秒确保统计结果稳定\",\n  \"子任务9\": \"获取StreamTemplate_1的StreamBlockStats统计信息\",\n  \"子任务10\": \"验证StreamTemplate_1的TxStreamFrames等于RxStreamFrames\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv4 Server头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Server'])\n\n    # 修改dhcpv4 server头部\n    edit_header_dhcpv4_server(Stream=stream, Level=0,\n                              MessageType=1,\n                              HardwareType=1,\n                              Hops=1,\n                              Bootpflags='0001',\n                              )\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='serverId',\n                                     ReqAddr='1.1.1.1',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ReqAddr'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='message',\n                                     Value='01',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='leaseTime',\n                                     LeaseTime=1,\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['LeaseTime'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='endOfOptions',\n                                     Type='01',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Type'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='messageSize',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='clientIdHW',\n                                     IdType='01',\n                                     ClientHWA='00:00:00:00:00:01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ClientHWA'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='clientIdNoneHW',\n                                     IdType='01',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='hostName',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='paramReqList',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reqAddr',\n                                     ReqAddr='1.1.1.1',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ReqAddr'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='optionOverload',\n                                     Overload=1,\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Overload='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Server'],\n                                             FieldName='dhcpv4Server_1.hops',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv3_DataOverIp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 data over ip报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 data over ip头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'l2tpv3DataOverIp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3 data over ip头部\n    header = edit_header_l2tpv3_data_over_ip(Stream=stream, Level=0, SessionId='1', Cookie4Byte='10203040', Atmspecificsublayer=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverIp', Attribute=header['Cookie4Byte'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv3 data over ip头部选项\n    header_option = edit_header_l2tpv3_data_sublayer(Stream=stream, Type='Atmspecificsublayer', Xbit=1, Qbit=1, Sequence=10)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverIp', Attribute=header_option['Sequence'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3DataOverIp_1.sessionId',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口（Port_1和Port_2）。\",\n  \"子任务3\": \"在Port_1上创建指定长度的流量模板（StreamTemplate_1）。\",\n  \"子任务4\": \"为流量模板添加EthernetII、IPv4和L2TPv3 data over IP三层协议头部。\",\n  \"子任务5\": \"修改L2TPv3 data over IP头部参数（SessionId、Cookie4Byte等）并配置字段跳变规则。\",\n  \"子任务6\": \"在Port_2上配置基于L2TPv3 sessionId的抓包过滤条件。\",\n  \"子任务7\": \"订阅流模板块统计视图（StreamBlockStats）用于结果监控。\",\n  \"子任务8\": \"设置Port_1发送模式为突发包模式，指定突发包数量。\",\n  \"子任务9\": \"保存当前测试配置文件。\",\n  \"子任务10\": \"启动Port_2抓包功能。\",\n  \"子任务11\": \"开始发送StreamTemplate_1流量。\",\n  \"子任务12\": \"等待指定时间（如10秒）让流量稳定传输。\",\n  \"子任务13\": \"停止发送所有流量。\",\n  \"子任务14\": \"停止Port_2抓包功能。\",\n  \"子任务15\": \"获取StreamTemplate_1的流模板块统计结果（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务16\": \"验证TxStreamFrames与RxStreamFrames数值是否相等。\",\n  \"子任务17\": \"释放所有预约的仪表端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 data over ip报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 data over ip头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'l2tpv3DataOverIp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3 data over ip头部\n    header = edit_header_l2tpv3_data_over_ip(Stream=stream, Level=0, SessionId='1', Cookie4Byte='10203040', Atmspecificsublayer=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverIp', Attribute=header['Cookie4Byte'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv3 data over ip头部选项\n    header_option = edit_header_l2tpv3_data_sublayer(Stream=stream, Type='Atmspecificsublayer', Xbit=1, Qbit=1, Sequence=10)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverIp', Attribute=header_option['Sequence'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3DataOverIp_1.sessionId',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/EthernetII.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ethernetii报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ethernetii头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Force=True)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改EthernetII头部\n    attribute_dict = edit_header_ethernet(Stream=stream, Level=0, DestMacAdd='00:00:00:00:00:01',\n                                          SourceMacAdd='00:00:00:00:00:02')\n    print(attribute_dict)\n    # EthernetII头部目的Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='ethernetii', Attribute=attribute_dict['DestMacAdd'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # EthernetII头部源Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='ethernetii', Attribute=attribute_dict['SourceMacAdd'],\n                  Type='List',\n                  List=['00:00:00:00:00:02', '00:00:00:00:00:03', '00:00:00:00:00:04', '00:00:00:00:00:05'])\n    # 配置过滤抓包\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ethernetII_1.sourceMacAdd',\n    #                                            Value='00:00:00:00:00:02', MaxValue='00:00:00:00:00:02')\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ethernetII_1.destMacAdd',\n    #                                            Value='00:00:00:00:00:01',\n    #                                            MaxValue='00:00:00:00:00:01')\n    # edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，强制占用端口资源。\",\n  \"子任务3\": \"在Port_1上创建流量StreamTemplate_1，设置固定帧长为256字节。\",\n  \"子任务4\": \"为StreamTemplate_1创建EthernetII报文头部。\",\n  \"子任务5\": \"修改StreamTemplate_1的EthernetII头部：设置目的MAC为00:00:00:00:00:01，源MAC为00:00:00:00:00:02。\",\n  \"子任务6\": \"为EthernetII头部的目的MAC字段添加增量跳变：类型Increment，数量10，步长2。\",\n  \"子任务7\": \"为EthernetII头部的源MAC字段添加列表跳变：类型List，列表值['00:00:00:00:00:02','00:00:00:00:00:03','00:00:00:00:00:04','00:00:00:00:00:05']。\",\n  \"子任务8\": \"在Port_2上配置抓包过滤条件：源MAC等于00:00:00:00:00:02且目的MAC等于00:00:00:00:00:01。\",\n  \"子任务9\": \"订阅StreamBlockStats统计视图类型。\",\n  \"子任务10\": \"设置Port_1的发送模式为突发包（BURST），突发包数量为100。\",\n  \"子任务11\": \"启动Port_2的抓包功能。\",\n  \"子任务12\": \"启动流量StreamTemplate_1发送。\",\n  \"子任务13\": \"等待10秒传输时间。\",\n  \"子任务14\": \"停止流量StreamTemplate_1发送。\",\n  \"子任务15\": \"停止Port_2的抓包功能。\",\n  \"子任务16\": \"获取StreamTemplate_1的流模板块统计信息（StreamBlockStats）。\",\n  \"子任务17\": \"验证统计结果：发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\",\n  \"子任务18\": \"释放Port_1和Port_2的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ethernetii报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ethernetii头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Force=True)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改EthernetII头部\n    attribute_dict = edit_header_ethernet(Stream=stream, Level=0, DestMacAdd='00:00:00:00:00:01',\n                                          SourceMacAdd='00:00:00:00:00:02')\n    print(attribute_dict)\n    # EthernetII头部目的Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='ethernetii', Attribute=attribute_dict['DestMacAdd'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # EthernetII头部源Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='ethernetii', Attribute=attribute_dict['SourceMacAdd'],\n                  Type='List',\n                  List=['00:00:00:00:00:02', '00:00:00:00:00:03', '00:00:00:00:00:04', '00:00:00:00:00:05'])\n    # 配置过滤抓包\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ethernetII_1.sourceMacAdd',\n    #                                            Value='00:00:00:00:00:02', MaxValue='00:00:00:00:00:02')\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ethernetII_1.destMacAdd',\n    #                                            Value='00:00:00:00:00:01',\n    #                                            MaxValue='00:00:00:00:00:01')\n    # edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4AddressMaskReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 address mask reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 address mask reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IcmpMaskReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv4 address mask reply头部\n    header = edit_header_icmp_mask_reply(Stream=stream, Level=0,\n                                Identifier=100, SequenceNumber='200', AddrMask='24')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IcmpMaskReply', Attribute=header['Identifier'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskReply_1.Identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskReply_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskReply_1.AddrMask',\n                                               Value='24',\n                                               MaxValue='24')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_mask_reply:修改测试仪表流量模板中Icmp Mask Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量StreamTemplate_1，设置固定帧长为256字节。\",\n  \"子任务4\": \"为流量StreamTemplate_1创建报文头部，包含EthernetII、IPv4和IcmpMaskReply三层协议。\",\n  \"子任务5\": \"修改流量StreamTemplate_1的ICMPv4地址掩码回复头部：设置Identifier=100、SequenceNumber=200、AddrMask=24。\",\n  \"子任务6\": \"配置流量StreamTemplate_1的Identifier字段修饰符为递增模式（Increment），计数步长为10。\",\n  \"子任务7\": \"在Port_2上创建PDU匹配模式1：过滤ICMPv4地址掩码回复报文的Identifier字段等于100。\",\n  \"子任务8\": \"在Port_2上创建PDU匹配模式2：过滤SequenceNumber字段等于200。\",\n  \"子任务9\": \"在Port_2上创建PDU匹配模式3：过滤AddrMask字段等于24。\",\n  \"子任务10\": \"配置Port_2的捕获过滤器逻辑表达式：同时满足模式1、模式2和模式3（逻辑与）。\",\n  \"子任务11\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务12\": \"设置Port_1的发送模式为突发包（BURST），突发包数量为100。\",\n  \"子任务13\": \"启动Port_2的数据包捕获功能。\",\n  \"子任务14\": \"开始发送Port_1上的所有流量。\",\n  \"子任务15\": \"等待10秒确保流量发送完成。\",\n  \"子任务16\": \"停止Port_1的流量发送。\",\n  \"子任务17\": \"停止Port_2的数据包捕获。\",\n  \"子任务18\": \"获取流量StreamTemplate_1的流模板块统计结果（StreamBlockStats）。\",\n  \"子任务19\": \"验证统计结果中发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\",\n  \"子任务20\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 address mask reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 address mask reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IcmpMaskReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv4 address mask reply头部\n    header = edit_header_icmp_mask_reply(Stream=stream, Level=0,\n                                Identifier=100, SequenceNumber='200', AddrMask='24')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IcmpMaskReply', Attribute=header['Identifier'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskReply_1.Identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskReply_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskReply_1.AddrMask',\n                                               Value='24',\n                                               MaxValue='24')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_mask_reply:修改测试仪表流量模板中Icmp Mask Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6EchoReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 echo reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 echo reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'icmpv6echoreply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6echoreply头部\n    header = edit_header_icmpv6_echo_reply(Stream=stream, Level=0,\n                          Identifier='65535',SequenceNumber='65535')\n    edit_modifier(Stream=stream, Level=0, HeaderType='icmpv6echoreply', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoReply_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoReply_1.sequenceNumber',\n                                               Value='65535',\n                                               MaxValue='65535')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_echo_reply:修改测试仪表流量模板中Icmpv6 Echo Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务3\": \"在 Port_1 创建流量 StreamTemplate_1，设置固定帧长为 256 字节。\",\n  \"子任务4\": \"为流量 StreamTemplate_1 配置报文头部结构：EthernetII + IPv6 + ICMPv6 Echo Reply。\",\n  \"子任务5\": \"修改 ICMPv6 Echo Reply 头部字段：标识符设为 65535，序列号设为 65535。\",\n  \"子任务6\": \"配置序列号字段的跳变规则：增量模式，跳变计数 10。\",\n  \"子任务7\": \"在 Port_2 创建两个 PDU 匹配模式：分别匹配 ICMPv6 标识符=65535 和序列号=65535。\",\n  \"子任务8\": \"设置 Port_2 抓包过滤逻辑：同时满足标识符和序列号匹配条件。\",\n  \"子任务9\": \"订阅 StreamBlockStats 统计视图。\",\n  \"子任务10\": \"配置 Port_1 发送模式为突发包，突发数量为 100。\",\n  \"子任务11\": \"启动 Port_2 数据抓包。\",\n  \"子任务12\": \"开始发送 StreamTemplate_1 流量。\",\n  \"子任务13\": \"等待 10 秒确保流量发送完成。\",\n  \"子任务14\": \"停止 StreamTemplate_1 流量发送。\",\n  \"子任务15\": \"停止 Port_2 数据抓包。\",\n  \"子任务16\": \"获取 StreamTemplate_1 的流统计信息（TxStreamFrames 和 RxStreamFrames）。\",\n  \"子任务17\": \"验证 TxStreamFrames 等于 RxStreamFrames。\",\n  \"子任务18\": \"释放所有预约的测试仪表端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 echo reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 echo reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'icmpv6echoreply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6echoreply头部\n    header = edit_header_icmpv6_echo_reply(Stream=stream, Level=0,\n                          Identifier='65535',SequenceNumber='65535')\n    edit_modifier(Stream=stream, Level=0, HeaderType='icmpv6echoreply', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoReply_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoReply_1.sequenceNumber',\n                                               Value='65535',\n                                               MaxValue='65535')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_echo_reply:修改测试仪表流量模板中Icmpv6 Echo Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Sr.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Sr头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0])\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6srheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_sr(Stream=stream, SRHeaderFlag='10101010',\n                               SRHOption=['sRSegment', 'sRSegment'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6srheader', Attribute=attr['SRHeaderFlag'],\n                  Type='Increment', Count=10, Step=2)\n    attr_segment = edit_header_ipv6_sr_option(Stream=stream, Option='sRSegment', Index=1,\n                                              Segment='2033::3')\n    edit_modifier(Stream=stream, Attribute=attr_segment['Segment'],\n                  Type='Increment', Count=10, HeaderType='ipv6srheader')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，地址分别为//10.0.11.191/1/5和//10.0.11.191/1/6。\",\n  \"子任务3\": \"在第一个预约端口上创建流量流。\",\n  \"子任务4\": \"设置流量流的帧长度类型为自动模式（AUTO）。\",\n  \"子任务5\": \"为流量流创建报文头部，包含EthernetII、IPv6和ipv6srheader三层协议。\",\n  \"子任务6\": \"编辑IPv6 SR头部内容，设置SRHeaderFlag为'10101010'并添加sRSegment选项。\",\n  \"子任务7\": \"为SRHeaderFlag字段配置递增修饰符，设置递增类型、计数和步长参数。\",\n  \"子任务8\": \"为sRSegment选项的Segment字段配置递增修饰符。\",\n  \"子任务9\": \"订阅流模板块统计视图（StreamBlockStats）用于结果监控。\",\n  \"子任务10\": \"配置端口发送模式为突发包（BURST），设置突发包数量为100。\",\n  \"子任务11\": \"保存当前测试配置到指定路径的配置文件。\",\n  \"子任务12\": \"启动流量发送。\",\n  \"子任务13\": \"等待10秒确保流量持续发送。\",\n  \"子任务14\": \"停止流量发送。\",\n  \"子任务15\": \"获取流模板块统计信息，提取发送帧数（TxStreamFrames）和接收帧数（RxStreamFrames）。\",\n  \"子任务16\": \"验证发送帧数与接收帧数是否相等。\",\n  \"子任务17\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Sr头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0])\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6srheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_sr(Stream=stream, SRHeaderFlag='10101010',\n                               SRHOption=['sRSegment', 'sRSegment'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6srheader', Attribute=attr['SRHeaderFlag'],\n                  Type='Increment', Count=10, Step=2)\n    attr_segment = edit_header_ipv6_sr_option(Stream=stream, Option='sRSegment', Index=1,\n                                              Segment='2033::3')\n    edit_modifier(Stream=stream, Attribute=attr_segment['Segment'],\n                  Type='Increment', Count=10, HeaderType='ipv6srheader')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/IPv4.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv4报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv4头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port1, port2 = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=port1, FixedLength=256)\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n    # 修改ipv4头部\n    HeaderOption = ['Security', 'RouterAlert']\n    attribute_dict = edit_header_ipv4(Stream=stream, Level=0, TTL=200, Source='10.1.1.2', Destination='20.1.1.2',\n                                      Flags=111, HeaderOption=HeaderOption)\n    # ipv4头部Source字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=10, Step=2)\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 修改ipv4头部，添加一个Security\n    attribute_dict_security = edit_header_ipv4_option(Stream=stream, Index=0, Option='Security', Security=1)\n    # ipv4头部Security的Security字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_security['Security'],\n                  Type='List', List=[1, 11, 111])\n    # ipv4头部RouterAlert的Length字段添加Random跳变\n    attribute_dict_RouterAlert = edit_header_ipv4_option(Stream=stream, Index=1, Option='RouterAlert', Length=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_RouterAlert['Length'],\n                  Type='Random', Range=15)\n    # 修改ipv4头部，添加一个LooseSourceRoute节点\n    attribute_dict_loose = edit_header_ipv4_option(Stream=stream, Index=2, Option='LooseSourceRoute',\n                                                   AddressList=['1.1.1.1', '2.2.2.2'])\n    # 修改其中一个地址的跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_loose['AddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n    # 修改ipv4头部，添加一个TimeStamp节点\n    timestamp = edit_header_ipv4_option(Stream=stream, Index=3, Option='TimeStamp',\n                                        TimeStampSet=['10203040', '50607080'])\n    # 修改其中一个地址的跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=timestamp['TimeStampSet: 50607080'],\n                  Type='Increment', Count=10)\n    # 使用Level和Attribute参数添加pdu_pattern\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=port2, HeaderTypes=['EthernetII', 'IPv4'],\n                                               Level=1,\n                                               Attribute=attribute_dict_security['Security'],\n                                               Value=1, MaxValue=1)\n    # 使用FieldName参数添加pdu_pattern\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=port2, HeaderTypes=['EthernetII', 'IPv4'],\n                                               FieldName='ipv4_1.ipv4HeaderOption.ipv4HeaderOptionList_1.optionRouterAlert.length',\n                                               Value=10, MaxValue=10)\n\n    edit_capture_filter(Port=port2, Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=port1, TransmitMode='BURST', BurstCount=100)\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    PackagesPath = download_packages(Port=port2, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    Result = get_streamblock_statistic(Stream=stream)\n    TxStreamFrames = Result['TxStreamFrames']\n    RxStreamFrames = Result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    release_port(locations)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "edit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台。\",\n  \"子任务2\": \"预约两个自环端口，使用提供的位置信息。\",\n  \"子任务3\": \"在第一个端口创建流量，指定固定帧长度。\",\n  \"子任务4\": \"为流量添加以太网和IPv4报文头部。\",\n  \"子任务5\": \"编辑IPv4头部基本字段：TTL、源IP、目的IP和标志位。\",\n  \"子任务6\": \"为IPv4源IP字段配置递增跳变模式，指定步长和数量。\",\n  \"子任务7\": \"编辑IPv4头部Security选项，设置Security值。\",\n  \"子任务8\": \"为Security选项的Security字段配置列表跳变模式。\",\n  \"子任务9\": \"编辑IPv4头部RouterAlert选项，设置Length值。\",\n  \"子任务10\": \"为RouterAlert选项的Length字段配置随机跳变模式。\",\n  \"子任务11\": \"编辑IPv4头部LooseSourceRoute选项，设置地址列表。\",\n  \"子任务12\": \"为LooseSourceRoute选项的指定地址配置递增跳变模式。\",\n  \"子任务13\": \"编辑IPv4头部TimeStamp选项，设置时间戳列表。\",\n  \"子任务14\": \"为TimeStamp选项的指定时间戳配置递增跳变模式。\",\n  \"子任务15\": \"在第二个端口创建第一个PDU模式，基于Security选项值过滤。\",\n  \"子任务16\": \"在第二个端口创建第二个PDU模式，基于RouterAlert长度字段过滤。\",\n  \"子任务17\": \"在第二个端口设置捕获过滤条件，组合两个PDU模式逻辑与。\",\n  \"子任务18\": \"订阅流统计视图，类型为StreamBlockStats。\",\n  \"子任务19\": \"设置第一个端口发送模式为突发包，指定突发包数量。\",\n  \"子任务20\": \"启动第二个端口的数据抓包。\",\n  \"子任务21\": \"开始发送流量。\",\n  \"子任务22\": \"等待指定时间（10秒）使流量发送完成。\",\n  \"子任务23\": \"停止发送流量。\",\n  \"子任务24\": \"停止数据抓包。\",\n  \"子任务25\": \"下载第二个端口捕获的报文，指定保存路径和文件名。\",\n  \"子任务26\": \"获取指定流的流统计信息。\",\n  \"子任务27\": \"验证发送帧数等于接收帧数。\",\n  \"子任务28\": \"释放预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv4报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv4头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port1, port2 = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=port1, FixedLength=256)\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n    # 修改ipv4头部\n    HeaderOption = ['Security', 'RouterAlert']\n    attribute_dict = edit_header_ipv4(Stream=stream, Level=0, TTL=200, Source='10.1.1.2', Destination='20.1.1.2',\n                                      Flags=111, HeaderOption=HeaderOption)\n    # ipv4头部Source字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=10, Step=2)\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 修改ipv4头部，添加一个Security\n    attribute_dict_security = edit_header_ipv4_option(Stream=stream, Index=0, Option='Security', Security=1)\n    # ipv4头部Security的Security字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_security['Security'],\n                  Type='List', List=[1, 11, 111])\n    # ipv4头部RouterAlert的Length字段添加Random跳变\n    attribute_dict_RouterAlert = edit_header_ipv4_option(Stream=stream, Index=1, Option='RouterAlert', Length=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_RouterAlert['Length'],\n                  Type='Random', Range=15)\n    # 修改ipv4头部，添加一个LooseSourceRoute节点\n    attribute_dict_loose = edit_header_ipv4_option(Stream=stream, Index=2, Option='LooseSourceRoute',\n                                                   AddressList=['1.1.1.1', '2.2.2.2'])\n    # 修改其中一个地址的跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_loose['AddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n    # 修改ipv4头部，添加一个TimeStamp节点\n    timestamp = edit_header_ipv4_option(Stream=stream, Index=3, Option='TimeStamp',\n                                        TimeStampSet=['10203040', '50607080'])\n    # 修改其中一个地址的跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=timestamp['TimeStampSet: 50607080'],\n                  Type='Increment', Count=10)\n    # 使用Level和Attribute参数添加pdu_pattern\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=port2, HeaderTypes=['EthernetII', 'IPv4'],\n                                               Level=1,\n                                               Attribute=attribute_dict_security['Security'],\n                                               Value=1, MaxValue=1)\n    # 使用FieldName参数添加pdu_pattern\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=port2, HeaderTypes=['EthernetII', 'IPv4'],\n                                               FieldName='ipv4_1.ipv4HeaderOption.ipv4HeaderOptionList_1.optionRouterAlert.length',\n                                               Value=10, MaxValue=10)\n\n    edit_capture_filter(Port=port2, Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=port1, TransmitMode='BURST', BurstCount=100)\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    PackagesPath = download_packages(Port=port2, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    Result = get_streamblock_statistic(Stream=stream)\n    TxStreamFrames = Result['TxStreamFrames']\n    RxStreamFrames = Result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    release_port(locations)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nedit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6PacketTooBig.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 packet too big报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 packet too big头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'packettoobig']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv6 packet too big头部\n    edit_header_icmpv6_packet_too_big(Stream=stream, Level=0,\n                                      Mtu='500', FlowLabel='1111', HopLimit='255',\n                                      Source='2020::2', Gateway='2020::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='packetTooBig_1.headerData.ipv6Header.hopLimit',\n                                               Value='255', MaxValue='255')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='packetTooBig_1.headerData.ipv6Header.source',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='packetTooBig_1.mtu',\n                                               Value='500',\n                                               MaxValue='500')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_packet_too_big:修改测试仪表流量模板中Icmpv6 Packet Too Big报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型（如DarYu）。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，指定端口位置。\",\n  \"子任务3\": \"创建流量模板在Port_1上，指定固定帧长度（如256字节）。\",\n  \"子任务4\": \"创建流量报文头部，指定头部类型为EthernetII、IPv6和packettoobig。\",\n  \"子任务5\": \"修改流量模板的icmpv6 packet too big头部内容，设置Mtu=500、FlowLabel=1111、HopLimit=255、Source='2020::2'、Gateway='2020::1'。\",\n  \"子任务6\": \"在Port_2上创建捕获PDU pattern，基于字段'packetTooBig_1.headerData.ipv6Header.hopLimit'、值'255'。\",\n  \"子任务7\": \"在Port_2上创建捕获PDU pattern，基于字段'packetTooBig_1.headerData.ipv6Header.source'、值'2020::2'。\",\n  \"子任务8\": \"在Port_2上创建捕获PDU pattern，基于字段'packetTooBig_1.mtu'、值'500'。\",\n  \"子任务9\": \"设置Port_2的捕获过滤表达式，组合PDU patterns（如pattern1 && pattern2 && pattern3）。\",\n  \"子任务10\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务11\": \"设置Port_1的发送模式为突发包，指定突发计数（如100）。\",\n  \"子任务12\": \"保存配置文件到指定路径。\",\n  \"子任务13\": \"启动Port_2的抓包。\",\n  \"子任务14\": \"启动流量发送。\",\n  \"子任务15\": \"等待指定时间（如10秒）。\",\n  \"子任务16\": \"停止流量发送。\",\n  \"子任务17\": \"停止Port_2的抓包。\",\n  \"子任务18\": \"下载Port_2捕获的报文到指定目录。\",\n  \"子任务19\": \"获取流量模板的StreamBlockStats统计信息。\",\n  \"子任务20\": \"验证发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\",\n  \"子任务21\": \"释放所有预约端口。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 packet too big报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 packet too big头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'packettoobig']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv6 packet too big头部\n    edit_header_icmpv6_packet_too_big(Stream=stream, Level=0,\n                                      Mtu='500', FlowLabel='1111', HopLimit='255',\n                                      Source='2020::2', Gateway='2020::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='packetTooBig_1.headerData.ipv6Header.hopLimit',\n                                               Value='255', MaxValue='255')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='packetTooBig_1.headerData.ipv6Header.source',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='packetTooBig_1.mtu',\n                                               Value='500',\n                                               MaxValue='500')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_packet_too_big:修改测试仪表流量模板中Icmpv6 Packet Too Big报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2TPv3ControlOverIp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Control Over Ip头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3ControlOverIp'])\n\n    # 修改l2tpv3 control over ip头部\n    edit_header_l2tpv3_control_over_ip(Stream=stream, Level=0,\n                                       SessionId=1,\n                                       Type=1,\n                                       UseLength=1,\n                                       ExcludeSessionLength=1,\n                                       )\n\n    # 修改l2tpv3 control over ip头部，添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='circuitError',\n                                      AlignmentOverruns=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='routeId',\n                                      RouteId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='assignedConnection',\n                                      ConnectionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='localSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='remoteSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='assignedCookie',\n                                      Cookie4Byte='00000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='pwType',\n                                      PwType=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='l2SpecificSub',\n                                      L2SpecificSublayer=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='dataSequencing',\n                                      DataSequencing=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='txConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='rxConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='circuitStatus',\n                                      Nbit=1,\n                                      Abit=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3ControlOverIp'],\n                                             FieldName='l2tpv3ControlOverIp_1.type',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品型号为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在端口Port_1上创建一条流量StreamTemplate_1，固定帧长度为512字节。\",\n  \"子任务4\": \"为流量StreamTemplate_1创建报文头部结构，包含EthernetII、IPv4和L2TPv3 Control Over IP三层协议。\",\n  \"子任务5\": \"修改流量StreamTemplate_1的L2TPv3 Control Over IP头部内容，设置SessionId、Type等基本字段。\",\n  \"子任务6\": \"为L2TPv3 Control Over IP头部添加多个选项字段，包括generalTLV、messageType、resultCode等18个选项。\",\n  \"子任务7\": \"订阅StreamBlockStats统计视图用于后续结果采集。\",\n  \"子任务8\": \"配置端口Port_1发送模式为突发包，设置突发包数量为100。\",\n  \"子任务9\": \"启动流量发送。\",\n  \"子任务10\": \"等待流量发送完成。\",\n  \"子任务11\": \"停止流量发送后等待3秒确保统计结果稳定。\",\n  \"子任务12\": \"获取流量StreamTemplate_1的StreamBlockStats统计信息。\",\n  \"子任务13\": \"验证流量StreamTemplate_1的TxStreamFrames发送帧数等于RxStreamFrames接收帧数。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Control Over Ip头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3ControlOverIp'])\n\n    # 修改l2tpv3 control over ip头部\n    edit_header_l2tpv3_control_over_ip(Stream=stream, Level=0,\n                                       SessionId=1,\n                                       Type=1,\n                                       UseLength=1,\n                                       ExcludeSessionLength=1,\n                                       )\n\n    # 修改l2tpv3 control over ip头部，添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='circuitError',\n                                      AlignmentOverruns=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='routeId',\n                                      RouteId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='assignedConnection',\n                                      ConnectionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='localSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='remoteSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='assignedCookie',\n                                      Cookie4Byte='00000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='pwType',\n                                      PwType=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='l2SpecificSub',\n                                      L2SpecificSublayer=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='dataSequencing',\n                                      DataSequencing=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='txConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='rxConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='circuitStatus',\n                                      Nbit=1,\n                                      Abit=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3ControlOverIp'],\n                                             FieldName='l2tpv3ControlOverIp_1.type',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Bier.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Bier头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['bier'])\n\n    # 修改Bier头部\n    attr = edit_header_bier(Stream=stream, Level=0,\n                            BiftId=10,\n                            BierbitString=1)\n    edit_modifier(Stream=stream, Attribute=attr['BiftId'],\n                  Type='Increment', Count=10, HeaderType='bier')\n\n    bit_string = edit_header_bier_bit_string(Stream=stream,\n                                             BitString='1' * 32)\n    edit_modifier(Stream=stream, Attribute=bit_string['BitString'],\n                  Type='Increment', Count=10, HeaderType='bier')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口，获取端口对象Port_1和Port_2。\",\n  \"子任务3\": \"在端口Port_1上创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"为StreamTemplate_1添加BIER报文头部。\",\n  \"子任务5\": \"修改BIER头部的Level、BiftId和BitString字段值。\",\n  \"子任务6\": \"配置BiftId字段为递增跳变模式，步长为10。\",\n  \"子任务7\": \"配置BitString字段为递增跳变模式，步长为10。\",\n  \"子任务8\": \"订阅PortStats和StreamBlockStats统计视图。\",\n  \"子任务9\": \"配置端口Port_1为突发包发送模式，设置突发包数量。\",\n  \"子任务10\": \"保存当前测试配置到文件。\",\n  \"子任务11\": \"启动流量发送。\",\n  \"子任务12\": \"等待流量发送完成。\",\n  \"子任务13\": \"等待至少3秒确保统计结果稳定。\",\n  \"子任务14\": \"获取StreamTemplate_1的流模板块统计信息。\",\n  \"子任务15\": \"验证收包数量RxStreamFrames等于发包数量TxStreamFrames。\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Bier头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['bier'])\n\n    # 修改Bier头部\n    attr = edit_header_bier(Stream=stream, Level=0,\n                            BiftId=10,\n                            BierbitString=1)\n    edit_modifier(Stream=stream, Attribute=attr['BiftId'],\n                  Type='Increment', Count=10, HeaderType='bier')\n\n    bit_string = edit_header_bier_bit_string(Stream=stream,\n                                             BitString='1' * 32)\n    edit_modifier(Stream=stream, Attribute=bit_string['BitString'],\n                  Type='Increment', Count=10, HeaderType='bier')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4EchoReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的icmpv4 echo reply头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'Icmpv4EchoReply'])\n\n    # 修改icmpv4 echo reply头部\n    attr = edit_header_icmp_echo_reply(Stream=stream, Level=0,\n                                       Type=2,\n                                       Code=4,\n                                       Identifier=65535,\n                                       SequenceNumber=65535)\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=2, Attribute=attr['SequenceNumber'],\n                  Start=100,\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'Icmpv4EchoReply'],\n                                             FieldName='Icmpv4EchoReply_1.code',\n                                             Value=4,\n                                             MaxValue=4,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_echo_reply:修改测试仪表流量模板中Icmp Echo Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在端口Port_1上创建流量StreamTemplate_1。\",\n  \"子任务4\": \"为流量StreamTemplate_1创建报文头部：EthernetII、IPv4、Icmpv4EchoReply。\",\n  \"子任务5\": \"修改流量StreamTemplate_1的icmpv4 echo reply头部：设置Type=2、Code=4、Identifier=65535、SequenceNumber=65535。\",\n  \"子任务6\": \"配置SequenceNumber字段的跳变规则：起始值100，增量步长1，跳变次数5，类型为InterModifier。\",\n  \"子任务7\": \"订阅StreamBlockStats和PortStats统计视图。\",\n  \"子任务8\": \"配置端口Port_1的发送模式为突发包，设置突发包数量为100。\",\n  \"子任务9\": \"启动端口抓包并开始发送流量。\",\n  \"子任务10\": \"等待流量发送完成并停止抓包。\",\n  \"子任务11\": \"等待3秒确保统计结果稳定。\",\n  \"子任务12\": \"获取流量StreamTemplate_1的StreamBlockStats统计信息。\",\n  \"子任务13\": \"验证TxStreamFrames和RxStreamFrames统计值相等且等于突发包数量100。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的icmpv4 echo reply头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'Icmpv4EchoReply'])\n\n    # 修改icmpv4 echo reply头部\n    attr = edit_header_icmp_echo_reply(Stream=stream, Level=0,\n                                       Type=2,\n                                       Code=4,\n                                       Identifier=65535,\n                                       SequenceNumber=65535)\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=2, Attribute=attr['SequenceNumber'],\n                  Start=100,\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'Icmpv4EchoReply'],\n                                             FieldName='Icmpv4EchoReply_1.code',\n                                             Value=4,\n                                             MaxValue=4,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_echo_reply:修改测试仪表流量模板中Icmp Echo Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv1Report.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发igmpv1 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的igmpv1 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv1']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv1_report(Stream=stream, Level=0, Type=99, Unused='255', Checksum='ffff',\n                              GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.GroupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv1_report:修改测试仪表流量模板中IGMPv1 Report报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务3\": \"在 Port_1 上创建流量模板 StreamTemplate_1，设置固定帧长为 256 字节。\",\n  \"子任务4\": \"为 StreamTemplate_1 创建三层协议头部：EthernetII → IPv4 → IGMPv1。\",\n  \"子任务5\": \"修改 StreamTemplate_1 的 IGMPv1 Report 头部：Type=99, Checksum=ffff, GroupAddress=10.1.1.1, Unused=255。\",\n  \"子任务6\": \"在 Port_2 配置三层过滤抓包条件：IGMPv1 Type=99 && Checksum=ffff && GroupAddress=10.1.1.1。\",\n  \"子任务7\": \"订阅 StreamBlockStats 统计视图。\",\n  \"子任务8\": \"设置 Port_1 发送模式为突发包（BURST），突发包数量为 100。\",\n  \"子任务9\": \"启动 Port_2 抓包，启动 Port_1 流量发送。\",\n  \"子任务10\": \"等待 10 秒后停止 Port_1 流量发送，停止 Port_2 抓包。\",\n  \"子任务11\": \"获取 StreamTemplate_1 的 StreamBlockStats 统计结果。\",\n  \"子任务12\": \"验证统计结果中 TxStreamFrames 等于 RxStreamFrames。\",\n  \"子任务13\": \"释放预约的 Port_1 和 Port_2 端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发igmpv1 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的igmpv1 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv1']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv1_report(Stream=stream, Level=0, Type=99, Unused='255', Checksum='ffff',\n                              GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.GroupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv1_report:修改测试仪表流量模板中IGMPv1 Report报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahEncapsulatedCustomerEthernetII.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['encapEthernetII', 'ipv4'])\n\n    # 修改Encapsulated Customer EthernetII头部\n    attr = edit_header_8021ah_EncapsulatedCustomerEthernetII(Stream=stream, Level=0,\n                                                           ServiceTag=True,\n                                                           CustomerTag=True\n                                                           )\n    attr_service = edit_header_8021ah_EncapsulatedCustomerEthernetII_serviceTag(Stream=stream,\n                                                                              Vid='101010101010')\n    attr_customer = edit_header_8021ah_EncapsulatedCustomerEthernetII_customerTag(Stream=stream,\n                                                                                Id='110011001100')\n    edit_modifier(Stream=stream, Attribute=attr_service['Vid'],\n                  Type='Increment', Count=10, HeaderType='encapEthernetII')\n    edit_modifier(Stream=stream, Attribute=attr_customer['Id'],\n                  Type='Increment', Count=10, HeaderType='encapEthernetII')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口（Port_1和Port_2）。\",\n  \"子任务3\": \"在Port_1端口上创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"为StreamTemplate_1流量创建报文头部，指定封装类型。\",\n  \"子任务5\": \"修改StreamTemplate_1流量的802.1ah头部中Service Tag字段的Vid属性，配置初始值和递增修改器。\",\n  \"子任务6\": \"修改StreamTemplate_1流量的802.1ah头部中Customer Tag字段的Id属性，配置初始值和递增修改器。\",\n  \"子任务7\": \"订阅流模板块统计（StreamBlockStats）。\",\n  \"子任务8\": \"配置Port_1端口的负载参数：设置发送模式为突发包，指定突发包数量。\",\n  \"子任务9\": \"保存当前测试配置文件。\",\n  \"子任务10\": \"开始发送所有流量。\",\n  \"子任务11\": \"等待流量完全停止发送。\",\n  \"子任务12\": \"等待3秒确保统计结果稳定。\",\n  \"子任务13\": \"获取StreamTemplate_1流量的流模板块统计结果。\",\n  \"子任务14\": \"验证StreamTemplate_1流量的发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['encapEthernetII', 'ipv4'])\n\n    # 修改Encapsulated Customer EthernetII头部\n    attr = edit_header_8021ah_EncapsulatedCustomerEthernetII(Stream=stream, Level=0,\n                                                           ServiceTag=True,\n                                                           CustomerTag=True\n                                                           )\n    attr_service = edit_header_8021ah_EncapsulatedCustomerEthernetII_serviceTag(Stream=stream,\n                                                                              Vid='101010101010')\n    attr_customer = edit_header_8021ah_EncapsulatedCustomerEthernetII_customerTag(Stream=stream,\n                                                                                Id='110011001100')\n    edit_modifier(Stream=stream, Attribute=attr_service['Vid'],\n                  Type='Increment', Count=10, HeaderType='encapEthernetII')\n    edit_modifier(Stream=stream, Attribute=attr_customer['Id'],\n                  Type='Increment', Count=10, HeaderType='encapEthernetII')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Destination.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Destination头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6destinationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_destination(Stream=stream,\n                                        Length=10,\n                                        OptionHeaders=['bierv6'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr['Length'],\n                  Type='Increment', Count=10, Step=2)\n    attr_bier = edit_header_ipv6_destination_option(Stream=stream, Option='bierv6',\n                                                    Optiontype=20,\n                                                    BierbitString=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr_bier['Optiontype'],\n                  Type='Increment', Count=10, Step=2)\n    attr_bit_string = edit_header_ipv6_destination_bier_bit_string(Stream=stream,\n                                                                   BitString='11001100110011001100110011001100')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr_bit_string['BitString'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型（如DarYu）。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，指定端口物理位置。\",\n  \"子任务3\": \"在Port_1上创建流量StreamTemplate_1，设置固定帧长度为256字节。\",\n  \"子任务4\": \"为StreamTemplate_1创建报文头部，包含EthernetII、IPv6和ipv6destinationheader三层协议。\",\n  \"子任务5\": \"修改ipv6destinationheader长度属性为10，并配置递增跳变规则（起始值10，步长2，数量10）。\",\n  \"子任务6\": \"修改ipv6destinationheader的BIER选项类型属性为20，并配置递增跳变规则（起始值20，步长2，数量10）。\",\n  \"子任务7\": \"修改ipv6destinationheader的BIER比特串属性为'11001100110011001100110011001100'，并配置递增跳变规则。\",\n  \"子任务8\": \"订阅StreamBlockStats统计视图以监控流量统计信息。\",\n  \"子任务9\": \"配置Port_1发送模式为突发包（BURST），设置突发包数量为100。\",\n  \"子任务10\": \"启动流量发送，开始传输StreamTemplate_1。\",\n  \"子任务11\": \"等待10秒确保流量稳定传输。\",\n  \"子任务12\": \"停止所有流量发送。\",\n  \"子任务13\": \"获取StreamTemplate_1的StreamBlockStats统计信息。\",\n  \"子任务14\": \"验证StreamTemplate_1的发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\",\n  \"子任务15\": \"释放所有预约的仪表端口资源。\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Destination头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6destinationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_destination(Stream=stream,\n                                        Length=10,\n                                        OptionHeaders=['bierv6'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr['Length'],\n                  Type='Increment', Count=10, Step=2)\n    attr_bier = edit_header_ipv6_destination_option(Stream=stream, Option='bierv6',\n                                                    Optiontype=20,\n                                                    BierbitString=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr_bier['Optiontype'],\n                  Type='Increment', Count=10, Step=2)\n    attr_bit_string = edit_header_ipv6_destination_bier_bit_string(Stream=stream,\n                                                                   BitString='11001100110011001100110011001100')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr_bit_string['BitString'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Encapsulation.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Encapsulation头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6encapsulationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_encapsulation(Stream=stream, Spi=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6encapsulationheader', Attribute=attr['Spi'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，位置为//10.0.11.191/1/5和//10.0.11.191/1/6。\",\n  \"子任务3\": \"在端口Port_1上创建流量，固定帧长度为256字节。\",\n  \"子任务4\": \"为流量配置报文头部：EthernetII、IPv6和ipv6encapsulationheader三层封装。\",\n  \"子任务5\": \"编辑IPv6封装头部，设置SPI参数值为10。\",\n  \"子任务6\": \"配置IPv6封装头部SPI字段的修改器：类型为递增(Increment)，步长为2，计数为10。\",\n  \"子任务7\": \"订阅流模板块统计(StreamBlockStats)视图。\",\n  \"子任务8\": \"设置端口发送模式为突发包(BURST)，突发包数量为100。\",\n  \"子任务9\": \"保存当前测试配置到文件。\",\n  \"子任务10\": \"开始发送流量。\",\n  \"子任务11\": \"等待10秒确保流量持续发送。\",\n  \"子任务12\": \"停止所有流量发送。\",\n  \"子任务13\": \"获取流模板块统计信息。\",\n  \"子任务14\": \"验证发送帧数(TxStreamFrames)与接收帧数(RxStreamFrames)相等。\",\n  \"子任务15\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Encapsulation头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6encapsulationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_encapsulation(Stream=stream, Spi=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6encapsulationheader', Attribute=attr['Spi'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/DHCPv6Server.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv6 Server头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Server'])\n\n    # 修改dhcpv6 server头部\n    header = edit_header_dhcpv6_server(Stream=stream, Level=0,\n                              MessageType=2,\n                              TransId=2,\n                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='clientIdOption',\n                                     Duid='01',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Duid'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='serverIdOption',\n                                     DuidType=2,\n                                     HardwareType=2,\n                                     LinkAddress='00:00:00:00:00:02',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['LinkAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='ianaOption',\n                                     Iaid='00000003',\n                                     T1=3,\n                                     T2=3,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Iaid'],\n                  Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_address(Stream=stream, Index=2,\n                                                Type=5, Length=5, Ipv6Address='2020::1',\n                                                PreferredLifetime=1, ValidLifetime=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=ia_option['Ipv6Address'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='requestOption',\n                                     Value='04',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='elapsedTimeOption',\n                                     ElapseTime=5,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['ElapseTime'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='serverUnicastOption',\n                                     ServerAddress='2022::1',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['ServerAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='statusCodeOption',\n                                     StatusCode=7,\n                                     StatusMsg='0000000007',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['StatusMsg'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='rapidCommitOption',\n                                     Length=8,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Length'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='interfaceIdOption',\n                                     InterfaceId='0000000009',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['InterfaceId'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reconfigureAcceptOption',\n                                     Type=10,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Type'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='iapdOption',\n                                     Iaid='00000011',\n                                     T1=11,\n                                     T2=11,\n                                     IaOption=1,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Iaid'],\n    #               Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_prefix(Stream=stream, Index=10,\n                                                            Type=5, Length=5, Ipv6Address='2020::1',\n                                                            PreferredLifetime=1, ValidLifetime=1, PrefixLength=128)\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=ia_option['Ipv6Address'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Value='12',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='13',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Server'],\n                                             FieldName='dhcpv6Server_1.messageType',\n                                             Value=2,\n                                             MaxValue=2,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务2\": \"在端口 Port_1 上创建流量 StreamTemplate_1。\",\n  \"子任务3\": \"修改流量 StreamTemplate_1 的 DHCPv6 Server 头部内容。\",\n  \"子任务4\": \"订阅 StreamBlockStats 统计视图。\",\n  \"子任务5\": \"配置端口发送模式为突发包，设置突发包数量。\",\n  \"子任务6\": \"启动流量发送并开始抓包。\",\n  \"子任务7\": \"等待流量发送完成并停止抓包。\",\n  \"子任务8\": \"获取 StreamBlockStats 统计信息中的发送帧数(TxStreamFrames)和接收帧数(RxStreamFrames)。\",\n  \"子任务9\": \"验证 TxStreamFrames 与 RxStreamFrames 是否相等。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv6 Server头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Server'])\n\n    # 修改dhcpv6 server头部\n    header = edit_header_dhcpv6_server(Stream=stream, Level=0,\n                              MessageType=2,\n                              TransId=2,\n                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='clientIdOption',\n                                     Duid='01',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Duid'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='serverIdOption',\n                                     DuidType=2,\n                                     HardwareType=2,\n                                     LinkAddress='00:00:00:00:00:02',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['LinkAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='ianaOption',\n                                     Iaid='00000003',\n                                     T1=3,\n                                     T2=3,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Iaid'],\n                  Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_address(Stream=stream, Index=2,\n                                                Type=5, Length=5, Ipv6Address='2020::1',\n                                                PreferredLifetime=1, ValidLifetime=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=ia_option['Ipv6Address'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='requestOption',\n                                     Value='04',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='elapsedTimeOption',\n                                     ElapseTime=5,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['ElapseTime'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='serverUnicastOption',\n                                     ServerAddress='2022::1',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['ServerAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='statusCodeOption',\n                                     StatusCode=7,\n                                     StatusMsg='0000000007',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['StatusMsg'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='rapidCommitOption',\n                                     Length=8,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Length'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='interfaceIdOption',\n                                     InterfaceId='0000000009',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['InterfaceId'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reconfigureAcceptOption',\n                                     Type=10,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Type'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='iapdOption',\n                                     Iaid='00000011',\n                                     T1=11,\n                                     T2=11,\n                                     IaOption=1,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Iaid'],\n    #               Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_prefix(Stream=stream, Index=10,\n                                                            Type=5, Length=5, Ipv6Address='2020::1',\n                                                            PreferredLifetime=1, ValidLifetime=1, PrefixLength=128)\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=ia_option['Ipv6Address'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Value='12',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='13',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Server'],\n                                             FieldName='dhcpv6Server_1.messageType',\n                                             Value=2,\n                                             MaxValue=2,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/DHCPv6Client.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv6 Client头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Client'])\n\n    # 修改dhcpv6 client头部\n    header = edit_header_dhcpv6_client(Stream=stream, Level=0,\n                              MessageType=2,\n                              TransId=2,\n                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='clientIdOption',\n                                     Duid='01',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Duid'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='serverIdOption',\n                                     DuidType=2,\n                                     HardwareType=2,\n                                     LinkAddress='00:00:00:00:00:02',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['LinkAddress'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='ianaOption',\n                                     Iaid='00000003',\n                                     T1=3,\n                                     T2=3,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['T1'],\n                  Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_address(Stream=stream, Index=2,\n                                                Type=5, Length=5, Ipv6Address='2020::1',\n                                                PreferredLifetime=1, ValidLifetime=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=ia_option['Ipv6Address'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='requestOption',\n                                     Value='04',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='elapsedTimeOption',\n                                     ElapseTime=5,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['ElapseTime'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='serverUnicastOption',\n                                     ServerAddress='2022::1',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['ServerAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='statusCodeOption',\n                                     StatusCode=7,\n                                     StatusMsg='0000000007',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['StatusMsg'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='rapidCommitOption',\n                                     Length=8,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Length'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='interfaceIdOption',\n                                     InterfaceId='0000000009',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['InterfaceId'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reconfigureAcceptOption',\n                                     Type=10,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Type'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='iapdOption',\n                                     Iaid='00000011',\n                                     T1=11,\n                                     T2=11,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Iaid'],\n    #               Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_prefix(Stream=stream, Index=10,\n                                                            Type=5, Length=5, Ipv6Address='2020::1',\n                                                            PreferredLifetime=1, ValidLifetime=1, PrefixLength=128)\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=ia_option['Ipv6Address'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Value='12',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='13',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Client'],\n                                             FieldName='dhcpv6Client_1.messageType',\n                                             Value=2,\n                                             MaxValue=2,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，指定端口位置。\",\n  \"子任务3\": \"在发送端口创建流量流，设置固定帧长为512字节。\",\n  \"子任务4\": \"为流量流添加协议头部：EthernetII、IPv6、UDP、dhcpv6Client。\",\n  \"子任务5\": \"修改dhcpv6 Client主头部字段（MessageType、TransId等）并设置跳变域。\",\n  \"子任务6\": \"添加并修改dhcpv6 Option头部（clientIdOption、serverIdOption等）并设置字段跳变。\",\n  \"子任务7\": \"在接收端口创建PDU抓包过滤模式，指定dhcpv6Client.messageType=2。\",\n  \"子任务8\": \"在接收端口设置报文捕获过滤表达式。\",\n  \"子任务9\": \"订阅统计视图：PortStats和StreamBlockStats。\",\n  \"子任务10\": \"配置发送端口负载为突发模式，设置突发包数量为100。\",\n  \"子任务11\": \"保存测试配置文件。\",\n  \"子任务12\": \"启动接收端口抓包。\",\n  \"子任务13\": \"开始发送流量流。\",\n  \"子任务14\": \"等待流量发送完成。\",\n  \"子任务15\": \"停止接收端口抓包。\",\n  \"子任务16\": \"等待3秒确保统计结果稳定。\",\n  \"子任务17\": \"下载接收端口捕获的报文。\",\n  \"子任务18\": \"获取接收端口捕获信息，验证捕获报文数量等于突发包数量。\",\n  \"子任务19\": \"获取流模板块统计信息，验证TxStreamFrames等于RxStreamFrames且等于100。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv6 Client头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Client'])\n\n    # 修改dhcpv6 client头部\n    header = edit_header_dhcpv6_client(Stream=stream, Level=0,\n                              MessageType=2,\n                              TransId=2,\n                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='clientIdOption',\n                                     Duid='01',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Duid'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='serverIdOption',\n                                     DuidType=2,\n                                     HardwareType=2,\n                                     LinkAddress='00:00:00:00:00:02',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['LinkAddress'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='ianaOption',\n                                     Iaid='00000003',\n                                     T1=3,\n                                     T2=3,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['T1'],\n                  Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_address(Stream=stream, Index=2,\n                                                Type=5, Length=5, Ipv6Address='2020::1',\n                                                PreferredLifetime=1, ValidLifetime=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=ia_option['Ipv6Address'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='requestOption',\n                                     Value='04',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='elapsedTimeOption',\n                                     ElapseTime=5,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['ElapseTime'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='serverUnicastOption',\n                                     ServerAddress='2022::1',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['ServerAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='statusCodeOption',\n                                     StatusCode=7,\n                                     StatusMsg='0000000007',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['StatusMsg'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='rapidCommitOption',\n                                     Length=8,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Length'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='interfaceIdOption',\n                                     InterfaceId='0000000009',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['InterfaceId'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reconfigureAcceptOption',\n                                     Type=10,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Type'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='iapdOption',\n                                     Iaid='00000011',\n                                     T1=11,\n                                     T2=11,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Iaid'],\n    #               Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_prefix(Stream=stream, Index=10,\n                                                            Type=5, Length=5, Ipv6Address='2020::1',\n                                                            PreferredLifetime=1, ValidLifetime=1, PrefixLength=128)\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=ia_option['Ipv6Address'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Value='12',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='13',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Client'],\n                                             FieldName='dhcpv6Client_1.messageType',\n                                             Value=2,\n                                             MaxValue=2,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahItag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['itag', 'ipv4'])\n\n    # 修改itag头部\n    attr = edit_header_8021ah_iTag(Stream=stream, Level=0,\n                                   EncapCusDstAddr='22:00:00:00:00:00',\n                                   SourceMacAdd='22:11:11:11:11:11')\n    edit_modifier(Stream=stream, Attribute=attr['EncapCusDstAddr'],\n                  Type='Increment', Count=10, HeaderType='itag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表。\",\n  \"子任务2\": \"预约两个自环端口，分别命名为Port_1和Port_2。\",\n  \"子任务3\": \"在端口Port_1上创建一条流量，命名为StreamTemplate_1。\",\n  \"子任务4\": \"为流量StreamTemplate_1创建802.1ah报文头部。\",\n  \"子任务5\": \"修改流量StreamTemplate_1的802.1ah头部iTag字段，包括封装客户目的地址和源MAC地址。\",\n  \"子任务6\": \"设置流量StreamTemplate_1的iTag目的地址跳变规则，类型为递增，数量为10。\",\n  \"子任务7\": \"订阅流模板块统计（StreamBlockStats）。\",\n  \"子任务8\": \"配置端口Port_1的发送模式为突发包，设置突发包数量为100。\",\n  \"子任务9\": \"开始发送所有流量。\",\n  \"子任务10\": \"等待流量停止发送。\",\n  \"子任务11\": \"等待3秒以确保统计结果稳定。\",\n  \"子任务12\": \"获取流量StreamTemplate_1的流模板块统计信息。\",\n  \"子任务13\": \"验证流量StreamTemplate_1的发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['itag', 'ipv4'])\n\n    # 修改itag头部\n    attr = edit_header_8021ah_iTag(Stream=stream, Level=0,\n                                   EncapCusDstAddr='22:00:00:00:00:00',\n                                   SourceMacAdd='22:11:11:11:11:11')\n    edit_modifier(Stream=stream, Attribute=attr['EncapCusDstAddr'],\n                  Type='Increment', Count=10, HeaderType='itag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4TimeStampReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 time stamp reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 time stamp reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimestampReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 TimestampReply头部\n    edit_header_icmp_time_stamp_reply(Stream=stream, Level=0,\n                                      Identifier='100', SequenceNumber='200', OriginateTimestamp='111',\n                                      ReceiveTimestamp='222', TransmitTimestamp='333')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampReply_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampReply_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_time_stamp_reply:修改测试仪表流量模板中Icmp Time Stamp Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型（如'DarYu'）。\",\n  \"子任务2\": \"预约两个自环端口，指定端口位置（如'//10.0.11.191/1/3'和'//10.0.11.191/1/4'）。\",\n  \"子任务3\": \"在发送端口创建流量，设置固定帧长度为256字节。\",\n  \"子任务4\": \"为流量创建报文头部，指定头部类型为EthernetII、IPv4和TimestampReply。\",\n  \"子任务5\": \"修改流量的ICMPv4时间戳回复报文头部，设置标识符、序列号、原始时间戳、接收时间戳和传输时间戳。\",\n  \"子任务6\": \"在接收端口创建第一个PDU匹配模式，过滤ICMPv4时间戳回复报文的标识符字段（如值'100'）。\",\n  \"子任务7\": \"在接收端口创建第二个PDU匹配模式，过滤ICMPv4时间戳回复报文的序列号字段（如值'200'）。\",\n  \"子任务8\": \"在接收端口设置捕获过滤表达式，组合两个PDU匹配模式（逻辑与关系）。\",\n  \"子任务9\": \"订阅流模板块统计视图（StreamBlockStats）。\",\n  \"子任务10\": \"设置发送端口的负载配置为突发模式，指定突发包数量（如100个包）。\",\n  \"子任务11\": \"启动接收端口的抓包功能。\",\n  \"子任务12\": \"开始发送流量。\",\n  \"子任务13\": \"等待指定时间（如10秒）。\",\n  \"子任务14\": \"停止发送流量。\",\n  \"子任务15\": \"停止接收端口的抓包功能。\",\n  \"子任务16\": \"获取流模板块统计信息，包括发送帧数（TxStreamFrames）和接收帧数（RxStreamFrames）。\",\n  \"子任务17\": \"验证发送帧数等于接收帧数。\",\n  \"子任务18\": \"释放预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 time stamp reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 time stamp reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimestampReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 TimestampReply头部\n    edit_header_icmp_time_stamp_reply(Stream=stream, Level=0,\n                                      Identifier='100', SequenceNumber='200', OriginateTimestamp='111',\n                                      ReceiveTimestamp='222', TransmitTimestamp='333')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampReply_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampReply_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_time_stamp_reply:修改测试仪表流量模板中Icmp Time Stamp Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6DestinationUnreachable.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 destination unreachable报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 destination unreachable头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'destinationunreachable']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 destination unreachable头部\n    header = edit_header_icmpv6_destination_unreachable(Stream=stream, Level=0,\n                                                        Code='3', HeaderData='1020304050607080',\n                                                        FlowLabel='2',\n                                                        HopLimit='250', Source='2022::2',\n                                                        Destination='2020::2', Gateway='2022::1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='destinationunreachable', Attribute=header['HeaderData'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='destinationunreachable', Attribute=header['Source'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.code',\n                                               Value='3', MaxValue='3')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.headerData.ipv6Header.hopLimit',\n                                               Value='250',\n                                               MaxValue='250')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.headerData.ipv6Header.destination',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_destination_unreachable:修改测试仪表流量模板中Icmpv6 Destination Unreachable报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定执行仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，指定端口位置参数。\",\n  \"子任务3\": \"在Port_1上创建流量StreamTemplate_1，设置固定帧长度为256字节。\",\n  \"子任务4\": \"为StreamTemplate_1创建报文头部，包含EthernetII、IPv6和ICMPv6 Destination Unreachable三层协议。\",\n  \"子任务5\": \"修改StreamTemplate_1的ICMPv6 Destination Unreachable头部：设置Level=0、Code='3'、HeaderData='1020304050607080'、FlowLabel='2'、HopLimit='250'、Source='2022::2'、Destination='2020::2'、Gateway='2022::1'。\",\n  \"子任务6\": \"为HeaderData字段添加增量修饰符，类型为Increment，计数为10。\",\n  \"子任务7\": \"为Source字段添加增量修饰符，类型为Increment，计数为10。\",\n  \"子任务8\": \"在Port_2上创建PDU模式1：过滤ICMPv6 Destination Unreachable报文的Code字段等于3。\",\n  \"子任务9\": \"在Port_2上创建PDU模式2：过滤IPv6头部的HopLimit字段等于250。\",\n  \"子任务10\": \"在Port_2上创建PDU模式3：过滤IPv6头部的Destination字段等于'2020::2'。\",\n  \"子任务11\": \"在Port_2上设置捕获过滤表达式，将PDU模式1、2、3进行逻辑与(&&)组合。\",\n  \"子任务12\": \"订阅测试仪表的StreamBlockStats统计视图。\",\n  \"子任务13\": \"设置Port_1的发送模式为BURST（突发包），突发计数为100。\",\n  \"子任务14\": \"保存当前测试配置文件。\",\n  \"子任务15\": \"启动Port_2的抓包功能。\",\n  \"子任务16\": \"开始发送StreamTemplate_1流量。\",\n  \"子任务17\": \"等待10秒确保流量发送完成。\",\n  \"子任务18\": \"停止所有流量发送。\",\n  \"子任务19\": \"停止Port_2的抓包功能。\",\n  \"子任务20\": \"下载Port_2捕获的报文到指定目录。\",\n  \"子任务21\": \"获取StreamTemplate_1的StreamBlockStats统计信息。\",\n  \"子任务22\": \"验证StreamTemplate_1的发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\",\n  \"子任务23\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 destination unreachable报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 destination unreachable头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'destinationunreachable']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 destination unreachable头部\n    header = edit_header_icmpv6_destination_unreachable(Stream=stream, Level=0,\n                                                        Code='3', HeaderData='1020304050607080',\n                                                        FlowLabel='2',\n                                                        HopLimit='250', Source='2022::2',\n                                                        Destination='2020::2', Gateway='2022::1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='destinationunreachable', Attribute=header['HeaderData'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='destinationunreachable', Attribute=header['Source'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.code',\n                                               Value='3', MaxValue='3')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.headerData.ipv6Header.hopLimit',\n                                               Value='250',\n                                               MaxValue='250')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.headerData.ipv6Header.destination',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_destination_unreachable:修改测试仪表流量模板中Icmpv6 Destination Unreachable报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/llc.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的llc头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp', 'logicLinkControl'])\n\n    # 修改802.3头部\n    attr = edit_header_llc(Stream=stream, Level=0, Dsap='FF')\n    edit_modifier(Stream=stream, Attribute=attr['Dsap'],\n                  Type='Increment', Count=10, HeaderType='logicLinkControl')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个端口，分别命名为Port_UP和Port_Down。\",\n  \"子任务3\": \"在Port_UP端口创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"设置流量模板的帧长度类型为AUTO模式。\",\n  \"子任务5\": \"为流量添加报文头部：ethernetii, ipv4, udp, logicLinkControl。\",\n  \"子任务6\": \"修改LLC头部Dsap字段值为'FF'（level=0）。\",\n  \"子任务7\": \"配置Dsap字段的跳变规则：增量模式(Increment)，步长10。\",\n  \"子任务8\": \"订阅统计视图：PortStats和StreamBlockStats。\",\n  \"子任务9\": \"设置端口发送模式为BURST，突发包数量100。\",\n  \"子任务10\": \"保存当前测试配置文件。\",\n  \"子任务11\": \"开始发送所有流量。\",\n  \"子任务12\": \"等待流量自动停止发送。\",\n  \"子任务13\": \"等待3秒确保统计结果稳定。\",\n  \"子任务14\": \"获取StreamTemplate_1的流模板块统计结果。\",\n  \"子任务15\": \"验证发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)且等于100。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的llc头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp', 'logicLinkControl'])\n\n    # 修改802.3头部\n    attr = edit_header_llc(Stream=stream, Level=0, Dsap='FF')\n    edit_modifier(Stream=stream, Attribute=attr['Dsap'],\n                  Type='Increment', Count=10, HeaderType='logicLinkControl')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl2csnpHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2csnpheader'])\n\n    header = edit_header_isis_csnp(Stream=stream,\n                                   Version=10,\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2csnpheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries', LspEntries=2)\n\n    edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在端口Port_1上创建流量StreamTemplate_1。\",\n  \"子任务4\": \"为流量StreamTemplate_1创建报文头部，指定头部类型为EthernetII和l2csnpheader。\",\n  \"子任务5\": \"修改流量StreamTemplate_1的ISIS CSNP头部，设置版本号为10并配置认证信息。\",\n  \"子任务6\": \"配置流量StreamTemplate_1的ISIS版本字段跳变规则，设置为增量模式，计数为10。\",\n  \"子任务7\": \"修改流量StreamTemplate_1的ISIS TLV头部，设置LSP条目数量为2。\",\n  \"子任务8\": \"修改流量StreamTemplate_1的ISIS LSP条目，设置剩余时间为10。\",\n  \"子任务9\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务10\": \"配置端口Port_1的发送模式为突发模式，设置突发包数量为100。\",\n  \"子任务11\": \"保存当前测试配置文件。\",\n  \"子任务12\": \"开始发送所有流量。\",\n  \"子任务13\": \"等待流量发送完成。\",\n  \"子任务14\": \"等待3秒确保统计结果稳定。\",\n  \"子任务15\": \"获取流量StreamTemplate_1的StreamBlockStats统计信息。\",\n  \"子任务16\": \"验证流量StreamTemplate_1的发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)且等于100。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2csnpheader'])\n\n    header = edit_header_isis_csnp(Stream=stream,\n                                   Version=10,\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2csnpheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries', LspEntries=2)\n\n    edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4AddressMaskRequest.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 address mask requset报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 address mask requset头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IcmpMaskRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改IcmpMaskRequest头部\n    header = edit_header_icmp_mask_request(Stream=stream, Level=0,\n                          Identifier='100',SequenceNumber='200',AddrMask='24')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IcmpMaskRequest', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.Identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.AddrMask',\n                                               Value='24',\n                                               MaxValue='24')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_mask_request:修改测试仪表流量模板中Icmp Mask Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型（如DarYu）。\",\n  \"子任务2\": \"预约两个指定位置的端口资源（如//10.0.11.191/1/3和//10.0.11.191/1/4）。\",\n  \"子任务3\": \"在发送端口创建流量流，设置固定帧长度为256字节。\",\n  \"子任务4\": \"为流量创建报文头部，依次包括EthernetII、IPv4和IcmpMaskRequest协议层。\",\n  \"子任务5\": \"修改IcmpMaskRequest头部字段：Identifier设为100，SequenceNumber设为200，AddrMask设为24。\",\n  \"子任务6\": \"配置SequenceNumber字段的跳变域：类型为增量模式，计数为10。\",\n  \"子任务7\": \"在接收端口创建三个PDU匹配模式：分别基于Identifier=100、SequenceNumber=200和AddrMask=24字段。\",\n  \"子任务8\": \"在接收端口设置报文过滤表达式，要求同时满足三个PDU匹配模式。\",\n  \"子任务9\": \"订阅流模板块统计视图（StreamBlockStats）。\",\n  \"子任务10\": \"设置发送端口负载模式为突发包（BURST），突发包数量为100。\",\n  \"子任务11\": \"保存当前测试配置到指定路径的配置文件。\",\n  \"子任务12\": \"启动接收端口的数据抓包功能。\",\n  \"子任务13\": \"开始发送所有流量流。\",\n  \"子任务14\": \"等待10秒以确保流量发送完成。\",\n  \"子任务15\": \"停止所有流量发送。\",\n  \"子任务16\": \"停止端口数据抓包。\",\n  \"子任务17\": \"等待3秒确保统计结果稳定。\",\n  \"子任务18\": \"下载接收端口捕获的数据包，保存到指定目录（最大数量100）。\",\n  \"子任务19\": \"获取流模板块统计结果，提取发送帧数（TxStreamFrames）和接收帧数（RxStreamFrames）。\",\n  \"子任务20\": \"验证发送帧数等于接收帧数。\",\n  \"子任务21\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 address mask requset报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 address mask requset头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IcmpMaskRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改IcmpMaskRequest头部\n    header = edit_header_icmp_mask_request(Stream=stream, Level=0,\n                          Identifier='100',SequenceNumber='200',AddrMask='24')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IcmpMaskRequest', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.Identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.AddrMask',\n                                               Value='24',\n                                               MaxValue='24')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_mask_request:修改测试仪表流量模板中Icmp Mask Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ancp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的ANCP头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['portManagement'])\n\n    # 修改ancp头部\n    attr = edit_header_ancp(Stream=stream, Level=0,\n                            Version=20,\n                            AccessLineIdentifyingTlvs=1,\n                            TestingRelatedTlvs=1,\n                            StatusInfoTlvs=1)\n    edit_modifier(Stream=stream, Attribute=attr['Version'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    access_attr = edit_header_ancp_access_line_identifying_tlv(Stream=stream,\n                                                               Value='102030')\n    edit_modifier(Stream=stream, Attribute=access_attr['Value'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    testing_attr = edit_header_ancp_testing_related_tlv(Stream=stream,\n                                                        Value1='405060')\n    edit_modifier(Stream=stream, Attribute=testing_attr['Value1'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    edit_header_ancp_status_info_tlv(Stream=stream,\n                                     OptionalSubTLV=1)\n    optinal_attr = edit_header_ancp_status_info_tlv_optional_sub_tlv(Stream=stream,\n                                                                     Data='708090')\n    edit_modifier(Stream=stream, Attribute=optinal_attr['Data'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约两个自环端口 Port_1 和 Port_2。\",\n  \"子任务2\": \"在端口 Port_1 上创建流量 StreamTemplate_1。\",\n  \"子任务3\": \"为流量 StreamTemplate_1 创建报文头部，指定头部类型为 portManagement。\",\n  \"子任务4\": \"修改流量 StreamTemplate_1 的 ANCP 头部内容：设置版本号为 20，启用 AccessLineIdentifyingTlvs、TestingRelatedTlvs 和 StatusInfoTlvs。\",\n  \"子任务5\": \"为 ANCP 头部的版本号字段配置增量跳变规则：起始值 20，增量 10。\",\n  \"子任务6\": \"修改 ANCP 头部的 AccessLineIdentifyingTlvs 字段值并配置增量跳变规则：起始值 '102030'，增量 10。\",\n  \"子任务7\": \"修改 ANCP 头部的 TestingRelatedTlvs 字段值并配置增量跳变规则：起始值 '405060'，增量 10。\",\n  \"子任务8\": \"启用 ANCP 头部的 StatusInfoTlvs 可选子字段并设置数据值，配置增量跳变规则：起始值 '708090'，增量 10。\",\n  \"子任务9\": \"订阅 StreamBlockStats 统计类型。\",\n  \"子任务10\": \"配置端口 Port_1 的发送模式为突发包（BURST），设置突发包数量为 100。\",\n  \"子任务11\": \"开始发送所有流量。\",\n  \"子任务12\": \"等待流量停止发送。\",\n  \"子任务13\": \"等待 3 秒确保统计结果准确。\",\n  \"子任务14\": \"获取流量 StreamTemplate_1 的 StreamBlockStats 统计信息。\",\n  \"子任务15\": \"验证流量 StreamTemplate_1 的发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）且都等于突发包数量（100）。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的ANCP头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['portManagement'])\n\n    # 修改ancp头部\n    attr = edit_header_ancp(Stream=stream, Level=0,\n                            Version=20,\n                            AccessLineIdentifyingTlvs=1,\n                            TestingRelatedTlvs=1,\n                            StatusInfoTlvs=1)\n    edit_modifier(Stream=stream, Attribute=attr['Version'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    access_attr = edit_header_ancp_access_line_identifying_tlv(Stream=stream,\n                                                               Value='102030')\n    edit_modifier(Stream=stream, Attribute=access_attr['Value'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    testing_attr = edit_header_ancp_testing_related_tlv(Stream=stream,\n                                                        Value1='405060')\n    edit_modifier(Stream=stream, Attribute=testing_attr['Value1'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    edit_header_ancp_status_info_tlv(Stream=stream,\n                                     OptionalSubTLV=1)\n    optinal_attr = edit_header_ancp_status_info_tlv_optional_sub_tlv(Stream=stream,\n                                                                     Data='708090')\n    edit_modifier(Stream=stream, Attribute=optinal_attr['Data'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/HsrTag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的hsr tag头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['hsrtag', 'ipv4'])\n\n    # 修改hsr头部\n    attr = edit_header_hsr_tag(Stream=stream, Level=0,\n                            LsduSize=4095)\n    edit_modifier(Stream=stream, Attribute=attr['LsduSize'],\n                  Type='Increment', Count=10, HeaderType='hsrtag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表平台，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个物理端口Port_1和Port_2，指定端口位置参数。\",\n  \"子任务3\": \"在端口Port_1上创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"为StreamTemplate_1添加报文头部，指定头部类型为hsrtag和ipv4。\",\n  \"子任务5\": \"修改hsrtag头部字段：设置Level=0，LsduSize=4095。\",\n  \"子任务6\": \"配置LsduSize字段的跳变规则：增量模式，步长为10。\",\n  \"子任务7\": \"订阅统计视图，包括PortStats和StreamBlockStats类型。\",\n  \"子任务8\": \"配置端口Port_1发送模式：突发包模式，设置突发包数量为100。\",\n  \"子任务9\": \"保存当前测试配置到指定路径的配置文件。\",\n  \"子任务10\": \"启动所有流量发送。\",\n  \"子任务11\": \"等待流量完全停止发送。\",\n  \"子任务12\": \"等待至少3秒确保统计结果稳定。\",\n  \"子任务13\": \"获取StreamTemplate_1的流模板块统计信息。\",\n  \"子任务14\": \"验证统计结果：发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)且等于突发包数量(100)。\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的hsr tag头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['hsrtag', 'ipv4'])\n\n    # 修改hsr头部\n    attr = edit_header_hsr_tag(Stream=stream, Level=0,\n                            LsduSize=4095)\n    edit_modifier(Stream=stream, Attribute=attr['LsduSize'],\n                  Type='Increment', Count=10, HeaderType='hsrtag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahMacInMac.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['mac-in-mac', 'ipv4'])\n\n    # 修改Encapsulated Mac-in-Mac头部\n    attr = edit_header_8021ah_MacInMac(Stream=stream, Level=0,\n                                       DestMacAdd='22:00:00:00:00:00',\n                                       SourceMacAdd='22:11:11:11:11:11')\n    edit_modifier(Stream=stream, Attribute=attr['DestMacAdd'],\n                  Type='Increment', Count=10, HeaderType='mac-in-mac')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试仪表平台（例如：DarYu）。\",\n  \"子任务2\": \"预约两个自环端口，分别命名为Port_1和Port_2，使用指定的位置信息。\",\n  \"子任务3\": \"在Port_1上创建一条流量，命名为StreamTemplate_1。\",\n  \"子任务4\": \"为StreamTemplate_1创建报文头部，指定头部类型为mac-in-mac和ipv4。\",\n  \"子任务5\": \"编辑StreamTemplate_1的802.1ah（Mac-in-Mac）头部，设置目的MAC地址为22:00:00:00:00:00，源MAC地址为22:11:11:11:11:11。\",\n  \"子任务6\": \"对StreamTemplate_1报文头部的目的MAC地址应用增量修改器，增量类型为Increment，增量为10。\",\n  \"子任务7\": \"配置Port_1的负载参数：发送模式为BURST，突发包数量为100。\",\n  \"子任务8\": \"订阅流模板块统计（StreamBlockStats）。\",\n  \"子任务9\": \"开始发送所有流量。\",\n  \"子任务10\": \"等待流量完全停止（包括仪表内部状态更新）。\",\n  \"子任务11\": \"等待3秒以确保统计结果稳定。\",\n  \"子任务12\": \"获取StreamTemplate_1的流模板块统计信息，包括TxStreamFrames和RxStreamFrames。\",\n  \"子任务13\": \"验证TxStreamFrames与RxStreamFrames统计值是否相等。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['mac-in-mac', 'ipv4'])\n\n    # 修改Encapsulated Mac-in-Mac头部\n    attr = edit_header_8021ah_MacInMac(Stream=stream, Level=0,\n                                       DestMacAdd='22:00:00:00:00:00',\n                                       SourceMacAdd='22:11:11:11:11:11')\n    edit_modifier(Stream=stream, Attribute=attr['DestMacAdd'],\n                  Type='Increment', Count=10, HeaderType='mac-in-mac')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ripv2.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发Ripv2报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的Ripv2头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripv2']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripv2(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripv2', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripv2_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripv2_entry(Stream=stream, Level=0, Index=0, Ipaddr='192.168.0.11', SubnetMask='192.168.1.11', NextHop='192.168.2.11', Afi=1, RouteTag=1)\n    edit_header_ripv2_entry(Stream=stream, Level=0, Index=1, Ipaddr='192.168.0.12', SubnetMask='192.168.1.12', NextHop='192.168.2.12', Afi=2, RouteTag=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量流，设置固定帧长为256字节。\",\n  \"子任务4\": \"为流量流创建三层协议头部：EthernetII、IPv4和Ripv2。\",\n  \"子任务5\": \"修改Ripv2头部字段：设置Command=2, Version=1, Reserved=2。\",\n  \"子任务6\": \"配置Ripv2头部的Reserved字段跳变规则：类型为递增(Increment)，变化次数为3。\",\n  \"子任务7\": \"在Ripv2头部插入两个路由条目。\",\n  \"子任务8\": \"修改第一个路由条目字段：IP地址、子网掩码、下一跳、Afi和RouteTag。\",\n  \"子任务9\": \"修改第二个路由条目字段：IP地址、子网掩码、下一跳、Afi和RouteTag。\",\n  \"子任务10\": \"在Port_2创建第一个PDU匹配模式：基于Ripv2头部的Reserved字段（值范围1-2）。\",\n  \"子任务11\": \"在Port_2创建第二个PDU匹配模式：基于Ripv2头部的Version字段（固定值1）。\",\n  \"子任务12\": \"在Port_2设置抓包过滤逻辑：组合两个PDU模式进行逻辑与过滤。\",\n  \"子任务13\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务14\": \"配置Port_1发送模式为突发包(BURST)，设置突发包数量为100。\",\n  \"子任务15\": \"保存当前测试配置文件。\",\n  \"子任务16\": \"启动Port_2的数据包捕获。\",\n  \"子任务17\": \"开始发送所有流量流。\",\n  \"子任务18\": \"等待10秒传输时间。\",\n  \"子任务19\": \"停止所有流量发送。\",\n  \"子任务20\": \"停止Port_2的数据包捕获。\",\n  \"子任务21\": \"获取流量流的StreamBlockStats统计信息。\",\n  \"子任务22\": \"验证流量统计结果：发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\",\n  \"子任务23\": \"释放所有预约端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发Ripv2报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的Ripv2头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripv2']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripv2(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripv2', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripv2_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripv2_entry(Stream=stream, Level=0, Index=0, Ipaddr='192.168.0.11', SubnetMask='192.168.1.11', NextHop='192.168.2.11', Afi=1, RouteTag=1)\n    edit_header_ripv2_entry(Stream=stream, Level=0, Index=1, Ipaddr='192.168.0.12', SubnetMask='192.168.1.12', NextHop='192.168.2.12', Afi=2, RouteTag=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/goose.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Goose头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetII', 'goose'])\n\n    # 修改Goose头部\n    attr = edit_header_goose(Stream=stream, Level=0,\n                             Apdu='102030405060')\n    edit_modifier(Stream=stream, Attribute=attr['Apdu'],\n                  Type='Increment', Count=10, HeaderType='goose')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口（Port_1和Port_2），获取端口对象。\",\n  \"子任务3\": \"在Port_1端口创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"配置流量模板的帧长度类型为自动模式（AUTO）。\",\n  \"子任务5\": \"为流量添加以太网II和Goose报文头部结构。\",\n  \"子任务6\": \"修改Goose头部的Apdu字段内容为指定值。\",\n  \"子任务7\": \"为Apdu字段配置跳变规则：增量模式，步长为10，计数10次。\",\n  \"子任务8\": \"订阅流模板块统计（StreamBlockStats）视图。\",\n  \"子任务9\": \"设置端口发送模式为突发包，指定突发包数量（如100个）。\",\n  \"子任务10\": \"保存当前测试配置文件到指定路径。\",\n  \"子任务11\": \"开始发送所有流量。\",\n  \"子任务12\": \"等待流量完全停止发送。\",\n  \"子任务13\": \"流量停止后等待3秒确保统计结果稳定。\",\n  \"子任务14\": \"获取StreamTemplate_1的流模板块统计结果，提取发送帧数（TxStreamFrames）和接收帧数（RxStreamFrames）。\",\n  \"子任务15\": \"验证发送帧数与接收帧数是否相等。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Goose头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetII', 'goose'])\n\n    # 修改Goose头部\n    attr = edit_header_goose(Stream=stream, Level=0,\n                             Apdu='102030405060')\n    edit_modifier(Stream=stream, Attribute=attr['Apdu'],\n                  Type='Increment', Count=10, HeaderType='goose')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisp2phelloHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'p2phelloheader'])\n\n    header = edit_header_isis_p2p_hello(Stream=stream,\n                                        PDUType=10,\n                                        IsIsTlv=['AreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                 'IpInterfaceAddress', 'P2pAdjacencyState', 'RestartSignal',\n                                                 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='p2phelloheader', Attribute=header['PDUType'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AreaAddress', AreaAddressEntries=1)\n    edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, NlPIDEntriesField=2)\n    edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='p2pAdjacencyState', Index=5,\n                                **{'adjacencyStateInitializing.extendLocalCircuitId':'10203040'})\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容",
      "edit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约测试仪表的两个自环端口 Port_1 和 Port_2。\",\n  \"子任务2\": \"在端口 Port_1 上创建流量模板 StreamTemplate_1。\",\n  \"子任务3\": \"修改流量模板 StreamTemplate_1 的 ISIS 协议头部内容。\",\n  \"子任务4\": \"订阅 StreamBlockStats 统计视图用于后续结果收集。\",\n  \"子任务5\": \"配置端口 Port_1 的负载模式为突发包发送模式，设置突发包数量。\",\n  \"子任务6\": \"启动所有流量发送。\",\n  \"子任务7\": \"等待流量发送完成（包括等待流量停止状态和额外3秒统计稳定时间）。\",\n  \"子任务8\": \"停止所有流量发送。\",\n  \"子任务9\": \"获取流量 StreamTemplate_1 的 StreamBlockStats 统计信息。\",\n  \"子任务10\": \"验证流量 StreamTemplate_1 的发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'p2phelloheader'])\n\n    header = edit_header_isis_p2p_hello(Stream=stream,\n                                        PDUType=10,\n                                        IsIsTlv=['AreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                 'IpInterfaceAddress', 'P2pAdjacencyState', 'RestartSignal',\n                                                 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='p2phelloheader', Attribute=header['PDUType'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AreaAddress', AreaAddressEntries=1)\n    edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, NlPIDEntriesField=2)\n    edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='p2pAdjacencyState', Index=5,\n                                **{'adjacencyStateInitializing.extendLocalCircuitId':'10203040'})\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容;\nedit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Udp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发udp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的udp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ipv4', 'udp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改vlan头部\n    header = edit_header_udp(Stream=stream, Level=0,\n                             SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Level=0, HeaderType='udp',\n                  Attribute=header['SourcePort'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='udp_1.destPort',\n                                               Value='2000', MaxValue='2000')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_udp:修改测试仪表流量模板中UDP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约两个指定位置的端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量流，设置固定帧长度为256字节。\",\n  \"子任务4\": \"为创建的流量配置报文头部结构：EthernetII → IPv4 → UDP。\",\n  \"子任务5\": \"修改流量UDP头部：源端口设为1000，目的端口设为2000。\",\n  \"子任务6\": \"为UDP源端口字段配置跳变规则：类型为递增(Increment)，步长2，计数10。\",\n  \"子任务7\": \"在Port_2创建PDU抓包过滤模式：匹配目的端口为2000的UDP报文。\",\n  \"子任务8\": \"在Port_2应用报文过滤逻辑表达式。\",\n  \"子任务9\": \"订阅流模板块统计视图(StreamBlockStats)。\",\n  \"子任务10\": \"设置Port_1发送模式为突发包(BURST)，突发包数量为100。\",\n  \"子任务11\": \"保存当前测试配置到文件。\",\n  \"子任务12\": \"启动Port_2的数据抓包。\",\n  \"子任务13\": \"启动Port_1的流量发送。\",\n  \"子任务14\": \"等待10秒确保流量发送完成。\",\n  \"子任务15\": \"停止Port_1的流量发送。\",\n  \"子任务16\": \"停止Port_2的数据抓包。\",\n  \"子任务17\": \"下载Port_2捕获的报文数据到本地目录。\",\n  \"子任务18\": \"获取流模板块统计结果。\",\n  \"子任务19\": \"验证流统计结果：发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\",\n  \"子任务20\": \"释放预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发udp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的udp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ipv4', 'udp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改vlan头部\n    header = edit_header_udp(Stream=stream, Level=0,\n                             SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Level=0, HeaderType='udp',\n                  Attribute=header['SourcePort'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='udp_1.destPort',\n                                               Value='2000', MaxValue='2000')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_udp:修改测试仪表流量模板中UDP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6Redirect.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 redirect报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 redirect头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'Icmpv6Redirect']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_redirect(Stream=stream, Level=0, Code=10,\n                                         HeaderOption=['OptionPrefixInformation', 'GeneralTLV'],\n                                         RedirectedHdrOption=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv6Redirect', Attribute=header['Code'],\n                  Type='Increment', Count=10)\n\n    option = edit_header_icmpv6_header_option(Stream=stream, Header='icmpv6redirect',\n                                              Option='GeneralTLV', Index=1,\n                                              Value='1020')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv6Redirect', Attribute=option['Value'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='icmpv6Redirect_1.code',\n                                               Value='10', MaxValue='10')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_header_option:修改测试仪表流量模板中ICMPv6报文头部Header Option内容",
      "edit_header_icmpv6_redirect:修改测试仪表流量模板中Icmpv6 Redirect报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表平台，指定仪表类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，端口位置为//10.0.11.191/1/5和//10.0.11.191/1/6。\",\n  \"子任务3\": \"在端口Port_1上创建流量StreamTemplate_1，设置固定帧长为256字节。\",\n  \"子任务4\": \"为流量StreamTemplate_1创建报文头部结构：EthernetII + IPv6 + Icmpv6Redirect。\",\n  \"子任务5\": \"修改ICMPv6重定向报文的Code字段值为10，并配置递增跳变规则（起始值10，增量1，计数10）。\",\n  \"子任务6\": \"修改ICMPv6重定向报文的Header Option（GeneralTLV）值为1020，并配置递增跳变规则（起始值1020，增量1，计数10）。\",\n  \"子任务7\": \"在端口Port_2配置抓包过滤规则：基于ICMPv6重定向报文的code字段值等于10。\",\n  \"子任务8\": \"订阅流模板块统计视图StreamBlockStats。\",\n  \"子任务9\": \"设置端口Port_1的发送模式为突发包模式，突发包数量为100。\",\n  \"子任务10\": \"保存当前测试配置文件到指定路径。\",\n  \"子任务11\": \"在端口Port_2启动报文捕获。\",\n  \"子任务12\": \"启动流量StreamTemplate_1发送。\",\n  \"子任务13\": \"等待10秒使流量稳定发送。\",\n  \"子任务14\": \"停止流量StreamTemplate_1发送。\",\n  \"子任务15\": \"停止端口Port_2的报文捕获。\",\n  \"子任务16\": \"获取流量StreamTemplate_1的流模板块统计结果。\",\n  \"子任务17\": \"验证发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\",\n  \"子任务18\": \"释放所有预约端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 redirect报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 redirect头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'Icmpv6Redirect']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_redirect(Stream=stream, Level=0, Code=10,\n                                         HeaderOption=['OptionPrefixInformation', 'GeneralTLV'],\n                                         RedirectedHdrOption=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv6Redirect', Attribute=header['Code'],\n                  Type='Increment', Count=10)\n\n    option = edit_header_icmpv6_header_option(Stream=stream, Header='icmpv6redirect',\n                                              Option='GeneralTLV', Index=1,\n                                              Value='1020')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv6Redirect', Attribute=option['Value'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='icmpv6Redirect_1.code',\n                                               Value='10', MaxValue='10')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_header_option:修改测试仪表流量模板中ICMPv6报文头部Header Option内容;\nedit_header_icmpv6_redirect:修改测试仪表流量模板中Icmpv6 Redirect报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6MLDv2Query.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv2 query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv2 query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv2query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2 query头部\n    header = edit_header_icmpv6_mldv2_query(Stream=stream, Level=0,\n                                            Code='2', Reserved='10',\n                                            GroupAddress='FF1E::1', Qrv='111',\n                                            SourceAddressList=['2001::1', '2002::2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2query', Attribute=header['SourceAddressList: 2002::2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.Qrv',\n                                               Value='111',\n                                               MaxValue='111')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_mldv2_query:修改测试仪表流量模板中Icmpv6 Mldv2 Query报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约两个自环端口，位置为'//10.0.11.191/1/3'和'//10.0.11.191/1/4'。\",\n  \"子任务3\": \"在端口Port_1创建流量，设置固定帧长度为256字节。\",\n  \"子任务4\": \"为流量添加三层协议头部：EthernetII、IPv6和mldv2query。\",\n  \"子任务5\": \"修改icmpv6 mldv2 query头部：设置Code=2、Reserved=10、GroupAddress='FF1E::1'、Qrv=111、SourceAddressList=['2001::1','2002::2']。\",\n  \"子任务6\": \"配置跳变域：对SourceAddressList中的'2002::2'应用增量变化(Increment)，增量计数为10。\",\n  \"子任务7\": \"在端口Port_2创建三个PDU Pattern：匹配mldv2 query头部的code=2、reserved=10、Qrv=111字段。\",\n  \"子任务8\": \"在端口Port_2设置报文过滤逻辑表达式：三个PDU Pattern的逻辑与(&&)组合。\",\n  \"子任务9\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务10\": \"配置端口Port_1发送模式为突发包(BURST)，设置突发包数量为100。\",\n  \"子任务11\": \"保存当前测试配置文件到指定路径。\",\n  \"子任务12\": \"启动端口Port_2的数据抓包。\",\n  \"子任务13\": \"开始发送所有流量。\",\n  \"子任务14\": \"等待10秒确保流量发送完成。\",\n  \"子任务15\": \"停止所有流量发送。\",\n  \"子任务16\": \"停止端口Port_2的数据抓包。\",\n  \"子任务17\": \"下载端口Port_2捕获的报文到本地目录。\",\n  \"子任务18\": \"获取流量的StreamBlockStats统计结果。\",\n  \"子任务19\": \"验证流量统计结果：TxStreamFrames发送帧数等于RxStreamFrames接收帧数。\",\n  \"子任务20\": \"释放所有预约的测试端口资源。\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv2 query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv2 query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv2query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2 query头部\n    header = edit_header_icmpv6_mldv2_query(Stream=stream, Level=0,\n                                            Code='2', Reserved='10',\n                                            GroupAddress='FF1E::1', Qrv='111',\n                                            SourceAddressList=['2001::1', '2002::2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2query', Attribute=header['SourceAddressList: 2002::2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.Qrv',\n                                               Value='111',\n                                               MaxValue='111')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_mldv2_query:修改测试仪表流量模板中Icmpv6 Mldv2 Query报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/DHCPv4Client.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv4 Client头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Client'])\n\n    # 修改dhcpv4 client头部\n    header = edit_header_dhcpv4_client(Stream=stream, Level=0,\n                                       MessageType=1,\n                                       HardwareType=1,\n                                       Hops=1,\n                                       Bootpflags='0001',\n                                       )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=0,\n                                              Types='serverId',\n                                              ReqAddr='1.1.1.1',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ReqAddr'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=1,\n                                              Types='message',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=2,\n                                              Types='leaseTime',\n                                              LeaseTime=1,\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['LeaseTime'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=3,\n                                              Types='endOfOptions',\n                                              Type='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Type'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=4,\n                                              Types='messageSize',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=5,\n                                              Types='clientIdHW',\n                                              IdType='01',\n                                              ClientHWA='00:00:00:00:00:01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ClientHWA'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=6,\n                                              Types='clientIdNoneHW',\n                                              IdType='01',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=7,\n                                              Types='hostName',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=8,\n                                              Types='paramReqList',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=9,\n                                              Types='reqAddr',\n                                              ReqAddr='1.1.1.1',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ReqAddr'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=10,\n                                              Types='optionOverload',\n                                              Overload=1,\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=11,\n                                              Types='customOption',\n                                              Overload='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=12,\n                                              Types='generalTLV',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=13,\n                                              Types='messageType',\n                                              Code=4,\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Code'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Client'],\n                                             FieldName='dhcpv4Client_1.hops',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_UP和Port_Down。\",\n  \"子任务3\": \"在Port_UP上创建固定长度为512字节的流量模板。\",\n  \"子任务4\": \"为流量模板添加EthernetII、IPv4、UDP、DHCPv4 Client协议头部。\",\n  \"子任务5\": \"修改DHCPv4 Client主头部字段（MessageType、HardwareType、Hops、Bootpflags）。\",\n  \"子任务6\": \"为DHCPv4 Client添加多个Option头部（serverId、message、leaseTime等共14种）。\",\n  \"子任务7\": \"为部分Option字段配置跳变规则（Increment类型，步长为10）。\",\n  \"子任务8\": \"在Port_Down配置抓包过滤规则：基于dhcpv4Client.hops字段值等于1。\",\n  \"子任务9\": \"订阅PortStats和StreamBlockStats统计视图。\",\n  \"子任务10\": \"设置Port_UP发送模式为BURST，指定突发包数量为100。\",\n  \"子任务11\": \"保存当前测试配置到.xcfg文件。\",\n  \"子任务12\": \"启动Port_Down抓包功能。\",\n  \"子任务13\": \"开始发送流量。\",\n  \"子任务14\": \"等待流量发送完成。\",\n  \"子任务15\": \"停止Port_Down抓包功能。\",\n  \"子任务16\": \"等待3秒确保统计结果稳定。\",\n  \"子任务17\": \"下载Port_Down捕获的报文到本地pcap文件。\",\n  \"子任务18\": \"获取Port_Down抓包信息，验证捕获报文数等于突发包数量(100)。\",\n  \"子任务19\": \"获取流模板块统计结果，验证TxStreamFrames等于RxStreamFrames且都等于100。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv4 Client头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Client'])\n\n    # 修改dhcpv4 client头部\n    header = edit_header_dhcpv4_client(Stream=stream, Level=0,\n                                       MessageType=1,\n                                       HardwareType=1,\n                                       Hops=1,\n                                       Bootpflags='0001',\n                                       )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=0,\n                                              Types='serverId',\n                                              ReqAddr='1.1.1.1',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ReqAddr'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=1,\n                                              Types='message',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=2,\n                                              Types='leaseTime',\n                                              LeaseTime=1,\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['LeaseTime'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=3,\n                                              Types='endOfOptions',\n                                              Type='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Type'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=4,\n                                              Types='messageSize',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=5,\n                                              Types='clientIdHW',\n                                              IdType='01',\n                                              ClientHWA='00:00:00:00:00:01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ClientHWA'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=6,\n                                              Types='clientIdNoneHW',\n                                              IdType='01',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=7,\n                                              Types='hostName',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=8,\n                                              Types='paramReqList',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=9,\n                                              Types='reqAddr',\n                                              ReqAddr='1.1.1.1',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ReqAddr'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=10,\n                                              Types='optionOverload',\n                                              Overload=1,\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=11,\n                                              Types='customOption',\n                                              Overload='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=12,\n                                              Types='generalTLV',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=13,\n                                              Types='messageType',\n                                              Code=4,\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Code'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Client'],\n                                             FieldName='dhcpv4Client_1.hops',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2LinkStateUpdate.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发OSPFv2 Link State Update Instance报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的OSPFv2 Link State Update Instance头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstateupdate']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2头部\n    header = edit_header_ospfv2_update(Stream=stream, Level=0,\n                                       RouterID='2.2.2.2', AuthType='MD5')\n\n    router_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Router',\n                                               RouterLsaReserved1=10,\n                                               LsaAge=20,\n                                               Reserved7=1,\n                                               Reserved7Router=0,\n                                               )\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['RouterLsaReserved1'],\n    #               Type='Increment',\n    #               Count=10, Step=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['LsaAge'],\n    #               Type='Increment',\n    #               Count=10, Step=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['Reserved7'],\n    #               Type='Increment',\n    #               Count=2, Step=1)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['Reserved7Router'],\n    #               Type='Increment',\n    #               Count=2, Step=1)\n\n    router_lsa_link = edit_header_ospfv2_update_route_lsa_link(Stream=stream,\n                                                               LinkId='3.3.3.3')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=router_lsa_link['LinkId'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    router_lsa_link_metric = edit_header_ospfv2_update_route_link_tos_metric(Stream=stream,\n                                                                             RouterLsaMetricReserved=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=router_lsa_link_metric['RouterLsaMetricReserved'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    network_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Network', Index=1,\n                                                LsType=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=network_lsa['LsType'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    network_attached_router = edit_header_ospfv2_update_network_attached_route(Stream=stream, LsaIndex=1,\n                                                                               RouterID='4.4.4.4')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=network_attached_router['RouterID'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    summary_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Summary', Index=2,\n                                                AdvertisingRouter='5.5.5.5')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=summary_lsa['AdvertisingRouter'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    summary_tos_metric = edit_header_ospfv2_update_tos_metric(Stream=stream, Type='Summary', LsaIndex=2,\n                                                              MetricReserved=20)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=summary_tos_metric['MetricReserved'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='ospfv2LinkStateUpdate_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_update:修改测试仪表流量模板中OSPFv2 Link State Update报文头部内容",
      "edit_header_ospfv2_update_lsa:修改测试仪表流量模板中OSPFv2 Update报文中Lsa头部内容.",
      "edit_header_ospfv2_update_route_link_tos_metric:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容",
      "edit_header_ospfv2_update_route_lsa_link:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容",
      "edit_header_ospfv2_update_tos_metric:修改测试仪表流量模板中OSPFv2 Update报文中Summary、 SummaryAsbr或AsExternal Lsa头部Tos Metric内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量模板，设置固定帧长度为256字节。\",\n  \"子任务4\": \"为流量创建报文头部，包含EthernetII、IPv4和OSPFv2 Link State Update三层协议。\",\n  \"子任务5\": \"修改OSPFv2 Link State Update报文头部的基本字段：设置RouterID为2.2.2.2，认证类型为MD5。\",\n  \"子任务6\": \"修改OSPFv2 Link State Update报文中Router LSA部分：设置LSA Age为20，RouterLsaReserved1为10。\",\n  \"子任务7\": \"修改OSPFv2 Link State Update报文中Router LSA的Link部分：设置LinkId为3.3.3.3，并配置LinkId字段的递增跳变（步长2，计数10）。\",\n  \"子任务8\": \"修改OSPFv2 Link State Update报文中Router LSA的Metric部分：设置RouterLsaMetricReserved为10，并配置该字段的递增跳变（步长2，计数10）。\",\n  \"子任务9\": \"修改OSPFv2 Link State Update报文中Network LSA部分：设置LsType为10，并配置该字段的递增跳变（步长2，计数10）。\",\n  \"子任务10\": \"修改OSPFv2 Link State Update报文中Network Attached Router部分：设置RouterID为4.4.4.4，并配置该字段的递增跳变（步长2，计数10）。\",\n  \"子任务11\": \"修改OSPFv2 Link State Update报文中Summary LSA部分：设置AdvertisingRouter为5.5.5.5，并配置该字段的递增跳变（步长2，计数10）。\",\n  \"子任务12\": \"修改OSPFv2 Link State Update报文中Summary LSA的Tos Metric部分：设置MetricReserved为20，并配置该字段的递增跳变（步长2，计数10）。\",\n  \"子任务13\": \"在Port_2上创建PDU匹配模式：过滤OSPFv2 Link State Update报文中RouterID等于2.2.2.2的报文。\",\n  \"子任务14\": \"在Port_2上配置抓包过滤器，应用步骤13创建的PDU匹配模式。\",\n  \"子任务15\": \"订阅测试仪表的StreamBlockStats统计视图。\",\n  \"子任务16\": \"配置Port_1的发送模式为突发包模式，设置突发包数量为100。\",\n  \"子任务17\": \"启动Port_2的数据包捕获功能。\",\n  \"子任务18\": \"从Port_1开始发送所有流量。\",\n  \"子任务19\": \"等待10秒使流量发送完成。\",\n  \"子任务20\": \"停止Port_1的流量发送。\",\n  \"子任务21\": \"停止Port_2的数据包捕获。\",\n  \"子任务22\": \"获取流量模板的StreamBlockStats统计结果，包括TxStreamFrames和RxStreamFrames。\",\n  \"子任务23\": \"验证流量统计结果：确认TxStreamFrames与RxStreamFrames数值相等。\",\n  \"子任务24\": \"释放预约的Port_1和Port_2端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发OSPFv2 Link State Update Instance报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的OSPFv2 Link State Update Instance头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstateupdate']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2头部\n    header = edit_header_ospfv2_update(Stream=stream, Level=0,\n                                       RouterID='2.2.2.2', AuthType='MD5')\n\n    router_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Router',\n                                               RouterLsaReserved1=10,\n                                               LsaAge=20,\n                                               Reserved7=1,\n                                               Reserved7Router=0,\n                                               )\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['RouterLsaReserved1'],\n    #               Type='Increment',\n    #               Count=10, Step=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['LsaAge'],\n    #               Type='Increment',\n    #               Count=10, Step=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['Reserved7'],\n    #               Type='Increment',\n    #               Count=2, Step=1)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['Reserved7Router'],\n    #               Type='Increment',\n    #               Count=2, Step=1)\n\n    router_lsa_link = edit_header_ospfv2_update_route_lsa_link(Stream=stream,\n                                                               LinkId='3.3.3.3')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=router_lsa_link['LinkId'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    router_lsa_link_metric = edit_header_ospfv2_update_route_link_tos_metric(Stream=stream,\n                                                                             RouterLsaMetricReserved=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=router_lsa_link_metric['RouterLsaMetricReserved'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    network_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Network', Index=1,\n                                                LsType=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=network_lsa['LsType'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    network_attached_router = edit_header_ospfv2_update_network_attached_route(Stream=stream, LsaIndex=1,\n                                                                               RouterID='4.4.4.4')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=network_attached_router['RouterID'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    summary_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Summary', Index=2,\n                                                AdvertisingRouter='5.5.5.5')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=summary_lsa['AdvertisingRouter'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    summary_tos_metric = edit_header_ospfv2_update_tos_metric(Stream=stream, Type='Summary', LsaIndex=2,\n                                                              MetricReserved=20)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=summary_tos_metric['MetricReserved'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='ospfv2LinkStateUpdate_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_update:修改测试仪表流量模板中OSPFv2 Link State Update报文头部内容;\nedit_header_ospfv2_update_lsa:修改测试仪表流量模板中OSPFv2 Update报文中Lsa头部内容.;\nedit_header_ospfv2_update_route_link_tos_metric:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容;\nedit_header_ospfv2_update_route_lsa_link:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容;\nedit_header_ospfv2_update_tos_metric:修改测试仪表流量模板中OSPFv2 Update报文中Summary、 SummaryAsbr或AsExternal Lsa头部Tos Metric内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl1psnpHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1psnpHeader'])\n\n    header = edit_header_isis_psnp(Stream=stream,\n                                   LengthIndicator=10,\n                                   CsnpDataTlvOptionHeader=['isIsLspEntries', 'authentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=header['LengthIndicator'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries',\n                                      Length=10,\n                                      LspEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=tlv['Length'],\n                  Type='Increment', Count=10)\n\n    entry = edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=entry['RemainTime'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1psnpHeader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型为DarYu\",\n  \"子任务2\": \"预约两个自环端口，分别命名为Port_1和Port_2\",\n  \"子任务3\": \"在端口Port_1上创建一条流量模板，命名为StreamTemplate_1\",\n  \"子任务4\": \"修改流量StreamTemplate_1的ISIS PSNP头部内容，包括LengthIndicator和CsnpDataTlvOptionHeader字段\",\n  \"子任务5\": \"修改流量StreamTemplate_1的ISIS TLV头部内容，设置Option为IsIsLspEntries并配置Length参数\",\n  \"子任务6\": \"修改流量StreamTemplate_1的ISIS LSP Entry内容，配置RemainTime参数\",\n  \"子任务7\": \"订阅StreamBlockStats统计视图\",\n  \"子任务8\": \"配置端口Port_1的发送模式为突发包模式，设置突发包数量为100\",\n  \"子任务9\": \"启动端口抓包功能\",\n  \"子任务10\": \"开始发送所有流量\",\n  \"子任务11\": \"等待流量发送完成\",\n  \"子任务12\": \"停止端口抓包功能\",\n  \"子任务13\": \"等待3秒确保统计结果稳定\",\n  \"子任务14\": \"获取流量StreamTemplate_1的StreamBlockStats统计信息\",\n  \"子任务15\": \"验证流量StreamTemplate_1的TxStreamFrames与RxStreamFrames统计值相等且等于100\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1psnpHeader'])\n\n    header = edit_header_isis_psnp(Stream=stream,\n                                   LengthIndicator=10,\n                                   CsnpDataTlvOptionHeader=['isIsLspEntries', 'authentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=header['LengthIndicator'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries',\n                                      Length=10,\n                                      LspEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=tlv['Length'],\n                  Type='Increment', Count=10)\n\n    entry = edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=entry['RemainTime'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1psnpHeader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/MstpConfig.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的mstp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'logicLinkControl', 'cfg'])\n\n    # 修改mstp头部\n    attr = edit_header_mstp_config(Stream=stream, Level=0,\n                                   RootBridgeSystemID='22:11:11:11:11:11',\n                                   MstInstances=1)\n    edit_modifier(Stream=stream, Attribute=attr['RootBridgeSystemID'],\n                  Type='Increment', Count=10, HeaderType='cfg')\n    attr_ins = edit_header_mstp_config_mst_instance(Stream=stream,\n                                                    RemainingHops=255)\n    edit_modifier(Stream=stream, Attribute=attr_ins['RemainingHops'],\n                  Type='Increment', Count=10, HeaderType='cfg')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2，使用指定位置信息。\",\n  \"子任务3\": \"在端口Port_1上创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"修改流量模板StreamTemplate_1的帧长度类型为AUTO。\",\n  \"子任务5\": \"为流量模板添加报文头部，包括ethernetii、logicLinkControl和cfg三层协议头。\",\n  \"子任务6\": \"修改cfg协议头中的MSTP配置：设置Level=0，RootBridgeSystemID='22:11:11:11:11:11'，MstInstances=1。\",\n  \"子任务7\": \"为RootBridgeSystemID字段配置增量修改器：类型Increment，步长10。\",\n  \"子任务8\": \"修改MSTP实例配置中的RemainingHops=255。\",\n  \"子任务9\": \"为RemainingHops字段配置增量修改器：类型Increment，步长10。\",\n  \"子任务10\": \"订阅统计视图，包括PortStats和StreamBlockStats统计类型。\",\n  \"子任务11\": \"配置端口发送模式为BURST，设置突发包数量为100。\",\n  \"子任务12\": \"保存当前测试配置到指定路径的xcfg文件。\",\n  \"子任务13\": \"开始发送所有流量。\",\n  \"子任务14\": \"等待流量自动停止发送。\",\n  \"子任务15\": \"流量停止后等待3秒确保统计结果稳定。\",\n  \"子任务16\": \"获取流量模板StreamTemplate_1的StreamBlockStats统计结果。\",\n  \"子任务17\": \"验证统计结果：TxStreamFrames等于RxStreamFrames且等于预设的突发包数量100。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的mstp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'logicLinkControl', 'cfg'])\n\n    # 修改mstp头部\n    attr = edit_header_mstp_config(Stream=stream, Level=0,\n                                   RootBridgeSystemID='22:11:11:11:11:11',\n                                   MstInstances=1)\n    edit_modifier(Stream=stream, Attribute=attr['RootBridgeSystemID'],\n                  Type='Increment', Count=10, HeaderType='cfg')\n    attr_ins = edit_header_mstp_config_mst_instance(Stream=stream,\n                                                    RemainingHops=255)\n    edit_modifier(Stream=stream, Attribute=attr_ins['RemainingHops'],\n                  Type='Increment', Count=10, HeaderType='cfg')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Vlan.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发vlan报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的vlan头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'vlan']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改vlan头部\n    attribute_dict = edit_header_vlan(Stream=stream, Level=0, ID=100, Priority=5, CFI=0)\n    # vlan头部目字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['ID'],\n                  Type='Increment', StreamType='InterModifier',\n                  Count=10, Step=2)\n    # vlan头部目字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['Priority'],\n                  Type='List',\n                  List=[2, 4, 6, 3])\n    # vlan头部目字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['CFI'],\n                  Type='Random',\n                  Range=1)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.cfi',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.id',\n                                               Value='100',\n                                               MaxValue='100')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.priority',\n                                               Value='5',\n                                               MaxValue='5')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，位置由输入参数或默认值确定。\",\n  \"子任务3\": \"在端口Port_1创建固定长度256字节的流量流。\",\n  \"子任务4\": \"为流量流添加EthernetII和vlan双层报文头部。\",\n  \"子任务5\": \"修改vlan头部字段：设置ID=100、Priority=5、CFI=0。\",\n  \"子任务6\": \"配置vlan头部ID字段的跳变规则：递增模式，步长2，数量10。\",\n  \"子任务7\": \"配置vlan头部Priority字段的跳变规则：列表模式，取值[2,4,6,3]。\",\n  \"子任务8\": \"配置vlan头部CFI字段的跳变规则：随机模式，范围0-1。\",\n  \"子任务9\": \"在端口Port_2创建抓包过滤规则：匹配vlan.cfi=1、vlan.id=100、vlan.priority=5。\",\n  \"子任务10\": \"设置端口Port_2的抓包过滤逻辑表达式（三个条件的逻辑与）。\",\n  \"子任务11\": \"订阅流模板块统计视图StreamBlockStats。\",\n  \"子任务12\": \"配置端口Port_1的发送模式为突发包，突发包数量100。\",\n  \"子任务13\": \"保存当前测试配置文件。\",\n  \"子任务14\": \"启动端口Port_2的数据包捕获。\",\n  \"子任务15\": \"启动流量发送。\",\n  \"子任务16\": \"等待10秒确保流量发送完成。\",\n  \"子任务17\": \"停止流量发送。\",\n  \"子任务18\": \"停止数据包捕获。\",\n  \"子任务19\": \"下载端口Port_2捕获的数据包到本地存储。\",\n  \"子任务20\": \"获取流量流的统计信息（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务21\": \"验证流量收发包数量相等：TxStreamFrames == RxStreamFrames。\",\n  \"子任务22\": \"释放所有预约的测试仪表端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发vlan报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的vlan头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'vlan']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改vlan头部\n    attribute_dict = edit_header_vlan(Stream=stream, Level=0, ID=100, Priority=5, CFI=0)\n    # vlan头部目字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['ID'],\n                  Type='Increment', StreamType='InterModifier',\n                  Count=10, Step=2)\n    # vlan头部目字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['Priority'],\n                  Type='List',\n                  List=[2, 4, 6, 3])\n    # vlan头部目字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['CFI'],\n                  Type='Random',\n                  Range=1)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.cfi',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.id',\n                                               Value='100',\n                                               MaxValue='100')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.priority',\n                                               Value='5',\n                                               MaxValue='5')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2TPv2Control.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv2 Control头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control'])\n\n    # 修改l2tpv2 control头部\n    edit_header_l2tpv2_control(Stream=stream, Level=0,\n                               Type=1,\n                               Reserved1=11,\n                               Ns=5,\n                               Nr=6,\n                               )\n\n    # 修改l2tpv2 control头部，添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='protocolVersion',\n                                      Ver=1,\n                                      Rev=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='framingCapabilities',\n                                      Abit=1,\n                                      Sbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='bearerCapabilities',\n                                      Abit=1,\n                                      Dbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='firmwareRevision',\n                                      FirmwareRevision=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='assignedTunnelId',\n                                      TunnelId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='assignedSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='response',\n                                      ResponseValue='00000000000000000000000000000001',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='minimumBps',\n                                      MinimumBps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='maximumBps',\n                                      MaximumBps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='bearerType',\n                                      Abit=1,\n                                      Dbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='framingType',\n                                      Abit=1,\n                                      Sbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='txConnectSpeed',\n                                      Bps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='rxConnectSpeed',\n                                      HighBPS=1,\n                                      LowBPS=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=19,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=20,\n                                      Types='proxyAuthenType',\n                                      AuthenType=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=21,\n                                      Types='proxyAuthenId',\n                                      AuthenId=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control'],\n                                             FieldName='l2tpv2Control_1.ns',\n                                             Value=5,\n                                             MaxValue=5,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个自环端口（Port_1和Port_2），指定端口位置。\",\n  \"子任务3\": \"在Port_1端口创建流量StreamTemplate_1，设置帧长度类型为AUTO。\",\n  \"子任务4\": \"为流量StreamTemplate_1创建报文头部（EthernetII, IPv4, UDP, l2tpv2Control）。\",\n  \"子任务5\": \"修改流量StreamTemplate_1的L2TPv2 Control头部基本字段（Level, Type, Reserved1, Ns, Nr）。\",\n  \"子任务6\": \"修改流量StreamTemplate_1的L2TPv2 Control头部Option字段（按索引配置多个Option类型和参数）。\",\n  \"子任务7\": \"订阅统计视图（StreamBlockStats）。\",\n  \"子任务8\": \"配置Port_1端口负载参数（发送模式=BURST，指定突发包数量）。\",\n  \"子任务9\": \"保存当前测试配置文件。\",\n  \"子任务10\": \"启动流量发送。\",\n  \"子任务11\": \"等待流量发送完成（流状态停止）。\",\n  \"子任务12\": \"等待3秒确保统计结果稳定。\",\n  \"子任务13\": \"获取流量StreamTemplate_1的StreamBlockStats统计结果（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务14\": \"验证统计结果：TxStreamFrames等于RxStreamFrames且等于预期突发包数量。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv2 Control头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control'])\n\n    # 修改l2tpv2 control头部\n    edit_header_l2tpv2_control(Stream=stream, Level=0,\n                               Type=1,\n                               Reserved1=11,\n                               Ns=5,\n                               Nr=6,\n                               )\n\n    # 修改l2tpv2 control头部，添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='protocolVersion',\n                                      Ver=1,\n                                      Rev=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='framingCapabilities',\n                                      Abit=1,\n                                      Sbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='bearerCapabilities',\n                                      Abit=1,\n                                      Dbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='firmwareRevision',\n                                      FirmwareRevision=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='assignedTunnelId',\n                                      TunnelId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='assignedSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='response',\n                                      ResponseValue='00000000000000000000000000000001',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='minimumBps',\n                                      MinimumBps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='maximumBps',\n                                      MaximumBps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='bearerType',\n                                      Abit=1,\n                                      Dbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='framingType',\n                                      Abit=1,\n                                      Sbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='txConnectSpeed',\n                                      Bps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='rxConnectSpeed',\n                                      HighBPS=1,\n                                      LowBPS=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=19,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=20,\n                                      Types='proxyAuthenType',\n                                      AuthenType=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=21,\n                                      Types='proxyAuthenId',\n                                      AuthenId=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control'],\n                                             FieldName='l2tpv2Control_1.ns',\n                                             Value=5,\n                                             MaxValue=5,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv2Report.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发igmpv2 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的igmpv2 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv2']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv2_report(Stream=stream, Level=0, Type=99, MaxResponseTime='255', Checksum='ffff',\n                              GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.GroupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv2_report:修改测试仪表流量模板中IGMPv2 Report报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表平台为DarYu\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2\",\n  \"子任务3\": \"在Port_1创建流量StreamTemplate_1，设置固定帧长度256字节\",\n  \"子任务4\": \"为流量创建三层报文头部：EthernetII、IPv4和igmpv2\",\n  \"子任务5\": \"修改igmpv2 report头部参数：Type=99, MaxResponseTime=255, Checksum=ffff, GroupAddress=10.1.1.1\",\n  \"子任务6\": \"在Port_2配置抓包过滤条件：匹配igmpv2 type=99 && Checksum=ffff && GroupAddress=10.1.1.1\",\n  \"子任务7\": \"订阅StreamBlockStats统计视图\",\n  \"子任务8\": \"设置Port_1发送模式为BURST，突发包数量100\",\n  \"子任务9\": \"保存当前测试配置文件\",\n  \"子任务10\": \"启动Port_2抓包功能\",\n  \"子任务11\": \"开始发送所有流量\",\n  \"子任务12\": \"等待10秒传输时间\",\n  \"子任务13\": \"停止所有流量发送\",\n  \"子任务14\": \"停止Port_2抓包\",\n  \"子任务15\": \"下载Port_2捕获的报文数据\",\n  \"子任务16\": \"获取StreamTemplate_1的流模板块统计信息\",\n  \"子任务17\": \"验证TxStreamFrames发送帧数等于RxStreamFrames接收帧数\",\n  \"子任务18\": \"释放所有预约端口资源\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发igmpv2 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的igmpv2 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv2']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv2_report(Stream=stream, Level=0, Type=99, MaxResponseTime='255', Checksum='ffff',\n                              GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.GroupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv2_report:修改测试仪表流量模板中IGMPv2 Report报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/LldpEnd.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的lldp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv', 'ttltlv', 'endtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_end_tlv(Stream=stream, Level=0, Length=10)\n    edit_modifier(Stream=stream, Attribute=attr['Length'],\n                  Type='Increment', Count=10, HeaderType='endtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，对应物理位置为//10.0.11.191/1/5和//10.0.11.191/1/6。\",\n  \"子任务3\": \"在预约端口Port_UP上创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"设置流量模板的帧长度类型为AUTO模式。\",\n  \"子任务5\": \"为流量添加报文头部，包括ethernetii、portidtlv、ttltlv和endtlv类型。\",\n  \"子任务6\": \"修改LLDP结束TLV的Length属性，设置跳变方式为增量模式，增量为10，计数10次。\",\n  \"子任务7\": \"订阅PortStats和StreamBlockStats统计视图。\",\n  \"子任务8\": \"配置端口发送模式为突发模式，设置突发包数量为100。\",\n  \"子任务9\": \"保存当前测试配置到本地xcfg文件。\",\n  \"子任务10\": \"启动所有流量发送。\",\n  \"子任务11\": \"等待流量自动停止发送。\",\n  \"子任务12\": \"等待3秒确保统计结果稳定。\",\n  \"子任务13\": \"获取StreamTemplate_1的流模板块统计信息。\",\n  \"子任务14\": \"验证发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)且都等于100。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的lldp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv', 'ttltlv', 'endtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_end_tlv(Stream=stream, Level=0, Length=10)\n    edit_modifier(Stream=stream, Attribute=attr['Length'],\n                  Type='Increment', Count=10, HeaderType='endtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2TPv3DataOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Data Over Udp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp'])\n\n    # 修改icmpv4 echo reply头部\n    edit_header_l2tpv3_data_over_udp(Stream=stream, Level=0,\n                                     Type=1,\n                                     Reserved1='00000000001',\n                                     Version=1,\n                                     Reserved2=1,\n                                     SessionId=1,\n                                     Cookie4Byte='00000001',\n                                     L2specificsublayer={'xbit': 1, 'sbit': 1, 'xbits': '000001', 'sequence': 1}, )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp'],\n                                             FieldName='l2tpv3DataOverUdp_1.sessionId',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试平台类型。\",\n  \"子任务2\": \"预约两个自环端口，分别命名为Port_1和Port_2。\",\n  \"子任务3\": \"在端口Port_1上创建一条流量StreamTemplate_1，配置固定帧长为512字节。\",\n  \"子任务4\": \"修改流量StreamTemplate_1的L2TPv3 Data Over UDP头部参数，包括Type、Version、SessionId等字段。\",\n  \"子任务5\": \"订阅StreamBlockStats统计视图用于后续结果验证。\",\n  \"子任务6\": \"配置端口Port_1的发送模式为突发模式，设置突发包数量为100。\",\n  \"子任务7\": \"启动流量发送，开始传输StreamTemplate_1。\",\n  \"子任务8\": \"等待流量发送完成，确认所有数据包已传输完毕。\",\n  \"子任务9\": \"停止所有流量发送。\",\n  \"子任务10\": \"等待3秒确保统计结果稳定。\",\n  \"子任务11\": \"获取流量StreamTemplate_1的StreamBlockStats统计信息。\",\n  \"子任务12\": \"验证StreamTemplate_1的发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Data Over Udp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp'])\n\n    # 修改icmpv4 echo reply头部\n    edit_header_l2tpv3_data_over_udp(Stream=stream, Level=0,\n                                     Type=1,\n                                     Reserved1='00000000001',\n                                     Version=1,\n                                     Reserved2=1,\n                                     SessionId=1,\n                                     Cookie4Byte='00000001',\n                                     L2specificsublayer={'xbit': 1, 'sbit': 1, 'xbits': '000001', 'sequence': 1}, )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp'],\n                                             FieldName='l2tpv3DataOverUdp_1.sessionId',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2UpdateRouteLsa.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 link state update报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的ospfv2 link state update头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n\n    stream = add_stream(Ports=Port_UP, FixedLength=256)\n\n    # 修改流量报文头部\n\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'ospfv2linkstateupdate'])\n\n    # 修改ospfv2 link state update头部，添加一个Router LSA\n\n    LsaHeaders = ['Router']\n    edit_header_ospfv2_update(Stream=stream, Level=0,\n                              RouterID='10.1.1.2',\n                              AreaID='0.0.0.2',\n                              AuthValue2=1,\n                              LsaHeaders=LsaHeaders,\n                              )\n\n    # 修改ospfv2 link state update头部，Router LSA内容，并添加4个Lsa Link即RouterLsaLinkCount=4\n\n    edit_header_ospfv2_update_lsa(Stream=stream, Level=0,\n                                  Index=0,\n                                  Type='Router',\n                                  LinkStateId='10.1.0.1',\n                                  AdvertisingRouter='10.1.0.2',\n                                  RouterLsaLinkCount=4,\n                                  )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第一个RouterLsaLinkCount内容即Index=0\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=0,\n                                             LinkId='10.1.0.0',\n                                             LinkData='255.255.255.255',\n                                             RouterLsaLinkType=3,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第二个RouterLsaLinkCount内容即Index=1\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=1,\n                                             LinkId='10.2.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=2,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第三个RouterLsaLinkCount内容即Index=2\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=2,\n                                             LinkId='10.3.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=4,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第四个RouterLsaLinkCount内容即Index=3\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=3,\n                                             LinkId='10.4.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=1,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 订阅StreamBlockStats统计视图\n\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n\n    start_capture()\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_capture()\n\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(stream, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 释放端口资源\n\n    result = release_port(Locations=locations)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_update:修改测试仪表流量模板中OSPFv2 Link State Update报文头部内容",
      "edit_header_ospfv2_update_lsa:修改测试仪表流量模板中OSPFv2 Update报文中Lsa头部内容.",
      "edit_header_ospfv2_update_route_lsa_link:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试平台类型。\",\n  \"子任务2\": \"预约两个端口资源，建立自环测试环境。\",\n  \"子任务3\": \"在指定端口创建流量模板，设置固定帧长度。\",\n  \"子任务4\": \"配置流量模板的协议头部栈，包括EthernetII、IPv4和OSPFv2 Link State Update协议层。\",\n  \"子任务5\": \"编辑OSPFv2 Link State Update报文头部公共字段（RouterID、AreaID、AuthValue等）。\",\n  \"子任务6\": \"编辑OSPFv2 Update报文中LSA头部内容，指定LSA类型和基本参数。\",\n  \"子任务7\": \"编辑Router LSA的第一个链路条目（Index=0），设置LinkID、LinkData等参数。\",\n  \"子任务8\": \"编辑Router LSA的第二个链路条目（Index=1），设置LinkID、LinkData等参数。\",\n  \"子任务9\": \"编辑Router LSA的第三个链路条目（Index=2），设置LinkID、LinkData等参数。\",\n  \"子任务10\": \"编辑Router LSA的第四个链路条目（Index=3），设置LinkID、LinkData等参数。\",\n  \"子任务11\": \"订阅流模板块统计视图（StreamBlockStats）用于后续结果采集。\",\n  \"子任务12\": \"保存当前测试配置到本地文件。\",\n  \"子任务13\": \"启动端口抓包功能捕获测试流量。\",\n  \"子任务14\": \"开始发送配置的流量模板。\",\n  \"子任务15\": \"等待指定时间（10秒）使流量稳定传输。\",\n  \"子任务16\": \"停止发送流量模板。\",\n  \"子任务17\": \"停止端口抓包功能。\",\n  \"子任务18\": \"下载捕获的报文数据到本地存储。\",\n  \"子任务19\": \"获取指定流量模板的统计信息（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务20\": \"验证流量模板的发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\",\n  \"子任务21\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 link state update报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的ospfv2 link state update头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n\n    stream = add_stream(Ports=Port_UP, FixedLength=256)\n\n    # 修改流量报文头部\n\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'ospfv2linkstateupdate'])\n\n    # 修改ospfv2 link state update头部，添加一个Router LSA\n\n    LsaHeaders = ['Router']\n    edit_header_ospfv2_update(Stream=stream, Level=0,\n                              RouterID='10.1.1.2',\n                              AreaID='0.0.0.2',\n                              AuthValue2=1,\n                              LsaHeaders=LsaHeaders,\n                              )\n\n    # 修改ospfv2 link state update头部，Router LSA内容，并添加4个Lsa Link即RouterLsaLinkCount=4\n\n    edit_header_ospfv2_update_lsa(Stream=stream, Level=0,\n                                  Index=0,\n                                  Type='Router',\n                                  LinkStateId='10.1.0.1',\n                                  AdvertisingRouter='10.1.0.2',\n                                  RouterLsaLinkCount=4,\n                                  )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第一个RouterLsaLinkCount内容即Index=0\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=0,\n                                             LinkId='10.1.0.0',\n                                             LinkData='255.255.255.255',\n                                             RouterLsaLinkType=3,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第二个RouterLsaLinkCount内容即Index=1\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=1,\n                                             LinkId='10.2.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=2,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第三个RouterLsaLinkCount内容即Index=2\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=2,\n                                             LinkId='10.3.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=4,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第四个RouterLsaLinkCount内容即Index=3\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=3,\n                                             LinkId='10.4.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=1,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 订阅StreamBlockStats统计视图\n\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n\n    start_capture()\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_capture()\n\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(stream, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 释放端口资源\n\n    result = release_port(Locations=locations)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_update:修改测试仪表流量模板中OSPFv2 Link State Update报文头部内容;\nedit_header_ospfv2_update_lsa:修改测试仪表流量模板中OSPFv2 Update报文中Lsa头部内容.;\nedit_header_ospfv2_update_route_lsa_link:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Gtpv1.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发gtpv1报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的gtpv1头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TCP', 'gtpv1', 'gtpv1opt', 'gtpv1ext']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改gtp头部\n    gtp = edit_header_gtpv1(Stream=stream, Teid=10)\n    opt = edit_header_gtpv1_optional(Stream=stream, Sequence=20)\n    optext = edit_header_gtpv1_optional_extension(Stream=stream, NPDUNumber=30)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1', Attribute=gtp['Teid'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1opt', Attribute=opt['Sequence'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1ext', Attribute=optext['NPDUNumber'],\n                  Type='Increment', Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='gtpv1_1.version',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试平台类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"创建流量模板StreamTemplate_1，设置固定帧长为256字节。\",\n  \"子任务4\": \"配置流量头部协议栈：EthernetII、IPv4、TCP、gtpv1、gtpv1opt、gtpv1ext。\",\n  \"子任务5\": \"修改gtpv1头部TEID字段值为10，并设置增量跳变规则：每次增加2，共10次。\",\n  \"子任务6\": \"修改gtpv1opt头部Sequence字段值为20，并设置增量跳变规则：每次增加2，共10次。\",\n  \"子任务7\": \"修改gtpv1ext头部NPDUNumber字段值为30，并设置增量跳变规则：每次增加2，共10次。\",\n  \"子任务8\": \"在Port_2创建PDU抓包过滤模式，匹配gtpv1.version字段值为1。\",\n  \"子任务9\": \"在Port_2应用报文过滤表达式。\",\n  \"子任务10\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务11\": \"设置Port_1发送模式为突发包，突发包数量为100。\",\n  \"子任务12\": \"保存当前测试配置文件。\",\n  \"子任务13\": \"启动Port_2抓包功能。\",\n  \"子任务14\": \"启动流量发送。\",\n  \"子任务15\": \"等待10秒传输时间。\",\n  \"子任务16\": \"停止流量发送。\",\n  \"子任务17\": \"停止Port_2抓包功能。\",\n  \"子任务18\": \"下载Port_2捕获的报文数据。\",\n  \"子任务19\": \"获取StreamTemplate_1的流统计信息。\",\n  \"子任务20\": \"验证TxStreamFrames与RxStreamFrames统计值相等。\",\n  \"子任务21\": \"释放所有预约端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发gtpv1报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的gtpv1头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TCP', 'gtpv1', 'gtpv1opt', 'gtpv1ext']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改gtp头部\n    gtp = edit_header_gtpv1(Stream=stream, Teid=10)\n    opt = edit_header_gtpv1_optional(Stream=stream, Sequence=20)\n    optext = edit_header_gtpv1_optional_extension(Stream=stream, NPDUNumber=30)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1', Attribute=gtp['Teid'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1opt', Attribute=opt['Sequence'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1ext', Attribute=optext['NPDUNumber'],\n                  Type='Increment', Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='gtpv1_1.version',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl1csnpHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1csnpheader'])\n\n    header = edit_header_isis_csnp(Stream=stream,\n                                   Version=1,\n                                   LspId='10203040506070',\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=header['LspId'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries',\n                                      TlvCode=10,\n                                      LspEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n\n    lsp = edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1,\n                                     RemainTime=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=lsp['RemainTime'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务2\": \"在端口Port_1上创建一条流量StreamTemplate_1。\",\n  \"子任务3\": \"修改流量StreamTemplate_1的ISIS头部内容，包括版本号、LspId等字段配置。\",\n  \"子任务4\": \"为ISIS头部字段配置跳变规则，包括版本号、LspId等字段的增量变化。\",\n  \"子任务5\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务6\": \"配置端口发送模式为突发包模式，设置突发包数量。\",\n  \"子任务7\": \"启动流量发送并等待流量发送完成。\",\n  \"子任务8\": \"停止流量后等待3秒以确保统计结果稳定。\",\n  \"子任务9\": \"获取流量StreamTemplate_1的StreamBlockStats统计信息。\",\n  \"子任务10\": \"验证流量StreamTemplate_1的收包数量等于发包数量。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1csnpheader'])\n\n    header = edit_header_isis_csnp(Stream=stream,\n                                   Version=1,\n                                   LspId='10203040506070',\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=header['LspId'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries',\n                                      TlvCode=10,\n                                      LspEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n\n    lsp = edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1,\n                                     RemainTime=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=lsp['RemainTime'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/IPv6.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6fragmentheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ipv6头部\n    attribute_dict = edit_header_ipv6(Stream=stream, Level=0, HopLimit=20,\n                                      Source='2022::2', Destination='2020::2', Gateway='2022::1')\n    # ipv6头部HopLimit字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['HopLimit'],\n                  Type='Increment', Count=10, Step=2)\n    # ipv6头部Source字段添加List跳变\n#    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['Source'],\n#                  Type='List', List=['2022::2', '2022::5', '2022::3'])\n    # ipv6头部Destination的Length字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['Destination'],\n                  Type='Random', Range='2020::10')\n    # ipv6 fragment\n    attr = edit_header_ipv6_fragment(Stream=stream, NextHeader=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6fragmentheader', Attribute=attr['NextHeader'],\n                  Type='Increment', Count=10, Step=2)\n\n    # 配置过滤抓包\n    # 使用Level和Attribute参数添加pdu_pattern\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            Level=1,\n    #                                            Attribute=attribute_dict['HopLimit'],\n    #                                            Value=20, MaxValue=22)\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            Level=1,\n    #                                            Attribute=attribute_dict['Source'],\n    #                                            Value='2022::2', MaxValue='2022::2')\n    # 使用FieldName参数添加pdu_pattern\n    # pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ipv6_1.destination',\n    #                                            Value='2020::2', MaxValue='2020::2')\n    # edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv6:修改测试仪表流量模板中IPv6报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约两个自环端口 Port_1 和 Port_2\",\n  \"子任务2\": \"创建流量 StreamTemplate_1 并指定固定帧长度\",\n  \"子任务3\": \"配置流量 StreamTemplate_1 的报文头部结构（包括 EthernetII、IPv6 和 ipv6fragmentheader）\",\n  \"子任务4\": \"修改流量 StreamTemplate_1 的 IPv6 头部基本字段（HopLimit、Source、Destination、Gateway）\",\n  \"子任务5\": \"为 IPv6 头部的 HopLimit 字段配置 Increment 类型跳变域\",\n  \"子任务6\": \"为 IPv6 头部的 Destination 字段配置 Random 类型跳变域\",\n  \"子任务7\": \"修改 IPv6 分片扩展头部（ipv6fragmentheader）的 NextHeader 字段\",\n  \"子任务8\": \"为 IPv6 分片扩展头部的 NextHeader 字段配置 Increment 类型跳变域\",\n  \"子任务9\": \"在接收端口配置基于报文头部的抓包过滤条件\",\n  \"子任务10\": \"订阅 StreamBlockStats 统计视图\",\n  \"子任务11\": \"配置端口发送模式为 BURST 突发模式并设置突发包数量\",\n  \"子任务12\": \"启动端口抓包\",\n  \"子任务13\": \"开始发送流量 StreamTemplate_1\",\n  \"子任务14\": \"等待指定时间（如10秒）使流量稳定发送\",\n  \"子任务15\": \"停止发送流量 StreamTemplate_1\",\n  \"子任务16\": \"停止端口抓包\",\n  \"子任务17\": \"获取流量 StreamTemplate_1 的 StreamBlockStats 统计结果\",\n  \"子任务18\": \"验证流量 StreamTemplate_1 的 TxStreamFrames 和 RxStreamFrames 统计值相等\",\n  \"子任务19\": \"释放所有预约的测试端口资源\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6fragmentheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ipv6头部\n    attribute_dict = edit_header_ipv6(Stream=stream, Level=0, HopLimit=20,\n                                      Source='2022::2', Destination='2020::2', Gateway='2022::1')\n    # ipv6头部HopLimit字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['HopLimit'],\n                  Type='Increment', Count=10, Step=2)\n    # ipv6头部Source字段添加List跳变\n#    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['Source'],\n#                  Type='List', List=['2022::2', '2022::5', '2022::3'])\n    # ipv6头部Destination的Length字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['Destination'],\n                  Type='Random', Range='2020::10')\n    # ipv6 fragment\n    attr = edit_header_ipv6_fragment(Stream=stream, NextHeader=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6fragmentheader', Attribute=attr['NextHeader'],\n                  Type='Increment', Count=10, Step=2)\n\n    # 配置过滤抓包\n    # 使用Level和Attribute参数添加pdu_pattern\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            Level=1,\n    #                                            Attribute=attribute_dict['HopLimit'],\n    #                                            Value=20, MaxValue=22)\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            Level=1,\n    #                                            Attribute=attribute_dict['Source'],\n    #                                            Value='2022::2', MaxValue='2022::2')\n    # 使用FieldName参数添加pdu_pattern\n    # pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ipv6_1.destination',\n    #                                            Value='2020::2', MaxValue='2020::2')\n    # edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv6:修改测试仪表流量模板中IPv6报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv3_ControlOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 control over udp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 control over udp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3ControlOverUdp头部\n    header = edit_header_l2tpv3_control_over_udp(Stream=stream, Level=0, Type=1, SequenceNumberNr=1, Length=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header['Length'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header['SequenceNumberNr'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv3ControlOverUdp头部选项\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=0, Types='generalTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=1, Types='messageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=2, Types='resultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=3, Types='tieBreaker', TieBreakerValue='0000000000000001')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['TieBreakerValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=4, Types='receiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=5, Types='callSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=6, Types='physicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=7, Types='circuitError', AlignmentOverruns='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['AlignmentOverruns'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=8, Types='routeId', RouteId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['RouteId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=9, Types='assignedConnection', ConnectionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['ConnectionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=10, Types='localSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=11, Types='remoteSessionId',  SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=12, Types='assignedCookie', Cookie8Byte='1020304050607080')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['Cookie8Byte'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=13, Types='pwType', PwType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['PwType'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=14, Types='l2SpecificSub', L2SpecificSublayer='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['L2SpecificSublayer'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=15, Types='dataSequencing', DataSequencing='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['DataSequencing'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=16, Types='txConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=17, Types='rxConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=18, Types='circuitStatus', Nbit='1',Abit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['Abit'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3ControlOverUdp_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1端口创建流量流，设置固定帧长为512字节。\",\n  \"子任务4\": \"为流量流创建报文头部，包含EthernetII、IPv4、UDP和l2tpv3ControlOverUdp协议层。\",\n  \"子任务5\": \"编辑l2tpv3ControlOverUdp头部基本字段：设置Level=0、Type=1、SequenceNumberNr=1、Length=1。\",\n  \"子任务6\": \"为l2tpv3ControlOverUdp头部的Length和SequenceNumberNr字段配置Increment跳变，步长为10。\",\n  \"子任务7\": \"编辑l2tpv3ControlOverUdp头部选项：依次配置generalTLV、messageType、resultCode等18个选项的具体属性值。\",\n  \"子任务8\": \"为前4个选项（generalTLV、messageType、resultCode、tieBreaker）的指定字段配置Increment跳变，步长为10。\",\n  \"子任务9\": \"在Port_2端口创建PDU抓包过滤规则，匹配l2tpv3ControlOverUdp.type=1的报文。\",\n  \"子任务10\": \"设置Port_2端口的抓包过滤表达式。\",\n  \"子任务11\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务12\": \"配置Port_1端口发送模式为BURST，设置突发包数量为100。\",\n  \"子任务13\": \"保存当前测试配置到指定路径。\",\n  \"子任务14\": \"启动Port_2端口抓包。\",\n  \"子任务15\": \"开始发送流量流。\",\n  \"子任务16\": \"等待10秒传输时间。\",\n  \"子任务17\": \"停止发送流量流。\",\n  \"子任务18\": \"停止Port_2端口抓包。\",\n  \"子任务19\": \"下载Port_2端口捕获的报文数据到本地目录。\",\n  \"子任务20\": \"获取流量流的StreamBlockStats统计结果。\",\n  \"子任务21\": \"验证流量流收发包数量相等：TxStreamFrames == RxStreamFrames。\",\n  \"子任务22\": \"释放所有预约端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 control over udp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 control over udp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3ControlOverUdp头部\n    header = edit_header_l2tpv3_control_over_udp(Stream=stream, Level=0, Type=1, SequenceNumberNr=1, Length=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header['Length'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header['SequenceNumberNr'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv3ControlOverUdp头部选项\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=0, Types='generalTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=1, Types='messageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=2, Types='resultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=3, Types='tieBreaker', TieBreakerValue='0000000000000001')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['TieBreakerValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=4, Types='receiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=5, Types='callSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=6, Types='physicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=7, Types='circuitError', AlignmentOverruns='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['AlignmentOverruns'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=8, Types='routeId', RouteId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['RouteId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=9, Types='assignedConnection', ConnectionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['ConnectionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=10, Types='localSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=11, Types='remoteSessionId',  SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=12, Types='assignedCookie', Cookie8Byte='1020304050607080')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['Cookie8Byte'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=13, Types='pwType', PwType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['PwType'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=14, Types='l2SpecificSub', L2SpecificSublayer='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['L2SpecificSublayer'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=15, Types='dataSequencing', DataSequencing='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['DataSequencing'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=16, Types='txConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=17, Types='rxConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=18, Types='circuitStatus', Nbit='1',Abit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['Abit'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3ControlOverUdp_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Mpls.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发mpls报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的mpls头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Log=True)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'mpls']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改mpls头部\n    attribute_dict = edit_header_mpls(Stream=stream, Level=0, Label=32, Exp='001', TTL=200)\n    # mpls头部Label字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['Label'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # mpls头部目Exp字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['Exp'],\n                  Type='List',\n                  List=['001', '011', '110'])\n    # mpls头部目TTL字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['TTL'],\n                  Type='Random',\n                  Range=1000)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mpls_1.label',\n                                               Value='32', MaxValue='32')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mpls_1.ttl',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_mpls:修改测试仪表流量模板中MPLS报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约测试仪表的两个自环端口 Port_1 和 Port_2。\",\n  \"子任务2\": \"创建流量模板并设置基本参数（固定帧长256字节）。\",\n  \"子任务3\": \"为流量模板配置报文头部：以太网头和MPLS头。\",\n  \"子任务4\": \"修改MPLS头部：设置第0层Label字段为32，Exp字段为'001'，TTL字段为200。\",\n  \"子任务5\": \"配置Label字段跳变规则：递增模式，起始值32，步长2，计数10。\",\n  \"子任务6\": \"配置Exp字段跳变规则：列表模式，取值['001','011','110']。\",\n  \"子任务7\": \"配置TTL字段跳变规则：随机模式，范围0-1000。\",\n  \"子任务8\": \"在Port_2创建抓包过滤条件：匹配MPLS Label=32 且 TTL=200 的报文。\",\n  \"子任务9\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务10\": \"配置Port_1发送模式：突发包模式，突发包数量100。\",\n  \"子任务11\": \"启动Port_2抓包功能。\",\n  \"子任务12\": \"开始发送所有流量。\",\n  \"子任务13\": \"等待10秒确保流量发送完成。\",\n  \"子任务14\": \"停止所有流量发送。\",\n  \"子任务15\": \"停止Port_2抓包功能。\",\n  \"子任务16\": \"获取流量StreamTemplate_1的StreamBlockStats统计信息。\",\n  \"子任务17\": \"验证统计结果：TxStreamFrames发送帧数等于RxStreamFrames接收帧数。\",\n  \"子任务18\": \"释放所有预约的测试仪表端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发mpls报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的mpls头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Log=True)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'mpls']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改mpls头部\n    attribute_dict = edit_header_mpls(Stream=stream, Level=0, Label=32, Exp='001', TTL=200)\n    # mpls头部Label字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['Label'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # mpls头部目Exp字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['Exp'],\n                  Type='List',\n                  List=['001', '011', '110'])\n    # mpls头部目TTL字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['TTL'],\n                  Type='Random',\n                  Range=1000)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mpls_1.label',\n                                               Value='32', MaxValue='32')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mpls_1.ttl',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_mpls:修改测试仪表流量模板中MPLS报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/LinkModifier.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv4报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv4头部内容;;\n                   测试步骤3: 设置link Modifer;\n\n Criteria    \t:   预期结果1: 配置无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port1, port2 = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=port1, FixedLength=256)\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n    # 修改ipv4头部\n    HeaderOption = ['Security', 'RouterAlert']\n    attribute_dict = edit_header_ipv4(Stream=stream, Level=0, TTL=200, Source='10.1.1.2', Destination='20.1.1.2',\n                                      Flags=111, HeaderOption=HeaderOption)\n    # ipv4头部Source字段添加Increment跳变\n    modifier_1 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=10, Step=2)\n\n    modifier_2 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=20, Step=2)\n\n    modifier_3 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Destination'],\n                               Type='Increment', Count=10, Step=2)\n\n    modifier_4 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Destination'],\n                               Type='Increment', Count=20, Step=2)\n    # 设置流量link modifer\n    link_modifier = [[modifier_1, modifier_2, modifier_3], [modifier_2, modifier_3, modifier_4], [modifier_3, modifier_4]]\n    edit_modifier_link(Stream=stream, Link=link_modifier)\n\n    # 保存配置\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 释放端口资源\n    release_port(locations)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，分别对应物理位置Location_1和Location_2。\",\n  \"子任务3\": \"在预约端口上创建流量，设置固定帧长度为256字节。\",\n  \"子任务4\": \"为流量添加报文头部，指定头部类型为EthernetII和IPv4。\",\n  \"子任务5\": \"修改IPv4头部参数：设置TTL=200、源地址=10.1.1.2、目的地址=20.1.1.2、Flags=111、HeaderOption=['Security','RouterAlert']。\",\n  \"子任务6\": \"为IPv4源地址字段创建增量跳变域：类型=Increment、计数=10、步长=2。\",\n  \"子任务7\": \"为IPv4源地址字段创建增量跳变域：类型=Increment、计数=20、步长=2。\",\n  \"子任务8\": \"为IPv4目的地址字段创建增量跳变域：类型=Increment、计数=10、步长=2。\",\n  \"子任务9\": \"为IPv4目的地址字段创建增量跳变域：类型=Increment、计数=20、步长=2。\",\n  \"子任务10\": \"设置跳变域链接关系：[[源地址跳变1,源地址跳变2,目的地址跳变1], [源地址跳变2,目的地址跳变1,目的地址跳变2], [目的地址跳变1,目的地址跳变2]]。\",\n  \"子任务11\": \"保存当前测试配置到指定路径的xcfg文件。\",\n  \"子任务12\": \"验证所有配置步骤执行无异常。\",\n  \"子任务13\": \"释放已预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv4报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv4头部内容;;\n                   测试步骤3: 设置link Modifer;\n\n Criteria    \t:   预期结果1: 配置无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port1, port2 = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=port1, FixedLength=256)\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n    # 修改ipv4头部\n    HeaderOption = ['Security', 'RouterAlert']\n    attribute_dict = edit_header_ipv4(Stream=stream, Level=0, TTL=200, Source='10.1.1.2', Destination='20.1.1.2',\n                                      Flags=111, HeaderOption=HeaderOption)\n    # ipv4头部Source字段添加Increment跳变\n    modifier_1 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=10, Step=2)\n\n    modifier_2 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=20, Step=2)\n\n    modifier_3 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Destination'],\n                               Type='Increment', Count=10, Step=2)\n\n    modifier_4 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Destination'],\n                               Type='Increment', Count=20, Step=2)\n    # 设置流量link modifer\n    link_modifier = [[modifier_1, modifier_2, modifier_3], [modifier_2, modifier_3, modifier_4], [modifier_3, modifier_4]]\n    edit_modifier_link(Stream=stream, Link=link_modifier)\n\n    # 保存配置\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 释放端口资源\n    release_port(locations)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv3_DataOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 data over udp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 data over udp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改l2tpv3DataOverUdp头部\n    header = edit_header_l2tpv3_data_over_udp(Stream=stream, Level=0, SessionId='1', Cookie8Byte='0000000000000001',\n                                     L2specificsublayer=1)\n    # 修改l2tpv3 data over udp头部选项\n    header_option = edit_header_l2tpv3_data_sublayer(Stream=stream, Type='L2specificsublayer', Xbit=1, Sbit=1, Sequence=10)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverUdp', Attribute=header_option['Sequence'],\n                  Type='Increment', Count=10)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverUdp', Attribute=header['Cookie8Byte'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3DataOverUdp_1.sessionId',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表平台，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"创建流量模板StreamTemplate_1，设置固定帧长度为512字节。\",\n  \"子任务4\": \"为流量StreamTemplate_1构建报文头部结构：EthernetII、IPv4、UDP和l2tpv3DataOverUdp。\",\n  \"子任务5\": \"编辑l2tpv3DataOverUdp头部字段：设置SessionId=1，Cookie8Byte=0000000000000001，启用L2特定子层。\",\n  \"子任务6\": \"配置l2tpv3DataOverUdp的L2特定子层参数：设置Xbit=1，Sbit=1，Sequence=10。\",\n  \"子任务7\": \"修改Sequence字段为递增模式，步长为1，变化次数为10。\",\n  \"子任务8\": \"修改Cookie8Byte字段为递增模式，步长为1，变化次数为10。\",\n  \"子任务9\": \"在Port_2创建PDU捕获模式，过滤条件为l2tpv3DataOverUdp.sessionId=1。\",\n  \"子任务10\": \"在Port_2应用报文捕获过滤器。\",\n  \"子任务11\": \"订阅流模板块统计视图StreamBlockStats。\",\n  \"子任务12\": \"配置Port_1发送模式为突发包模式，设置突发包数量为100。\",\n  \"子任务13\": \"启动Port_2的数据包捕获功能。\",\n  \"子任务14\": \"开始发送流量StreamTemplate_1。\",\n  \"子任务15\": \"等待10秒传输时间。\",\n  \"子任务16\": \"停止流量发送。\",\n  \"子任务17\": \"停止数据包捕获。\",\n  \"子任务18\": \"获取StreamTemplate_1的流模板块统计信息。\",\n  \"子任务19\": \"验证发送帧数(TxStreamFrames)与接收帧数(RxStreamFrames)相等。\",\n  \"子任务20\": \"释放所有预约端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 data over udp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 data over udp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改l2tpv3DataOverUdp头部\n    header = edit_header_l2tpv3_data_over_udp(Stream=stream, Level=0, SessionId='1', Cookie8Byte='0000000000000001',\n                                     L2specificsublayer=1)\n    # 修改l2tpv3 data over udp头部选项\n    header_option = edit_header_l2tpv3_data_sublayer(Stream=stream, Type='L2specificsublayer', Xbit=1, Sbit=1, Sequence=10)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverUdp', Attribute=header_option['Sequence'],\n                  Type='Increment', Count=10)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverUdp', Attribute=header['Cookie8Byte'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3DataOverUdp_1.sessionId',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/ControlWord.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Control Word头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['cw', 'ethernetii', 'ipv4'])\n\n    # 修改Control Word头部\n    attr = edit_header_control_word(Stream=stream, Level=0,\n                                    Sn='65535')\n    edit_modifier(Stream=stream, Attribute=attr['Sn'],\n                  Type='Increment', Count=10, HeaderType='cw')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约两个端口 Port_1 和 Port_2 作为自环测试端口。\",\n  \"子任务3\": \"在端口 Port_1 上创建流量模板 StreamTemplate_1。\",\n  \"子任务4\": \"为流量 StreamTemplate_1 配置报文头部，包含 Control Word、EthernetII 和 IPv4 头部。\",\n  \"子任务5\": \"修改流量 StreamTemplate_1 的 Control Word 头部序列号字段，设置起始值并配置递增跳变规则。\",\n  \"子任务6\": \"设置端口 Port_1 的发送模式为突发包，指定突发包数量。\",\n  \"子任务7\": \"保存当前测试配置到本地文件。\",\n  \"子任务8\": \"订阅流模板块统计 StreamBlockStats。\",\n  \"子任务9\": \"启动所有流量发送。\",\n  \"子任务10\": \"等待流量发送完成自动停止。\",\n  \"子任务11\": \"等待至少 3 秒确保统计结果稳定。\",\n  \"子任务12\": \"获取流量 StreamTemplate_1 的流模板块统计信息。\",\n  \"子任务13\": \"验证流量 StreamTemplate_1 的发送帧数 (TxStreamFrames) 等于接收帧数 (RxStreamFrames)，且均等于设定的突发包数量。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Control Word头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['cw', 'ethernetii', 'ipv4'])\n\n    # 修改Control Word头部\n    attr = edit_header_control_word(Stream=stream, Level=0,\n                                    Sn='65535')\n    edit_modifier(Stream=stream, Attribute=attr['Sn'],\n                  Type='Increment', Count=10, HeaderType='cw')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6MLDv1Done.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv1 done报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv1 done头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv1done']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # icmpv6 mldv1done头部\n    edit_header_icmpv6_mldv1_done(Stream=stream, Level=0,\n                          Type='132',MaxRespDelay='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.maxRespDelay',\n                                               Value='10', MaxValue='10')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.type',\n                                               Value='132',\n                                               MaxValue='132')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_mldv1_done:修改测试仪表流量模板中Icmpv6 Mldv1 Done报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量流，设置固定帧长256字节。\",\n  \"子任务4\": \"为流量流创建三层报文头部：EthernetII、IPv6和mldv1done。\",\n  \"子任务5\": \"修改mldv1done报文头部参数：Type=132, MaxRespDelay=10, MulticastAddress=FF1E::1。\",\n  \"子任务6\": \"在Port_2上创建三个PDU匹配模式：分别验证maxRespDelay=10、multicastAddress=FF1E::1和type=132。\",\n  \"子任务7\": \"在Port_2上配置报文过滤逻辑表达式（三个PDU模式的逻辑与组合）。\",\n  \"子任务8\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务9\": \"设置Port_1的发送模式为突发包，突发包数量100。\",\n  \"子任务10\": \"保存当前测试配置文件。\",\n  \"子任务11\": \"启动Port_2的抓包功能。\",\n  \"子任务12\": \"开始发送流量流。\",\n  \"子任务13\": \"等待10秒确保流量发送完成。\",\n  \"子任务14\": \"停止流量发送。\",\n  \"子任务15\": \"停止抓包。\",\n  \"子任务16\": \"等待3秒确保数据收集完成。\",\n  \"子任务17\": \"下载Port_2捕获的报文数据。\",\n  \"子任务18\": \"获取流量流的StreamBlockStats统计结果。\",\n  \"子任务19\": \"验证统计结果中TxStreamFrames等于RxStreamFrames。\",\n  \"子任务20\": \"释放所有预约端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv1 done报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv1 done头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv1done']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # icmpv6 mldv1done头部\n    edit_header_icmpv6_mldv1_done(Stream=stream, Level=0,\n                          Type='132',MaxRespDelay='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.maxRespDelay',\n                                               Value='10', MaxValue='10')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.type',\n                                               Value='132',\n                                               MaxValue='132')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_mldv1_done:修改测试仪表流量模板中Icmpv6 Mldv1 Done报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ethernet8023.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.3头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['8023'])\n\n    # 修改802.3头部\n    attr = edit_header_8023(Stream=stream, Level=0,\n                            Oui='102030')\n    edit_modifier(Stream=stream, Attribute=attr['Oui'],\n                  Type='Increment', Count=10, HeaderType='8023')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型（如DarYu）。\",\n  \"子任务2\": \"预约两个自环端口（Port_1和Port_2），指定端口位置。\",\n  \"子任务3\": \"在预约端口（Port_1）上创建流量模板。\",\n  \"子任务4\": \"配置流量模板的帧长度类型为自动（AUTO）。\",\n  \"子任务5\": \"为流量模板添加802.3报文头部。\",\n  \"子任务6\": \"修改802.3头部指定字段（如OUI），并配置字段跳变规则（递增类型和步长）。\",\n  \"子任务7\": \"订阅流模板块统计（StreamBlockStats）。\",\n  \"子任务8\": \"配置端口发送模式为突发包（BURST），指定突发包数量。\",\n  \"子任务9\": \"保存当前测试配置到文件。\",\n  \"子任务10\": \"开始发送所有流量。\",\n  \"子任务11\": \"等待流量停止发送。\",\n  \"子任务12\": \"等待至少3秒确保统计结果稳定。\",\n  \"子任务13\": \"获取流模板块统计信息。\",\n  \"子任务14\": \"验证流量模板的发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.3头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['8023'])\n\n    # 修改802.3头部\n    attr = edit_header_8023(Stream=stream, Level=0,\n                            Oui='102030')\n    edit_modifier(Stream=stream, Attribute=attr['Oui'],\n                  Type='Increment', Count=10, HeaderType='8023')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2HelloInstance.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 hello报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ospfv2 hello头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2hello']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 hello头部\n    header = edit_header_ospfv2_hello(Stream=stream, Level=0,\n                                      RouterID='2.2.2.2', AuthType='MD5',\n                                      NetworkMask='255.255.255.0',\n                                      Neighbors=['1.1.1.1', '2.2.2.2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2hello',\n                  Attribute=header['NetworkMask'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2hello',\n                  Attribute=header['Neighbors: 2.2.2.2'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.networkMask',\n                                               Value='255.255.255.0', MaxValue='255.255.255.0')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.ospfHeader.routerID',\n                                               Value='2.2.2.2',\n                                               MaxValue='2.2.2.2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.routerDeadInterval',\n                                               Value='50',\n                                               MaxValue='50')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_hello:修改测试仪表流量模板中OSPFv2 Hello报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型为DarYu。\",\n  \"子任务2\": \"预约两个自环端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量StreamTemplate_1，设置固定帧长为256字节。\",\n  \"子任务4\": \"为StreamTemplate_1创建报文头部：EthernetII、IPv4、ospfv2hello三层协议。\",\n  \"子任务5\": \"修改StreamTemplate_1的OSPFv2 Hello头部：设置RouterID=2.2.2.2、AuthType=MD5、NetworkMask=255.255.255.0、Neighbors=[1.1.1.1,2.2.2.2]。\",\n  \"子任务6\": \"配置NetworkMask字段的跳变规则：类型为Increment，计数10次，步长2。\",\n  \"子任务7\": \"配置Neighbors字段的跳变规则：类型为Increment，计数10次，步长2。\",\n  \"子任务8\": \"在Port_2上创建三个PDU Pattern：匹配networkMask=255.255.255.0、routerID=2.2.2.2、routerDeadInterval=50。\",\n  \"子任务9\": \"在Port_2上设置抓包过滤表达式：组合三个PDU Pattern的逻辑与(&&)条件。\",\n  \"子任务10\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务11\": \"设置Port_1发送模式为BURST突发包，突发包数量为100。\",\n  \"子任务12\": \"保存当前测试配置文件。\",\n  \"子任务13\": \"启动Port_2抓包功能。\",\n  \"子任务14\": \"开始发送Port_1上的所有流量。\",\n  \"子任务15\": \"等待10秒确保流量收发完成。\",\n  \"子任务16\": \"停止Port_1流量发送。\",\n  \"子任务17\": \"停止Port_2抓包功能。\",\n  \"子任务18\": \"下载Port_2捕获的报文数据。\",\n  \"子任务19\": \"获取StreamTemplate_1的流统计信息：TxStreamFrames和RxStreamFrames。\",\n  \"子任务20\": \"验证TxStreamFrames是否等于RxStreamFrames。\",\n  \"子任务21\": \"释放Port_1和Port_2端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 hello报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ospfv2 hello头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2hello']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 hello头部\n    header = edit_header_ospfv2_hello(Stream=stream, Level=0,\n                                      RouterID='2.2.2.2', AuthType='MD5',\n                                      NetworkMask='255.255.255.0',\n                                      Neighbors=['1.1.1.1', '2.2.2.2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2hello',\n                  Attribute=header['NetworkMask'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2hello',\n                  Attribute=header['Neighbors: 2.2.2.2'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.networkMask',\n                                               Value='255.255.255.0', MaxValue='255.255.255.0')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.ospfHeader.routerID',\n                                               Value='2.2.2.2',\n                                               MaxValue='2.2.2.2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.routerDeadInterval',\n                                               Value='50',\n                                               MaxValue='50')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_hello:修改测试仪表流量模板中OSPFv2 Hello报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Tcp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发tcp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的tcp头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ipv4', 'tcp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改vlan头部\n    header = edit_header_tcp(Stream=stream, Level=0,\n                             SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Level=0, HeaderType='tcp',\n                  Attribute=header['SourcePort'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='tcp_1.destPort',\n                                               Value='2000', MaxValue='2000')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_tcp:修改测试仪表流量模板中TCP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型（如DarYu）。\",\n  \"子任务2\": \"预约两个自环端口（Port_1和Port_2），获取端口对象。\",\n  \"子任务3\": \"创建流量模板（StreamTemplate_1），指定绑定端口和固定帧长度（256字节）。\",\n  \"子任务4\": \"创建流量报文头部，指定头部协议栈（EthernetII/ipv4/tcp）。\",\n  \"子任务5\": \"修改流量模板的TCP头部内容，设置源端口和目的端口（如1000/2000）。\",\n  \"子任务6\": \"修改流量模板的跳变域，设置TCP源端口字段的递增规则（步长2，计数10）。\",\n  \"子任务7\": \"在抓包端口创建PDU匹配模式，指定过滤字段（tcp.destPort=2000）。\",\n  \"子任务8\": \"配置抓包端口的报文过滤逻辑表达式，应用PDU匹配模式。\",\n  \"子任务9\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务10\": \"设置流量发送端口负载模式为突发包（BURST），指定突发包数量（100）。\",\n  \"子任务11\": \"保存当前测试配置到文件。\",\n  \"子任务12\": \"启动抓包端口的数据包捕获。\",\n  \"子任务13\": \"开始发送流量。\",\n  \"子任务14\": \"等待指定时间（10秒）。\",\n  \"子任务15\": \"停止流量发送。\",\n  \"子任务16\": \"停止抓包端口的数据包捕获。\",\n  \"子任务17\": \"下载抓包端口捕获的数据包文件到本地。\",\n  \"子任务18\": \"获取流量模板的StreamBlockStats统计结果。\",\n  \"子任务19\": \"验证统计结果中发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\",\n  \"子任务20\": \"释放预约的测试仪表端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发tcp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的tcp头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ipv4', 'tcp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改vlan头部\n    header = edit_header_tcp(Stream=stream, Level=0,\n                             SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Level=0, HeaderType='tcp',\n                  Attribute=header['SourcePort'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='tcp_1.destPort',\n                                               Value='2000', MaxValue='2000')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_tcp:修改测试仪表流量模板中TCP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4TimeStampRequest.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 time stamp request报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 time stamp request头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimestampRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改TimestampRequest头部\n    edit_header_icmp_time_stamp_request(Stream=stream, Level=0,\n                          Identifier='100', SequenceNumber='200',\n                          OriginateTimestamp='111', ReceiveTimestamp='222', TransmitTimestamp='333')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampRequest_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampRequest_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_time_stamp_request:修改测试仪表流量模板中Icmp Time Stamp Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约两个自环端口，指定端口位置参数。\",\n  \"子任务3\": \"在第一个端口上创建流量流，设置固定帧长为256字节。\",\n  \"子任务4\": \"配置流量报文头部结构，依次包含EthernetII、IPv4和TimestampRequest协议层。\",\n  \"子任务5\": \"修改ICMP时间戳请求头部参数，包括标识符、序列号、原始/接收/传输时间戳值。\",\n  \"子任务6\": \"在第二个端口创建PDU匹配模式1，基于时间戳标识符字段'100'设置过滤条件。\",\n  \"子任务7\": \"在第二个端口创建PDU匹配模式2，基于时间戳序列号字段'200'设置过滤条件。\",\n  \"子任务8\": \"配置端口抓包过滤规则，将两个PDU模式组合为逻辑与表达式。\",\n  \"子任务9\": \"订阅流模板块统计视图用于结果收集。\",\n  \"子任务10\": \"设置第一个端口发送模式为突发包，指定突发包数量为100。\",\n  \"子任务11\": \"保存当前测试配置文件到指定路径。\",\n  \"子任务12\": \"启动第二个端口的数据包捕获功能。\",\n  \"子任务13\": \"开始发送第一个端口的流量流。\",\n  \"子任务14\": \"等待10秒使流量充分发送。\",\n  \"子任务15\": \"停止所有流量发送。\",\n  \"子任务16\": \"停止端口数据包捕获。\",\n  \"子任务17\": \"下载捕获的数据包文件到本地存储路径。\",\n  \"子任务18\": \"获取流模板块统计结果数据。\",\n  \"子任务19\": \"验证发送帧数(TxStreamFrames)等于接收帧数(RxStreamFrames)。\",\n  \"子任务20\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 time stamp request报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 time stamp request头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimestampRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改TimestampRequest头部\n    edit_header_icmp_time_stamp_request(Stream=stream, Level=0,\n                          Identifier='100', SequenceNumber='200',\n                          OriginateTimestamp='111', ReceiveTimestamp='222', TransmitTimestamp='333')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampRequest_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampRequest_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_time_stamp_request:修改测试仪表流量模板中Icmp Time Stamp Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ripv1.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发Ripv1报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的Ripv1头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripv1']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripv1(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripv1', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripv1_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripv1_entry(Stream=stream, Level=0, Index=0, Ipaddr='192.168.0.11', Afi=1, Reserved=1, Reserved1=1, Reserved2=1, Metric=1)\n    edit_header_ripv1_entry(Stream=stream, Level=0, Index=1, Ipaddr='192.168.0.12', Afi=2, Reserved=2, Reserved1=2, Reserved2=2, Metric=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试平台为DarYu。\",\n  \"子任务2\": \"预约两个指定位置的端口Port_1和Port_2。\",\n  \"子任务3\": \"在Port_1上创建流量StreamTemplate_1，设置固定帧长为256字节。\",\n  \"子任务4\": \"为流量创建三层报文头部：EthernetII、IPv4和Ripv1。\",\n  \"子任务5\": \"编辑Ripv1头部字段：设置Level=0，Command=2，Version=1，Reserved=2。\",\n  \"子任务6\": \"配置Ripv1头部的Reserved字段为增量跳变模式，跳变次数为3。\",\n  \"子任务7\": \"在Ripv1头部插入两个条目。\",\n  \"子任务8\": \"编辑第一个条目：设置IP地址为192.168.0.11，Afi=1，Metric=1。\",\n  \"子任务9\": \"编辑第二个条目：设置IP地址为192.168.0.12，Afi=2，Metric=2。\",\n  \"子任务10\": \"在Port_2创建PDU模式1：匹配Ripv1头部的Reserved字段（值范围1-2）。\",\n  \"子任务11\": \"在Port_2创建PDU模式2：匹配Ripv1头部的Version字段（固定值1）。\",\n  \"子任务12\": \"在Port_2设置抓包过滤表达式：组合PDU模式1和PDU模式2的逻辑与条件。\",\n  \"子任务13\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务14\": \"配置Port_1的发送模式为BURST，设置突发包数量为100。\",\n  \"子任务15\": \"保存当前测试配置文件。\",\n  \"子任务16\": \"启动Port_2的抓包功能。\",\n  \"子任务17\": \"在Port_1开始发送流量。\",\n  \"子任务18\": \"等待10秒传输时间。\",\n  \"子任务19\": \"停止Port_1的流量发送。\",\n  \"子任务20\": \"停止Port_2的抓包功能。\",\n  \"子任务21\": \"下载Port_2捕获的报文数据。\",\n  \"子任务22\": \"获取StreamTemplate_1的流量统计结果（TxStreamFrames和RxStreamFrames）。\",\n  \"子任务23\": \"验证TxStreamFrames与RxStreamFrames是否相等。\",\n  \"子任务24\": \"释放所有预约的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发Ripv1报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的Ripv1头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripv1']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripv1(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripv1', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripv1_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripv1_entry(Stream=stream, Level=0, Index=0, Ipaddr='192.168.0.11', Afi=1, Reserved=1, Reserved1=1, Reserved2=1, Metric=1)\n    edit_header_ripv1_entry(Stream=stream, Level=0, Index=1, Ipaddr='192.168.0.12', Afi=2, Reserved=2, Reserved1=2, Reserved2=2, Metric=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/LoadProfile/EditLoadProfile_BaseOnStream_DarYu.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Stream负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约4个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Stream,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\n\nProduct = 'DarYu'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'daryu':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Stream,  传输模式：Continuous, （突发报文数：10, 突发间隔：100, 突发间隔单位: ns）\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               BurstSize=10,\n                               InterFrameGap=100,\n                               InterFrameGapUnit='NS')\n        # 创建流量\n        stream = add_stream(Ports=Ports[0], FixedLength=256)\n        # 负载单位：Percent(%) 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='PERCENT', Rate=5)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Stream, 传输模式：Burst, （（突发报文数：15, 突发间隔：110, 突发间隔单位: us , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=110,\n                               InterFrameGapUnit='US',\n                               BurstCount=10)\n        # 创建流量\n        stream = add_stream(Ports=Ports[1], FixedLength=256)\n        # 负载单位：Frames per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='FRAME_PER_SEC', Rate=10)\n        \n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Stream, 传输模式：Time, （突发报文数：20, 突发间隔：120, 突发间隔单位: ms, 发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"TIME\",\n                               BurstSize=15,\n                               InterFrameGap=120,\n                               InterFrameGapUnit='MS',\n                               Seconds=15)\n        # 创建流量\n        stream = add_stream(Ports=Ports[2], FixedLength=256)\n        # 负载单位：Byte per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='BYTE_PER_SEC', Rate=15)\n        \n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Stream, 传输模式：Step, （突发报文数：25, 突发间隔：130, 突发间隔单位: sec, 发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"STEP\",\n                               BurstSize=20,\n                               InterFrameGap=130,\n                               InterFrameGapUnit='SEC',\n                               Frames=20)\n        # 创建流量\n        stream = add_stream(Ports=Ports[3], FixedLength=256)\n        # 负载单位：Line Bits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='LINEBIT_PER_SEC', Rate=20)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "add_stream:测试仪表创建流量"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表型号为DarYu（使用init_tester函数）\",\n  \"子任务2\": \"预约4个指定的离线测试端口（使用reserve_port函数）\",\n  \"子任务3\": \"为每个端口配置负载模式为STREAM_BASE，并设置传输模式及关联参数（使用edit_port_load_profile函数）\",\n  \"子任务4\": \"验证所有端口的负载配置参数设置成功（通过检查函数执行状态和异常捕获机制）\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Stream负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约4个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Stream,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\n\nProduct = 'DarYu'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'daryu':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Stream,  传输模式：Continuous, （突发报文数：10, 突发间隔：100, 突发间隔单位: ns）\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               BurstSize=10,\n                               InterFrameGap=100,\n                               InterFrameGapUnit='NS')\n        # 创建流量\n        stream = add_stream(Ports=Ports[0], FixedLength=256)\n        # 负载单位：Percent(%) 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='PERCENT', Rate=5)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Stream, 传输模式：Burst, （（突发报文数：15, 突发间隔：110, 突发间隔单位: us , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=110,\n                               InterFrameGapUnit='US',\n                               BurstCount=10)\n        # 创建流量\n        stream = add_stream(Ports=Ports[1], FixedLength=256)\n        # 负载单位：Frames per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='FRAME_PER_SEC', Rate=10)\n        \n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Stream, 传输模式：Time, （突发报文数：20, 突发间隔：120, 突发间隔单位: ms, 发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"TIME\",\n                               BurstSize=15,\n                               InterFrameGap=120,\n                               InterFrameGapUnit='MS',\n                               Seconds=15)\n        # 创建流量\n        stream = add_stream(Ports=Ports[2], FixedLength=256)\n        # 负载单位：Byte per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='BYTE_PER_SEC', Rate=15)\n        \n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Stream, 传输模式：Step, （突发报文数：25, 突发间隔：130, 突发间隔单位: sec, 发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"STEP\",\n                               BurstSize=20,\n                               InterFrameGap=130,\n                               InterFrameGapUnit='SEC',\n                               Frames=20)\n        # 创建流量\n        stream = add_stream(Ports=Ports[3], FixedLength=256)\n        # 负载单位：Line Bits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='LINEBIT_PER_SEC', Rate=20)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nadd_stream:测试仪表创建流量\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/LoadProfile/EditLoadProfile_BaseOnPort_DarYu.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Port负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约4个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Port,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\n\nProduct = 'DarYu'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'daryu':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Port, （端口负载：15, 负载单位：Percent(%)） 传输模式：Continuous, （突发报文数：10, 突发间隔：100, 突发间隔单位: ns）\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='PORT_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               BurstSize=10,\n                               InterFrameGap=100,\n                               InterFrameGapUnit='NS',\n                               Rate=15,\n                               Unit='PERCENT',)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Port （端口负载：20, 负载单位：Inter Frame Gap(ns)）, 传输模式：Burst, （突发报文数：15, 突发间隔：110, 突发间隔单位: us , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='PORT_BASE',\n                               Rate=20,\n                               Unit='NS',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=110,\n                               InterFrameGapUnit='US',\n                               BurstCount=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Port, （端口负载：25, 负载单位：Inter Frame Gap(byte)） 传输模式：Time, （突发报文数：20, 突发间隔：120, 突发间隔单位: ms, 发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='PORT_BASE',\n                               Rate=25,\n                               Unit='INTER_FRAME_GAP_BYTE',\n                               TransmitMode=\"TIME\",\n                               BurstSize=15,\n                               InterFrameGap=120,\n                               InterFrameGapUnit='MS',\n                               Seconds=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Port, （端口负载：30, 负载单位：Frames per Second） 传输模式：Step, （突发报文数：25, 突发间隔：130, 突发间隔单位: sec, 发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='PORT_BASE',\n                               Rate=30,\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               BurstSize=20,\n                               InterFrameGap=130,\n                               InterFrameGapUnit='SEC',\n                               Frames=20)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为 'DarYu' 产品类型。\",\n  \"子任务2\": \"预约四个指定位置的离线端口，启用调试模式。\",\n  \"子任务3\": \"对端口1设置Base On Port负载配置：传输模式为Continuous，负载率15%（单位Percent），突发报文数10，帧间隔100ns。\",\n  \"子任务4\": \"对端口2设置Base On Port负载配置：传输模式为Burst，负载率20（单位ns），突发报文数15，帧间隔110us，突发次数10。\",\n  \"子任务5\": \"对端口3设置Base On Port负载配置：传输模式为Time，负载率25（单位Inter Frame Gap(byte)），突发报文数15，帧间隔120ms，发送时间15秒。\",\n  \"子任务6\": \"对端口4设置Base On Port负载配置：传输模式为Step，负载率30（单位Frames per Second），突发报文数20，帧间隔130秒，发送帧数20。\",\n  \"子任务7\": \"将当前测试配置保存为.xcfg格式文件，路径基于当前脚本位置生成。\",\n  \"子任务8\": \"验证所有端口负载配置是否设置成功，捕获并输出异常信息，最终返回测试结果状态。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Port负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约4个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Port,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\n\nProduct = 'DarYu'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'daryu':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Port, （端口负载：15, 负载单位：Percent(%)） 传输模式：Continuous, （突发报文数：10, 突发间隔：100, 突发间隔单位: ns）\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='PORT_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               BurstSize=10,\n                               InterFrameGap=100,\n                               InterFrameGapUnit='NS',\n                               Rate=15,\n                               Unit='PERCENT',)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Port （端口负载：20, 负载单位：Inter Frame Gap(ns)）, 传输模式：Burst, （突发报文数：15, 突发间隔：110, 突发间隔单位: us , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='PORT_BASE',\n                               Rate=20,\n                               Unit='NS',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=110,\n                               InterFrameGapUnit='US',\n                               BurstCount=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Port, （端口负载：25, 负载单位：Inter Frame Gap(byte)） 传输模式：Time, （突发报文数：20, 突发间隔：120, 突发间隔单位: ms, 发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='PORT_BASE',\n                               Rate=25,\n                               Unit='INTER_FRAME_GAP_BYTE',\n                               TransmitMode=\"TIME\",\n                               BurstSize=15,\n                               InterFrameGap=120,\n                               InterFrameGapUnit='MS',\n                               Seconds=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Port, （端口负载：30, 负载单位：Frames per Second） 传输模式：Step, （突发报文数：25, 突发间隔：130, 突发间隔单位: sec, 发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='PORT_BASE',\n                               Rate=30,\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               BurstSize=20,\n                               InterFrameGap=130,\n                               InterFrameGapUnit='SEC',\n                               Frames=20)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/LoadProfile/EditLoadProfile_BaseOnStream_BigTao.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Stream负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约6个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Stream,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\n\nProduct = 'BigTao'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n    '//10.0.11.191/1/5',\n    '//10.0.11.191/1/6',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'bigtao':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Continuous,\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               LoadMode='FRAME_PER_SEC')\n        # 创建流量\n        stream = add_stream(Ports=Ports[0], FixedLength=256)\n        # 负载单位：Percent(%) 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='PERCENT', Rate=5)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Stream （调速模式：Byte per Second）, 传输模式：Burst, （突发报文数：15, 突发间隔：2, 突发间隔单位: ms , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='BYTE_PER_SEC',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=2,\n                               InterFrameGapUnit='MS',\n                               BurstCount=10)\n        # 创建流量\n        stream = add_stream(Ports=Ports[1], FixedLength=256)\n        # 负载单位：Frames per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='FRAME_PER_SEC', Rate=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Time, （发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"TIME\",\n                               Seconds=99)\n        # 创建流量\n        stream = add_stream(Ports=Ports[2], FixedLength=256)\n        # 负载单位：Byte per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='BYTE_PER_SEC', Rate=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Step, （发送帧数：15）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               Frames=110)\n        # 创建流量\n        stream = add_stream(Ports=Ports[3], FixedLength=256)\n        # 负载单位：Line Bits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='LINEBIT_PER_SEC', Rate=20)\n\n        # =============== *设置模式5* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：On Stream, 流传输模式：Continuous\n        edit_port_load_profile(Ports=Ports[4],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[4], FixedLength=256)\n        # 负载单位：Line KBits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='KLINEBIT_PER_SEC', Rate=25)\n\n        # =============== *设置模式6* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：On Stream, 流传输模式：Burst （突发间隔单位：MS, 突发次数：3, 突发间隔：4, 突发数量：10）\n        edit_port_load_profile(Ports=Ports[5],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[5], FixedLength=256)\n        # 负载单位：Line KBits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='MLINEBIT_PER_SEC', Rate=30, StreamTransmitMode='BURST', BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "add_stream:测试仪表创建流量"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'BigTao'。\",\n  \"子任务2\": \"预约6个离线端口，使用指定位置列表进行端口预约。\",\n  \"子任务3\": \"设置端口0的负载模式：负载类型为Base On Stream，传输模式为Continuous，调速模式为Frames per Second。\",\n  \"子任务4\": \"在端口0上创建固定长度256字节的流量流。\",\n  \"子任务5\": \"设置端口0流量的负载配置：单位Percent(%)，速率5。\",\n  \"子任务6\": \"设置端口1的负载模式：负载类型为Base On Stream，调速模式为Byte per Second，传输模式为Burst，突发报文数15，突发间隔2ms，突发次数10。\",\n  \"子任务7\": \"在端口1上创建固定长度256字节的流量流。\",\n  \"子任务8\": \"设置端口1流量的负载配置：单位Frames per Second，速率10。\",\n  \"子任务9\": \"设置端口2的负载模式：负载类型为Base On Stream，调速模式为Frames per Second，传输模式为Time，发送时间15秒。\",\n  \"子任务10\": \"在端口2上创建固定长度256字节的流量流。\",\n  \"子任务11\": \"设置端口2流量的负载配置：单位Byte per Second，速率15。\",\n  \"子任务12\": \"设置端口3的负载模式：负载类型为Base On Stream，调速模式为Frames per Second，传输模式为Step，发送帧数110。\",\n  \"子任务13\": \"在端口3上创建固定长度256字节的流量流。\",\n  \"子任务14\": \"设置端口3流量的负载配置：单位Line Bits per Second，速率20。\",\n  \"子任务15\": \"设置端口4的负载模式：负载类型为Base On Stream，调速模式为Frames per Second，传输模式为On Stream。\",\n  \"子任务16\": \"在端口4上创建固定长度256字节的流量流。\",\n  \"子任务17\": \"设置端口4流量的负载配置：单位Line KBits per Second，速率25。\",\n  \"子任务18\": \"设置端口5的负载模式：负载类型为Base On Stream，调速模式为Frames per Second，传输模式为On Stream。\",\n  \"子任务19\": \"在端口5上创建固定长度256字节的流量流。\",\n  \"子任务20\": \"设置端口5流量的负载配置：单位Line MBits per Second，速率30，流传输模式为Burst，突发间隔单位MS，突发次数3，突发间隔4，突发数量10。\",\n  \"子任务21\": \"保存当前测试配置文件至指定路径。\",\n  \"子任务22\": \"验证所有端口的负载配置参数是否与设置值一致，包括负载类型、传输模式、调速模式及相关参数。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Stream负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约6个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Stream,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\n\nProduct = 'BigTao'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n    '//10.0.11.191/1/5',\n    '//10.0.11.191/1/6',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'bigtao':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Continuous,\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               LoadMode='FRAME_PER_SEC')\n        # 创建流量\n        stream = add_stream(Ports=Ports[0], FixedLength=256)\n        # 负载单位：Percent(%) 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='PERCENT', Rate=5)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Stream （调速模式：Byte per Second）, 传输模式：Burst, （突发报文数：15, 突发间隔：2, 突发间隔单位: ms , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='BYTE_PER_SEC',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=2,\n                               InterFrameGapUnit='MS',\n                               BurstCount=10)\n        # 创建流量\n        stream = add_stream(Ports=Ports[1], FixedLength=256)\n        # 负载单位：Frames per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='FRAME_PER_SEC', Rate=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Time, （发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"TIME\",\n                               Seconds=99)\n        # 创建流量\n        stream = add_stream(Ports=Ports[2], FixedLength=256)\n        # 负载单位：Byte per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='BYTE_PER_SEC', Rate=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Step, （发送帧数：15）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               Frames=110)\n        # 创建流量\n        stream = add_stream(Ports=Ports[3], FixedLength=256)\n        # 负载单位：Line Bits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='LINEBIT_PER_SEC', Rate=20)\n\n        # =============== *设置模式5* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：On Stream, 流传输模式：Continuous\n        edit_port_load_profile(Ports=Ports[4],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[4], FixedLength=256)\n        # 负载单位：Line KBits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='KLINEBIT_PER_SEC', Rate=25)\n\n        # =============== *设置模式6* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：On Stream, 流传输模式：Burst （突发间隔单位：MS, 突发次数：3, 突发间隔：4, 突发数量：10）\n        edit_port_load_profile(Ports=Ports[5],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[5], FixedLength=256)\n        # 负载单位：Line KBits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='MLINEBIT_PER_SEC', Rate=30, StreamTransmitMode='BURST', BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nadd_stream:测试仪表创建流量\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl2psnpHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2psnpHeader'])\n\n    header = edit_header_isis_psnp(Stream=stream,\n                                   SourceId='102030405060',\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2psnpHeader', Attribute=header['SourceId'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsLspEntries', LspEntries=2)\n\n    edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l2psnpHeader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型（如DarYu）。\",\n  \"子任务2\": \"预约两个端口（Port_1和Port_2），指定端口位置信息。\",\n  \"子任务3\": \"在Port_1端口创建流量模板StreamTemplate_1。\",\n  \"子任务4\": \"配置流量模板的报文头部，包含EthernetII和ISIS PSNP头部类型。\",\n  \"子任务5\": \"修改ISIS PSNP头部内容：设置源ID、CSNP数据TLV选项头（含IsIsLspEntries和AuthenticationInfo）。\",\n  \"子任务6\": \"为ISIS头部字段配置跳变规则：指定递增类型、起始值和变化次数。\",\n  \"子任务7\": \"修改ISIS TLV头部：设置LSP条目数量为2。\",\n  \"子任务8\": \"配置ISIS LSP条目参数：指定剩余时间值为10。\",\n  \"子任务9\": \"订阅统计视图：包含流模板块统计（StreamBlockStats）和端口统计（PortStats）。\",\n  \"子任务10\": \"设置端口发送模式：配置Port_1为突发包模式，指定突发包数量（如100）。\",\n  \"子任务11\": \"启动流量发送：开始发送所有配置的流量。\",\n  \"子任务12\": \"等待流量发送完成：监控流状态直至停止，并额外等待3秒确保统计稳定。\",\n  \"子任务13\": \"获取流模板块统计结果：针对StreamTemplate_1采集TxStreamFrames和RxStreamFrames。\",\n  \"子任务14\": \"验证统计结果：确认TxStreamFrames等于RxStreamFrames且等于配置的突发包数量。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2psnpHeader'])\n\n    header = edit_header_isis_psnp(Stream=stream,\n                                   SourceId='102030405060',\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2psnpHeader', Attribute=header['SourceId'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsLspEntries', LspEntries=2)\n\n    edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l2psnpHeader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2DatabaseDescription.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 database description报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ospfv2 database description头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2databasedescription']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 database description头部\n    header = edit_header_ospfv2_dd(Stream=stream, Level=0,\n                                   PacketOptionsReserved7=1,\n                                   RouterID='2.2.2.2', AuthType='SimplePassword',\n                                   AuthValue1=123, AuthValue2=456,\n                                   PacketOptionsDcBit=1, DdOptionsReserved3=1,\n                                   SequenceNumber=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['RouterID'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['PacketOptionsReserved7'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['AuthValue1'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['DdOptionsReserved3'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    lsa = edit_header_ospfv2_lsa(Stream=stream, HeaderType='Ospfv2DatabaseDescription',\n                                 LsaAge=10, Reserved7=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=lsa['LsaAge'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=lsa['Reserved7'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.ddOptions.dcBit',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.ospfHeader.authSelect.hdrAuthSelectNone.authValue2',\n                                               Value='456',\n                                               MaxValue='456')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.sequenceNumber',\n                                               Value='10',\n                                               MaxValue='10')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_dd:修改测试仪表流量模板中OSPFv2 Database Description报文头部内容",
      "edit_header_ospfv2_lsa:修改测试仪表流量模板中OSPFv2报文中Lsa头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型（如DarYu）。\",\n  \"子任务2\": \"预约两个自环端口，指定端口物理位置。\",\n  \"子任务3\": \"在预约端口上创建流量，设置固定帧长度（如256字节）。\",\n  \"子任务4\": \"为流量创建报文头部，指定头部类型（EthernetII/IPv4/OSPFv2 Database Description）。\",\n  \"子任务5\": \"修改流量的OSPFv2 Database Description头部字段（RouterID/AuthType/AuthValue等）并配置字段跳变规则（递增类型/步长/计数）。\",\n  \"子任务6\": \"在接收端口创建PDU匹配模式，指定OSPFv2字段过滤条件（dcBit/authValue2/sequenceNumber等）。\",\n  \"子任务7\": \"在接收端口设置报文过滤逻辑表达式（组合多个PDU匹配模式）。\",\n  \"子任务8\": \"订阅StreamBlockStats统计视图。\",\n  \"子任务9\": \"设置发送端口负载模式为突发包（BURST），指定突发包数量。\",\n  \"子任务10\": \"启动接收端口抓包。\",\n  \"子任务11\": \"开始发送流量。\",\n  \"子任务12\": \"等待指定时间（如10秒）。\",\n  \"子任务13\": \"停止发送流量。\",\n  \"子任务14\": \"停止抓包。\",\n  \"子任务15\": \"获取流量的StreamBlockStats统计结果（TxStreamFrames/RxStreamFrames）。\",\n  \"子任务16\": \"验证流量统计结果：发送帧数（TxStreamFrames）等于接收帧数（RxStreamFrames）。\",\n  \"子任务17\": \"释放预约端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 database description报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ospfv2 database description头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2databasedescription']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 database description头部\n    header = edit_header_ospfv2_dd(Stream=stream, Level=0,\n                                   PacketOptionsReserved7=1,\n                                   RouterID='2.2.2.2', AuthType='SimplePassword',\n                                   AuthValue1=123, AuthValue2=456,\n                                   PacketOptionsDcBit=1, DdOptionsReserved3=1,\n                                   SequenceNumber=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['RouterID'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['PacketOptionsReserved7'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['AuthValue1'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['DdOptionsReserved3'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    lsa = edit_header_ospfv2_lsa(Stream=stream, HeaderType='Ospfv2DatabaseDescription',\n                                 LsaAge=10, Reserved7=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=lsa['LsaAge'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=lsa['Reserved7'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.ddOptions.dcBit',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.ospfHeader.authSelect.hdrAuthSelectNone.authValue2',\n                                               Value='456',\n                                               MaxValue='456')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.sequenceNumber',\n                                               Value='10',\n                                               MaxValue='10')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_dd:修改测试仪表流量模板中OSPFv2 Database Description报文头部内容;\nedit_header_ospfv2_lsa:修改测试仪表流量模板中OSPFv2报文中Lsa头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl1lspHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, )\n    edit_stream(Stream=stream, FrameLengthType='Auto')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1lspheader'])\n\n    header = edit_header_isis_lsp(Stream=stream, \n                                  InterRoutingProtocolDiscriminator=10,\n                                  PDULength=20,\n                                  LspisIsTlvOptionSet=['IsIsAreaAddress', 'IsIsReachability', 'ExtendedReachability',\n                                    'IsIsIpInterReachability', 'IsIsProtocolsSupported', 'IsIsIPExternalReachability',\n                                    'IpInterfaceAddress', 'Ipv6InterfaceAddress', 'IsIsIpv6Reachability'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=header['InterRoutingProtocolDiscriminator'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=header['PDULength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsAreaAddress', \n                                      TlvCode=10,\n                                      AreaAddressEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n    entry = edit_header_isis_area_address_entry(Stream=stream, TlvLength=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=entry['TlvLength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsReachability', Index=1,\n                                      VirtualFlag=10,\n                                      MetricEntries=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=tlv['VirtualFlag'],\n                  Type='Increment', Count=10)\n    entry = edit_header_isis_metric_entry(Stream=stream, TlvIndex=1, EntryIndex=1, DefaultMetric=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=entry['DefaultMetric'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ExtendedReachability', Index=2,\n                                IisNeighborSubTlv=['AdGroupSubtlv', 'Ipv4InterfaceAddressSubtlv', 'Ipv4NeighborAddressSubtlv',\n                                      'MaxLinkBandwidthSubtlv', 'ReservableLinkBandwidthSubtlv', 'UnReservedBandwidthSubtlv',\n                                      'InterfaceIpv6Subtlv', 'NeigbhorIpv6Subtlv'])\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='AdGroupSubtlv', TlvIndex=2, SubTlvIndex=0, tlvCode=20)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4InterfaceAddressSubtlv', TlvIndex=2, SubTlvIndex=1, Ipv4InterfaceAddressValue='1.1.1.1')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4NeighborAddressSubtlv', TlvIndex=2, SubTlvIndex=2, Ipv4NeighborAddressValue='2.2.2.2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='MaxLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=3, MaxBandwidthValue=30)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='ReservableLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=4, ReservableLinkBandwidthValue=40)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='UnReservedBandwidthSubtlv', TlvIndex=2, SubTlvIndex=5, ResBandwidth0Value=50)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='InterfaceIpv6Subtlv', TlvIndex=2, SubTlvIndex=6, InterfaceIpv6Value='2022::2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='NeigbhorIpv6Subtlv', TlvIndex=2, SubTlvIndex=7, Neighboripv6Value='2033::3')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsIpInterReachability', Index=3, InternalmetricEntries=1)\n    edit_header_isis_internal_metric_entry(Stream=stream, TlvIndex=3, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IpInterfaceAddress', Index=6, Ipv4InterfaceAddress=['1.1.1.1', '2.2.2.2'])\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Ipv6InterfaceAddress', Index=7, Ipv6InterfaceAddress=['2022::2', '2033::3'])\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    # start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容",
      "edit_header_isis_internal_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容",
      "edit_header_isis_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容",
      "edit_header_isis_sub_tlv:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Sub Tlv内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为'DarYu'。\",\n  \"子任务2\": \"预约两个自环端口，指定端口位置参数。\",\n  \"子任务3\": \"在指定端口上创建流量模板，设置帧长度类型为自动。\",\n  \"子任务4\": \"为流量创建报文头部，包含EthernetII和ISIS L1 LSP头部。\",\n  \"子任务5\": \"修改ISIS LSP头部字段：设置路由协议鉴别符和PDU长度，并配置递增跳变域。\",\n  \"子任务6\": \"修改ISIS TLV头部（AreaAddress类型），设置TLV编码并配置递增跳变域。\",\n  \"子任务7\": \"修改ISIS区域地址条目，设置TLV长度并配置递增跳变域。\",\n  \"子任务8\": \"修改ISIS TLV头部（Reachability类型），设置虚拟标志位并配置递增跳变域。\",\n  \"子任务9\": \"修改ISIS度量条目，设置默认度量值并配置递增跳变域。\",\n  \"子任务10\": \"修改ISIS TLV头部（ExtendedReachability类型），配置多个子TLV参数。\",\n  \"子任务11\": \"修改ISIS TLV头部（IpInterReachability类型），设置内部度量条目。\",\n  \"子任务12\": \"修改ISIS TLV头部（IpInterfaceAddress类型），设置IPv4接口地址。\",\n  \"子任务13\": \"修改ISIS TLV头部（Ipv6InterfaceAddress类型），设置IPv6接口地址。\",\n  \"子任务14\": \"订阅统计视图，包含流模板块统计和端口统计。\",\n  \"子任务15\": \"配置端口负载参数：设置发送模式为突发包，指定突发包数量。\",\n  \"子任务16\": \"保存当前测试配置到文件。\",\n  \"子任务17\": \"启动流量发送。\",\n  \"子任务18\": \"等待流量发送完成。\",\n  \"子任务19\": \"等待3秒确保统计结果稳定。\",\n  \"子任务20\": \"获取流模板块统计信息，记录发送帧数和接收帧数。\",\n  \"子任务21\": \"验证流模板块统计结果：发送帧数等于接收帧数且等于突发包数量。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, )\n    edit_stream(Stream=stream, FrameLengthType='Auto')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1lspheader'])\n\n    header = edit_header_isis_lsp(Stream=stream, \n                                  InterRoutingProtocolDiscriminator=10,\n                                  PDULength=20,\n                                  LspisIsTlvOptionSet=['IsIsAreaAddress', 'IsIsReachability', 'ExtendedReachability',\n                                    'IsIsIpInterReachability', 'IsIsProtocolsSupported', 'IsIsIPExternalReachability',\n                                    'IpInterfaceAddress', 'Ipv6InterfaceAddress', 'IsIsIpv6Reachability'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=header['InterRoutingProtocolDiscriminator'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=header['PDULength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsAreaAddress', \n                                      TlvCode=10,\n                                      AreaAddressEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n    entry = edit_header_isis_area_address_entry(Stream=stream, TlvLength=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=entry['TlvLength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsReachability', Index=1,\n                                      VirtualFlag=10,\n                                      MetricEntries=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=tlv['VirtualFlag'],\n                  Type='Increment', Count=10)\n    entry = edit_header_isis_metric_entry(Stream=stream, TlvIndex=1, EntryIndex=1, DefaultMetric=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=entry['DefaultMetric'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ExtendedReachability', Index=2,\n                                IisNeighborSubTlv=['AdGroupSubtlv', 'Ipv4InterfaceAddressSubtlv', 'Ipv4NeighborAddressSubtlv',\n                                      'MaxLinkBandwidthSubtlv', 'ReservableLinkBandwidthSubtlv', 'UnReservedBandwidthSubtlv',\n                                      'InterfaceIpv6Subtlv', 'NeigbhorIpv6Subtlv'])\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='AdGroupSubtlv', TlvIndex=2, SubTlvIndex=0, tlvCode=20)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4InterfaceAddressSubtlv', TlvIndex=2, SubTlvIndex=1, Ipv4InterfaceAddressValue='1.1.1.1')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4NeighborAddressSubtlv', TlvIndex=2, SubTlvIndex=2, Ipv4NeighborAddressValue='2.2.2.2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='MaxLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=3, MaxBandwidthValue=30)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='ReservableLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=4, ReservableLinkBandwidthValue=40)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='UnReservedBandwidthSubtlv', TlvIndex=2, SubTlvIndex=5, ResBandwidth0Value=50)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='InterfaceIpv6Subtlv', TlvIndex=2, SubTlvIndex=6, InterfaceIpv6Value='2022::2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='NeigbhorIpv6Subtlv', TlvIndex=2, SubTlvIndex=7, Neighboripv6Value='2033::3')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsIpInterReachability', Index=3, InternalmetricEntries=1)\n    edit_header_isis_internal_metric_entry(Stream=stream, TlvIndex=3, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IpInterfaceAddress', Index=6, Ipv4InterfaceAddress=['1.1.1.1', '2.2.2.2'])\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Ipv6InterfaceAddress', Index=7, Ipv6InterfaceAddress=['2022::2', '2033::3'])\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    # start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容;\nedit_header_isis_internal_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容;\nedit_header_isis_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容;\nedit_header_isis_sub_tlv:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Sub Tlv内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_6/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.6 地址缓存能力\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2889 中规定，将交换机三个端口与测试仪连接，分别为端口 1（测试端口），端口 2（学习端口），端口 3（监视端口），见图 5；\n                   测试步骤2: 测试方法采用 RFC2889 标准测试方法。\n\n Criteria    \t:   预期结果1: 技术要求二层交换机不低于 4k；三层交换机不低于 16k。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressCachingCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    # 提供学习的地址数和地址学习速率\n    edit_benchmark_address_learning_capacity(Config=Config,\n                                             MinAddressCount=cfg['arg']['learning_capacity']['default']['min_address_count']['default'],\n                                             MaxAddressCount=cfg['arg']['learning_capacity']['default']['max_address_count']['default'],\n                                             InitAddressCount=cfg['arg']['learning_capacity']['default']['init_address_count']['default'],\n                                             Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                             AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                             LearningRate=cfg['arg']['learning_capacity']['default']['learning_rate']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_address_learning_capacity:编辑RFC2889测试套件地址容量测试项参数",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试仪的网络连接。\",\n  \"子任务2\": \"预约测试仪端口资源，分配端口1作为测试端口，端口2作为学习端口，端口3作为监视端口。\",\n  \"子任务3\": \"配置测试仪端口参数，确保端口状态符合测试要求。\",\n  \"子任务4\": \"创建RFC2889测试套件，选择地址缓存容量(addressCachingCapacity)测试项。\",\n  \"子任务5\": \"关联测试套件使用的三个端口：测试端口、学习端口、监视端口。\",\n  \"子任务6\": \"在测试端口和学习端口上创建以太网接口。\",\n  \"子任务7\": \"配置测试端口和学习端口的MAC地址参数。\",\n  \"子任务8\": \"获取接口的以太网层对象，为流量配置做准备。\",\n  \"子任务9\": \"创建测试流量流，设置从测试端口到学习端口的单向流量，指定监视端口。\",\n  \"子任务10\": \"配置测试延迟参数：延迟前2秒，延迟后10秒。\",\n  \"子任务11\": \"设置测试试验次数为1次。\",\n  \"子任务12\": \"配置测试帧长度为定制值。\",\n  \"子任务13\": \"配置地址缓存容量参数：最小地址数、最大地址数、初始地址数、分辨率、老化时间和学习速率。\",\n  \"子任务14\": \"生成测试脚本并展开测试套件配置。\",\n  \"子任务15\": \"保存测试配置文件。\",\n  \"子任务16\": \"执行RFC2889测试套件，运行地址缓存容量测试。\",\n  \"子任务17\": \"获取测试结果数据并转换为表格格式。\",\n  \"子任务18\": \"验证测试结果：确认地址缓存容量满足要求（二层交换机≥4k，三层交换机≥16k）。\",\n  \"子任务19\": \"保存测试报告数据。\",\n  \"子任务20\": \"释放测试仪端口资源。\",\n  \"子任务21\": \"关闭测试仪表连接并清理测试环境。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.6 地址缓存能力\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2889 中规定，将交换机三个端口与测试仪连接，分别为端口 1（测试端口），端口 2（学习端口），端口 3（监视端口），见图 5；\n                   测试步骤2: 测试方法采用 RFC2889 标准测试方法。\n\n Criteria    \t:   预期结果1: 技术要求二层交换机不低于 4k；三层交换机不低于 16k。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressCachingCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    # 提供学习的地址数和地址学习速率\n    edit_benchmark_address_learning_capacity(Config=Config,\n                                             MinAddressCount=cfg['arg']['learning_capacity']['default']['min_address_count']['default'],\n                                             MaxAddressCount=cfg['arg']['learning_capacity']['default']['max_address_count']['default'],\n                                             InitAddressCount=cfg['arg']['learning_capacity']['default']['init_address_count']['default'],\n                                             Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                             AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                             LearningRate=cfg['arg']['learning_capacity']['default']['learning_rate']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_address_learning_capacity:编辑RFC2889测试套件地址容量测试项参数;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_9/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.5.9 生成树协议\n\n Step\t\t\t:\t测试步骤1: 将4台交换机按照图9连接，级联口均采用100M光口；\n                   测试步骤2: 整个组网设备间运行标准生成树协议，配置各设备的生成树参数，\n                   测试步骤3: 观察设备能否根据配置的参数修剪环路，完成生成树\n                   测试步骤4: 阻断开设备目前的生成树链路，观察设备是否可自动完成网络拓扑重构；\n                   测试步骤5: 启用所有交换机的RSTP功能\n                   测试步骤6: 将交换机如图9连接；\n                   测试步骤7: 用SmartBits 在任意两台交换机之间加载95Mbps数据流量；\n                   测试步骤8: 拔插环网中的任一链路，查看网络是否可以正常收敛\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95,)\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插链路\n        time.sleep(30)\n\n        # 查看收敛时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxFCSErr = Result['RxFCSErr']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=True)\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表。\",\n  \"子任务2\": \"预约测试仪表的端口。\",\n  \"子任务3\": \"编辑测试仪表端口参数，设置级联口速率为100Mbps以模拟光口连接。\",\n  \"子任务4\": \"导入网络拓扑配置，配置设备运行标准生成树协议并设置生成树参数。\",\n  \"子任务5\": \"等待设备生成树收敛，观察并验证环路修剪完成。\",\n  \"子任务6\": \"阻断开生成树链路：编辑测试仪表指定端口状态为down以模拟链路断开。\",\n  \"子任务7\": \"观察网络拓扑重构：等待后验证连通性恢复。\",\n  \"子任务8\": \"配置设备启用RSTP功能。\",\n  \"子任务9\": \"重新连接设备：编辑测试仪表端口状态为up以恢复连接。\",\n  \"子任务10\": \"编辑测试仪表负载配置文件，设置数据流量速率为95Mbps。\",\n  \"子任务11\": \"创建流量流，定义帧长度为64字节并添加Ethernet和IPv4头部。\",\n  \"子任务12\": \"订阅测试仪表统计视图。\",\n  \"子任务13\": \"启动测试仪表二层学习。\",\n  \"子任务14\": \"开始发送数据流。\",\n  \"子任务15\": \"模拟拔插环网链路：编辑测试仪表指定端口状态为down，等待后编辑为up。\",\n  \"子任务16\": \"获取流模板块统计结果，计算收敛时间并验证Rx帧数等于Tx帧数以指示正常收敛。\",\n  \"子任务17\": \"清除测试仪表统计。\",\n  \"子任务18\": \"释放测试仪表的端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.5.9 生成树协议\n\n Step\t\t\t:\t测试步骤1: 将4台交换机按照图9连接，级联口均采用100M光口；\n                   测试步骤2: 整个组网设备间运行标准生成树协议，配置各设备的生成树参数，\n                   测试步骤3: 观察设备能否根据配置的参数修剪环路，完成生成树\n                   测试步骤4: 阻断开设备目前的生成树链路，观察设备是否可自动完成网络拓扑重构；\n                   测试步骤5: 启用所有交换机的RSTP功能\n                   测试步骤6: 将交换机如图9连接；\n                   测试步骤7: 用SmartBits 在任意两台交换机之间加载95Mbps数据流量；\n                   测试步骤8: 拔插环网中的任一链路，查看网络是否可以正常收敛\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95,)\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插链路\n        time.sleep(30)\n\n        # 查看收敛时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxFCSErr = Result['RxFCSErr']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=True)\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_7/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.7 地址学习速率\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2889 中规定，将交换机三个端口与测试仪连接，分别为端口 1（测试端口），端口 2（学习端口），端口 3（监视端口），见图 5；\n                   测试步骤2: 测试方法采用 RFC2889 标准测试方法。\n\n Criteria    \t:   预期结果1: 技术要求应不低于 1000 帧/s。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressLearningRate'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n\n    # 地址学习速率和地址数量\n    edit_benchmark_address_learning_rate(Config=Config,\n                                         MinRateCount=cfg['arg']['learning_capacity']['default']['min_rate_count']['default'],\n                                         MaxRateCount=cfg['arg']['learning_capacity']['default']['max_rate_count']['default'],\n                                         InitRateCount=cfg['arg']['learning_capacity']['default']['init_rate_count']['default'],\n                                         Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                         AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                         AddressCount=cfg['arg']['learning_capacity']['default']['address_count']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_address_learning_rate:编辑RFC2889测试套件地址容量测试项参数",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试仪的控制连接。\",\n  \"子任务2\": \"预约测试仪的端口1、端口2和端口3资源，对应交换机测试端口、学习端口和监视端口。\",\n  \"子任务3\": \"修改测试仪端口参数（如速率、双工模式）并等待端口链路状态就绪。\",\n  \"子任务4\": \"创建RFC2889测试套件，指定测试类型为地址学习速率(addressLearningRate)。\",\n  \"子任务5\": \"关联测试套件使用的端口：端口1作为测试端口，端口2作为学习端口，端口3作为监视端口。\",\n  \"子任务6\": \"在测试端口（端口1）上创建以太网接口并配置MAC地址。\",\n  \"子任务7\": \"在学习端口（端口2）上创建以太网接口并配置MAC地址。\",\n  \"子任务8\": \"获取测试端口和学习端口接口的以太网层对象。\",\n  \"子任务9\": \"创建测试流量：从测试端口发往学习端口的单向流量，指定监视端口捕获数据。\",\n  \"子任务10\": \"配置测试延迟参数：FIFO类型，延迟前2秒，延迟后10秒。\",\n  \"子任务11\": \"配置测试持续时间：设置试验次数为1次。\",\n  \"子任务12\": \"配置测试帧长：使用自定义帧长参数。\",\n  \"子任务13\": \"配置地址学习速率参数：设置最小速率计数、最大速率计数、初始速率计数、分辨率、老化时间和地址数量。\",\n  \"子任务14\": \"生成测试套件的智能脚本。\",\n  \"子任务15\": \"保存测试配置文件到指定路径。\",\n  \"子任务16\": \"执行测试套件，运行地址学习速率测试。\",\n  \"子任务17\": \"获取测试结果数据，提取地址学习速率指标。\",\n  \"子任务18\": \"验证测试结果：地址学习速率不低于1000帧/秒。\",\n  \"子任务19\": \"释放测试仪端口资源。\",\n  \"子任务20\": \"关闭测试仪表连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.7 地址学习速率\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2889 中规定，将交换机三个端口与测试仪连接，分别为端口 1（测试端口），端口 2（学习端口），端口 3（监视端口），见图 5；\n                   测试步骤2: 测试方法采用 RFC2889 标准测试方法。\n\n Criteria    \t:   预期结果1: 技术要求应不低于 1000 帧/s。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressLearningRate'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n\n    # 地址学习速率和地址数量\n    edit_benchmark_address_learning_rate(Config=Config,\n                                         MinRateCount=cfg['arg']['learning_capacity']['default']['min_rate_count']['default'],\n                                         MaxRateCount=cfg['arg']['learning_capacity']['default']['max_rate_count']['default'],\n                                         InitRateCount=cfg['arg']['learning_capacity']['default']['init_rate_count']['default'],\n                                         Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                         AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                         AddressCount=cfg['arg']['learning_capacity']['default']['address_count']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_address_learning_rate:编辑RFC2889测试套件地址容量测试项参数;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_6/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.6 IGMP-Snooping 组播: 二层交换机应支持 IGMP-Snooping 组播功能\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示，交换机端口为同一VLAN 内的UNTAGGED 端口；\n                   测试步骤2: 端口1 向端口2 发送1 个组的组播流量\n                   测试步骤3: 在被测交换机上禁用IGMP Snooping 功能，观察端口2 流量接收情况；\n                   测试步骤4: 在被测交换机上启用IGMP Snooping 功能，观察端口2 流量接收情况；\n                   测试步骤5: 端口2 使用IGMP 协议V2 加入组播组，观察端口2 流量接收情况；\n                   测试步骤6: 端口2 发送离开组请求，观察端口2 流量接收情况。\n\n Criteria    \t:   预期结果1: 步骤2）在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量；\n                   预期结果2: 步骤3）在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量；\n                   预期结果3: 步骤4）端口2 发送组加入请求后，可接收组播流量；\n                   预期结果4: 步骤5）端口2 发送离开组请求后，不能接收组播流量。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port_1, port_2 = ports\n    # 创建接口\n    interface_1 = create_interface(Port=port_1,Layers=['eth', 'ipv4'])\n    interface_2 = create_interface(Port=port_2,Layers=['eth', 'ipv4'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_2, Version='IGMPV2')\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interface_2)\n\n    # 创建全局组播组\n    multicast_group = create_multicast_group(Start='225.0.1.2',Count=1)\n\n    # 创建组播协议和组播组绑定关系对象\n    memberships = create_memberships(Session=igmp)\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP绑定流\n    src_point = get_layer_from_interfaces(Interfaces=interface_1)\n\n    stream = add_stream(Type='binding', SrcPoints=src_point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        # 获取流量统计结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'RxLossStreamFrames',\n                                                                    'RealtimeLossRate'])\n        if  Result['RxStreamFrames'] > 0  and Result['RxLossStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，没有所有端口都接收到组播流量', step=5, result=False)\n\n        # 被测设备使能igmp snooping\n        cmd_cfg = '_'.join('DeviceA_Step3'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        # 清空统计计数\n        clear_result()\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        printf(message='step3：端口1向端口2发送1个组的组播流量, 在被测交换机上启用IGMP Snooping 功能')\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=False)\n\n        igmp_send_report(Sessions=igmp)\n        time.sleep(3)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=False)\n\n        igmp_send_leave(Sessions=igmp)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if Result['TxStreamFrames'] != Result['RxStreamFrames'] and Result['RxStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "create_igmp:创建IGMP协议会话对象",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并预约端口，确保端口状态就绪。\",\n  \"子任务2\": \"创建网络接口：在端口1和端口2上分别创建以太网和IPv4协议栈的接口。\",\n  \"子任务3\": \"在端口2创建IGMPv2协议会话，并将其绑定到接口。\",\n  \"子任务4\": \"创建全局组播组（起始地址225.0.1.2，数量1）。\",\n  \"子任务5\": \"创建组播成员关系对象，并将组播组绑定到IGMP会话。\",\n  \"子任务6\": \"创建流量流：从端口1接口到组播组的单向组播流量。\",\n  \"子任务7\": \"订阅流模板块统计视图以监控流量。\",\n  \"子任务8\": \"在交换机上执行禁用IGMP Snooping的命令。\",\n  \"子任务9\": \"清除统计计数，启动组播流量发送，持续10秒后停止。\",\n  \"子任务10\": \"获取端口2流量统计结果，验证接收帧数等于发送帧数且丢帧数为0（预期结果1：禁用时所有端口可接收）。\",\n  \"子任务11\": \"在交换机上执行启用IGMP Snooping的命令。\",\n  \"子任务12\": \"启动IGMP协议并等待会话稳定状态。\",\n  \"子任务13\": \"清除统计计数，再次启动组播流量发送，持续10秒后停止。\",\n  \"子任务14\": \"获取端口2流量统计结果，验证接收帧数为0（预期结果2：启用后非成员端口不能接收）。\",\n  \"子任务15\": \"通过IGMP会话发送组加入报告（V2版本）。\",\n  \"子任务16\": \"清除统计计数，启动组播流量发送，持续10秒后停止。\",\n  \"子任务17\": \"获取端口2流量统计结果，验证接收帧数等于发送帧数（预期结果3：加入后成员端口可接收）。\",\n  \"子任务18\": \"通过IGMP会话发送离开组请求。\",\n  \"子任务19\": \"清除统计计数，启动组播流量发送，持续10秒后停止。\",\n  \"子任务20\": \"获取端口2流量统计结果，验证接收帧数为0（预期结果4：离开后成员端口不能接收）。\",\n  \"子任务21\": \"释放测试仪表端口资源并关闭测试进程。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.6 IGMP-Snooping 组播: 二层交换机应支持 IGMP-Snooping 组播功能\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示，交换机端口为同一VLAN 内的UNTAGGED 端口；\n                   测试步骤2: 端口1 向端口2 发送1 个组的组播流量\n                   测试步骤3: 在被测交换机上禁用IGMP Snooping 功能，观察端口2 流量接收情况；\n                   测试步骤4: 在被测交换机上启用IGMP Snooping 功能，观察端口2 流量接收情况；\n                   测试步骤5: 端口2 使用IGMP 协议V2 加入组播组，观察端口2 流量接收情况；\n                   测试步骤6: 端口2 发送离开组请求，观察端口2 流量接收情况。\n\n Criteria    \t:   预期结果1: 步骤2）在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量；\n                   预期结果2: 步骤3）在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量；\n                   预期结果3: 步骤4）端口2 发送组加入请求后，可接收组播流量；\n                   预期结果4: 步骤5）端口2 发送离开组请求后，不能接收组播流量。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port_1, port_2 = ports\n    # 创建接口\n    interface_1 = create_interface(Port=port_1,Layers=['eth', 'ipv4'])\n    interface_2 = create_interface(Port=port_2,Layers=['eth', 'ipv4'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_2, Version='IGMPV2')\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interface_2)\n\n    # 创建全局组播组\n    multicast_group = create_multicast_group(Start='225.0.1.2',Count=1)\n\n    # 创建组播协议和组播组绑定关系对象\n    memberships = create_memberships(Session=igmp)\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP绑定流\n    src_point = get_layer_from_interfaces(Interfaces=interface_1)\n\n    stream = add_stream(Type='binding', SrcPoints=src_point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        # 获取流量统计结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'RxLossStreamFrames',\n                                                                    'RealtimeLossRate'])\n        if  Result['RxStreamFrames'] > 0  and Result['RxLossStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，没有所有端口都接收到组播流量', step=5, result=False)\n\n        # 被测设备使能igmp snooping\n        cmd_cfg = '_'.join('DeviceA_Step3'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        # 清空统计计数\n        clear_result()\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        printf(message='step3：端口1向端口2发送1个组的组播流量, 在被测交换机上启用IGMP Snooping 功能')\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=False)\n\n        igmp_send_report(Sessions=igmp)\n        time.sleep(3)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=False)\n\n        igmp_send_leave(Sessions=igmp)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if Result['TxStreamFrames'] != Result['RxStreamFrames'] and Result['RxStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\ncreate_igmp:创建IGMP协议会话对象;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_6_1/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.6.1 三层转发速率\n\n Step\t\t\t:\t测试步骤1: 按拓扑图搭建测试环境；\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为192.168.2.100/24；\n                   测试步骤3: DUT port1 地址为 192.168.1.1/24，port2 地址为 192.168.2.1/24；\n                   测试步骤4: 测试仪从端口以最大负荷，不同帧长度（64、128、256、512、1024、1518byte）发送数据，测试时间为 30 秒。\n\n Criteria    \t:   预期结果1: 记录转发速率。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['seconds']['default'])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 初始化一个空的DataFrame来存储所有数据\n        printf(message='Test start')\n        all_data = pd.DataFrame()\n        for frame_size in cfg['arg']['stream']['default']['frame_size']['default']:\n            # 修改帧长\n            for s in streams:\n                s.edit(FixedLength=frame_size)\n            # 发送流量\n            start_stream()\n            time.sleep(3)\n            df = get_streamblock_statistic()\n            wait_stream_state(TimeOut=cfg['arg']['load_profile']['default']['seconds']['default'] + 3)\n            time.sleep(3)\n            result = get_streamblock_statistic()\n            # 使用 concat 拼接 DataFrame\n            df = pd.concat([df, result])\n            # 重置索引\n            df = df.reset_index(drop=True)\n            # 添加一列帧长，全部值为当前循环的frame_length，并命名为'frame_length'\n            # 注意：这里我们假设原始DataFrame中没有名为'frame_length'的列，或者即使有，我们也想要覆盖它\n            df['FrameSize'] = frame_size\n            # 但是，由于我们想要将'frame_length'放在第二列，我们需要重新排列列\n            # 首先获取当前列名列表\n            columns = df.columns.tolist()\n            # 如果'FrameSize'已经在列表中，移除它以便我们可以重新插入到正确的位置\n            if 'FrameSize' in columns:\n                columns.remove('FrameSize')\n            # 将'frame_length'插入到第二列的位置（索引为1）\n            columns.insert(1, 'FrameSize')\n            # 重新排序DataFrame的列\n            df = df.reindex(columns=columns)\n            # 将当前循环的数据追加到所有数据的DataFrame中\n            all_data = pd.concat([all_data, df])\n            # 重置all_data的索引，虽然这不是严格必要的，但可以保持索引的连续性\n            all_data = all_data.reset_index(drop=True)\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(all_data, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(all_data)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表系统，建立测试环境连接\",\n  \"子任务2\": \"预约测试仪表端口资源，获取端口位置信息\",\n  \"子任务3\": \"配置测试仪表端口参数，包括速率和双工模式\",\n  \"子任务4\": \"在测试仪端口1创建IPv4接口，设置MAC地址为配置值\",\n  \"子任务5\": \"在测试仪端口1设置IPv4地址为192.168.1.100/24，网关为192.168.1.1\",\n  \"子任务6\": \"在测试仪端口2创建IPv4接口，设置MAC地址为配置值\",\n  \"子任务7\": \"在测试仪端口2设置IPv4地址为192.168.2.100/24，网关为192.168.2.1\",\n  \"子任务8\": \"获取端口接口的IPv4层对象用于流量生成\",\n  \"子任务9\": \"创建双向绑定流，源为端口1 IPv4层，目的为端口2 IPv4层\",\n  \"子任务10\": \"配置端口负载模式：基于端口的百分比负载，传输模式为时间模式\",\n  \"子任务11\": \"设置负载参数：100%速率，持续30秒\",\n  \"子任务12\": \"订阅端口统计和流统计视图用于结果采集\",\n  \"子任务13\": \"保存当前测试配置到文件系统\",\n  \"子任务14\": \"针对每个帧长度(64,128,256,512,1024,1518字节)执行测试：\",\n  \"子任务15\": \"修改流模板块的帧长度为当前测试值\",\n  \"子任务16\": \"启动流量发送\",\n  \"子任务17\": \"等待流量发送完成，超时时间33秒\",\n  \"子任务18\": \"获取流模板块统计结果数据\",\n  \"子任务19\": \"记录当前帧长度的转发速率结果\",\n  \"子任务20\": \"释放测试仪表端口资源\",\n  \"子任务21\": \"关闭测试仪表连接\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.6.1 三层转发速率\n\n Step\t\t\t:\t测试步骤1: 按拓扑图搭建测试环境；\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为192.168.2.100/24；\n                   测试步骤3: DUT port1 地址为 192.168.1.1/24，port2 地址为 192.168.2.1/24；\n                   测试步骤4: 测试仪从端口以最大负荷，不同帧长度（64、128、256、512、1024、1518byte）发送数据，测试时间为 30 秒。\n\n Criteria    \t:   预期结果1: 记录转发速率。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['seconds']['default'])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 初始化一个空的DataFrame来存储所有数据\n        printf(message='Test start')\n        all_data = pd.DataFrame()\n        for frame_size in cfg['arg']['stream']['default']['frame_size']['default']:\n            # 修改帧长\n            for s in streams:\n                s.edit(FixedLength=frame_size)\n            # 发送流量\n            start_stream()\n            time.sleep(3)\n            df = get_streamblock_statistic()\n            wait_stream_state(TimeOut=cfg['arg']['load_profile']['default']['seconds']['default'] + 3)\n            time.sleep(3)\n            result = get_streamblock_statistic()\n            # 使用 concat 拼接 DataFrame\n            df = pd.concat([df, result])\n            # 重置索引\n            df = df.reset_index(drop=True)\n            # 添加一列帧长，全部值为当前循环的frame_length，并命名为'frame_length'\n            # 注意：这里我们假设原始DataFrame中没有名为'frame_length'的列，或者即使有，我们也想要覆盖它\n            df['FrameSize'] = frame_size\n            # 但是，由于我们想要将'frame_length'放在第二列，我们需要重新排列列\n            # 首先获取当前列名列表\n            columns = df.columns.tolist()\n            # 如果'FrameSize'已经在列表中，移除它以便我们可以重新插入到正确的位置\n            if 'FrameSize' in columns:\n                columns.remove('FrameSize')\n            # 将'frame_length'插入到第二列的位置（索引为1）\n            columns.insert(1, 'FrameSize')\n            # 重新排序DataFrame的列\n            df = df.reindex(columns=columns)\n            # 将当前循环的数据追加到所有数据的DataFrame中\n            all_data = pd.concat([all_data, df])\n            # 重置all_data的索引，虽然这不是严格必要的，但可以保持索引的连续性\n            all_data = all_data.reset_index(drop=True)\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(all_data, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(all_data)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_3/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  6.7.3动态主机配置协议（DHCP）\n\n Step\t\t\t:\t测试步骤1: ：按图10搭建测试环境\n                   测试步骤2: DUT port1 地址为192.168.1.1/24，DUT 上开启 DHCP 服务，设置为DHCP服务器，配置地址池192.168.1.2~192.168.1.254；\n                   测试步骤3: tester port1 作为 DHCP 客户端，发送DHCP请求\n                   测试步骤4: 观察客户端能否接收到正确的地址配置\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    # 创建DHCPv4协议会话\n    client = create_dhcp_client(Port=port_up)\n\n    # DHCPv4协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_up)\n\n    # # 获取DHCP Server地址池\n    # configDict = get_configs(Configs='Dhcpv4AddressPool')\n    # dhcpv4AddressPool = list(configDict.values())[0]\n    # edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='192.168.1.2', PrefixLength=19, PoolAddressCount=253)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n        start_protocol()\n        # dhcp_bind(Sessions=client)\n        # 等待DHCP协议协议会话状态正确\n        result = wait_dhcp_client_state(Sessions=client)\n\n        if result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is Bound', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is not Bound', step=4, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "create_dhcp_client:创建DHCPv4客户端协议会话对象",
      "wait_dhcp_client_state:等待DHCP协议会话达到指定状态"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表。\",\n  \"子任务2\": \"预约测试仪端口资源。\",\n  \"子任务3\": \"等待测试仪端口链路状态变为Up。\",\n  \"子任务4\": \"在测试仪端口上创建网络接口。\",\n  \"子任务5\": \"创建DHCPv4客户端协议会话对象。\",\n  \"子任务6\": \"将DHCPv4客户端协议会话绑定到网络接口。\",\n  \"子任务7\": \"启动协议，使客户端发送DHCP请求。\",\n  \"子任务8\": \"等待DHCPv4客户端协议会话状态变为Bound，验证客户端是否获得地址配置。\",\n  \"子任务9\": \"释放测试仪端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 :  6.7.3动态主机配置协议（DHCP）\n\n Step\t\t\t:\t测试步骤1: ：按图10搭建测试环境\n                   测试步骤2: DUT port1 地址为192.168.1.1/24，DUT 上开启 DHCP 服务，设置为DHCP服务器，配置地址池192.168.1.2~192.168.1.254；\n                   测试步骤3: tester port1 作为 DHCP 客户端，发送DHCP请求\n                   测试步骤4: 观察客户端能否接收到正确的地址配置\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    # 创建DHCPv4协议会话\n    client = create_dhcp_client(Port=port_up)\n\n    # DHCPv4协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_up)\n\n    # # 获取DHCP Server地址池\n    # configDict = get_configs(Configs='Dhcpv4AddressPool')\n    # dhcpv4AddressPool = list(configDict.values())[0]\n    # edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='192.168.1.2', PrefixLength=19, PoolAddressCount=253)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n        start_protocol()\n        # dhcp_bind(Sessions=client)\n        # 等待DHCP协议协议会话状态正确\n        result = wait_dhcp_client_state(Sessions=client)\n\n        if result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is Bound', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is not Bound', step=4, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\ncreate_dhcp_client:创建DHCPv4客户端协议会话对象;\nwait_dhcp_client_state:等待DHCP协议会话达到指定状态\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_1/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.1IP 广播功能\n\n Step\t\t\t:\t测试步骤1: ：1.按图10搭建测试环境；\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为 192.168.2.100/24；\n                   测试步骤3: DUT port1 地址为 192.168.1.1/24，port2 地址为 192.168.2.1/24；port1和port2 均开启直接广播支持；\n                   测试步骤4: tester port1 发送目的地址为255.255.255.255的数据包；\n                   测试步骤5: tester port1 发送目的地址为192.168.2.255的数据包；\n                   测试步骤6: DUT port2 配置192.168.3.0 路由；\n                   测试步骤7: tester port1 发送目的地址为192.168.3.255的数据包；\n                   测试步骤8: 记录步骤4、5、7中tester port2是否收到广播包。\n\n Criteria    \t:   预期结果1: 1.有限广播不能转发。2.三层交换机必须将网络前缀直接广播作为有效\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        TransmitMode=\"CONTINUOUS\",\n    #                        Frames=100,\n    #                        Unit='FRAME_PER_SEC')\n    # edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['255.255.255.255', '192.168.2.255', '192.168.3.255']\n\n    # 创建广播流量\n    # edit_port_load_profile(Ports=port1,LoadProfileType='PORT_BASE',Rate=30,Unit='FRAME_PER_SEC',TransmitMode=\"STEP\",Frames=20)\n    # tester port1 发送目的地址为255.255.255.255的数据包\n    stream = add_stream(Ports=port1, Names=f'step4')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168\n    # .2.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step5')\n\n    edit_stream(Stream=stream, FixedLength=64, )\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168.3.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[2],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_port_load_profile(Ports=port1, LoadProfileType='STREAM_BASE', TransmitMode='TIME', Seconds=30)\n\n    # 订阅统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        streams = get_streams(Ports=port1)\n        start_stream(Type='stream', Objects=streams[0])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[0],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 未收到广播包',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 收到广播包',\n                step=3, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[1])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[1],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=4, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[2])\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[2],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=5, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l3_learning:启动测试仪表流量三层ARP ND学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立测试环境连接。\",\n  \"子任务2\": \"预约测试仪表端口 port1 和 port2，并配置端口基础参数。\",\n  \"子任务3\": \"配置测试仪 port1 接口：IPv4地址=192.168.1.100/24，MAC地址按需设置，网关=192.168.1.1。\",\n  \"子任务4\": \"配置测试仪 port2 接口：IPv4地址=192.168.2.100/24，MAC地址按需设置，网关=192.168.2.1。\",\n  \"子任务5\": \"配置DUT端口：port1 IP=192.168.1.1/24，port2 IP=192.168.2.1/24，并开启直接广播支持（通过外部方式配置）。\",\n  \"子任务6\": \"在测试仪 port1 创建流量流1：目的IP=255.255.255.255，帧长=64字节，配置IPv4头部参数。\",\n  \"子任务7\": \"在测试仪 port1 创建流量流2：目的IP=192.168.2.255，帧长=64字节，配置IPv4头部参数。\",\n  \"子任务8\": \"在测试仪 port1 创建流量流3：目的IP=192.168.3.255，帧长=64字节，配置IPv4头部参数。\",\n  \"子任务9\": \"配置DUT port2 路由：添加192.168.3.0网络路由（通过外部方式配置）。\",\n  \"子任务10\": \"启动三层ARP学习，确保DUT地址解析完成。\",\n  \"子任务11\": \"清除测试仪统计结果，准备流量测试。\",\n  \"子任务12\": \"发送流量流1（目的IP=255.255.255.255），持续指定时间。\",\n  \"子任务13\": \"获取流量流1统计结果，验证port2是否收到广播包（预期：未收到）。\",\n  \"子任务14\": \"清除测试仪统计结果，准备下一轮测试。\",\n  \"子任务15\": \"发送流量流2（目的IP=192.168.2.255），持续指定时间。\",\n  \"子任务16\": \"获取流量流2统计结果，验证port2是否收到广播包（预期：收到）。\",\n  \"子任务17\": \"清除测试仪统计结果，准备下一轮测试。\",\n  \"子任务18\": \"发送流量流3（目的IP=192.168.3.255），持续指定时间。\",\n  \"子任务19\": \"获取流量流3统计结果，验证port2是否收到广播包（预期：收到）。\",\n  \"子任务20\": \"释放测试仪端口资源，关闭测试仪表连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.7.1IP 广播功能\n\n Step\t\t\t:\t测试步骤1: ：1.按图10搭建测试环境；\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为 192.168.2.100/24；\n                   测试步骤3: DUT port1 地址为 192.168.1.1/24，port2 地址为 192.168.2.1/24；port1和port2 均开启直接广播支持；\n                   测试步骤4: tester port1 发送目的地址为255.255.255.255的数据包；\n                   测试步骤5: tester port1 发送目的地址为192.168.2.255的数据包；\n                   测试步骤6: DUT port2 配置192.168.3.0 路由；\n                   测试步骤7: tester port1 发送目的地址为192.168.3.255的数据包；\n                   测试步骤8: 记录步骤4、5、7中tester port2是否收到广播包。\n\n Criteria    \t:   预期结果1: 1.有限广播不能转发。2.三层交换机必须将网络前缀直接广播作为有效\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        TransmitMode=\"CONTINUOUS\",\n    #                        Frames=100,\n    #                        Unit='FRAME_PER_SEC')\n    # edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['255.255.255.255', '192.168.2.255', '192.168.3.255']\n\n    # 创建广播流量\n    # edit_port_load_profile(Ports=port1,LoadProfileType='PORT_BASE',Rate=30,Unit='FRAME_PER_SEC',TransmitMode=\"STEP\",Frames=20)\n    # tester port1 发送目的地址为255.255.255.255的数据包\n    stream = add_stream(Ports=port1, Names=f'step4')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168\n    # .2.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step5')\n\n    edit_stream(Stream=stream, FixedLength=64, )\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168.3.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[2],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_port_load_profile(Ports=port1, LoadProfileType='STREAM_BASE', TransmitMode='TIME', Seconds=30)\n\n    # 订阅统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        streams = get_streams(Ports=port1)\n        start_stream(Type='stream', Objects=streams[0])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[0],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 未收到广播包',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 收到广播包',\n                step=3, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[1])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[1],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=4, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[2])\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[2],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=5, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l3_learning:启动测试仪表流量三层ARP ND学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_10/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.5.10 环网倒换时间\n\n Step\t\t\t:\t测试步骤1: 将4台交换机按照图9连接，允许交换机启用私有环网协议；\n                   测试步骤2: 在整个试验过程中，端口1、端口2互发数据流，测试帧长度为64字节，测试时间为30s，负荷率分别为10%和95%；\n                   测试步骤3: 分别拔插A、B、C路径，测试环网恢复时间。环网倒换时间（ms）=帧丢失数/总发送帧数×测试时间（ms）。\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=10,)\n    edit_port_load_profile(Ports=port2,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95, )\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插路径\n        time.sleep(30)\n\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time1 =( TxStreamFrames - RxStreamFrames)/TxStreamFrames * 3000\n        print(switch_time1)\n        stop_stream()\n\n        start_stream(Type='stream', Objects=stream2)\n        # 拔插路径\n        time.sleep(30)\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time2 = (TxStreamFrames - RxStreamFrames) / TxStreamFrames * 3000\n        print(switch_time2)\n        stop_stream()\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表\",\n  \"子任务2\": \"预约测试仪表端口资源（端口1和端口2）\",\n  \"子任务3\": \"配置端口1负载参数：传输模式为连续，单位百分比，速率10%\",\n  \"子任务4\": \"配置端口2负载参数：传输模式为连续，单位百分比，速率95%\",\n  \"子任务5\": \"在端口1创建流量流stream1：设置帧长度64字节，添加EthernetII和IPv4报文头\",\n  \"子任务6\": \"在端口1创建流量流stream2：设置帧长度64字节，添加EthernetII和IPv4报文头\",\n  \"子任务7\": \"订阅端口统计和流模板块统计视图\",\n  \"子任务8\": \"保存测试配置文件\",\n  \"子任务9\": \"启动二层地址学习\",\n  \"子任务10\": \"开始发送stream1流量\",\n  \"子任务11\": \"模拟断开路径A（等待30秒测试时间）\",\n  \"子任务12\": \"停止stream1流量发送\",\n  \"子任务13\": \"获取stream1统计结果：发送帧数和接收帧数\",\n  \"子任务14\": \"计算路径A的环网倒换时间：(TxFrames - RxFrames)/TxFrames × 30000ms\",\n  \"子任务15\": \"开始发送stream2流量\",\n  \"子任务16\": \"模拟断开路径A（等待30秒测试时间）\",\n  \"子任务17\": \"停止stream2流量发送\",\n  \"子任务18\": \"获取stream2统计结果：发送帧数和接收帧数\",\n  \"子任务19\": \"计算路径A的环网倒换时间：(TxFrames - RxFrames)/TxFrames × 30000ms\",\n  \"子任务20\": \"清除统计结果\",\n  \"子任务21\": \"重复子任务10-20流程测试路径B（断开路径B）\",\n  \"子任务22\": \"重复子任务10-20流程测试路径C（断开路径C）\",\n  \"子任务23\": \"释放测试仪表端口资源\",\n  \"子任务24\": \"关闭测试仪表进程\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.5.10 环网倒换时间\n\n Step\t\t\t:\t测试步骤1: 将4台交换机按照图9连接，允许交换机启用私有环网协议；\n                   测试步骤2: 在整个试验过程中，端口1、端口2互发数据流，测试帧长度为64字节，测试时间为30s，负荷率分别为10%和95%；\n                   测试步骤3: 分别拔插A、B、C路径，测试环网恢复时间。环网倒换时间（ms）=帧丢失数/总发送帧数×测试时间（ms）。\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=10,)\n    edit_port_load_profile(Ports=port2,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95, )\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插路径\n        time.sleep(30)\n\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time1 =( TxStreamFrames - RxStreamFrames)/TxStreamFrames * 3000\n        print(switch_time1)\n        stop_stream()\n\n        start_stream(Type='stream', Objects=stream2)\n        # 拔插路径\n        time.sleep(30)\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time2 = (TxStreamFrames - RxStreamFrames) / TxStreamFrames * 3000\n        print(switch_time2)\n        stop_stream()\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_3/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.3 队头阻塞测试\n\n Step\t\t\t:\t测试步骤1: 按图7，从交换机任意选取4 个端口与测试仪相连接，分别定为端口A、端口B、端口C 和端口D；\n                   测试步骤2: 网络测试仪、交换机均关闭流控，12 发送100%流量，32 发送50%流量，34 发送50%流量；\n                    1) 口建立untag流量 连接交换机端口 access vlan 100,\n                    2) 口连接交换机trunk vlan 100,200\n                    3) 口建立vlan 200,vlan4094流量 连接交换机trunk vlan 200,4094\n                    4) 口连接交换机access vlan 4094\n                   测试步骤3: 记录端口D 是否有丢包。\n\n Criteria    \t:   预期结果1: 记录端口D 是否有丢包。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=100, Seconds=30)\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 绑定流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4', 'tcp'])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 绑定流量\n    edit_port_load_profile(Ports=port3, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    #edit_port_load_profile(Ports=port3, Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan200_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 50)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan4094_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=4094)\n    edit_stream_load_profile(Streams=stream, Rate=50)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        stream1=get_streams(Ports=port1)\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n        stream_object = get_streams(Ports=port3)\n        for stream in stream_object:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=3, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=3, result=True)\n\n        stream = stream_object[1]\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames}),端口D丢包',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),端口D未丢包',\n                step=4, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，连接测试仪管理接口。\",\n  \"子任务2\": \"预约测试仪四个端口，分别对应交换机端口A、B、C、D。\",\n  \"子任务3\": \"修改测试仪所有端口参数，关闭流控功能。\",\n  \"子任务4\": \"配置交换机端口：端口A为access模式VLAN 100，端口B为trunk模式允许VLAN 100/200，端口C为trunk模式允许VLAN 200/4094，端口D为access模式VLAN 4094。\",\n  \"子任务5\": \"在端口A创建到端口B的流量：100%速率，untagged VLAN 100，固定帧长128字节。\",\n  \"子任务6\": \"在端口C创建到端口B的流量：50%速率，VLAN 200标签，固定帧长128字节。\",\n  \"子任务7\": \"在端口C创建到端口D的流量：50%速率，VLAN 4094标签，固定帧长128字节。\",\n  \"子任务8\": \"订阅流统计视图StreamBlockStats。\",\n  \"子任务9\": \"启动二层地址学习功能。\",\n  \"子任务10\": \"启动所有端口流量发送，等待流量发送完成。\",\n  \"子任务11\": \"获取端口C到端口D的流量统计结果，记录发送帧数和接收帧数。\",\n  \"子任务12\": \"判断端口D是否丢包：比较接收帧数是否等于发送帧数。\",\n  \"子任务13\": \"清除测试仪统计结果。\",\n  \"子任务14\": \"释放测试仪所有端口资源。\",\n  \"子任务15\": \"关闭测试仪表连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.3 队头阻塞测试\n\n Step\t\t\t:\t测试步骤1: 按图7，从交换机任意选取4 个端口与测试仪相连接，分别定为端口A、端口B、端口C 和端口D；\n                   测试步骤2: 网络测试仪、交换机均关闭流控，12 发送100%流量，32 发送50%流量，34 发送50%流量；\n                    1) 口建立untag流量 连接交换机端口 access vlan 100,\n                    2) 口连接交换机trunk vlan 100,200\n                    3) 口建立vlan 200,vlan4094流量 连接交换机trunk vlan 200,4094\n                    4) 口连接交换机access vlan 4094\n                   测试步骤3: 记录端口D 是否有丢包。\n\n Criteria    \t:   预期结果1: 记录端口D 是否有丢包。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=100, Seconds=30)\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 绑定流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4', 'tcp'])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 绑定流量\n    edit_port_load_profile(Ports=port3, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    #edit_port_load_profile(Ports=port3, Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan200_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 50)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan4094_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=4094)\n    edit_stream_load_profile(Streams=stream, Rate=50)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        stream1=get_streams(Ports=port1)\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n        stream_object = get_streams(Ports=port3)\n        for stream in stream_object:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=3, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=3, result=True)\n\n        stream = stream_object[1]\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames}),端口D丢包',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),端口D未丢包',\n                step=4, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_8_1/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.8.1错误帧过滤功能\n\n Step\t\t\t:\t测试步骤1: ：按图4，任选交换机两个端口作为测试端口；\n                   测试步骤2: 端口1向端口2发送CRC校验错误帧，观察接收情况；\n                   测试步骤3: 端口1向端口2发送源MAC地址错误帧，观察接收情况\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100,\n                           GenerateError='CRC')\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=False)\n\n        clear_result()\n        edit_port_load_profile(Ports=port1,\n                               LoadProfileType='PORT_BASE',\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=100,\n                               GenerateError='NO_ERROR')\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames == RxStreamFrames and  RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试设备的连接。\",\n  \"子任务2\": \"预约测试仪表的两个端口作为测试端口（端口1和端口2）。\",\n  \"子任务3\": \"配置测试端口参数，确保端口状态就绪。\",\n  \"子任务4\": \"在端口1上创建网络接口，配置MAC地址和IPv4地址。\",\n  \"子任务5\": \"在端口2上创建网络接口，配置MAC地址和IPv4地址。\",\n  \"子任务6\": \"配置端口1负载参数：设置CRC错误帧生成模式，速率100帧/秒。\",\n  \"子任务7\": \"在端口1创建第一个流量流（stream1）：设置64字节固定长度，配置正常源MAC和目的MAC的以太网头部。\",\n  \"子任务8\": \"在端口1创建第二个流量流（stream2）：设置64字节固定长度，配置错误源MAC（00:00:00:00:00:00）和目的MAC的以太网头部。\",\n  \"子任务9\": \"订阅端口统计和流统计视图用于结果监控。\",\n  \"子任务10\": \"启动二层地址学习过程，持续3秒。\",\n  \"子任务11\": \"启动发送stream1（含CRC错误的流量），持续10秒后停止。\",\n  \"子任务12\": \"获取stream1统计结果，验证接收帧数是否为0（预期：CRC错误帧被过滤）。\",\n  \"子任务13\": \"清除统计结果，修改端口1负载参数为无错误生成模式。\",\n  \"子任务14\": \"再次启动二层地址学习过程，持续3秒。\",\n  \"子任务15\": \"启动发送stream2（源MAC错误帧），持续10秒后停止。\",\n  \"子任务16\": \"获取stream2统计结果，验证接收帧数等于发送帧数（预期：源MAC错误帧未被过滤）。\",\n  \"子任务17\": \"释放测试仪表端口资源，关闭测试连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.8.1错误帧过滤功能\n\n Step\t\t\t:\t测试步骤1: ：按图4，任选交换机两个端口作为测试端口；\n                   测试步骤2: 端口1向端口2发送CRC校验错误帧，观察接收情况；\n                   测试步骤3: 端口1向端口2发送源MAC地址错误帧，观察接收情况\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100,\n                           GenerateError='CRC')\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=False)\n\n        clear_result()\n        edit_port_load_profile(Ports=port1,\n                               LoadProfileType='PORT_BASE',\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=100,\n                               GenerateError='NO_ERROR')\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames == RxStreamFrames and  RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/LoadProfile/EditLoadProfile_BaseOnPort_BigTao.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Port负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约6个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Port,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\n\nProduct = 'BigTao'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n    '//10.0.11.191/1/5',\n    '//10.0.11.191/1/6',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'bigtao':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Port, （端口负载：15, 负载单位：Percent(%)） 传输模式：Continuous,\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='PORT_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=15,\n                               Unit='PERCENT')\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Port （端口负载：20, 负载单位：Inter Frame Gap(ns)）, 传输模式：Burst, （突发报文数：15, 突发间隔：2, 突发间隔单位: ms , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='PORT_BASE',\n                               Rate=20,\n                               Unit='NS',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=2,\n                               InterFrameGapUnit='MS',\n                               BurstCount=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Port, （端口负载：25, 负载单位：Inter Frame Gap(byte)） 传输模式：Time, （发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='PORT_BASE',\n                               Rate=25,\n                               Unit='INTER_FRAME_GAP_BYTE',\n                               TransmitMode=\"TIME\",\n                               Seconds=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Port, （端口负载：30, 负载单位：Frames per Second） 传输模式：Step, （发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='PORT_BASE',\n                               Rate=30,\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               Frames=20)\n\n        # =============== *设置模式5* ===============\n        # 负载模式：Base On Port, （端口负载：35, 负载单位：Byte per Second） 传输模式：On Stream, 流传输模式：Continuous\n        edit_port_load_profile(Ports=Ports[4],\n                               LoadProfileType='PORT_BASE',\n                               Rate=35,\n                               Unit='BYTE_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[4], FixedLength=256)\n        edit_stream_load_profile(Streams=stream, StreamTransmitMode='CONTINUOUS')\n\n        # =============== *设置模式6* ===============\n        # 负载模式：Base On Port, （端口负载：40, 负载单位：Data Bits per Second） 传输模式：On Stream, 流传输模式：Burst （突发间隔单位：MS, 突发次数：3, 突发间隔：4, 突发数量：10）\n        edit_port_load_profile(Ports=Ports[5],\n                               LoadProfileType='PORT_BASE',\n                               Rate=40,\n                               Unit='DATABIT_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[5], FixedLength=256)\n        edit_stream_load_profile(Streams=stream, StreamTransmitMode='BURST', BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "add_stream:测试仪表创建流量"
    ],
    "rewrite_intent": "```json\n{\n  \"子任务1\": \"初始化测试仪表，指定产品类型为BigTao。\",\n  \"子任务2\": \"预约6个离线测试端口，使用指定的物理位置地址列表。\",\n  \"子任务3\": \"设置端口1负载模式：Base On Port，传输模式Continuous，负载速率15，单位Percent(%), 并验证配置成功。\",\n  \"子任务4\": \"设置端口2负载模式：Base On Port，传输模式Burst，负载速率20，单位Inter Frame Gap(ns)，突发报文数15，突发间隔2ms，突发次数10, 并验证配置成功。\",\n  \"子任务5\": \"设置端口3负载模式：Base On Port，传输模式Time，负载速率25，单位Inter Frame Gap(byte)，发送时间15秒, 并验证配置成功。\",\n  \"子任务6\": \"设置端口4负载模式：Base On Port，传输模式Step，负载速率30，单位Frames per Second，发送帧数20, 并验证配置成功。\",\n  \"子任务7\": \"设置端口5负载模式：Base On Port，传输模式On Stream，负载速率35，单位Byte per Second；创建256字节固定长度流量，设置流传输模式Continuous, 并验证配置成功。\",\n  \"子任务8\": \"设置端口6负载模式：Base On Port，传输模式On Stream，负载速率40，单位Data Bits per Second；创建256字节固定长度流量，设置流传输模式Burst，突发间隔4ms，突发次数3，突发数量10, 并验证配置成功。\",\n  \"子任务9\": \"保存当前测试配置文件到指定路径，文件名与当前脚本同名。\"\n}\n```",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Port负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约6个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Port,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\n\nProduct = 'BigTao'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n    '//10.0.11.191/1/5',\n    '//10.0.11.191/1/6',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'bigtao':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Port, （端口负载：15, 负载单位：Percent(%)） 传输模式：Continuous,\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='PORT_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=15,\n                               Unit='PERCENT')\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Port （端口负载：20, 负载单位：Inter Frame Gap(ns)）, 传输模式：Burst, （突发报文数：15, 突发间隔：2, 突发间隔单位: ms , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='PORT_BASE',\n                               Rate=20,\n                               Unit='NS',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=2,\n                               InterFrameGapUnit='MS',\n                               BurstCount=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Port, （端口负载：25, 负载单位：Inter Frame Gap(byte)） 传输模式：Time, （发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='PORT_BASE',\n                               Rate=25,\n                               Unit='INTER_FRAME_GAP_BYTE',\n                               TransmitMode=\"TIME\",\n                               Seconds=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Port, （端口负载：30, 负载单位：Frames per Second） 传输模式：Step, （发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='PORT_BASE',\n                               Rate=30,\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               Frames=20)\n\n        # =============== *设置模式5* ===============\n        # 负载模式：Base On Port, （端口负载：35, 负载单位：Byte per Second） 传输模式：On Stream, 流传输模式：Continuous\n        edit_port_load_profile(Ports=Ports[4],\n                               LoadProfileType='PORT_BASE',\n                               Rate=35,\n                               Unit='BYTE_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[4], FixedLength=256)\n        edit_stream_load_profile(Streams=stream, StreamTransmitMode='CONTINUOUS')\n\n        # =============== *设置模式6* ===============\n        # 负载模式：Base On Port, （端口负载：40, 负载单位：Data Bits per Second） 传输模式：On Stream, 流传输模式：Burst （突发间隔单位：MS, 突发次数：3, 突发间隔：4, 突发数量：10）\n        edit_port_load_profile(Ports=Ports[5],\n                               LoadProfileType='PORT_BASE',\n                               Rate=40,\n                               Unit='DATABIT_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[5], FixedLength=256)\n        edit_stream_load_profile(Streams=stream, StreamTransmitMode='BURST', BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nadd_stream:测试仪表创建流量\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_8/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.8 网络风暴抑制: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示；\n                   测试步骤2: 测试帧长设为64，端口负载为满负载，测试时间30s；\n                   测试步骤3: 交换机分别开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能；\n                   测试步骤4: 设置抑制值为1M+粒度；\n                   测试步骤5: 端口1 向端口2 发送3 条数据流，分别为Stream1（广播帧）、Stream2（广播帧）、Stream3（IPv4 帧），端口2 向端口1 发送2 条数据流，分别为Stream1（组播帧）、Stream2（未知单播帧）；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断网络风暴抑制功能是否设置成功；\n                   测试步骤7: 根据帧丢失率，计算网络风暴抑制比偏差。\n\n Criteria    \t:   预期结果1: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启；\n                   预期结果2: 网络风暴实际抑制值不应超过抑制设定值的110%。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并预约端口，确保测试环境准备就绪。\",\n  \"子任务2\": \"配置交换机开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，并确认广播风暴抑制功能默认开启。\",\n  \"子任务3\": \"在交换机上设置风暴抑制值为1Mbps（或1M+粒度）。\",\n  \"子任务4\": \"编辑测试仪表端口负载配置文件参数：设置帧长度为64字节、端口负载为100%、测试时间为30秒。\",\n  \"子任务5\": \"在测试仪表端口1上创建并配置数据流：Stream1（广播帧）、Stream2（广播帧）、Stream3（IPv4帧），包括设置Ethernet头部源和目的MAC地址。\",\n  \"子任务6\": \"在测试仪表端口2上创建并配置数据流：Stream1（组播帧）、Stream2（未知单播帧），包括设置Ethernet头部源和目的MAC地址。\",\n  \"子任务7\": \"订阅测试仪表流模板块统计视图，用于后续结果收集。\",\n  \"子任务8\": \"保存测试配置文件到指定路径。\",\n  \"子任务9\": \"启动端口1的数据流发送，等待发送完成，并获取流模板块统计结果。\",\n  \"子任务10\": \"记录端口1各数据流（Stream1、Stream2、Stream3）的帧丢失率。\",\n  \"子任务11\": \"判断广播风暴抑制功能是否成功：基于Stream1和Stream2的帧丢失率是否超过99%。\",\n  \"子任务12\": \"验证IPv4帧转发是否成功：基于Stream3的帧丢失率是否接近0%（发送帧数与接收帧数相等）。\",\n  \"子任务13\": \"清除测试仪表统计结果，启动端口2的数据流发送，等待发送完成，并获取流模板块统计结果。\",\n  \"子任务14\": \"记录端口2各数据流（Stream1、Stream2）的帧丢失率。\",\n  \"子任务15\": \"判断组播风暴抑制和未知单播风暴抑制功能是否成功：基于Stream1和Stream2的帧丢失率是否超过99%。\",\n  \"子任务16\": \"计算网络风暴抑制比偏差：比较实际抑制值（基于帧丢失率推导的抑制速率）与设定抑制值（1Mbps），确保实际抑制值不超过设定值的110%。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.8 网络风暴抑制: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示；\n                   测试步骤2: 测试帧长设为64，端口负载为满负载，测试时间30s；\n                   测试步骤3: 交换机分别开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能；\n                   测试步骤4: 设置抑制值为1M+粒度；\n                   测试步骤5: 端口1 向端口2 发送3 条数据流，分别为Stream1（广播帧）、Stream2（广播帧）、Stream3（IPv4 帧），端口2 向端口1 发送2 条数据流，分别为Stream1（组播帧）、Stream2（未知单播帧）；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断网络风暴抑制功能是否设置成功；\n                   测试步骤7: 根据帧丢失率，计算网络风暴抑制比偏差。\n\n Criteria    \t:   预期结果1: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启；\n                   预期结果2: 网络风暴实际抑制值不应超过抑制设定值的110%。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_9/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.9 支持网关数\n\n Step\t\t\t:\t测试步骤1: 记录三层交换机配置网络层地址的方式（路由口配置方式或者VLANInterface 方式）。\n                   测试步骤2: 记录三层交换机可配置的网关数目\n                   测试步骤3: 按图10建立测试环境\n                   测试步骤4: tester port1 地 址 为 192.168.9.100/24 ， port2 地 址 为192.168.11.100/24；DUT port1\n                   和 port2 分别配置 192.168.9.0 网段和192.168.11.0 网段网关，抽样验证网关是否配置成功。\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.9.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n        ipv4_ping(Interface=interfaces_down, IpAddr='192.168.11.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试设备的连接。\",\n  \"子任务2\": \"预约测试仪表端口，获取测试环境中的端口位置信息。\",\n  \"子任务3\": \"配置测试仪表端口参数，包括速率、双工模式等基础设置。\",\n  \"子任务4\": \"在测试仪表端口1创建网络接口，配置MAC地址为指定值，IPv4地址为192.168.9.100/24，网关为192.168.9.1。\",\n  \"子任务5\": \"在测试仪表端口2创建网络接口，配置MAC地址为指定值，IPv4地址为192.168.11.100/24，网关为192.168.11.1。\",\n  \"子任务6\": \"保存当前测试仪配置到指定路径的配置文件。\",\n  \"子任务7\": \"从端口1接口向DUT端口1网关地址192.168.9.1发送5个ICMP请求包，验证连通性。\",\n  \"子任务8\": \"从端口2接口向DUT端口2网关地址192.168.11.1发送5个ICMP请求包，验证连通性。\",\n  \"子任务9\": \"检查两次ping测试结果，确认丢包率为0%则判定网关配置成功。\",\n  \"子任务10\": \"释放测试仪表端口资源，断开连接。\",\n  \"子任务11\": \"关闭测试仪表进程，清理测试环境。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.7.9 支持网关数\n\n Step\t\t\t:\t测试步骤1: 记录三层交换机配置网络层地址的方式（路由口配置方式或者VLANInterface 方式）。\n                   测试步骤2: 记录三层交换机可配置的网关数目\n                   测试步骤3: 按图10建立测试环境\n                   测试步骤4: tester port1 地 址 为 192.168.9.100/24 ， port2 地 址 为192.168.11.100/24；DUT port1\n                   和 port2 分别配置 192.168.9.0 网段和192.168.11.0 网段网关，抽样验证网关是否配置成功。\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.9.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n        ipv4_ping(Interface=interfaces_down, IpAddr='192.168.11.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_5/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.5 多链路聚合: 链路聚合时不应丢失数据\n\n Step\t\t\t:\t测试步骤1: 按图8 建立测试环境；\n                   测试步骤2: 将交换机1 的2 个端口和交换机2 的2 个端口对应连接。将交换机1 的 2个端口配置为一个静态聚合端口，交换机2 的2 个端口配置为一个静态聚合端口；\n                   测试步骤3: 由测试仪1、3 端口分别向2、4 端口发送数据流，负载率为100%；\n                   测试步骤4: 在测试仪的2、4 端口观察流量的接收情况，应无丢包；\n                   测试步骤5: 断开交换机1 和交换机2 间的1 条链路，观察流量的接收情况，应各丢 50%；\n                   测试步骤6: 停掉3 向4 的数据流，观察1 向2 的数据流的接收情况，应无丢包。\n\n Criteria    \t:   预期结果1: 记录端口4 接收到的数据帧数量，判断镜像功能是否设置成功。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    # 端口1创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream1 = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream1, FixedLength=128)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 端口3创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream2 = add_stream(Ports=port3, Names=f'{port3.Name}_100%')\n    edit_stream(Stream=stream2, FixedLength=128)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取流量结果\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step4：get  stream statistic')\n        # 获取流量1统计结果\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames'] and Result2['TxStreamFrames']==Result2['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames']*2 and Result2['TxStreamFrames']==Result2['RxStreamFrames']*2:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        # 停止3口流量\n        stop_stream(Type='stream',Objects=stream2)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result1['TxStreamFrames'] == Result1['RxStreamFrames']  and Result2['TxStreamFrames'] == Result2[\n            'RxStreamFrames'] :\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立测试环境。\",\n  \"子任务2\": \"预约测试仪表的四个端口资源。\",\n  \"子任务3\": \"使用NTO导入拓扑文件配置交换机1和交换机2的静态聚合端口。\",\n  \"子任务4\": \"编辑测试仪表负载配置文件，设置负载率为100%。\",\n  \"子任务5\": \"为端口1创建TCP数据流，配置以太网头部源/目的MAC地址。\",\n  \"子任务6\": \"为端口3创建TCP数据流，配置以太网头部源/目的MAC地址。\",\n  \"子任务7\": \"订阅StreamBlockStats统计视图用于结果监控。\",\n  \"子任务8\": \"启动二层地址学习功能。\",\n  \"子任务9\": \"清除现有统计结果。\",\n  \"子任务10\": \"启动所有数据流发送。\",\n  \"子任务11\": \"等待数据流状态稳定。\",\n  \"子任务12\": \"获取端口2和端口4的流量统计结果，验证无丢包（Rx等于Tx）。\",\n  \"子任务13\": \"再次清除统计结果。\",\n  \"子任务14\": \"模拟断开交换机间的一条链路。\",\n  \"子任务15\": \"重新启动所有数据流发送。\",\n  \"子任务16\": \"获取流量统计结果，验证各丢包50%（Rx等于Tx/2）。\",\n  \"子任务17\": \"再次清除统计结果。\",\n  \"子任务18\": \"启动所有数据流发送。\",\n  \"子任务19\": \"停止端口3到端口4的数据流。\",\n  \"子任务20\": \"获取端口1到端口2的数据流统计结果，验证无丢包（Rx等于Tx）。\",\n  \"子任务21\": \"释放测试仪表端口资源。\",\n  \"子任务22\": \"关闭测试仪表进程。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.5 多链路聚合: 链路聚合时不应丢失数据\n\n Step\t\t\t:\t测试步骤1: 按图8 建立测试环境；\n                   测试步骤2: 将交换机1 的2 个端口和交换机2 的2 个端口对应连接。将交换机1 的 2个端口配置为一个静态聚合端口，交换机2 的2 个端口配置为一个静态聚合端口；\n                   测试步骤3: 由测试仪1、3 端口分别向2、4 端口发送数据流，负载率为100%；\n                   测试步骤4: 在测试仪的2、4 端口观察流量的接收情况，应无丢包；\n                   测试步骤5: 断开交换机1 和交换机2 间的1 条链路，观察流量的接收情况，应各丢 50%；\n                   测试步骤6: 停掉3 向4 的数据流，观察1 向2 的数据流的接收情况，应无丢包。\n\n Criteria    \t:   预期结果1: 记录端口4 接收到的数据帧数量，判断镜像功能是否设置成功。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    # 端口1创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream1 = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream1, FixedLength=128)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 端口3创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream2 = add_stream(Ports=port3, Names=f'{port3.Name}_100%')\n    edit_stream(Stream=stream2, FixedLength=128)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取流量结果\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step4：get  stream statistic')\n        # 获取流量1统计结果\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames'] and Result2['TxStreamFrames']==Result2['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames']*2 and Result2['TxStreamFrames']==Result2['RxStreamFrames']*2:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        # 停止3口流量\n        stop_stream(Type='stream',Objects=stream2)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result1['TxStreamFrames'] == Result1['RxStreamFrames']  and Result2['TxStreamFrames'] == Result2[\n            'RxStreamFrames'] :\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_4/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.4 端口镜像:支持单端口镜像和多端口镜像，镜像端口在不丢失数据的前提下应保证系统要求的转发速率。\n\n Step\t\t\t:\t测试步骤1: 测试帧长度为 64 字节，测试时间不小于 30s；\n                   测试步骤2: 测试配置图如图 7 所示，交换机端口 4 设置成镜像端口，端口 1 和端口 3设置成被镜像端口，镜像方式为输入和输出同时镜像；\n                   测试步骤3: 端口 1 向端口 2 双向发送数据，端口 2 和端口 3 双向发送数据，负载率分别为 25%；\n\n Criteria    \t:   预期结果1: 记录端口 4 接收到的数据帧数量，判断镜像功能是否设置成功。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_25%')\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=25, Seconds=30)\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 流量\n    edit_port_load_profile(Ports=port2, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan200_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 25)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan100_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_stream_load_profile(Streams=stream, Rate= 25)\n\n    # 端口3创建绑定1-》2 绑定流量\n    edit_port_load_profile(Ports=port3, TransmitMode='TIME', Rate=25, Seconds=30)\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        #清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        result = get_port_statistic(StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port1_Result = get_port_statistic(Port=port1, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port3_Result = get_port_statistic(Port=port3, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port4_Result = get_port_statistic(Port=port4, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        MirrotFrames = Port1_Result['TxStreamFrames']+Port1_Result['RxSignatureStreamFrames']+Port3_Result['TxStreamFrames']+Port3_Result['RxSignatureStreamFrames']\n        RX_Result=Port4_Result['RxSignatureStreamFrames']\n        if MirrotFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is not equal to 0',\n                step=3, result=True)\n\n        if  MirrotFrames == RX_Result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is not equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_port_statistic:获取测试仪表端口统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并预约测试端口（端口1、端口2、端口3、端口4）。\",\n  \"子任务2\": \"配置交换机端口：端口4设置为镜像端口，端口1和端口3设置为被镜像端口，镜像方向为双向（输入和输出）。\",\n  \"子任务3\": \"在端口1创建发往端口2的流量：帧长度64字节，负载率25%，测试时间30秒。\",\n  \"子任务4\": \"在端口2创建发往端口1的流量：帧长度64字节，负载率25%，测试时间30秒。\",\n  \"子任务5\": \"在端口2创建发往端口3的流量：帧长度64字节，负载率25%，测试时间30秒。\",\n  \"子任务6\": \"在端口3创建发往端口2的流量：帧长度64字节，负载率25%，测试时间30秒。\",\n  \"子任务7\": \"订阅端口统计视图，重点关注TxStreamFrames和RxSignatureStreamFrames指标。\",\n  \"子任务8\": \"启动二层学习并清除所有统计计数。\",\n  \"子任务9\": \"开始发送所有配置的流量并等待测试完成（持续30秒）。\",\n  \"子任务10\": \"获取端口1的发送帧数（TxStreamFrames）和接收帧数（RxSignatureStreamFrames）。\",\n  \"子任务11\": \"获取端口3的发送帧数（TxStreamFrames）和接收帧数（RxSignatureStreamFrames）。\",\n  \"子任务12\": \"计算被镜像端口的总流量：端口1发送+接收 + 端口3发送+接收。\",\n  \"子任务13\": \"获取端口4的接收帧数（RxSignatureStreamFrames）。\",\n  \"子任务14\": \"验证端口4接收帧数是否等于被镜像端口总流量。\",\n  \"子任务15\": \"释放所有测试端口资源并关闭仪表连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.4 端口镜像:支持单端口镜像和多端口镜像，镜像端口在不丢失数据的前提下应保证系统要求的转发速率。\n\n Step\t\t\t:\t测试步骤1: 测试帧长度为 64 字节，测试时间不小于 30s；\n                   测试步骤2: 测试配置图如图 7 所示，交换机端口 4 设置成镜像端口，端口 1 和端口 3设置成被镜像端口，镜像方式为输入和输出同时镜像；\n                   测试步骤3: 端口 1 向端口 2 双向发送数据，端口 2 和端口 3 双向发送数据，负载率分别为 25%；\n\n Criteria    \t:   预期结果1: 记录端口 4 接收到的数据帧数量，判断镜像功能是否设置成功。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_25%')\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=25, Seconds=30)\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 流量\n    edit_port_load_profile(Ports=port2, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan200_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 25)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan100_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_stream_load_profile(Streams=stream, Rate= 25)\n\n    # 端口3创建绑定1-》2 绑定流量\n    edit_port_load_profile(Ports=port3, TransmitMode='TIME', Rate=25, Seconds=30)\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        #清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        result = get_port_statistic(StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port1_Result = get_port_statistic(Port=port1, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port3_Result = get_port_statistic(Port=port3, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port4_Result = get_port_statistic(Port=port4, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        MirrotFrames = Port1_Result['TxStreamFrames']+Port1_Result['RxSignatureStreamFrames']+Port3_Result['TxStreamFrames']+Port3_Result['RxSignatureStreamFrames']\n        RX_Result=Port4_Result['RxSignatureStreamFrames']\n        if MirrotFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is not equal to 0',\n                step=3, result=True)\n\n        if  MirrotFrames == RX_Result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is not equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_port_statistic:获取测试仪表端口统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_7/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.7 网络风暴抑制: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示；\n                   测试步骤2: 测试帧长设为64，端口负载为满负载，测试时间30s；\n                   测试步骤3: 交换机分别开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能；\n                   测试步骤4: 使用默认抑制值或者设置抑制值为1M；\n                   测试步骤5: 端口1 向端口2 发送3 条数据流，分别为Stream1（广播帧）、Stream2（广播帧）、Stream3（IPv4 帧），端口2 向端口1 发送2 条数据流，分别为Stream1（组播帧）、Stream2（未知单播帧）；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断网络风暴抑制功能是否设置成功；\n                   测试步骤7: 根据帧丢失率，计算网络风暴抑制比偏差。\n\n Criteria    \t:   预期结果1: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启；\n                   预期结果2: 网络风暴实际抑制值不应超过抑制设定值的110%。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        expected_value = 0.1 * 1.1\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 3 * 2\n\n            if round(prss, 2) < expected_value:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 2\n            if round(prss, 2) < expected_value:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并预约端口资源\",\n  \"子任务2\": \"配置交换机开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，设置抑制值为1Mbps\",\n  \"子任务3\": \"设置测试仪表端口参数：帧长64字节，负载率100%，测试时间30秒\",\n  \"子任务4\": \"在端口1创建三条数据流：两条广播帧流，一条IPv4帧流\",\n  \"子任务5\": \"在端口2创建两条数据流：一条组播帧流，一条未知单播帧流\",\n  \"子任务6\": \"订阅流模板块统计视图并保存测试配置\",\n  \"子任务7\": \"启动端口1流量，获取流统计结果并计算帧丢失率\",\n  \"子任务8\": \"验证端口1广播帧流的实际抑制值不超过设定值110%，IPv4帧无丢包\",\n  \"子任务9\": \"清除统计结果后启动端口2流量，获取流统计结果\",\n  \"子任务10\": \"验证端口2组播帧和未知单播帧的实际抑制值不超过设定值110%\",\n  \"子任务11\": \"计算网络风暴抑制比偏差并记录测试结果\",\n  \"子任务12\": \"释放端口资源并关闭测试仪表\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.7 网络风暴抑制: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示；\n                   测试步骤2: 测试帧长设为64，端口负载为满负载，测试时间30s；\n                   测试步骤3: 交换机分别开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能；\n                   测试步骤4: 使用默认抑制值或者设置抑制值为1M；\n                   测试步骤5: 端口1 向端口2 发送3 条数据流，分别为Stream1（广播帧）、Stream2（广播帧）、Stream3（IPv4 帧），端口2 向端口1 发送2 条数据流，分别为Stream1（组播帧）、Stream2（未知单播帧）；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断网络风暴抑制功能是否设置成功；\n                   测试步骤7: 根据帧丢失率，计算网络风暴抑制比偏差。\n\n Criteria    \t:   预期结果1: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启；\n                   预期结果2: 网络风暴实际抑制值不应超过抑制设定值的110%。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        expected_value = 0.1 * 1.1\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 3 * 2\n\n            if round(prss, 2) < expected_value:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 2\n            if round(prss, 2) < expected_value:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_6/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  开放式最短路径优先路由协议（OSPF)\n\n Step\t\t\t:\t测试步骤1: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24；\n                   测试步骤2: DUT port1 IP地址为192.168.1.1/24，port2为 192.168.2.1/24；\n                   测试步骤3: 在DUT上配置OSPFv2路由协议；\n                   测试步骤4: 测试仪tester使用port1、port2建立OSPF路由器，在port1插入一些LSA，并使port1和DUT的port1达到FULL状态，port2和DUT的port2达到FULL状态，观察port2是否能得到port1的LSA。\n\n Criteria    \t:   预期结果1: ospf建立成功，可以收到lsa\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    #创建ospf协议\n    session_1 = create_ospf(Port=port_up, Priority=1)\n    session_2 = create_ospf(Port=port_down, Priority=2)\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    # OSPFv2协议会话1创建Summary Lsa\n    summary_lsa = create_ospf_summary_lsa(Session=session_1)\n\n    # OSPFv2协议会话2创建External Lsa\n    external_lsa = create_ospf_external_lsa(Session=session_2)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=summary_lsa)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        advertise_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n\n        # 发送流量\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        withdraw_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n        stop_protocol()\n        time.sleep(3)\n\n        # 获取OSPFv2会话1统计\n        import pandas\n        result = get_ospf_statistic()\n        print(result)\n        if not isinstance(result, pandas.DataFrame):\n            verdict = 'fail'\n\n        result = get_ospf_statistic(Session=session_1)\n        print(result)\n        TxSummaryLsa = result['TxSummaryLsa']\n        RxAsExternalLsa = result['RxAsExternalLsa']\n        print('TxSummaryLsa: {}'.format(TxSummaryLsa))\n        print('RxAsExternalLsa: {}'.format(RxAsExternalLsa))\n\n        # 获取OSPFv2会话2统计\n        result = get_ospf_statistic(Session=session_2)\n        print(result)\n        RxSummaryLsa = result['RxSummaryLsa']\n        TxAsExternalLsa = result['TxAsExternalLsa']\n        print('RxSummaryLsa: {}'.format(RxSummaryLsa))\n        print('TxAsExternalLsa: {}'.format(TxAsExternalLsa))\n\n        # 获取流量1统计\n        result = get_streamblock_statistic(Stream=streams[0])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name,TxStreamFrames,RxStreamFrames)\n\n        # 获取流量2统计\n\n        result = get_streamblock_statistic(Stream=streams[1])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name,TxStreamFrames,RxStreamFrames)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_ospf_lsa:通告 OSPFv2 协议会话 lsa",
      "create_ospf:创建OSPFv2协议会话对象",
      "create_ospf_external_lsa:创建OSPFv2 External LSA对象",
      "create_ospf_summary_lsa:创建OSPFv2 Summary LSA对象",
      "get_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象",
      "get_ospf_statistic:获取OSPFv2协议会话统计结果",
      "wait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态",
      "withdraw_ospf_lsa:撤销OSPFv2协议会话lsa",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表。\",\n  \"子任务2\": \"预约测试仪表端口1和端口2。\",\n  \"子任务3\": \"修改测试仪表端口参数（如速率、双工模式等）。\",\n  \"子任务4\": \"等待测试仪表端口链路状态变为Up。\",\n  \"子任务5\": \"在测试仪端口1创建接口，设置MAC地址和IPv4地址为192.168.1.100/24，网关为192.168.1.1。\",\n  \"子任务6\": \"在测试仪端口2创建接口，设置MAC地址和IPv4地址为192.168.2.100/24，网关为192.168.2.1。\",\n  \"子任务7\": \"在测试仪端口1创建OSPFv2协议会话对象。\",\n  \"子任务8\": \"在测试仪端口2创建OSPFv2协议会话对象。\",\n  \"子任务9\": \"将OSPFv2协议会话分别绑定到对应接口。\",\n  \"子任务10\": \"在测试仪端口1的OSPF会话上创建Summary LSA。\",\n  \"子任务11\": \"启动OSPFv2协议。\",\n  \"子任务12\": \"等待测试仪端口1与DUT端口1的OSPF邻接状态达到FULL。\",\n  \"子任务13\": \"等待测试仪端口2与DUT端口2的OSPF邻接状态达到FULL。\",\n  \"子任务14\": \"通告测试仪端口1上创建的Summary LSA。\",\n  \"子任务15\": \"等待5秒确保LSA传播。\",\n  \"子任务16\": \"获取测试仪端口2的OSPF会话统计信息。\",\n  \"子任务17\": \"验证端口2接收到的Summary LSA数量（RxSummaryLsa）大于0。\",\n  \"子任务18\": \"停止OSPFv2协议。\",\n  \"子任务19\": \"释放测试仪表端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 :  开放式最短路径优先路由协议（OSPF)\n\n Step\t\t\t:\t测试步骤1: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24；\n                   测试步骤2: DUT port1 IP地址为192.168.1.1/24，port2为 192.168.2.1/24；\n                   测试步骤3: 在DUT上配置OSPFv2路由协议；\n                   测试步骤4: 测试仪tester使用port1、port2建立OSPF路由器，在port1插入一些LSA，并使port1和DUT的port1达到FULL状态，port2和DUT的port2达到FULL状态，观察port2是否能得到port1的LSA。\n\n Criteria    \t:   预期结果1: ospf建立成功，可以收到lsa\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    #创建ospf协议\n    session_1 = create_ospf(Port=port_up, Priority=1)\n    session_2 = create_ospf(Port=port_down, Priority=2)\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    # OSPFv2协议会话1创建Summary Lsa\n    summary_lsa = create_ospf_summary_lsa(Session=session_1)\n\n    # OSPFv2协议会话2创建External Lsa\n    external_lsa = create_ospf_external_lsa(Session=session_2)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=summary_lsa)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        advertise_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n\n        # 发送流量\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        withdraw_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n        stop_protocol()\n        time.sleep(3)\n\n        # 获取OSPFv2会话1统计\n        import pandas\n        result = get_ospf_statistic()\n        print(result)\n        if not isinstance(result, pandas.DataFrame):\n            verdict = 'fail'\n\n        result = get_ospf_statistic(Session=session_1)\n        print(result)\n        TxSummaryLsa = result['TxSummaryLsa']\n        RxAsExternalLsa = result['RxAsExternalLsa']\n        print('TxSummaryLsa: {}'.format(TxSummaryLsa))\n        print('RxAsExternalLsa: {}'.format(RxAsExternalLsa))\n\n        # 获取OSPFv2会话2统计\n        result = get_ospf_statistic(Session=session_2)\n        print(result)\n        RxSummaryLsa = result['RxSummaryLsa']\n        TxAsExternalLsa = result['TxAsExternalLsa']\n        print('RxSummaryLsa: {}'.format(RxSummaryLsa))\n        print('TxAsExternalLsa: {}'.format(TxAsExternalLsa))\n\n        # 获取流量1统计\n        result = get_streamblock_statistic(Stream=streams[0])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name,TxStreamFrames,RxStreamFrames)\n\n        # 获取流量2统计\n\n        result = get_streamblock_statistic(Stream=streams[1])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name,TxStreamFrames,RxStreamFrames)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_ospf_lsa:通告 OSPFv2 协议会话 lsa;\ncreate_ospf:创建OSPFv2协议会话对象;\ncreate_ospf_external_lsa:创建OSPFv2 External LSA对象;\ncreate_ospf_summary_lsa:创建OSPFv2 Summary LSA对象;\nget_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象;\nget_ospf_statistic:获取OSPFv2协议会话统计结果;\nwait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态;\nwithdraw_ospf_lsa:撤销OSPFv2协议会话lsa;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_4/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  6.7.4静态路由\n\n Step\t\t\t:\t测试步骤1: ：按图搭建测试环境\n                   测试步骤2: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24\n                   测试步骤3:  DUT1 port1 IP地址为192.168.1.1/24，port2 为1.1.1.1/24；\n                   测试步骤4:  DUT2 port2 IP地址为192.168.2.1/24，port1 为1.1.1.2/24；\n                   测试步骤5: 在DUT1、DUT2上配置tester port1和port2之间的静态路由；\n                   测试步骤6: 测试仪tester使用port1、port2发送双向数据流，检验连通性\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import time\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    sip_address_list = ['192.168.1.100','192.168.2.100']\n    dip_address_list = ['192.168.3.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'stream1_2')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0])\n\n    stream = add_stream(Ports=port_down, Names=f'stream2_1')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[1], Destination=dip_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        if RxStreamFrames == TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is avaliable',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is not avaliable',\n                step=6, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试仪的控制连接。\",\n  \"子任务2\": \"预约测试仪端口 port1 和 port2，准备测试资源。\",\n  \"子任务3\": \"配置测试仪端口参数，包括强制模式和调试模式设置。\",\n  \"子任务4\": \"在 port1 上创建网络接口，设置 MAC 地址为配置值，IPv4 地址为 192.168.1.100/24，网关为 192.168.1.1。\",\n  \"子任务5\": \"在 port2 上创建网络接口，设置 MAC 地址为配置值，IPv4 地址为 192.168.2.100/24，网关为 192.168.2.1。\",\n  \"子任务6\": \"编辑端口负载配置文件，设置传输模式为时间模式，速率100%，持续时间30秒。\",\n  \"子任务7\": \"在 port1 创建流量流 stream1_2，设置固定帧长128字节，配置以太网和IPv4头部，源IP 192.168.1.100，目的IP 192.168.3.1。\",\n  \"子任务8\": \"在 port2 创建流量流 stream2_1，设置固定帧长128字节，配置以太网和IPv4头部，源IP 192.168.2.100，目的IP 192.168.3.1。\",\n  \"子任务9\": \"订阅端口统计和流模块统计视图，准备收集测试数据。\",\n  \"子任务10\": \"保存当前测试用例配置文件。\",\n  \"子任务11\": \"在 port1 和 port2 同时启动流量发送。\",\n  \"子任务12\": \"等待流量发送状态稳定，确保测试充分执行。\",\n  \"子任务13\": \"获取 stream1_2 和 stream2_1 的流统计结果，包括发送帧数(TxStreamFrames)和接收帧数(RxStreamFrames)。\",\n  \"子任务14\": \"验证 port1 发送帧数是否大于0，确认流量正常发送。\",\n  \"子任务15\": \"验证接收帧数是否等于发送帧数，确认双向连通性无丢包。\",\n  \"子任务16\": \"清除测试仪表统计结果，重置计数。\",\n  \"子任务17\": \"释放测试仪端口资源，完成测试清理。\",\n  \"子任务18\": \"关闭测试仪表连接，结束测试会话。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 :  6.7.4静态路由\n\n Step\t\t\t:\t测试步骤1: ：按图搭建测试环境\n                   测试步骤2: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24\n                   测试步骤3:  DUT1 port1 IP地址为192.168.1.1/24，port2 为1.1.1.1/24；\n                   测试步骤4:  DUT2 port2 IP地址为192.168.2.1/24，port1 为1.1.1.2/24；\n                   测试步骤5: 在DUT1、DUT2上配置tester port1和port2之间的静态路由；\n                   测试步骤6: 测试仪tester使用port1、port2发送双向数据流，检验连通性\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    sip_address_list = ['192.168.1.100','192.168.2.100']\n    dip_address_list = ['192.168.3.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'stream1_2')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0])\n\n    stream = add_stream(Ports=port_down, Names=f'stream2_1')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[1], Destination=dip_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        if RxStreamFrames == TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is avaliable',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is not avaliable',\n                step=6, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_1/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.1 虚拟局域网 VLAN 功能\n\n Step\t\t\t:\t测试步骤1: 测试帧长度为 128 字节，测试时间为 30；\n                   测试步骤2: 任意选取 3 个端口与测试仪相连接，测试配置图如图 6 所示；\n                   测试步骤3: 在测试仪端口 3 上构造 7 个数据流；\n                   测试步骤4: 交换机端口均设置为 untagged，端口 A 设置为 VLAN100，端口 B 设置为 VLAN4094，端口 C 设置为 TRUNK 口、VLAN1，其他端口默认设；\n                   测试步骤5: 网络测试仪端口 3 向端口 1、端口 2 分别以 10%负载发送数；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断 VLAN 是否划分成功；\n                   测试步骤7: 在测试仪端口 1、端口 2 上构造以上 7 个数据；\n                   测试步骤8: 端口 1、端口 2 分别向端口 3 以 10%负载发送数据；\n                   测试步骤9: 记录不同数据流的帧丢失率，判断 VLAN TRUNK 是否成功。\n\n Criteria    \t:   预期结果1: 测试仪发送到交换机的数据流，若 VLAN ID 不同，则交换机丢弃该数据流（入口不透传）或转发至相应 VLAN 端口（入口透传）；若相同则转发至相同 VLAN 的端口。广播风暴仅可在 VLAN 内广播。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n\n    # 端口1创建流量\n    mac_address_list = ['00:02:00:00:00:01', '00:02:00:00:00:02', '00:02:00:00:00:03']\n    vlan_id_list = [100, 4094, 1]\n\n    # interfaces_1 = create_interface(Port=ports[0], Layers=['eth', 'vlan'])\n    # interfaces_2 = create_interface(Port=ports[1], Layers=['eth', 'vlan'])\n    # interfaces_3 = create_interface(Port=ports[2], Layers=['eth', 'vlan'])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[2])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[2])\n\n    streams = {}\n    # 端口创建7条流量\n    number = -1\n    for port in ports:\n        number += 1\n        test_mac_address = mac_address_list.copy()\n        source_mac = test_mac_address.pop(number)\n        # 数据流 1：无 VID 标识 IPv4 报文\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 2：VID 为 100 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 3：VID 为 4094 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 4：无 VID 标识的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n        # 数据流 5：VID 为 100 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 6：VID 为 4094 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 7：广播报文，无 VID 标识；\n        stream_port1_VID_100 = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Broadcast')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream_port1_VID_100, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream_port1_VID_100, SourceMacAdd=source_mac,\n                                      DestMacAdd='ff:ff:ff:ff:ff:ff')\n        streams.update({stream[0].Name: stream})\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 步骤5：端口3发流量测试\n        printf(message='step5：port3 start stream')\n        start_stream(Type='port', Objects=ports[2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step6：get port3 stream statistic')\n        # 获取端口3下所有流量统计结果\n        streams_obj = get_streams(ports[2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=6, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=6, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0', step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0', step=6,\n                        result=False)\n            if 'VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_1':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n            if 'VID_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n        clear_result()\n        # 步骤8：端口1，2发流量测试\n        printf(message='step8：port1,port2 start stream')\n        start_stream(Type='port', Objects=ports[:2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，3口收到报文\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=9, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=9, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}))',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=9, result=False)\n            if 'Port_1_VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_3':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            if 'Port_2_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            else:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0,RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0',\n                        step=9, result=True)\n\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试仪的连接\",\n  \"子任务2\": \"预约测试仪表的三个端口（端口1、端口2、端口3）并获取端口对象\",\n  \"子任务3\": \"配置测试仪表端口参数：设置传输模式为时间模式，速率10%，持续时间30秒\",\n  \"子任务4\": \"在测试仪表每个端口创建7条数据流：无VLAN IPv4单播、VLAN100 IPv4单播、VLAN4094 IPv4单播、无VLAN组播、VLAN100组播、VLAN4094组播、无VLAN广播，固定帧长128字节\",\n  \"子任务5\": \"配置交换机端口：端口1设置为untagged VLAN100，端口2设置为untagged VLAN4094，端口3设置为TRUNK口允许VLAN1\",\n  \"子任务6\": \"订阅流模板块统计视图用于结果收集\",\n  \"子任务7\": \"启动测试仪端口3的所有数据流发送（10%负载）\",\n  \"子任务8\": \"等待端口3数据流发送完成\",\n  \"子任务9\": \"获取端口3每条流的统计信息（发送帧数、接收帧数、接收端口等）\",\n  \"子任务10\": \"验证VLAN划分结果：无VLAN流应丢弃，VLAN100流应被端口1接收，VLAN4094流应被端口2接收，组播/广播按VLAN规则转发\",\n  \"子任务11\": \"清除测试仪表统计结果\",\n  \"子任务12\": \"启动测试仪端口1和端口2的所有数据流发送（10%负载）\",\n  \"子任务13\": \"等待端口1和端口2数据流发送完成\",\n  \"子任务14\": \"获取端口1和端口2每条流的统计信息\",\n  \"子任务15\": \"验证VLAN TRUNK功能：相同VLAN流应被端口3接收，不同VLAN流应丢弃，广播限于VLAN内\",\n  \"子任务16\": \"释放测试仪表端口资源并关闭测试仪连接\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.1 虚拟局域网 VLAN 功能\n\n Step\t\t\t:\t测试步骤1: 测试帧长度为 128 字节，测试时间为 30；\n                   测试步骤2: 任意选取 3 个端口与测试仪相连接，测试配置图如图 6 所示；\n                   测试步骤3: 在测试仪端口 3 上构造 7 个数据流；\n                   测试步骤4: 交换机端口均设置为 untagged，端口 A 设置为 VLAN100，端口 B 设置为 VLAN4094，端口 C 设置为 TRUNK 口、VLAN1，其他端口默认设；\n                   测试步骤5: 网络测试仪端口 3 向端口 1、端口 2 分别以 10%负载发送数；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断 VLAN 是否划分成功；\n                   测试步骤7: 在测试仪端口 1、端口 2 上构造以上 7 个数据；\n                   测试步骤8: 端口 1、端口 2 分别向端口 3 以 10%负载发送数据；\n                   测试步骤9: 记录不同数据流的帧丢失率，判断 VLAN TRUNK 是否成功。\n\n Criteria    \t:   预期结果1: 测试仪发送到交换机的数据流，若 VLAN ID 不同，则交换机丢弃该数据流（入口不透传）或转发至相应 VLAN 端口（入口透传）；若相同则转发至相同 VLAN 的端口。广播风暴仅可在 VLAN 内广播。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n\n    # 端口1创建流量\n    mac_address_list = ['00:02:00:00:00:01', '00:02:00:00:00:02', '00:02:00:00:00:03']\n    vlan_id_list = [100, 4094, 1]\n\n    # interfaces_1 = create_interface(Port=ports[0], Layers=['eth', 'vlan'])\n    # interfaces_2 = create_interface(Port=ports[1], Layers=['eth', 'vlan'])\n    # interfaces_3 = create_interface(Port=ports[2], Layers=['eth', 'vlan'])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[2])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[2])\n\n    streams = {}\n    # 端口创建7条流量\n    number = -1\n    for port in ports:\n        number += 1\n        test_mac_address = mac_address_list.copy()\n        source_mac = test_mac_address.pop(number)\n        # 数据流 1：无 VID 标识 IPv4 报文\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 2：VID 为 100 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 3：VID 为 4094 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 4：无 VID 标识的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n        # 数据流 5：VID 为 100 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 6：VID 为 4094 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 7：广播报文，无 VID 标识；\n        stream_port1_VID_100 = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Broadcast')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream_port1_VID_100, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream_port1_VID_100, SourceMacAdd=source_mac,\n                                      DestMacAdd='ff:ff:ff:ff:ff:ff')\n        streams.update({stream[0].Name: stream})\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 步骤5：端口3发流量测试\n        printf(message='step5：port3 start stream')\n        start_stream(Type='port', Objects=ports[2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step6：get port3 stream statistic')\n        # 获取端口3下所有流量统计结果\n        streams_obj = get_streams(ports[2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=6, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=6, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0', step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0', step=6,\n                        result=False)\n            if 'VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_1':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n            if 'VID_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n        clear_result()\n        # 步骤8：端口1，2发流量测试\n        printf(message='step8：port1,port2 start stream')\n        start_stream(Type='port', Objects=ports[:2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，3口收到报文\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=9, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=9, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}))',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=9, result=False)\n            if 'Port_1_VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_3':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            if 'Port_2_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            else:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0,RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0',\n                        step=9, result=True)\n\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_3/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.3 端口吞吐量\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2544 中规定，将交换机任意两个同类型端口与测试仪相连接，见图 3；\n                   测试步骤2: 配置流量发生器：测试帧长度分别为（64、65、256、1024、1518）字节；\n                   测试步骤3: 测试时间为 60s。\n\n Criteria    \t:   预期结果1: 技术要求吞吐量为100%。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\nimport time\n\nstart_time=time.time()\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_search(Config=Config, Mode='binary', Init=cfg['arg']['search']['default']['init']['default'],\n                          Lower=cfg['arg']['search']['default']['lower']['default'], Upper=cfg['arg']['search']['default']['upper']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表（init_tester），准备测试环境。\",\n  \"子任务2\": \"获取测试端口位置信息（get_locations），确定连接配置。\",\n  \"子任务3\": \"预约测试仪表端口（reserve_port），确保端口资源可用。\",\n  \"子任务4\": \"编辑端口参数（edit_port），根据测试需求配置端口属性。\",\n  \"子任务5\": \"等待端口状态就绪（wait_port_state），确保链路正常。\",\n  \"子任务6\": \"在端口上创建以太网接口（create_interface），建立通信基础。\",\n  \"子任务7\": \"编辑接口参数（edit_interface），配置MAC地址等必要信息。\",\n  \"子任务8\": \"获取接口的以太网层对象（get_layer_from_interfaces），用于流量绑定。\",\n  \"子任务9\": \"创建双向绑定流量（add_stream），连接源和目的端口。\",\n  \"子任务10\": \"创建RFC2544吞吐量测试套件（create_benchmark），指定测试类型。\",\n  \"子任务11\": \"关联测试套件与端口（relate_benchmark_ports），绑定测试资源。\",\n  \"子任务12\": \"配置测试套件使用现有流量（benchmark_stream_use_exist）。\",\n  \"子任务13\": \"设置地址学习参数（edit_benchmark_learning），频率为单次。\",\n  \"子任务14\": \"配置测试时长（edit_benchmark_duration），设置为60秒。\",\n  \"子任务15\": \"配置测试帧长度（edit_benchmark_frame），指定64/65/256/1024/1518字节。\",\n  \"子任务16\": \"配置负载搜索模式（edit_benchmark_search），使用二分法搜索。\",\n  \"子任务17\": \"生成测试套件配置（expand_benchmark），完成测试准备。\",\n  \"子任务18\": \"保存测试配置文件（save_case），持久化测试方案。\",\n  \"子任务19\": \"执行测试套件（run_benchmark），启动吞吐量测试。\",\n  \"子任务20\": \"获取测试结果数据（get_benchmark_result），提取RFC2544吞吐量指标。\",\n  \"子任务21\": \"验证测试结果：检查所有帧长度的吞吐量是否达到100%。\",\n  \"子任务22\": \"释放测试端口资源（release_port），清理测试环境。\",\n  \"子任务23\": \"关闭测试仪表进程（shutdown_tester），结束测试。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.3 端口吞吐量\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2544 中规定，将交换机任意两个同类型端口与测试仪相连接，见图 3；\n                   测试步骤2: 配置流量发生器：测试帧长度分别为（64、65、256、1024、1518）字节；\n                   测试步骤3: 测试时间为 60s。\n\n Criteria    \t:   预期结果1: 技术要求吞吐量为100%。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\nimport time\n\nstart_time=time.time()\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_search(Config=Config, Mode='binary', Init=cfg['arg']['search']['default']['init']['default'],\n                          Lower=cfg['arg']['search']['default']['lower']['default'], Upper=cfg['arg']['search']['default']['upper']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_4/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.4 存储转发时延\n\n Step\t\t\t:\t测试步骤1: 按照图 4，将交换机任意两个同类型端口与测试仪相连接；\n                   测试步骤2: 两个端口同时以相应负载互相发送数据，测试帧长度分别为（64、65、256、1024、1518）字节，测试时间为 60s；负载率设置为：重载 95%，轻载10%；\n                   测试步骤3: 记录不同帧长的平均存储转发时延。\n\n Criteria    \t:   预期结果1: 技术要求平均时延应小于10µs。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\nimport time\n\nstart_time=time.time()\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        print(\"111\",testbed['tester']['rtsm']['ip'])\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    print(\"port_up\",port_up)\n    print(\"port_down\", port_down)\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    for k, v in testbed['tester'].items():\n        edit_port_kwargs = {}\n        if k in edit_port_params:\n            edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    print(\"interfaces_up\", interfaces_up)\n    print(\"interfaces_down\", interfaces_down)\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['latency'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试仪的控制连接\",\n  \"子任务2\": \"预约测试仪的两个同类型端口，准备进行测试\",\n  \"子任务3\": \"配置端口参数（如速率、双工模式等），确保端口状态就绪\",\n  \"子任务4\": \"在端口1上创建以太网接口，设置源MAC地址\",\n  \"子任务5\": \"在端口2上创建以太网接口，设置目的MAC地址\",\n  \"子任务6\": \"获取两个端口的以太网层对象，用于流量构造\",\n  \"子任务7\": \"创建双向流量流，源为端口1，目的为端口2\",\n  \"子任务8\": \"创建RFC2544测试套件，指定测试类型为时延测量\",\n  \"子任务9\": \"关联测试套件与两个测试端口\",\n  \"子任务10\": \"配置测试套件使用已创建的流量流\",\n  \"子任务11\": \"设置地址学习模式为单次学习并启用\",\n  \"子任务12\": \"配置测试时长为60秒\",\n  \"子任务13\": \"配置测试帧长度序列为[64, 65, 256, 1024, 1518]字节\",\n  \"子任务14\": \"配置流量负载序列为[10%, 95%]，使用百分比负载单位\",\n  \"子任务15\": \"生成完整的测试套件配置\",\n  \"子任务16\": \"执行测试套件，启动流量发送并测量时延\",\n  \"子任务17\": \"从测试结果数据库中获取RFC2544时延数据\",\n  \"子任务18\": \"验证不同帧长和负载下的平均时延是否小于10µs\",\n  \"子任务19\": \"释放测试端口资源\",\n  \"子任务20\": \"关闭测试仪表连接\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.4 存储转发时延\n\n Step\t\t\t:\t测试步骤1: 按照图 4，将交换机任意两个同类型端口与测试仪相连接；\n                   测试步骤2: 两个端口同时以相应负载互相发送数据，测试帧长度分别为（64、65、256、1024、1518）字节，测试时间为 60s；负载率设置为：重载 95%，轻载10%；\n                   测试步骤3: 记录不同帧长的平均存储转发时延。\n\n Criteria    \t:   预期结果1: 技术要求平均时延应小于10µs。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\nimport time\n\nstart_time=time.time()\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        print(\"111\",testbed['tester']['rtsm']['ip'])\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    print(\"port_up\",port_up)\n    print(\"port_down\", port_down)\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    for k, v in testbed['tester'].items():\n        edit_port_kwargs = {}\n        if k in edit_port_params:\n            edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    print(\"interfaces_up\", interfaces_up)\n    print(\"interfaces_down\", interfaces_down)\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['latency'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_2/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  6.7.2互联网控制消息协议（ICMP）\n\n Step\t\t\t:\t测试步骤1: ：按图10搭建测试环境\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为192.168.2.100/24\n                   测试步骤3: DUT port1 地址为192.168.1.1/24，port2 地址为192.168.2.1/24\n                   测试步骤4: tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n                   测试步骤5: tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n                   测试步骤6: tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n                   测试步骤7: tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # edit_port_load_profile(Ports=port_up, TransmitMode='TIME', Rate=1, Seconds=30)\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['192.168.3.1 ','192.168.1.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'step5')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0], Gateway='192.168.1.1')\n\n    # step6 tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n    stream = add_stream(Ports=port_up, Names=f'step6')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=100, Gateway='192.168.1.1')\n\n    # step7 tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n    stream = add_stream(Ports=port_up, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=17, Gateway='192.168.1.1')\n    edit_header_udp(Stream=stream, SourcePort=100)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.1.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n\n        stream1, stream2, stream3 = get_streams(Ports=port_up)\n        # 端口1测试\n        net_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step5', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '0' and pkt.icmp.type == '3':\n                net_unreached_pkt.append(pkt)\n\n        if len(net_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到网络不可达报文，类型为 3，编码为 0',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到网络不可达报文',\n                step=5, result=False)\n\n        protocol_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '2' and pkt.icmp.type == '3':\n                protocol_unreached_pkt.append(pkt)\n        if len(protocol_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到协议不可达报文，类型为 3，编码为 2',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到协议不可达报文',\n                step=6, result=False)\n\n        port_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream3)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '3' and pkt.icmp.code == '3':\n                port_unreached_pkt.append(pkt)\n\n        if len(port_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到端口不可达报文，类型为 3，编码为 3',\n                step=7, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到端口不可达报文',\n                step=7, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "edit_header_udp:修改测试仪表流量模板中UDP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l3_learning:启动测试仪表流量三层ARP ND学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试设备的连接。\",\n  \"子任务2\": \"预约测试仪端口资源，获取端口位置信息。\",\n  \"子任务3\": \"配置测试仪端口参数，包括强制模式和调试状态。\",\n  \"子任务4\": \"等待测试仪端口链路状态变为UP。\",\n  \"子任务5\": \"在端口1上创建IPv4接口，设置地址为192.168.1.100/24，网关为192.168.1.1。\",\n  \"子任务6\": \"在端口2上创建IPv4接口，设置地址为192.168.2.100/24，网关为192.168.2.1。\",\n  \"子任务7\": \"编辑端口负载配置文件，设置传输模式为连续发送，速率为100帧/秒。\",\n  \"子任务8\": \"执行ICMP连通性测试：从端口1向192.168.1.1发送ping包，验证是否收到响应。\",\n  \"子任务9\": \"配置测试流1：创建目的IP为192.168.3.1的IPv4流，帧长128字节。\",\n  \"子任务10\": \"启动三层学习，准备端口1的抓包功能。\",\n  \"子任务11\": \"发送测试流1，捕获端口1的响应报文。\",\n  \"子任务12\": \"分析抓包结果，验证是否收到ICMP类型3编码0（网络不可达）报文。\",\n  \"子任务13\": \"配置测试流2：创建目的IP为192.168.1.1、协议号100的IPv4流，帧长128字节。\",\n  \"子任务14\": \"启动三层学习，准备端口1的抓包功能。\",\n  \"子任务15\": \"发送测试流2，捕获端口1的响应报文。\",\n  \"子任务16\": \"分析抓包结果，验证是否收到ICMP类型3编码2（协议不可达）报文。\",\n  \"子任务17\": \"配置测试流3：创建目的IP为192.168.1.1、协议号17、源端口100的UDP流，帧长128字节。\",\n  \"子任务18\": \"启动三层学习，准备端口1的抓包功能。\",\n  \"子任务19\": \"发送测试流3，捕获端口1的响应报文。\",\n  \"子任务20\": \"分析抓包结果，验证是否收到ICMP类型3编码3（端口不可达）报文。\",\n  \"子任务21\": \"释放测试仪端口资源，关闭仪表连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 :  6.7.2互联网控制消息协议（ICMP）\n\n Step\t\t\t:\t测试步骤1: ：按图10搭建测试环境\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为192.168.2.100/24\n                   测试步骤3: DUT port1 地址为192.168.1.1/24，port2 地址为192.168.2.1/24\n                   测试步骤4: tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n                   测试步骤5: tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n                   测试步骤6: tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n                   测试步骤7: tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # edit_port_load_profile(Ports=port_up, TransmitMode='TIME', Rate=1, Seconds=30)\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['192.168.3.1 ','192.168.1.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'step5')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0], Gateway='192.168.1.1')\n\n    # step6 tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n    stream = add_stream(Ports=port_up, Names=f'step6')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=100, Gateway='192.168.1.1')\n\n    # step7 tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n    stream = add_stream(Ports=port_up, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=17, Gateway='192.168.1.1')\n    edit_header_udp(Stream=stream, SourcePort=100)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.1.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n\n        stream1, stream2, stream3 = get_streams(Ports=port_up)\n        # 端口1测试\n        net_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step5', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '0' and pkt.icmp.type == '3':\n                net_unreached_pkt.append(pkt)\n\n        if len(net_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到网络不可达报文，类型为 3，编码为 0',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到网络不可达报文',\n                step=5, result=False)\n\n        protocol_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '2' and pkt.icmp.type == '3':\n                protocol_unreached_pkt.append(pkt)\n        if len(protocol_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到协议不可达报文，类型为 3，编码为 2',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到协议不可达报文',\n                step=6, result=False)\n\n        port_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream3)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '3' and pkt.icmp.code == '3':\n                port_unreached_pkt.append(pkt)\n\n        if len(port_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到端口不可达报文，类型为 3，编码为 3',\n                step=7, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到端口不可达报文',\n                step=7, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nedit_header_udp:修改测试仪表流量模板中UDP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l3_learning:启动测试仪表流量三层ARP ND学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_5/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.5 帧丢失率\n\n Step\t\t\t:\t测试步骤1: 按照图 4，将交换机任意两个同类型端口与测试仪相连接；\n                   测试步骤2: 两个端口同时互相发送数据，测试帧长度分别为（64、65、256、1024、1518）字节，测试时间为 60s；负载率设置为 100%；\n                   测试步骤3: 记录不同帧长的丢包率。\n\n Criteria    \t:   预期结果1: 技术要求在端口转发速率达到 100%的情况下，丢包率应为0。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['frameloss'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试仪的控制连接。\",\n  \"子任务2\": \"预约测试仪的两个端口，对应交换机两个同类型端口。\",\n  \"子任务3\": \"配置测试仪端口参数，确保满足测试要求。\",\n  \"子任务4\": \"等待端口链路状态达到Up状态。\",\n  \"子任务5\": \"在两个端口上分别创建以太网接口。\",\n  \"子任务6\": \"配置接口的MAC地址参数。\",\n  \"子任务7\": \"获取接口的以太网封装层对象。\",\n  \"子任务8\": \"创建双向流量流，实现端口互相发送数据。\",\n  \"子任务9\": \"创建RFC2544测试套件，指定测试类型为帧丢失率。\",\n  \"子任务10\": \"关联测试套件与预约的测试端口。\",\n  \"子任务11\": \"配置测试套件使用已创建的流量流。\",\n  \"子任务12\": \"配置测试套件的地址学习参数（频率为once）。\",\n  \"子任务13\": \"设置测试时长为60秒。\",\n  \"子任务14\": \"配置测试帧长度：64、65、256、1024、1518字节。\",\n  \"子任务15\": \"配置负载率为100%（负载模式为custom）。\",\n  \"子任务16\": \"生成测试套件配置。\",\n  \"子任务17\": \"保存测试配置文件。\",\n  \"子任务18\": \"执行测试套件，运行帧丢失率测试。\",\n  \"子任务19\": \"获取测试结果数据（RFC2544类型）。\",\n  \"子任务20\": \"记录不同帧长的丢包率结果数据。\",\n  \"子任务21\": \"验证丢包率是否为0（端口转发速率100%条件下）。\",\n  \"子任务22\": \"释放测试端口资源。\",\n  \"子任务23\": \"关闭测试仪表连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.5 帧丢失率\n\n Step\t\t\t:\t测试步骤1: 按照图 4，将交换机任意两个同类型端口与测试仪相连接；\n                   测试步骤2: 两个端口同时互相发送数据，测试帧长度分别为（64、65、256、1024、1518）字节，测试时间为 60s；负载率设置为 100%；\n                   测试步骤3: 记录不同帧长的丢包率。\n\n Criteria    \t:   预期结果1: 技术要求在端口转发速率达到 100%的情况下，丢包率应为0。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['frameloss'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_2/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.2 优先级QoS\n\n Step\t\t\t:\t测试步骤1: 按图6，从交换机任意选取三个端口与测试仪相连接，分别定为端口1、端口2 和端口3，交换机配置为绝对优先级，交换机设置端口trunk模式保证不剥掉vlan1；\n                   测试步骤2: 端口1 和端口2 同时端口3 发送数据；\n                   测试步骤3: 在端口1 构造两条优先级分别为7 和5 的数据流，在端口2 构造两条优先级分别为3 和1 的数据流，vlan1 的优先级设置为7 和5，3 和1；\n                   测试步骤4: 测试帧长度为64 字节，测试时间30s，端口负荷设置为100%；\n                   测试步骤5: 记录不同数据流的帧丢失率，判断优先级是否设置成功。\n\n Criteria    \t:   预期结果1: 不同数据流的帧丢失率，与优先级设置一致。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    port1,port2,port3=ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建流量\n    # 数据流 1：qos优先级为 7 的 IPv4 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_7')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    edit_header_vlan(Stream=stream, Priority=7)\n    # 数据流 2：qos优先级为 5 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_5')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, Priority=5)\n\n    # 端口2创建流量\n    # 数据流 1：qos优先级为 3 的 IPv4 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_3')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, Priority=3)\n    # 数据流 2：qos优先级为 1 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_1')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[3])\n    edit_header_vlan(Stream=stream, Priority=1)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(5)\n        # 检查统计结果\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxPortID'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            TxPortID = Result['TxPortID']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=5, result=True)\n            if RxStreamFrames != TxStreamFrames:\n                if TxPortID == port2.Name:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=5, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试仪的连接。\",\n  \"子任务2\": \"预约测试仪端口，获取端口位置信息并绑定端口对象（端口1、端口2、端口3）。\",\n  \"子任务3\": \"导入交换机配置拓扑文件，设置交换机为绝对优先级模式并配置端口trunk模式保留VLAN1。\",\n  \"子任务4\": \"编辑测试仪端口负载参数：设置传输模式为时间模式，速率100%，持续时间30秒。\",\n  \"子任务5\": \"在端口1创建两条数据流：第一条设置VLAN优先级为7，帧长64字节；第二条设置VLAN优先级为5，帧长64字节；均指定接收端口为端口3。\",\n  \"子任务6\": \"在端口2创建两条数据流：第一条设置VLAN优先级为3，帧长64字节；第二条设置VLAN优先级为1，帧长64字节；均指定接收端口为端口3。\",\n  \"子任务7\": \"订阅流模板块统计视图，准备收集流量统计结果。\",\n  \"子任务8\": \"启动二层学习功能，建立MAC地址表。\",\n  \"子任务9\": \"同时启动端口1和端口2的所有数据流发送。\",\n  \"子任务10\": \"等待流量发送完成，确保测试持续30秒。\",\n  \"子任务11\": \"获取四条数据流的发送帧数和接收帧数统计结果。\",\n  \"子任务12\": \"计算每条数据流的帧丢失率：(发送帧数-接收帧数)/发送帧数。\",\n  \"子任务13\": \"验证优先级设置：检查端口1的两条流（优先级7和5）帧丢失率是否为0%，端口2的两条流（优先级3和1）帧丢失率是否大于0%。\",\n  \"子任务14\": \"清除测试仪统计结果，释放所有预约端口。\",\n  \"子任务15\": \"关闭测试仪表连接。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.2 优先级QoS\n\n Step\t\t\t:\t测试步骤1: 按图6，从交换机任意选取三个端口与测试仪相连接，分别定为端口1、端口2 和端口3，交换机配置为绝对优先级，交换机设置端口trunk模式保证不剥掉vlan1；\n                   测试步骤2: 端口1 和端口2 同时端口3 发送数据；\n                   测试步骤3: 在端口1 构造两条优先级分别为7 和5 的数据流，在端口2 构造两条优先级分别为3 和1 的数据流，vlan1 的优先级设置为7 和5，3 和1；\n                   测试步骤4: 测试帧长度为64 字节，测试时间30s，端口负荷设置为100%；\n                   测试步骤5: 记录不同数据流的帧丢失率，判断优先级是否设置成功。\n\n Criteria    \t:   预期结果1: 不同数据流的帧丢失率，与优先级设置一致。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    port1,port2,port3=ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建流量\n    # 数据流 1：qos优先级为 7 的 IPv4 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_7')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    edit_header_vlan(Stream=stream, Priority=7)\n    # 数据流 2：qos优先级为 5 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_5')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, Priority=5)\n\n    # 端口2创建流量\n    # 数据流 1：qos优先级为 3 的 IPv4 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_3')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, Priority=3)\n    # 数据流 2：qos优先级为 1 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_1')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[3])\n    edit_header_vlan(Stream=stream, Priority=1)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(5)\n        # 检查统计结果\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxPortID'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            TxPortID = Result['TxPortID']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=5, result=True)\n            if RxStreamFrames != TxStreamFrames:\n                if TxPortID == port2.Name:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=5, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_8/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :   6.7.8 互联网组管理协议（IGMP)\n\n Step\t\t\t:\t测试步骤1:  按图10建立测试环境；\n                   测试步骤2:  tester port1 地 址 为 192.168.1.100/24 ， port2 地 址 为192.168.2.100/24\n                   测试步骤3:  DUT port1 地址为192.168.1.1/24，port2 地址为192.168.2.1/24\n                   测试步骤4:   DUT 设置IGMPv2组播查询；\n                   测试步骤5:   tester 向port1 发目的地址为225.1.1.1，TTL=1的IGMPv2应答报文，其组地址域也为225.1.1.1，周期为1秒\n                   测试步骤6:   停止发送步骤5中的IGMPv2应答报文，观察交换机组播组成员变化；\n                   测试步骤7:    tester 向port1 发目的地址为225.1.1.1，TTL=1的IGMPv2应答报文，\n                               其组地址域也为225.1.1.1，周期为1秒，停止发送应答报文之后tester\n                               立刻向port1发目的地址为224.0.0.2，TTL=1的IGMPv2离开报文，其组地址域为225.1.1.1。观察交换机组播组成员变化\n                   测试步骤8:   停止发送步骤7中的报文；\n                   测试步骤9:   检查DUT配置，看是否支持IGMPv1、IGMPv2、IGMPv3\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_up, Version='IGMPV2')\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interfaces_up)\n\n    # 创建组播组\n    multicast_group = create_multicast_group(Start='225.1.1.1')\n\n    # IGMP协议会话创建组成员关系\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=port_down, Version='IGMPV2')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_down)\n\n    # 创建IGMP绑定流\n\n    # point = get_layer_from_interfaces(Interfaces=interfaces_down)\n    #\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints='224.0.0', Bidirection=False)\n\n\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        Rate=100,\n    #                        Unit='FRAME_PER_SEC',\n    #                        TransmitMode=\"STEP\",\n    #                        Frames=20)\n\n\n    #创建IGMPv2报文\n    # stream1 = add_stream(Ports=port_up, Names=f'igmpv2_report')\n    # edit_stream(Stream=stream1, FixedLength=128)\n    # create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4','igmpv2'])\n    # edit_header_ipv4(Stream=stream1, Source='192.168.1.100', Destination= '225.1.1.1', TTl=1)\n    #\n    # stream2 = add_stream(Ports=port_up, Names=f'igmpv2_query')\n    # edit_stream(Stream=stream2, FixedLength=128)\n    # create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4','igmpv2query'])\n    # edit_header_ipv4(Stream=stream2, Source='192.168.1.100', Destination= '224.0.0.2', TTl=1)\n\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        #停止协议\n        stop_protocol()\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_igmp:创建IGMP协议会话对象",
      "create_igmp_querier:创建IGMP Querier协议会话对象",
      "edit_igmp:编辑IGMP协议会话对象",
      "edit_igmp_querier:编辑IGMP Querier协议会话对象",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"配置测试仪端口参数：设置 port1 的 IPv4 地址为 192.168.1.100/24，网关为 192.168.1.1；设置 port2 的 IPv4 地址为 192.168.2.100/24，网关为 192.168.2.1。\",\n  \"子任务2\": \"在测试仪 port1 上创建 IPv4 接口并绑定 MAC 地址，在 port2 上创建 IPv4 接口并绑定 MAC 地址。\",\n  \"子任务3\": \"在 DUT 上配置端口参数：设置 port1 的 IPv4 地址为 192.168.1.1/24，设置 port2 的 IPv4 地址为 192.168.2.1/24。\",\n  \"子任务4\": \"在 DUT 上启用 IGMPv2 组播查询功能。\",\n  \"子任务5\": \"在测试仪 port1 上创建 IGMPv2 协议会话，绑定组播组 225.1.1.1，设置初始加入状态和周期报告间隔为 1 秒。\",\n  \"子任务6\": \"启动 IGMP 协议会话，发送目的地址为 225.1.1.1、TTL=1 的 IGMPv2 报告报文。\",\n  \"子任务7\": \"等待 IGMP 协议会话稳定运行 10 秒，确保 DUT 学习到组播组成员。\",\n  \"子任务8\": \"停止测试仪上的 IGMP 协议会话，终止报告报文发送。\",\n  \"子任务9\": \"检查 DUT 上组播组 225.1.1.1 的成员状态变化（预期：组成员移除）。\",\n  \"子任务10\": \"重新启动测试仪上的 IGMP 协议会话，再次发送周期报告报文（目的地址 225.1.1.1，TTL=1）。\",\n  \"子任务11\": \"停止报告报文发送后，立即在测试仪 port1 创建并发送 IGMPv2 离开报文（目的地址 224.0.0.2，TTL=1，组地址域 225.1.1.1）。\",\n  \"子任务12\": \"检查 DUT 上组播组 225.1.1.1 的成员状态变化（预期：组成员立即移除）。\",\n  \"子任务13\": \"停止测试仪所有协议会话和报文发送。\",\n  \"子任务14\": \"验证 DUT 配置：检查是否支持 IGMPv1、IGMPv2 和 IGMPv3 协议。\",\n  \"子任务15\": \"释放测试仪端口资源，清理测试环境。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 :   6.7.8 互联网组管理协议（IGMP)\n\n Step\t\t\t:\t测试步骤1:  按图10建立测试环境；\n                   测试步骤2:  tester port1 地 址 为 192.168.1.100/24 ， port2 地 址 为192.168.2.100/24\n                   测试步骤3:  DUT port1 地址为192.168.1.1/24，port2 地址为192.168.2.1/24\n                   测试步骤4:   DUT 设置IGMPv2组播查询；\n                   测试步骤5:   tester 向port1 发目的地址为225.1.1.1，TTL=1的IGMPv2应答报文，其组地址域也为225.1.1.1，周期为1秒\n                   测试步骤6:   停止发送步骤5中的IGMPv2应答报文，观察交换机组播组成员变化；\n                   测试步骤7:    tester 向port1 发目的地址为225.1.1.1，TTL=1的IGMPv2应答报文，\n                               其组地址域也为225.1.1.1，周期为1秒，停止发送应答报文之后tester\n                               立刻向port1发目的地址为224.0.0.2，TTL=1的IGMPv2离开报文，其组地址域为225.1.1.1。观察交换机组播组成员变化\n                   测试步骤8:   停止发送步骤7中的报文；\n                   测试步骤9:   检查DUT配置，看是否支持IGMPv1、IGMPv2、IGMPv3\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_up, Version='IGMPV2')\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interfaces_up)\n\n    # 创建组播组\n    multicast_group = create_multicast_group(Start='225.1.1.1')\n\n    # IGMP协议会话创建组成员关系\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=port_down, Version='IGMPV2')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_down)\n\n    # 创建IGMP绑定流\n\n    # point = get_layer_from_interfaces(Interfaces=interfaces_down)\n    #\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints='224.0.0', Bidirection=False)\n\n\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        Rate=100,\n    #                        Unit='FRAME_PER_SEC',\n    #                        TransmitMode=\"STEP\",\n    #                        Frames=20)\n\n\n    #创建IGMPv2报文\n    # stream1 = add_stream(Ports=port_up, Names=f'igmpv2_report')\n    # edit_stream(Stream=stream1, FixedLength=128)\n    # create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4','igmpv2'])\n    # edit_header_ipv4(Stream=stream1, Source='192.168.1.100', Destination= '225.1.1.1', TTl=1)\n    #\n    # stream2 = add_stream(Ports=port_up, Names=f'igmpv2_query')\n    # edit_stream(Stream=stream2, FixedLength=128)\n    # create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4','igmpv2query'])\n    # edit_header_ipv4(Stream=stream2, Source='192.168.1.100', Destination= '224.0.0.2', TTl=1)\n\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        #停止协议\n        stop_protocol()\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_igmp:创建IGMP协议会话对象;\ncreate_igmp_querier:创建IGMP Querier协议会话对象;\nedit_igmp:编辑IGMP协议会话对象;\nedit_igmp_querier:编辑IGMP Querier协议会话对象;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_6_2/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.6.2 路由表容量\n\n Step\t\t\t:\t测试步骤1: 按拓扑图搭建测试环境；\n                   测试步骤2: tester port1 IP 地址为 192.168.1.100/24，port2 为 192.168.2.100/24；\n                   测试步骤3: DUT port1 IP地址为192.168.1.1/24，port2 IP地址为192.168.2.1/24；\n                   测试步骤4: 配置 DUT 与 tester 在相同 Area 域，DUT 的接口 1、2 分别和 tester 建立 OSPF 邻居；\n                   测试步骤5: Tester 的接口 port1、port2 分别向 DUT 的接口 port1、port2 发布 Type类型的 LSA，总数为被测交换机路由表容量的规定值。\n\n Criteria    \t:   预期结果1: 查看并记录被测交换机的 OSPF 生成的路由表统计信息。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建OSPFv2协议会话\n    session_1 = create_ospf(Port=port_up, Priority=cfg['arg']['ospf']['default']['priority_session_up']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n    session_2 = create_ospf(Port=port_down, Priority=cfg['arg']['ospf']['default']['priority_session_down']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    route_count = int(cfg['arg']['ospf']['default']['advertise_count']['default'] / 2)\n    # OSPFv2协议会话创建External Lsa\n    external_lsa_1 = create_ospf_external_lsa(Session=session_1, RouteCount=route_count)\n    external_lsa_2 = create_ospf_external_lsa(Session=session_2, RouteCount=route_count)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=external_lsa_1)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa_2)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['rate']['default'])\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats', 'Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 启动协议\n        printf(message='Test start')\n        start_protocol()\n        time.sleep(3)\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        advertise_ospf_lsa(Lsa=[external_lsa_1, external_lsa_2])\n        time.sleep(cfg['arg']['ospf']['default']['advertise_wait']['default'])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 发送流量\n        printf(message='Stream test start')\n        start_stream()\n        time.sleep(3)\n        df = get_streamblock_statistic()\n        wait_stream_state(State='RUNNING')\n        time.sleep(3)\n        result = get_streamblock_statistic()\n        # 使用 concat 拼接 DataFrame\n        df = pd.concat([df, result])\n        # 重置索引\n        df = df.reset_index(drop=True)\n        printf(message='Test completed')\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        stop_protocol()\n        time.sleep(3)\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_ospf_lsa:通告 OSPFv2 协议会话 lsa",
      "create_ospf:创建OSPFv2协议会话对象",
      "create_ospf_external_lsa:创建OSPFv2 External LSA对象",
      "get_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象",
      "get_ospf_statistic:获取OSPFv2协议会话统计结果",
      "wait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，建立与测试仪的控制连接。\",\n  \"子任务2\": \"预约测试仪表端口，对应拓扑图中的物理连接位置。\",\n  \"子任务3\": \"配置测试仪端口参数，包括速率、双工模式等链路层参数。\",\n  \"子任务4\": \"在测试仪端口1创建三层接口，配置IPv4地址为192.168.1.100/24，网关为192.168.1.1。\",\n  \"子任务5\": \"在测试仪端口2创建三层接口，配置IPv4地址为192.168.2.100/24，网关为192.168.2.1。\",\n  \"子任务6\": \"在测试仪端口1创建OSPFv2会话，设置区域ID与DUT相同，并指定优先级参数。\",\n  \"子任务7\": \"在测试仪端口2创建OSPFv2会话，设置相同区域ID，并指定优先级参数。\",\n  \"子任务8\": \"将OSPFv2会话分别绑定到对应端口的IPv4接口上。\",\n  \"子任务9\": \"启动OSPFv2协议，建立测试仪与DUT的邻居关系。\",\n  \"子任务10\": \"等待OSPFv2会话达到Full邻接状态，确认邻居关系建立成功。\",\n  \"子任务11\": \"在每个OSPFv2会话上创建外部LSA，数量为路由表容量规定值的一半。\",\n  \"子任务12\": \"向DUT通告所有创建的外部LSA路由信息。\",\n  \"子任务13\": \"等待指定时间确保路由信息传播完成。\",\n  \"子任务14\": \"获取OSPFv2协议统计信息，记录路由表容量数据。\",\n  \"子任务15\": \"停止OSPFv2协议会话。\",\n  \"子任务16\": \"释放测试仪表端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.6.2 路由表容量\n\n Step\t\t\t:\t测试步骤1: 按拓扑图搭建测试环境；\n                   测试步骤2: tester port1 IP 地址为 192.168.1.100/24，port2 为 192.168.2.100/24；\n                   测试步骤3: DUT port1 IP地址为192.168.1.1/24，port2 IP地址为192.168.2.1/24；\n                   测试步骤4: 配置 DUT 与 tester 在相同 Area 域，DUT 的接口 1、2 分别和 tester 建立 OSPF 邻居；\n                   测试步骤5: Tester 的接口 port1、port2 分别向 DUT 的接口 port1、port2 发布 Type类型的 LSA，总数为被测交换机路由表容量的规定值。\n\n Criteria    \t:   预期结果1: 查看并记录被测交换机的 OSPF 生成的路由表统计信息。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建OSPFv2协议会话\n    session_1 = create_ospf(Port=port_up, Priority=cfg['arg']['ospf']['default']['priority_session_up']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n    session_2 = create_ospf(Port=port_down, Priority=cfg['arg']['ospf']['default']['priority_session_down']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    route_count = int(cfg['arg']['ospf']['default']['advertise_count']['default'] / 2)\n    # OSPFv2协议会话创建External Lsa\n    external_lsa_1 = create_ospf_external_lsa(Session=session_1, RouteCount=route_count)\n    external_lsa_2 = create_ospf_external_lsa(Session=session_2, RouteCount=route_count)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=external_lsa_1)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa_2)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['rate']['default'])\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats', 'Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 启动协议\n        printf(message='Test start')\n        start_protocol()\n        time.sleep(3)\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        advertise_ospf_lsa(Lsa=[external_lsa_1, external_lsa_2])\n        time.sleep(cfg['arg']['ospf']['default']['advertise_wait']['default'])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 发送流量\n        printf(message='Stream test start')\n        start_stream()\n        time.sleep(3)\n        df = get_streamblock_statistic()\n        wait_stream_state(State='RUNNING')\n        time.sleep(3)\n        result = get_streamblock_statistic()\n        # 使用 concat 拼接 DataFrame\n        df = pd.concat([df, result])\n        # 重置索引\n        df = df.reset_index(drop=True)\n        printf(message='Test completed')\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        stop_protocol()\n        time.sleep(3)\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_ospf_lsa:通告 OSPFv2 协议会话 lsa;\ncreate_ospf:创建OSPFv2协议会话对象;\ncreate_ospf_external_lsa:创建OSPFv2 External LSA对象;\nget_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象;\nget_ospf_statistic:获取OSPFv2协议会话统计结果;\nwait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_5/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.5 路由信息协议（RIP）\n\n Step\t\t\t:\t测试步骤1: 按图4，任选交换机两个端口作为测试端口；\n                   测试步骤2:  tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24;\n                   测试步骤3:  DUT1 port1 IP 地 址 为 192.168.1.1/24 ， port2 IP 地 址 为192.168.2.1/24\n                   测试步骤3:  在DUT上配置RIPv2路由协议；\n                   测试步骤3:   tester port1 从 UDP端口520向组播地址224.0.0.9的520 UDP端口发\n                               送地址簇为2，RIP条目为192.168.4.0/255.255.255.0/8 的RIPv2 应答报\n                               文，周期为1s，观察DUT的路由表变化，观察testerport2是否收到路由更新报文；\n                   测试步骤3:  停止发送步骤6的报文，tester port1 从UDP端口520向组播地址\n                               224.0.0.9 的 520 UDP 端 口 发 送 地 址 簇 为 2 ， RIP 条 目 为\n                               192.168.4.0/255.255.255.0/6 的 RIPv2 应答报文，周期为 1s，观察 DUT\n                               的路由表变化，观察tester port2是否收到路由更新报文；\n                   测试步骤3:   停止发送步骤7的报文，tester port1 从UDP端口520向组播地址\n                               224.0.0.9 的 520 UDP 端 口 发 送 地 址 簇 为 2 ， RIP 条 目 为\n                               192.168.4.0/255.255.255.0/10 的 RIPv2 应答报文，周期为 1s，观察 DUT\n                               的路由表变化，观察tester port2是否收到路由更新报文\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建RIP协议会话\n    session_1 = create_rip(Port=port_up)\n    session_2 = create_rip(Port=port_down)\n\n    # RIP协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    #创建流量\n    port1, port2 = ports\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n\n        route = create_rip_ipv4_route(Session=session_1, StartIpv4Prefix='192.168.4.0', Increment=8)\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 6\n        save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 10\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step8', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_rip:通告RIP协议路由",
      "create_rip:创建RIP协议会话对象",
      "create_rip_ipv4_route:创建RIP IPv4路由对象",
      "wait_rip_state:等待RIP协议会话达到指定状态",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"预约测试仪的两个端口，作为测试端口使用。\",\n  \"子任务2\": \"配置测试仪端口1的IP地址为192.168.1.100/24，端口2的IP地址为192.168.2.100/24。\",\n  \"子任务3\": \"在DUT设备上配置端口1的IP地址为192.168.1.1/24，端口2的IP地址为192.168.2.1/24（需通过外部方式完成）。\",\n  \"子任务4\": \"在DUT设备上启用RIPv2路由协议（需通过外部方式完成）。\",\n  \"子任务5\": \"在测试仪上创建RIPv2协议会话，并绑定到对应端口的接口。\",\n  \"子任务6\": \"在测试仪端口1创建RIP IPv4路由条目：192.168.4.0/255.255.255.0，metric值设为8。\",\n  \"子任务7\": \"启动RIP协议会话，等待协议状态就绪。\",\n  \"子任务8\": \"在测试仪端口2启动报文捕获功能。\",\n  \"子任务9\": \"从测试仪端口1向组播地址224.0.0.9的UDP 520端口发送RIPv2应答报文，周期1秒。\",\n  \"子任务10\": \"停止端口2的报文捕获，下载捕获文件。\",\n  \"子任务11\": \"验证DUT路由表是否添加192.168.4.0/24路由（需外部观察）。\",\n  \"子任务12\": \"分析捕获文件，确认端口2是否收到包含192.168.4.0/24 metric=8的RIPv2更新报文。\",\n  \"子任务13\": \"停止RIP协议会话，修改路由条目metric值为6。\",\n  \"子任务14\": \"重启RIP协议会话，等待状态就绪。\",\n  \"子任务15\": \"在端口2重启报文捕获。\",\n  \"子任务16\": \"从端口1发送metric=6的RIPv2应答报文，周期1秒。\",\n  \"子任务17\": \"停止捕获并下载文件，验证DUT路由表变化和端口2报文接收情况。\",\n  \"子任务18\": \"停止协议会话，修改路由条目metric值为10。\",\n  \"子任务19\": \"重启RIP协议会话，等待状态就绪。\",\n  \"子任务20\": \"在端口2重启报文捕获。\",\n  \"子任务21\": \"从端口1发送metric=10的RIPv2应答报文，周期1秒。\",\n  \"子任务22\": \"停止捕获并下载文件，最终验证DUT路由表变化和端口2报文接收情况。\",\n  \"子任务23\": \"释放测试仪端口资源。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.7.5 路由信息协议（RIP）\n\n Step\t\t\t:\t测试步骤1: 按图4，任选交换机两个端口作为测试端口；\n                   测试步骤2:  tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24;\n                   测试步骤3:  DUT1 port1 IP 地 址 为 192.168.1.1/24 ， port2 IP 地 址 为192.168.2.1/24\n                   测试步骤3:  在DUT上配置RIPv2路由协议；\n                   测试步骤3:   tester port1 从 UDP端口520向组播地址224.0.0.9的520 UDP端口发\n                               送地址簇为2，RIP条目为192.168.4.0/255.255.255.0/8 的RIPv2 应答报\n                               文，周期为1s，观察DUT的路由表变化，观察testerport2是否收到路由更新报文；\n                   测试步骤3:  停止发送步骤6的报文，tester port1 从UDP端口520向组播地址\n                               224.0.0.9 的 520 UDP 端 口 发 送 地 址 簇 为 2 ， RIP 条 目 为\n                               192.168.4.0/255.255.255.0/6 的 RIPv2 应答报文，周期为 1s，观察 DUT\n                               的路由表变化，观察tester port2是否收到路由更新报文；\n                   测试步骤3:   停止发送步骤7的报文，tester port1 从UDP端口520向组播地址\n                               224.0.0.9 的 520 UDP 端 口 发 送 地 址 簇 为 2 ， RIP 条 目 为\n                               192.168.4.0/255.255.255.0/10 的 RIPv2 应答报文，周期为 1s，观察 DUT\n                               的路由表变化，观察tester port2是否收到路由更新报文\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建RIP协议会话\n    session_1 = create_rip(Port=port_up)\n    session_2 = create_rip(Port=port_down)\n\n    # RIP协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    #创建流量\n    port1, port2 = ports\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n\n        route = create_rip_ipv4_route(Session=session_1, StartIpv4Prefix='192.168.4.0', Increment=8)\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 6\n        save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 10\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step8', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_rip:通告RIP协议路由;\ncreate_rip:创建RIP协议会话对象;\ncreate_rip_ipv4_route:创建RIP IPv4路由对象;\nwait_rip_state:等待RIP协议会话达到指定状态;\nsubscribe_result:订阅测试仪表统计视图\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/Interface/create_interface.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查仪表创建接口正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建各种类型接口;\n\n Criteria    \t:   预期结果1: 步骤2中所有接口创建成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    # ------------------------------------------------------------------------------\n    # 链路层: eth,  网络层: None\n    interface = create_interface(Port=Port_UP, Layers='eth')\n    # 等价写法, 先使用create_interface创建接口，再使用edit_interface_stack修改接口结构\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth')\n\n    # 链路层: eth,  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers='eth', Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth', Tops='ipv4')\n\n    # 链路层: eth,  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers='eth', Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth', Tops='ipv6')\n\n    # 链路层: eth,  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers='eth', Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth', Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------单层vlan-----------------------------------------\n    # 链路层: eth, vlan  网络层: None\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'])\n\n    # 链路层: eth, vlan  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'], Tops='ipv4')\n\n    # 链路层: eth, vlan  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'], Tops='ipv6')\n\n    # 链路层: eth, vlan  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'], Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------双层vlan-----------------------------------------\n    # 链路层: eth, vlan, vlan  网络层: None\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'])\n\n    # 链路层: eth, vlan, vlan  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'], Tops='ipv4')\n\n    # 链路层: eth, vlan, vlan  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'], Tops='ipv6')\n\n    # 链路层: eth, vlan, vlan  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'], Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------pppoe-----------------------------------------\n    # 链路层: eth, pppoe  网络层: None\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'])\n\n    # 链路层: eth, pppoe  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'], Tops='ipv4')\n\n    # 链路层: eth, pppoe  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'], Tops='ipv6')\n\n    # 链路层: eth, pppoe  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'], Tops=['ipv4', 'ipv6'])\n\n    # 链路层: eth, vlan, pppoe  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n\n    # 链路层: eth, vlan, vlan, pppoe  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------l2tp-----------------------------------------\n    # 链路层: eth, l2tp 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp'], Tops='ipv4')\n    # 链路层: eth, l2tp 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp'], Tops='ipv6')\n\n    # 链路层: eth, l2tp, ipv4 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    # 链路层: eth, l2tp, ipv4 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv6')\n\n    # 链路层: eth, l2tp, ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, l2tp, ipv4 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv6')\n\n    # 链路层: eth, l2tp, ipv4/ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, l2tp, ipv4/ipv6 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n\n    # 链路层: eth, vlan, l2tp, ipv4/ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, vlan, l2tp, ipv4/ipv6 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n\n    # 链路层: eth, vlan, vlan, l2tp, ipv4/ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, vlan, vlan, l2tp, ipv4/ipv6 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface_stack:修改测试仪表接口的结构"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台为DarYu。\",\n  \"子任务2\": \"预约两个自环端口，位置分别为//10.0.11.191/1/15和//10.0.11.191/1/16。\",\n  \"子任务3\": \"在端口Port_UP上创建以下接口类型并验证创建成功：1) 链路层eth无网络层 2) 链路层eth网络层ipv4 3) 链路层eth网络层ipv6 4) 链路层eth网络层ipv4+ipv6 5) 链路层eth+vlan无网络层 6) 链路层eth+vlan网络层ipv4 7) 链路层eth+vlan网络层ipv6 8) 链路层eth+vlan网络层ipv4+ipv6 9) 链路层eth+双层vlan无网络层 10) 链路层eth+双层vlan网络层ipv4 11) 链路层eth+双层vlan网络层ipv6 12) 链路层eth+双层vlan网络层ipv4+ipv6 13) 链路层eth+pppoe无网络层 14) 链路层eth+pppoe网络层ipv4 15) 链路层eth+pppoe网络层ipv6 16) 链路层eth+pppoe网络层ipv4+ipv6 17) 链路层eth+vlan+pppoe网络层ipv4+ipv6 18) 链路层eth+双层vlan+pppoe网络层ipv4+ipv6 19) 链路层eth+l2tp网络层ipv4 20) 链路层eth+l2tp网络层ipv6 21) 链路层eth+l2tp+ipv4网络层ipv4 22) 链路层eth+l2tp+ipv4网络层ipv6 23) 链路层eth+l2tp+ipv6网络层ipv4 24) 链路层eth+l2tp+ipv6网络层ipv6 25) 链路层eth+l2tp+ipv4/ipv6网络层ipv4 26) 链路层eth+l2tp+ipv4/ipv6网络层ipv6 27) 链路层eth+vlan+l2tp+ipv4/ipv6网络层ipv4 28) 链路层eth+vlan+l2tp+ipv4/ipv6网络层ipv6 29) 链路层eth+双层vlan+l2tp+ipv4/ipv6网络层ipv4 30) 链路层eth+双层vlan+l2tp+ipv4/ipv6网络层ipv6。\",\n  \"子任务4\": \"在端口Port_Down上创建与子任务3完全相同的30种接口类型并验证创建成功。\",\n  \"子任务5\": \"保存当前测试配置到指定路径的xcfg文件。\",\n  \"子任务6\": \"检查所有接口创建操作是否成功完成，无异常抛出。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查仪表创建接口正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建各种类型接口;\n\n Criteria    \t:   预期结果1: 步骤2中所有接口创建成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    # ------------------------------------------------------------------------------\n    # 链路层: eth,  网络层: None\n    interface = create_interface(Port=Port_UP, Layers='eth')\n    # 等价写法, 先使用create_interface创建接口，再使用edit_interface_stack修改接口结构\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth')\n\n    # 链路层: eth,  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers='eth', Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth', Tops='ipv4')\n\n    # 链路层: eth,  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers='eth', Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth', Tops='ipv6')\n\n    # 链路层: eth,  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers='eth', Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth', Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------单层vlan-----------------------------------------\n    # 链路层: eth, vlan  网络层: None\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'])\n\n    # 链路层: eth, vlan  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'], Tops='ipv4')\n\n    # 链路层: eth, vlan  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'], Tops='ipv6')\n\n    # 链路层: eth, vlan  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'], Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------双层vlan-----------------------------------------\n    # 链路层: eth, vlan, vlan  网络层: None\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'])\n\n    # 链路层: eth, vlan, vlan  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'], Tops='ipv4')\n\n    # 链路层: eth, vlan, vlan  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'], Tops='ipv6')\n\n    # 链路层: eth, vlan, vlan  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'], Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------pppoe-----------------------------------------\n    # 链路层: eth, pppoe  网络层: None\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'])\n\n    # 链路层: eth, pppoe  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'], Tops='ipv4')\n\n    # 链路层: eth, pppoe  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'], Tops='ipv6')\n\n    # 链路层: eth, pppoe  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'], Tops=['ipv4', 'ipv6'])\n\n    # 链路层: eth, vlan, pppoe  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n\n    # 链路层: eth, vlan, vlan, pppoe  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------l2tp-----------------------------------------\n    # 链路层: eth, l2tp 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp'], Tops='ipv4')\n    # 链路层: eth, l2tp 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp'], Tops='ipv6')\n\n    # 链路层: eth, l2tp, ipv4 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    # 链路层: eth, l2tp, ipv4 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv6')\n\n    # 链路层: eth, l2tp, ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, l2tp, ipv4 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv6')\n\n    # 链路层: eth, l2tp, ipv4/ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, l2tp, ipv4/ipv6 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n\n    # 链路层: eth, vlan, l2tp, ipv4/ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, vlan, l2tp, ipv4/ipv6 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n\n    # 链路层: eth, vlan, vlan, l2tp, ipv4/ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, vlan, vlan, l2tp, ipv4/ipv6 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface_stack:修改测试仪表接口的结构\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_7/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.7 虚拟路由冗余协议（VRRP）\n\n Step\t\t\t:\t测试步骤1:  按图12建立测试环境\n                   测试步骤2:  DUT1 和DUT4为二层接入交换机\n                   测试步骤3:  DUT2（主机）和DUT3（备机）组成双机冗余，两机之间可增加心跳线；\n                   测试步骤4:  tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24\n                   测试步骤5:   DUT2 port1 与DUT3 port1作为192.168.1.0网段网关，代表IP为192.168.1.1/24；\n                   测试步骤6:   DUT2 port2 与DUT3 port2作为192.168.2.0网段网关，代表IP为192.168.2.1/24；\n                   测试步骤7:   tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，\n                               网关设置为VRRP组的虚拟IP地址，查看并记录数据的接收\n                   测试步骤8:  断开交换机DUT1与VRRP主机的连接，查看并记录DUT2、DUT3上VRRP\n                               的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间；\n                               恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流；\n                   测试步骤9:   重复步骤7、8两次。\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，10.1.1.111\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Frames=10000)\n\n    stream = add_stream(Ports=port_up, Names=f'stream1')\n    edit_stream(Stream=stream, FixedLength=256)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=cfg['arg']['interface']['default']['ipv4_up_address'],\n                     Destination=cfg['arg']['interface']['default']['ipv4_down_address'],Gateway ='10.1.1.111')\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        for i in range(2):\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n            start_stream()\n            # 断开交换机DUT1与VRRP主机的连接,，查看并记录DUT2、DUT3上VRRP的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            #VRRP的收敛时间\n            Convergence_time = (TxStreamFrames - RxStreamFrames)/TxStreamFrames\n            clear_result()\n            #恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表并预约端口\",\n  \"子任务2\": \"配置测试仪端口参数并等待端口状态就绪\",\n  \"子任务3\": \"在测试仪端口上创建网络接口\",\n  \"子任务4\": \"编辑接口参数：设置port1 MAC地址、IPv4地址192.168.1.100/24，网关192.168.1.1\",\n  \"子任务5\": \"编辑接口参数：设置port2 MAC地址、IPv4地址192.168.2.100/24，网关192.168.2.1\",\n  \"子任务6\": \"配置端口负载：连续传输模式，帧速率10000帧/秒\",\n  \"子任务7\": \"创建port1到port2的流量流\",\n  \"子任务8\": \"编辑流量参数：固定帧长256字节\",\n  \"子任务9\": \"构建流量头部：以太网II和IPv4协议\",\n  \"子任务10\": \"编辑IPv4头部：源地址192.168.1.100，目的地址192.168.2.100，网关192.168.1.1\",\n  \"子任务11\": \"订阅端口统计和流统计视图\",\n  \"子任务12\": \"保存测试仪配置文件\",\n  \"子任务13\": \"执行第一次正常流量测试：启动流量→等待5秒→停止流量→获取流统计结果\",\n  \"子任务14\": \"验证第一次测试结果：接收帧数应等于发送帧数\",\n  \"子任务15\": \"清除统计结果\",\n  \"子任务16\": \"执行故障模拟测试：启动流量→断开DUT1与VRRP主机连接→等待5秒→停止流量→获取流统计结果\",\n  \"子任务17\": \"计算VRRP收敛时间：(发送帧数-接收帧数)/发送帧速率\",\n  \"子任务18\": \"清除统计结果\",\n  \"子任务19\": \"执行恢复测试：恢复链路→启动流量→等待5秒→停止流量→获取流统计结果\",\n  \"子任务20\": \"验证恢复测试结果：接收帧数应等于发送帧数\",\n  \"子任务21\": \"清除统计结果\",\n  \"子任务22\": \"重复执行子任务13-21两次\",\n  \"子任务23\": \"释放测试仪端口资源\",\n  \"子任务24\": \"关闭测试仪表进程\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 6.7.7 虚拟路由冗余协议（VRRP）\n\n Step\t\t\t:\t测试步骤1:  按图12建立测试环境\n                   测试步骤2:  DUT1 和DUT4为二层接入交换机\n                   测试步骤3:  DUT2（主机）和DUT3（备机）组成双机冗余，两机之间可增加心跳线；\n                   测试步骤4:  tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24\n                   测试步骤5:   DUT2 port1 与DUT3 port1作为192.168.1.0网段网关，代表IP为192.168.1.1/24；\n                   测试步骤6:   DUT2 port2 与DUT3 port2作为192.168.2.0网段网关，代表IP为192.168.2.1/24；\n                   测试步骤7:   tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，\n                               网关设置为VRRP组的虚拟IP地址，查看并记录数据的接收\n                   测试步骤8:  断开交换机DUT1与VRRP主机的连接，查看并记录DUT2、DUT3上VRRP\n                               的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间；\n                               恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流；\n                   测试步骤9:   重复步骤7、8两次。\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，10.1.1.111\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Frames=10000)\n\n    stream = add_stream(Ports=port_up, Names=f'stream1')\n    edit_stream(Stream=stream, FixedLength=256)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=cfg['arg']['interface']['default']['ipv4_up_address'],\n                     Destination=cfg['arg']['interface']['default']['ipv4_down_address'],Gateway ='10.1.1.111')\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        for i in range(2):\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n            start_stream()\n            # 断开交换机DUT1与VRRP主机的连接,，查看并记录DUT2、DUT3上VRRP的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            #VRRP的收敛时间\n            Convergence_time = (TxStreamFrames - RxStreamFrames)/TxStreamFrames\n            clear_result()\n            #恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  }
]
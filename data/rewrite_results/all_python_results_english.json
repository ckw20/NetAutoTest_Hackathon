[
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_Congestion.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的拥塞控制\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项拥塞控制;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective      :   Test Purpose: Determine the congestion control of the LAN switch device.\n\nStep           :   Step 1: Create ports and reserve ports.\n                   Step 2: Create RFC2889 wizard, select test item Congestion Control.\n                   Step 3: Select ports.\n                   Step 4: Configure endpoints.\n                   Step 5: Configure flows.\n                   Step 6: Configure test options.\n                   Step 7: Set address rate parameters.\n                   Step 8: Generate smart script.\n                   Step 8: Execute smart script test.\n\nCriteria       :   Expected Result 1: Step 9 correctly measures the device address buffer capacity.\n\nCreated by     :   Tester-002\n\nBugs           :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 4 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 5 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_congested, port_uncongested = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['congestionControl'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_1, port_2, port_congested, port_uncongested])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_1, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_2, Layers=['eth'])\n    interfaces_3 = create_interface(Port=port_congested, Layers=['eth'])\n    interfaces_4 = create_interface(Port=port_uncongested, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')[0]\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')[0]\n    point_congested = get_layer_from_interfaces(Interfaces=interfaces_3, Layer='eth')[0]\n    point_uncongested = get_layer_from_interfaces(Interfaces=interfaces_4, Layer='eth')[0]\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=[point_1, point_2],\n                                       DstPoints=[point_congested, point_uncongested], Mode='congestion')\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *拥塞控制参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='congestionControl',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product type (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve four ports using their locations and force reservation.\",\n  \"Subtask 3\": \"Create an RFC2889 benchmark test suite selecting 'congestionControl' as the test item.\",\n  \"Subtask 4\": \"Assign the four reserved ports to the benchmark test suite.\",\n  \"Subtask 5\": \"Create Ethernet interfaces on each of the four reserved ports.\",\n  \"Subtask 6\": \"Retrieve Ethernet layer objects from all created interfaces.\",\n  \"Subtask 7\": \"Create benchmark streams for congestion control test with source points (ports 1-2), destination points (congested/uncongested ports), and 'congestion' mode.\",\n  \"Subtask 8\": \"Configure benchmark latency settings: FIFO type with 2ms delay before and 10ms delay after.\",\n  \"Subtask 9\": \"Set benchmark file path for test results (e.g., 'D:/test').\",\n  \"Subtask 10\": \"Configure benchmark address learning: per-trial frequency, enabled with 100 packets/sec rate, 3 repeats, and 5ms delay.\",\n  \"Subtask 11\": \"Set benchmark duration: 1 trial in burst mode with 100 bursts.\",\n  \"Subtask 12\": \"Configure frame size: custom length of 64 bytes.\",\n  \"Subtask 13\": \"Configure traffic load: step mode from 10% to 20% with 10% increment.\",\n  \"Subtask 14\": \"Configure burst count: custom mode with 1 burst.\",\n  \"Subtask 15\": \"Set custom result file name for benchmark (e.g., 'congestionControl' with timestamp).\",\n  \"Subtask 16\": \"Expand benchmark configuration to generate executable smart scripts.\",\n  \"Subtask 17\": \"Save test configuration to specified file path.\",\n  \"Subtask 18\": \"Execute benchmark test with 1200-second timeout and analyzer enabled.\",\n  \"Subtask 19\": \"Retrieve RFC2889 test results from the database.\",\n  \"Subtask 20\": \"Format benchmark results into a structured table.\",\n  \"Subtask 21\": \"Validate that the results correctly measure the device's address buffer capacity as per test criteria.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective      :   Test Purpose: Determine the congestion control of the LAN switch device.\n\nStep           :   Step 1: Create ports and reserve ports.\n                   Step 2: Create RFC2889 wizard, select test item Congestion Control.\n                   Step 3: Select ports.\n                   Step 4: Configure endpoints.\n                   Step 5: Configure flows.\n                   Step 6: Configure test options.\n                   Step 7: Set address rate parameters.\n                   Step 8: Generate smart script.\n                   Step 8: Execute smart script test.\n\nCriteria       :   Expected Result 1: Step 9 correctly measures the device address buffer capacity.\n\nCreated by     :   Tester-002\n\nBugs           :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 4 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 5 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_congested, port_uncongested = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['congestionControl'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_1, port_2, port_congested, port_uncongested])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_1, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_2, Layers=['eth'])\n    interfaces_3 = create_interface(Port=port_congested, Layers=['eth'])\n    interfaces_4 = create_interface(Port=port_uncongested, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')[0]\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')[0]\n    point_congested = get_layer_from_interfaces(Interfaces=interfaces_3, Layer='eth')[0]\n    point_uncongested = get_layer_from_interfaces(Interfaces=interfaces_4, Layer='eth')[0]\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=[point_1, point_2],\n                                       DstPoints=[point_congested, point_uncongested], Mode='congestion')\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *拥塞控制参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='congestionControl',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_BackToBack.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备背靠背测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2544向导, 选择背靠背测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址缓存容量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Back-to-Back Test for LAN Switch Equipment  \n\nStep:  \nTest Step 1: Create ports and reserve ports  \nTest Step 2: Create RFC2544 wizard, select back-to-back test  \nTest Step 3: Select ports  \nTest Step 4: Configure endpoints  \nTest Step 5: Configure flows  \nTest Step 6: Configure test options  \nTest Step 7: Set address cache capacity parameters  \nTest Step 8: Generate smart script  \nTest Step 8: Execute smart script test  \n\nCriteria:  \nExpected Result 1: Step 9 correctly measures the device’s address cache capacity  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "import pandas\n\nfrom TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2544', Items=['backtoback'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth', 'ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth', 'ipv4'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置rfc2544* ===============\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_latency(Configs=Config, Type='FILO', DelayBefore=1, DelayAfter=2)\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='tcp')\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *配置背靠背* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[128])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 时间阈值\n    edit_benchmark_backtoback_binary_search(Config=Config, MinDuration=0.01)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='backtoback',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2544')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n    pandas.to_excel(tmp, index=False)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (e.g., 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two specified ports (e.g., '//10.0.11.191/1/5' and '//10.0.11.191/1/6') using reserve_port API with Force=True.\",\n  \"Subtask 3\": \"Create RFC2544 benchmark test suite with back-to-back test item selected using create_benchmark API.\",\n  \"Subtask 4\": \"Assign reserved ports to the benchmark test suite using relate_benchmark_ports API.\",\n  \"Subtask 5\": \"Create Ethernet and IPv4 interfaces on first reserved port using create_interface API.\",\n  \"Subtask 6\": \"Create Ethernet and IPv4 interfaces on second reserved port using create_interface API.\",\n  \"Subtask 7\": \"Retrieve IPv4 layer object from first port's interface using get_layer_from_interfaces API.\",\n  \"Subtask 8\": \"Retrieve IPv4 layer object from second port's interface using get_layer_from_interfaces API.\",\n  \"Subtask 9\": \"Create unidirectional traffic streams for benchmark using create_benchmark_streams API with IPv4 endpoints.\",\n  \"Subtask 10\": \"Configure address learning settings for benchmark (Frequency='once', EnableArp=False) using edit_benchmark_learning API.\",\n  \"Subtask 11\": \"Configure latency settings (Type='FILO', DelayBefore=1, DelayAfter=2) using edit_benchmark_latency API.\",\n  \"Subtask 12\": \"Configure transport layer to use TCP header using edit_benchmark_transport_layer API.\",\n  \"Subtask 13\": \"Set result storage path (e.g., 'D:/test') using edit_benchmark_path API.\",\n  \"Subtask 14\": \"Configure test duration with 1 trial using edit_benchmark_duration API.\",\n  \"Subtask 15\": \"Set custom frame length to 128 bytes using edit_benchmark_frame API.\",\n  \"Subtask 16\": \"Configure traffic load pattern (LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10) using edit_benchmark_traffic_load_loop API.\",\n  \"Subtask 17\": \"Configure custom result file name ('backtoback' with timestamp) using edit_benchmark_result_file_name API.\",\n  \"Subtask 18\": \"Generate executable test script using expand_benchmark API.\",\n  \"Subtask 19\": \"Save test configuration to .xcfg file using save_case API.\",\n  \"Subtask 20\": \"Execute benchmark test with analyzer enabled and 1200s timeout using run_benchmark API.\",\n  \"Subtask 21\": \"Retrieve RFC2544 test results from database using get_benchmark_result API.\",\n  \"Subtask 22\": \"Format test results into tabular structure using format_benchmark_result API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Back-to-Back Test for LAN Switch Equipment  \n\nStep:  \nTest Step 1: Create ports and reserve ports  \nTest Step 2: Create RFC2544 wizard, select back-to-back test  \nTest Step 3: Select ports  \nTest Step 4: Configure endpoints  \nTest Step 5: Configure flows  \nTest Step 6: Configure test options  \nTest Step 7: Set address cache capacity parameters  \nTest Step 8: Generate smart script  \nTest Step 8: Execute smart script test  \n\nCriteria:  \nExpected Result 1: Step 9 correctly measures the device’s address cache capacity  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  import pandas\n\nfrom TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2544', Items=['backtoback'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth', 'ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth', 'ipv4'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置rfc2544* ===============\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_latency(Configs=Config, Type='FILO', DelayBefore=1, DelayAfter=2)\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='tcp')\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *配置背靠背* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[128])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 时间阈值\n    edit_benchmark_backtoback_binary_search(Config=Config, MinDuration=0.01)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='backtoback',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2544')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n    pandas.to_excel(tmp, index=False)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_imix.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查BLDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Objective: Verify normal configuration generation of the LDP VPLS wizard\n\nStep: Test Step 1: Create eight offline ports Port_1, Port_2;\nTest Step 2: Create LDP VPLS wizard;\nTest Step 3: Configure client-side ports and provider-side ports;\nTest Step 4: Configure provider-side routers;\nTest Step 5: Configure VPLS;\nTest Step 6: Configure Host;\nTest Step 7: Configure traffic;\nTest Step 8: Generate LDP VPLS wizard configuration;\n\nCriteria: Expected Result 1: Step 8 LDP VPLS wizard configuration generates without exceptions;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 获取仪表已有imix模板\n    imix_template = [get_imix_from_name(Name='Default'), get_imix_from_name(Name='4-Point'),\n                     get_imix_from_name(Name='IPSEC'), get_imix_from_name(Name='TCPv4')]\n\n    # 创建新imix模板\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_02')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_03')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    # 创建RFC2544 Throughput测试套件\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='imix', ImixTemplates=imix_template)\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n    imix = create_imix(Name='CTRI_IMIX424')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "add_imix_distribution_frame:在Imix模板添加自定义帧长",
      "create_imix:创建流量Imix模板",
      "get_imix_from_name:通过Imix模板名称获取流量Imix模板对象",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester using the specified product platform.\",\n  \"Subtask 2\": \"Reserve eight offline ports on the tester, specifically naming Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create network interfaces on Port_1 and Port_2 with IPv4 layer configurations.\",\n  \"Subtask 4\": \"Configure IPv4 parameters for the interfaces including IP addresses and gateways.\",\n  \"Subtask 5\": \"Create bidirectional binding traffic streams between the IPv4 endpoints of Port_1 and Port_2.\",\n  \"Subtask 6\": \"Create and configure IMIX templates for traffic frames with specific size distributions.\",\n  \"Subtask 7\": \"Create an LDP VPLS wizard benchmark configuration of type RFC2544 Throughput.\",\n  \"Subtask 8\": \"Assign the reserved ports (Port_1 and Port_2) to the benchmark configuration.\",\n  \"Subtask 9\": \"Associate the pre-created traffic streams with the benchmark configuration.\",\n  \"Subtask 10\": \"Configure benchmark learning settings with ARP disabled and single learning frequency.\",\n  \"Subtask 11\": \"Set benchmark duration parameters for test execution.\",\n  \"Subtask 12\": \"Configure frame type and IMIX templates for the benchmark traffic.\",\n  \"Subtask 13\": \"Set benchmark search parameters including initial, lower, and upper load percentages.\",\n  \"Subtask 14\": \"Generate the LDP VPLS wizard configuration by expanding the benchmark setup.\",\n  \"Subtask 15\": \"Save the generated LDP VPLS wizard configuration to a file.\",\n  \"Subtask 16\": \"Verify that the LDP VPLS wizard configuration generates without exceptions.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Objective: Verify normal configuration generation of the LDP VPLS wizard\n\nStep: Test Step 1: Create eight offline ports Port_1, Port_2;\nTest Step 2: Create LDP VPLS wizard;\nTest Step 3: Configure client-side ports and provider-side ports;\nTest Step 4: Configure provider-side routers;\nTest Step 5: Configure VPLS;\nTest Step 6: Configure Host;\nTest Step 7: Configure traffic;\nTest Step 8: Generate LDP VPLS wizard configuration;\n\nCriteria: Expected Result 1: Step 8 LDP VPLS wizard configuration generates without exceptions;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 获取仪表已有imix模板\n    imix_template = [get_imix_from_name(Name='Default'), get_imix_from_name(Name='4-Point'),\n                     get_imix_from_name(Name='IPSEC'), get_imix_from_name(Name='TCPv4')]\n\n    # 创建新imix模板\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_02')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_03')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    # 创建RFC2544 Throughput测试套件\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='imix', ImixTemplates=imix_template)\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n    imix = create_imix(Name='CTRI_IMIX424')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nadd_imix_distribution_frame:在Imix模板添加自定义帧长;\ncreate_imix:创建流量Imix模板;\nget_imix_from_name:通过Imix模板名称获取流量Imix模板对象;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc3918_MulticastLatency.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 得到DUT/SUT一个端口到多个出端口的一组时延数据\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项组播转发时延测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置组播转发时延;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成组播转发时延测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Obtain a set of latency data from one port to multiple egress ports of the DUT/SUT\n\nStep: Test Step 1: Create ports and reserve ports.\n      Test Step 2: Create RFC3918 wizard, select test item Multicast Forwarding Latency Test.\n      Test Step 3: Select ports.\n      Test Step 4: Configure endpoints.\n      Test Step 5: Configure stream.\n      Test Step 6: Configure multicast parameters.\n      Test Step 7: Configure test options.\n      Test Step 8: Configure multicast forwarding latency.\n      Test Step 9: Generate smart script.\n\nCriteria: Expected Result 1: Step 9 correctly generates the multicast forwarding latency test item.\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastLatency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed',\n                                   DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置组播转发时延* ===============\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='step', FixedGroup=10, MinGroup=10, MaxGroup=50,\n                                              StartGroup=10, EndGroup=20, StepGroup=10, CustomGroup=(10, 20, 100))\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True,\n                                    ResultFileName='Rfc3918MulticastLatency',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastLatency')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数",
      "edit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组",
      "edit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他",
      "edit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product using init_tester.\",\n  \"Subtask 2\": \"Reserve the specified ports using reserve_port with force option enabled.\",\n  \"Subtask 3\": \"Create an RFC3918 benchmark configuration for multicast forwarding latency test using create_benchmark.\",\n  \"Subtask 4\": \"Assign the reserved ports to the benchmark configuration using relate_benchmark_ports.\",\n  \"Subtask 5\": \"Create IPv4 interfaces on both reserved ports using create_interface.\",\n  \"Subtask 6\": \"Configure IPv4 addresses and gateways for both interfaces using edit_interface.\",\n  \"Subtask 7\": \"Retrieve IPv4 layer objects from both interfaces using get_layer_from_interfaces.\",\n  \"Subtask 8\": \"Create multicast streams between source and destination points using create_benchmark_streams in many-to-many mode.\",\n  \"Subtask 9\": \"Configure multicast base parameters (IGMP version, group addresses, join/leave delays) using edit_benchmark_multicast_base_parameters.\",\n  \"Subtask 10\": \"Configure transport layer parameters (UDP header, random ports) using edit_benchmark_transport_layer.\",\n  \"Subtask 11\": \"Configure multicast stream TOS parameters (TOS value, TTL, priority) using edit_benchmark_multicast_stream_tos.\",\n  \"Subtask 12\": \"Configure address learning settings (learning frequency, ARP settings) using edit_benchmark_learning.\",\n  \"Subtask 13\": \"Configure test duration parameters (trial count, burst mode) using edit_benchmark_duration.\",\n  \"Subtask 14\": \"Configure frame length settings (step mode, size range) using edit_benchmark_frame.\",\n  \"Subtask 15\": \"Set latency measurement type to FIFO using edit_benchmark_latency.\",\n  \"Subtask 16\": \"Configure multicast other parameters (stop conditions, verification frequency) using edit_benchmark_multicast_other.\",\n  \"Subtask 17\": \"Set benchmark path for results using edit_benchmark_path.\",\n  \"Subtask 18\": \"Configure additional latency parameters (delay after) using edit_benchmark_latency.\",\n  \"Subtask 19\": \"Configure multicast group count loop settings (step mode, group ranges) using edit_benchmark_multicast_group_count_loop.\",\n  \"Subtask 20\": \"Configure traffic load loop settings (random load percentage) using edit_benchmark_traffic_load_loop.\",\n  \"Subtask 21\": \"Configure custom result file name with timestamp using edit_benchmark_result_file_name.\",\n  \"Subtask 22\": \"Generate the smart script by expanding the benchmark configuration using expand_benchmark.\",\n  \"Subtask 23\": \"Save the test configuration to an XCFG file using save_case.\",\n  \"Subtask 24\": \"Execute the benchmark with analyzer enabled using run_benchmark.\",\n  \"Subtask 25\": \"Retrieve multicast latency test results from the benchmark database using get_benchmark_result.\",\n  \"Subtask 26\": \"Format the latency results into a table using format_benchmark_result.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Obtain a set of latency data from one port to multiple egress ports of the DUT/SUT\n\nStep: Test Step 1: Create ports and reserve ports.\n      Test Step 2: Create RFC3918 wizard, select test item Multicast Forwarding Latency Test.\n      Test Step 3: Select ports.\n      Test Step 4: Configure endpoints.\n      Test Step 5: Configure stream.\n      Test Step 6: Configure multicast parameters.\n      Test Step 7: Configure test options.\n      Test Step 8: Configure multicast forwarding latency.\n      Test Step 9: Generate smart script.\n\nCriteria: Expected Result 1: Step 9 correctly generates the multicast forwarding latency test item.\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastLatency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed',\n                                   DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置组播转发时延* ===============\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='step', FixedGroup=10, MinGroup=10, MaxGroup=50,\n                                              StartGroup=10, EndGroup=20, StepGroup=10, CustomGroup=(10, 20, 100))\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True,\n                                    ResultFileName='Rfc3918MulticastLatency',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastLatency')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数;\nedit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组;\nedit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他;\nedit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_AddressCachingCapacity.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的地址缓存容量\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项地址缓存容量;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址缓存容量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective\t:\tTo determine the address cache capacity of the LAN switch device\n\nStep\t\t:\tStep 1: Create ports and reserve ports\n                Step 2: Create an RFC2889 wizard and select the test item 'Address Cache Capacity'\n                Step 3: Select ports\n                Step 4: Configure endpoints\n                Step 5: Configure flows\n                Step 6: Configure test options\n                Step 7: Address cache capacity parameter settings\n                Step 8: Generate a smart script\n                Step 8: Execute the smart script test\n\nCriteria\t:\tStep 9 correctly measures the device's address cache capacity\n\nCreated by\t:\tTester-001\n\nBugs\t\t:\tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressCachingCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64, 128])\n    # 提供学习的地址数和地址学习速率\n    edit_benchmark_address_learning_capacity(Config=Config, MinAddressCount=1000, MaxAddressCount=5000,\n                                             InitAddressCount=5000, Resolution=2, AgingTime=30, LearningRate=1000)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='addressCachingCapacity',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_address_learning_capacity:编辑RFC2889测试套件地址容量测试项参数",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester with the specified product type (default 'DarYu')\",\n  \"Subtask 2\": \"Reserve two test ports using provided locations and force reservation\",\n  \"Subtask 3\": \"Create RFC2889 benchmark test suite with 'addressCachingCapacity' as the selected test item\",\n  \"Subtask 4\": \"Assign the reserved ports to the benchmark test suite configuration\",\n  \"Subtask 5\": \"Create Ethernet interfaces on both reserved ports\",\n  \"Subtask 6\": \"Retrieve Ethernet layer objects from both created interfaces\",\n  \"Subtask 7\": \"Create unidirectional traffic streams between source and destination Ethernet endpoints for the benchmark\",\n  \"Subtask 8\": \"Configure benchmark latency options with FIFO type, 2s delay before and 10s delay after\",\n  \"Subtask 9\": \"Set benchmark result storage path to 'D:/test'\",\n  \"Subtask 10\": \"Configure test duration with 1 trial execution\",\n  \"Subtask 11\": \"Set custom frame lengths to 64 and 128 bytes for testing\",\n  \"Subtask 12\": \"Configure address learning parameters: min 1000, max 5000 addresses, initial 5000 addresses, resolution 2, aging time 30s, learning rate 1000\",\n  \"Subtask 13\": \"Set custom result file name to 'addressCachingCapacity' with timestamp appended\",\n  \"Subtask 14\": \"Expand benchmark configuration to generate executable smart scripts\",\n  \"Subtask 15\": \"Save test configuration to file in 'xcfg' subdirectory with current script name\",\n  \"Subtask 16\": \"Execute benchmark test with analyzer enabled and 1200s timeout\",\n  \"Subtask 17\": \"Retrieve RFC2889 benchmark results from execution database\",\n  \"Subtask 18\": \"Format benchmark results into readable table structure\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective\t:\tTo determine the address cache capacity of the LAN switch device\n\nStep\t\t:\tStep 1: Create ports and reserve ports\n                Step 2: Create an RFC2889 wizard and select the test item 'Address Cache Capacity'\n                Step 3: Select ports\n                Step 4: Configure endpoints\n                Step 5: Configure flows\n                Step 6: Configure test options\n                Step 7: Address cache capacity parameter settings\n                Step 8: Generate a smart script\n                Step 8: Execute the smart script test\n\nCriteria\t:\tStep 9 correctly measures the device's address cache capacity\n\nCreated by\t:\tTester-001\n\nBugs\t\t:\tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressCachingCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64, 128])\n    # 提供学习的地址数和地址学习速率\n    edit_benchmark_address_learning_capacity(Config=Config, MinAddressCount=1000, MaxAddressCount=5000,\n                                             InitAddressCount=5000, Resolution=2, AgingTime=30, LearningRate=1000)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='addressCachingCapacity',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_address_learning_capacity:编辑RFC2889测试套件地址容量测试项参数;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_AddressLearningRate.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的地址学习速率\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项地址学习速率;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    : Determine the address learning rate of the LAN switch device\n\nStep         : Step 1: Create ports and reserve ports\n                   Step 2: Create RFC2889 wizard, select test item: address learning rate\n                   Step 3: Select ports\n                   Step 4: Configure endpoints\n                   Step 5: Configure flows\n                   Step 6: Configure test options\n                   Step 7: Set address rate parameters\n                   Step 8: Generate smart script\n                   Step 8: Execute smart script test\n\nCriteria     : Expected Result 1: Step 9 correctly measures the device's address cache capacity\n\nCreated by   : Tester-001\n\nBugs         : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressLearningRate'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *地址学习速率参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 地址学习速率和地址数量\n    edit_benchmark_address_learning_rate(Config=Config, MinRateCount=1000, MaxRateCount=5000, InitRateCount=5000,\n                                         Resolution=2, AgingTime=30, AddressCount=5000)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='addressLearningRate',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_address_learning_rate:编辑RFC2889测试套件地址容量测试项参数",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester with specified product configuration using init_tester API.\",\n  \"Subtask 2\": \"Reserve two test ports using reserve_port API with force reservation enabled.\",\n  \"Subtask 3\": \"Create RFC2889 benchmark test suite with addressLearningRate test item using create_benchmark API.\",\n  \"Subtask 4\": \"Assign reserved ports to benchmark configuration using relate_benchmark_ports API.\",\n  \"Subtask 5\": \"Create Ethernet interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 6\": \"Retrieve Ethernet layer objects from created interfaces using get_layer_from_interfaces API.\",\n  \"Subtask 7\": \"Create unidirectional test streams between source and destination Ethernet points using create_benchmark_streams API.\",\n  \"Subtask 8\": \"Configure test latency options (FIFO mode with 2s delay before and 10s after) using edit_benchmark_latency API.\",\n  \"Subtask 9\": \"Set test result storage path using edit_benchmark_path API.\",\n  \"Subtask 10\": \"Configure test duration parameters (1 trial) using edit_benchmark_duration API.\",\n  \"Subtask 11\": \"Set custom frame size (64 bytes) using edit_benchmark_frame API.\",\n  \"Subtask 12\": \"Configure address learning rate parameters (min 1000, max 5000, init 5000 addresses with 2 resolution, 30s aging) using edit_benchmark_address_learning_rate API.\",\n  \"Subtask 13\": \"Set custom result filename with timestamp using edit_benchmark_result_file_name API.\",\n  \"Subtask 14\": \"Generate executable test script from benchmark configuration using expand_benchmark API.\",\n  \"Subtask 15\": \"Save test case configuration to .xcfg file using save_case API.\",\n  \"Subtask 16\": \"Execute benchmark test with analyzer enabled using run_benchmark API (1200s timeout).\",\n  \"Subtask 17\": \"Retrieve RFC2889 test results from database using get_benchmark_result API.\",\n  \"Subtask 18\": \"Format test results into tabular output using format_benchmark_result API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    : Determine the address learning rate of the LAN switch device\n\nStep         : Step 1: Create ports and reserve ports\n                   Step 2: Create RFC2889 wizard, select test item: address learning rate\n                   Step 3: Select ports\n                   Step 4: Configure endpoints\n                   Step 5: Configure flows\n                   Step 6: Configure test options\n                   Step 7: Set address rate parameters\n                   Step 8: Generate smart script\n                   Step 8: Execute smart script test\n\nCriteria     : Expected Result 1: Step 9 correctly measures the device's address cache capacity\n\nCreated by   : Tester-001\n\nBugs         : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressLearningRate'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *地址学习速率参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 地址学习速率和地址数量\n    edit_benchmark_address_learning_rate(Config=Config, MinRateCount=1000, MaxRateCount=5000, InitRateCount=5000,\n                                         Resolution=2, AgingTime=30, AddressCount=5000)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='addressLearningRate',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_address_learning_rate:编辑RFC2889测试套件地址容量测试项参数;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_Lantency.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备时延测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2544向导, 选择时延测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址缓存容量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     :   Purpose: LAN switch latency testing\n\nStep          :   Step 1: Create ports and reserve ports\n                   Step 2: Create RFC2544 wizard, select latency test;\n                   Step 3: Select ports;\n                   Step 4: Configure endpoints;\n                   Step 5: Configure flows;\n                   Step 6: Configure test options;\n                   Step 7: Set address caching capacity parameters;\n                   Step 8: Generate smart script;\n                   Step 8: Execute smart script test;\n\nCriteria      :   Expected Result 1: Step 9 correctly measures device address caching capacity;\n\nCreated by    :   Tester-002\n\nBugs          :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2544', Items=['latency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth', 'ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth', 'ipv4'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置rfc2544* ===============\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_latency(Configs=Config, Type='FILO', DelayBefore=1, DelayAfter=2)\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='tcp')\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *配置时延* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[128])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='latency',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2544')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform for product 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations using reserve_port API with Force=True.\",\n  \"Subtask 3\": \"Create RFC2544 benchmark configuration with latency test selected using create_benchmark API.\",\n  \"Subtask 4\": \"Assign reserved ports to the benchmark configuration using relate_benchmark_ports API.\",\n  \"Subtask 5\": \"Create Ethernet and IPv4 interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 6\": \"Retrieve IPv4 layer objects from created interfaces using get_layer_from_interfaces API.\",\n  \"Subtask 7\": \"Create unidirectional traffic streams between IPv4 endpoints using create_benchmark_streams API.\",\n  \"Subtask 8\": \"Configure address learning settings: set frequency to 'once' and disable ARP using edit_benchmark_learning API.\",\n  \"Subtask 9\": \"Configure latency parameters: set type to 'FILO', delay before to 1s, delay after to 2s using edit_benchmark_latency API.\",\n  \"Subtask 10\": \"Set transport layer protocol to TCP using edit_benchmark_transport_layer API.\",\n  \"Subtask 11\": \"Configure result storage path to 'D:/test' using edit_benchmark_path API.\",\n  \"Subtask 12\": \"Set test duration: configure trial count to 1 using edit_benchmark_duration API.\",\n  \"Subtask 13\": \"Configure frame size: set custom frame length to 128 bytes using edit_benchmark_frame API.\",\n  \"Subtask 14\": \"Configure traffic load: set step mode from 10% to 20% with 10% step using edit_benchmark_traffic_load_loop API.\",\n  \"Subtask 15\": \"Configure custom result filename as 'latency' with timestamp using edit_benchmark_result_file_name API.\",\n  \"Subtask 16\": \"Generate smart script by expanding benchmark configuration using expand_benchmark API.\",\n  \"Subtask 17\": \"Save test case configuration to specified file path using save_case API.\",\n  \"Subtask 18\": \"Execute benchmark test with 1200s timeout and analyzer enabled using run_benchmark API.\",\n  \"Subtask 19\": \"Retrieve RFC2544 test results from database using get_benchmark_result API.\",\n  \"Subtask 20\": \"Format test results into two-dimensional table and output using format_benchmark_result API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     :   Purpose: LAN switch latency testing\n\nStep          :   Step 1: Create ports and reserve ports\n                   Step 2: Create RFC2544 wizard, select latency test;\n                   Step 3: Select ports;\n                   Step 4: Configure endpoints;\n                   Step 5: Configure flows;\n                   Step 6: Configure test options;\n                   Step 7: Set address caching capacity parameters;\n                   Step 8: Generate smart script;\n                   Step 8: Execute smart script test;\n\nCriteria      :   Expected Result 1: Step 9 correctly measures device address caching capacity;\n\nCreated by    :   Tester-002\n\nBugs          :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2544', Items=['latency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth', 'ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth', 'ipv4'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置rfc2544* ===============\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_latency(Configs=Config, Type='FILO', DelayBefore=1, DelayAfter=2)\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='tcp')\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *配置时延* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[128])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='latency',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2544')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc3918_ScaledGroupForwarding.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定再DUT/SUT在一定数量端口加入不同数量的组播组时的转发率\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项组转发矩阵测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置组转发矩阵;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成组转发矩阵测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Objective: Determine the forwarding rate on the DUT/SUT when a specified number of ports join varying quantities of multicast groups.\n\nStep: Test Step 1: Create ports and reserve ports\n      Test Step 2: Create RFC3918 wizard, select test item: Group Forwarding Matrix Test\n      Test Step 3: Select ports\n      Test Step 4: Configure endpoints\n      Test Step 5: Configure flows\n      Test Step 6: Configure multicast parameters\n      Test Step 7: Configure test options\n      Test Step 8: Configure group forwarding matrix\n      Test Step 9: Generate smart script\n\nCriteria: Expected Result 1: Step 9 correctly generates the Group Forwarding Matrix test item\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['scaledGroupForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=2, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed',\n                                   DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置组转发矩阵* ===============\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', MinGroup=10, MaxGroup=50)\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True,\n                                    ResultFileName='Rfc3918Scaledgroupforwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='scaledGroupForwarding')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数",
      "edit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组",
      "edit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他",
      "edit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product type and reserve ports using the given locations.\",\n  \"Subtask 2\": \"Create an RFC3918 benchmark wizard for 'scaledGroupForwarding' test item.\",\n  \"Subtask 3\": \"Assign the reserved ports to the benchmark configuration.\",\n  \"Subtask 4\": \"Create IPv4 interfaces on both ports and configure their IP addresses and gateways.\",\n  \"Subtask 5\": \"Generate IPv4 layer objects from the interfaces and create benchmark streams with many-to-many (m2m) mode.\",\n  \"Subtask 6\": \"Configure multicast base parameters: IGMPv2 version, group address range (225.0.0.1 with step 0.1.0.0), join/leave delays (15ms), and even group distribution.\",\n  \"Subtask 7\": \"Configure transport layer: UDP header type with random port selection enabled.\",\n  \"Subtask 8\": \"Configure multicast stream parameters: ToS=2, TTL=11, and priority=1.\",\n  \"Subtask 9\": \"Set test options: frame-based address learning with ARP enabled, burst mode duration (2 trials), stepped frame lengths (128-512 bytes), FIFO latency type, and verification on topology change.\",\n  \"Subtask 10\": \"Configure group forwarding matrix: random multicast group count (10-50 groups) and random traffic load (10-50% in percent mode).\",\n  \"Subtask 11\": \"Set custom result file name with timestamp and save path configuration.\",\n  \"Subtask 12\": \"Generate the smart script by expanding the benchmark configuration and verify successful creation of Group Forwarding Matrix test item.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Objective: Determine the forwarding rate on the DUT/SUT when a specified number of ports join varying quantities of multicast groups.\n\nStep: Test Step 1: Create ports and reserve ports\n      Test Step 2: Create RFC3918 wizard, select test item: Group Forwarding Matrix Test\n      Test Step 3: Select ports\n      Test Step 4: Configure endpoints\n      Test Step 5: Configure flows\n      Test Step 6: Configure multicast parameters\n      Test Step 7: Configure test options\n      Test Step 8: Configure group forwarding matrix\n      Test Step 9: Generate smart script\n\nCriteria: Expected Result 1: Step 9 correctly generates the Group Forwarding Matrix test item\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['scaledGroupForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=2, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed',\n                                   DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置组转发矩阵* ===============\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', MinGroup=10, MaxGroup=50)\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True,\n                                    ResultFileName='Rfc3918Scaledgroupforwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='scaledGroupForwarding')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数;\nedit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组;\nedit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他;\nedit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_throughput.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的吞吐量\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2544向导, 选择测试项吞吐量;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 吞吐量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备吞吐量;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Determine the throughput of the LAN switch device  \n\nStep: Test Step 1: Create ports and reserve ports  \nTest Step 2: Create RFC2544 wizard, select test item throughput  \nTest Step 3: Select ports  \nTest Step 4: Configure endpoints  \nTest Step 5: Configure flows  \nTest Step 6: Configure test options  \nTest Step 7: Set throughput parameters  \nTest Step 8: Generate smart script  \nTest Step 8: Execute smart script test  \n\nCriteria: Expected Result 1: Step 9 correctly measures the device throughput  \n\nCreated by: Tester-001  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='custom')\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with the specified product type.\",\n  \"Subtask 2\": \"Reserve two ports using the provided locations.\",\n  \"Subtask 3\": \"Create an IPv4 interface on the first reserved port.\",\n  \"Subtask 4\": \"Configure the IPv4 interface on the first port with address 192.168.1.2 and gateway 192.168.1.3.\",\n  \"Subtask 5\": \"Create an IPv4 interface on the second reserved port.\",\n  \"Subtask 6\": \"Configure the IPv4 interface on the second port with address 192.168.1.3 and gateway 192.168.1.2.\",\n  \"Subtask 7\": \"Retrieve the IPv4 layer objects from both interfaces.\",\n  \"Subtask 8\": \"Create a bidirectional binding stream between the IPv4 endpoints.\",\n  \"Subtask 9\": \"Create an RFC2544 benchmark configuration for throughput testing.\",\n  \"Subtask 10\": \"Assign the reserved ports to the benchmark configuration.\",\n  \"Subtask 11\": \"Configure the benchmark to use the existing bidirectional stream.\",\n  \"Subtask 12\": \"Set benchmark address learning to occur once with ARP disabled.\",\n  \"Subtask 13\": \"Configure benchmark test duration with count set to 1.\",\n  \"Subtask 14\": \"Set benchmark frame type to custom.\",\n  \"Subtask 15\": \"Configure throughput search parameters: initial rate 100%, lower bound 100%, upper bound 100%.\",\n  \"Subtask 16\": \"Expand the benchmark configuration to generate the test script.\",\n  \"Subtask 17\": \"Save the test configuration to a file.\",\n  \"Subtask 18\": \"Execute the throughput test and measure device performance.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Determine the throughput of the LAN switch device  \n\nStep: Test Step 1: Create ports and reserve ports  \nTest Step 2: Create RFC2544 wizard, select test item throughput  \nTest Step 3: Select ports  \nTest Step 4: Configure endpoints  \nTest Step 5: Configure flows  \nTest Step 6: Configure test options  \nTest Step 7: Set throughput parameters  \nTest Step 8: Generate smart script  \nTest Step 8: Execute smart script test  \n\nCriteria: Expected Result 1: Step 9 correctly measures the device throughput  \n\nCreated by: Tester-001  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='custom')\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_BroadcastForwarding.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Purpose: Determine the broadcast frame forwarding of the LAN switch device\n\nStep 1: Create ports and reserve ports\nStep 2: Create RFC2889 wizard, select test item broadcast frame forwarding\nStep 3: Select ports\nStep 4: Configure endpoints\nStep 5: Configure flows\nStep 6: Configure test options\nStep 7: Set address rate parameters\nStep 8: Generate smart script\nStep 8: Execute smart script test\n\nCriteria: Expected Result 1: Step 9 correctly measures the device's address cache capacity\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastForwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with the specified product (default 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at given locations using reserve_port API with Force=True parameter.\",\n  \"Subtask 3\": \"Create an RFC2889 benchmark configuration selecting 'broadcastForwarding' test item using create_benchmark API.\",\n  \"Subtask 4\": \"Assign the reserved ports to the benchmark configuration using relate_benchmark_ports API.\",\n  \"Subtask 5\": \"Create Ethernet interfaces on both reserved ports using create_interface API with 'eth' layer specification.\",\n  \"Subtask 6\": \"Retrieve Ethernet layer objects from both interfaces using get_layer_from_interfaces API.\",\n  \"Subtask 7\": \"Create unidirectional benchmark streams between source and destination Ethernet points using create_benchmark_streams API.\",\n  \"Subtask 8\": \"Configure benchmark latency settings: Type=FIFO, DelayBefore=2μs, DelayAfter=10μs using edit_benchmark_latency API.\",\n  \"Subtask 9\": \"Set benchmark result storage path to 'D:/test' using edit_benchmark_path API.\",\n  \"Subtask 10\": \"Configure address learning parameters: Frequency=trial, EnableLearning=True, LearningRate=100pps, LearningRepeat=3, DelayBefore=5s using edit_benchmark_learning API.\",\n  \"Subtask 11\": \"Configure test duration parameters: Trial=1, Mode=burst, Count=100 frames using edit_benchmark_duration API.\",\n  \"Subtask 12\": \"Set frame length to 64 bytes using edit_benchmark_frame API with Type=custom and Custom=[64].\",\n  \"Subtask 13\": \"Configure load search parameters: Mode=step, Lower=10%, Upper=20%, Step=10% using edit_benchmark_search API.\",\n  \"Subtask 14\": \"Set burst count to 1 using edit_benchmark_burst_count_loop API with Mode=custom and Custom=[1].\",\n  \"Subtask 15\": \"Configure custom result file name as 'broadcastForwarding' with timestamp using edit_benchmark_result_file_name API.\",\n  \"Subtask 16\": \"Expand the benchmark configuration to generate smart scripts using expand_benchmark API.\",\n  \"Subtask 17\": \"Save test configuration to an .xcfg file in specified directory path using save_case API.\",\n  \"Subtask 18\": \"Execute the benchmark test with 1200s timeout and analyzer enabled using run_benchmark API.\",\n  \"Subtask 19\": \"Retrieve RFC2889 test results from the database using get_benchmark_result API.\",\n  \"Subtask 20\": \"Format test results into a readable table structure using format_benchmark_result API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Purpose: Determine the broadcast frame forwarding of the LAN switch device\n\nStep 1: Create ports and reserve ports\nStep 2: Create RFC2889 wizard, select test item broadcast frame forwarding\nStep 3: Select ports\nStep 4: Configure endpoints\nStep 5: Configure flows\nStep 6: Configure test options\nStep 7: Set address rate parameters\nStep 8: Generate smart script\nStep 8: Execute smart script test\n\nCriteria: Expected Result 1: Step 9 correctly measures the device's address cache capacity\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastForwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc3918_MixedThroughput.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 如RFC2432规定，混合吞吐量测试是确定想一定数量的接口同时发送单播和组播流量时，DUT/SUT的吞吐量\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项混合吞吐量测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置混合吞吐量;\n                   测试步骤9: 配置单播流量;\n                   测试步骤10: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤10 正确生成混合吞吐量测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "Objective: As specified in RFC2432, the mixed throughput test determines the throughput of the DUT/SUT when a specific number of interfaces simultaneously transmit unicast and multicast traffic.\n\nStep: Test Step 1: Create ports and reserve ports\nTest Step 2: Create RFC3918 wizard, select test item: Mixed Throughput Test\nTest Step 3: Select ports\nTest Step 4: Configure endpoints\nTest Step 5: Configure flows\nTest Step 6: Configure multicast parameters\nTest Step 7: Configure test options\nTest Step 8: Configure mixed throughput\nTest Step 9: Configure unicast traffic\nTest Step 10: Generate smart scripts\n\nCriteria: Expected Result 1: Step 10 correctly generates the mixed throughput test item.\n\nCreated by: Tester-001\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['mixedThroughput'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed', DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置混合吞吐量* ===============\n    # 搜索算法\n    edit_benchmark_search(Config=Config, Mode='step', Lower=1, Upper=50, Init=10, Step=10, Resolution=1, Ratio=50,\n                          Acceptance=0, Ignore=False, EnableLatency=False, Maxlatency=30)\n    # 组播流百分比\n    edit_benchmark_multicast_traffic_ratio_loop(Config=Config, LoopMode='random', MinRatio=10, MaxRatio=50)\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', MinGroup=10, MaxGroup=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='Rfc3918MixedThroughput',\n                                    AddTimeStamp=True)\n\n    # =============== *配置单播流量* ===============\n    unicast_streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=False)\n    edit_benchmark_multicast_mixed_throughput_unicast_streams(Config=Config, Streams=unicast_streams)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='mixedThroughput')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数",
      "edit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组",
      "edit_benchmark_multicast_mixed_throughput_unicast_streams:RFC3918测试套件组播混合吞吐量-配置单播流量",
      "edit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他",
      "edit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置",
      "edit_benchmark_multicast_traffic_ratio_loop:RFC3918测试套件配置组播混合吞吐量-组播百分比设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product using init_tester API.\",\n  \"Subtask 2\": \"Reserve specified ports with force option using reserve_port API.\",\n  \"Subtask 3\": \"Create RFC3918 benchmark selecting 'mixedThroughput' test item using create_benchmark API.\",\n  \"Subtask 4\": \"Assign reserved ports to benchmark using relate_benchmark_ports API.\",\n  \"Subtask 5\": \"Create IPv4 interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 6\": \"Configure IPv4 addresses and gateways for both interfaces using edit_interface API (Port1: 1.1.1.1/1.1.1.2, Port2: 1.1.1.2/1.1.1.1).\",\n  \"Subtask 7\": \"Retrieve IPv4 layer objects from interfaces using get_layer_from_interfaces API.\",\n  \"Subtask 8\": \"Create benchmark streams using IPv4 layer objects in m2m mode with bidirectional=False via create_benchmark_streams API.\",\n  \"Subtask 9\": \"Configure multicast base parameters (IGMPv2, group address 225.0.0.1, step 0.1.0.0) using edit_benchmark_multicast_base_parameters API.\",\n  \"Subtask 10\": \"Set transport layer to UDP with random ports using edit_benchmark_transport_layer API.\",\n  \"Subtask 11\": \"Configure multicast stream TOS/TTL (TOS=2, TTL=11) using edit_benchmark_multicast_stream_tos API.\",\n  \"Subtask 12\": \"Configure address learning parameters (frequency=frame, ARP enabled) using edit_benchmark_learning API.\",\n  \"Subtask 13\": \"Set test duration parameters (trial=1, mode=burst) using edit_benchmark_duration API.\",\n  \"Subtask 14\": \"Configure frame length settings (type=step, min=128, max=512) using edit_benchmark_frame API.\",\n  \"Subtask 15\": \"Set latency type to FIFO using edit_benchmark_latency API.\",\n  \"Subtask 16\": \"Configure multicast other parameters (stop_on_fail=True, verify_freq=topo_changed) using edit_benchmark_multicast_other API.\",\n  \"Subtask 17\": \"Set result path to 'D:/test' using edit_benchmark_path API.\",\n  \"Subtask 18\": \"Configure latency delay-after to 20ms using edit_benchmark_latency API.\",\n  \"Subtask 19\": \"Set mixed throughput search algorithm (mode=step, init=10, step=10) using edit_benchmark_search API.\",\n  \"Subtask 20\": \"Configure multicast traffic ratio loop (min=10%, max=50%, mode=random) using edit_benchmark_multicast_traffic_ratio_loop API.\",\n  \"Subtask 21\": \"Configure multicast group count loop (min=10, max=50, mode=random) using edit_benchmark_multicast_group_count_loop API.\",\n  \"Subtask 22\": \"Set custom result filename (Rfc3918MixedThroughput) with timestamp using edit_benchmark_result_file_name API.\",\n  \"Subtask 23\": \"Create unicast streams binding IPv4 layers using add_stream API with bidirectional=False.\",\n  \"Subtask 24\": \"Assign unicast streams to mixed throughput test using edit_benchmark_multicast_mixed_throughput_unicast_streams API.\",\n  \"Subtask 25\": \"Generate test scripts by expanding benchmark configuration using expand_benchmark API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: As specified in RFC2432, the mixed throughput test determines the throughput of the DUT/SUT when a specific number of interfaces simultaneously transmit unicast and multicast traffic.\n\nStep: Test Step 1: Create ports and reserve ports\nTest Step 2: Create RFC3918 wizard, select test item: Mixed Throughput Test\nTest Step 3: Select ports\nTest Step 4: Configure endpoints\nTest Step 5: Configure flows\nTest Step 6: Configure multicast parameters\nTest Step 7: Configure test options\nTest Step 8: Configure mixed throughput\nTest Step 9: Configure unicast traffic\nTest Step 10: Generate smart scripts\n\nCriteria: Expected Result 1: Step 10 correctly generates the mixed throughput test item.\n\nCreated by: Tester-001\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['mixedThroughput'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed', DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置混合吞吐量* ===============\n    # 搜索算法\n    edit_benchmark_search(Config=Config, Mode='step', Lower=1, Upper=50, Init=10, Step=10, Resolution=1, Ratio=50,\n                          Acceptance=0, Ignore=False, EnableLatency=False, Maxlatency=30)\n    # 组播流百分比\n    edit_benchmark_multicast_traffic_ratio_loop(Config=Config, LoopMode='random', MinRatio=10, MaxRatio=50)\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', MinGroup=10, MaxGroup=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='Rfc3918MixedThroughput',\n                                    AddTimeStamp=True)\n\n    # =============== *配置单播流量* ===============\n    unicast_streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=False)\n    edit_benchmark_multicast_mixed_throughput_unicast_streams(Config=Config, Streams=unicast_streams)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='mixedThroughput')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数;\nedit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组;\nedit_benchmark_multicast_mixed_throughput_unicast_streams:RFC3918测试套件组播混合吞吐量-配置单播流量;\nedit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他;\nedit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置;\nedit_benchmark_multicast_traffic_ratio_loop:RFC3918测试套件配置组播混合吞吐量-组播百分比设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc3918_MulticastThroughput.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定再DUT/SUT在一定数量端口加入不同数量的组播组时的转发率\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项聚合组播吞吐量测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置聚合组播吞吐量;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成聚合组播吞吐量测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective\t:   To determine the forwarding rate when the DUT/SUT joins different numbers of multicast groups on a certain number of ports.\n\nStep\t\t:   Step 1: Create ports and reserve ports\n                Step 2: Create RFC3918 wizard and select test item: Aggregate Multicast Throughput Test;\n                Step 3: Select ports;\n                Step 4: Configure endpoints;\n                Step 5: Configure streams;\n                Step 6: Configure multicast parameters;\n                Step 7: Configure test options;\n                Step 8: Configure aggregate multicast throughput;\n                Step 9: Generate smart script;\n\nCriteria\t:   Expected result 1: Step 9 correctly generates the Aggregate Multicast Throughput test item;\n\nCreated by\t:   Tester-001\n\nBugs\t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastThroughput'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=2, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed', DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置聚合组播吞吐量* ===============\n    # 搜索算法\n    edit_benchmark_search(Config=Config, Mode='step', Lower=1, Upper=20, Init=10, Step=10, Resolution=1, Ratio=50,\n                          Acceptance=0, Ignore=False, EnableLatency=False, Maxlatency=30)\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', FixedGroup=10, MinGroup=10, MaxGroup=50,\n                                              StartGroup=10, EndGroup=50, StepGroup=10, CustomGroup=(10, 20, 100))\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='Rfc3918MulticastThroughput',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastThroughput')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数",
      "edit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组",
      "edit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他",
      "edit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product parameters.\",\n  \"Subtask 2\": \"Reserve specified ports for testing using force reservation.\",\n  \"Subtask 3\": \"Create RFC3918 benchmark test suite and select 'Aggregate Multicast Throughput' test item.\",\n  \"Subtask 4\": \"Assign reserved ports to the benchmark test suite.\",\n  \"Subtask 5\": \"Create IPv4 interfaces on both reserved ports.\",\n  \"Subtask 6\": \"Configure IPv4 addresses and gateways on both interfaces (1.1.1.1/1.1.1.2 and 1.1.1.2/1.1.1.1).\",\n  \"Subtask 7\": \"Retrieve IPv4 layer objects from created interfaces.\",\n  \"Subtask 8\": \"Create unidirectional multicast streams between source and destination IPv4 endpoints.\",\n  \"Subtask 9\": \"Configure multicast base parameters: IGMPv2, group address range (225.0.0.1 with 0.1.0.0 step), join/leave delays, and distribution mode.\",\n  \"Subtask 10\": \"Configure transport layer: UDP protocol with random port assignment.\",\n  \"Subtask 11\": \"Configure stream parameters: TOS=2, TTL=11, priority=1.\",\n  \"Subtask 12\": \"Configure address learning: frame-based frequency, ARP enablement, and rate settings.\",\n  \"Subtask 13\": \"Set test duration: 2 trials in burst mode with single count.\",\n  \"Subtask 14\": \"Configure frame length: step mode from 128 to 512 bytes with 128-byte increment.\",\n  \"Subtask 15\": \"Set latency type to FIFO and post-test delay to 20 seconds.\",\n  \"Subtask 16\": \"Configure multicast other parameters: failure stop condition, verification frequency, and frame rate.\",\n  \"Subtask 17\": \"Set result storage path.\",\n  \"Subtask 18\": \"Configure multicast throughput search: step algorithm with 1-20% load range and 10% increment.\",\n  \"Subtask 19\": \"Configure multicast group variation: random mode with 10-50 group range.\",\n  \"Subtask 20\": \"Set custom result filename with timestamp.\",\n  \"Subtask 21\": \"Generate benchmark smart script.\",\n  \"Subtask 22\": \"Save test configuration to .xcfg file.\",\n  \"Subtask 23\": \"Execute benchmark test with 3600s timeout and analyzer enabled.\",\n  \"Subtask 24\": \"Retrieve and format multicast throughput results from benchmark database.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective\t:   To determine the forwarding rate when the DUT/SUT joins different numbers of multicast groups on a certain number of ports.\n\nStep\t\t:   Step 1: Create ports and reserve ports\n                Step 2: Create RFC3918 wizard and select test item: Aggregate Multicast Throughput Test;\n                Step 3: Select ports;\n                Step 4: Configure endpoints;\n                Step 5: Configure streams;\n                Step 6: Configure multicast parameters;\n                Step 7: Configure test options;\n                Step 8: Configure aggregate multicast throughput;\n                Step 9: Generate smart script;\n\nCriteria\t:   Expected result 1: Step 9 correctly generates the Aggregate Multicast Throughput test item;\n\nCreated by\t:   Tester-001\n\nBugs\t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastThroughput'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=2, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed', DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置聚合组播吞吐量* ===============\n    # 搜索算法\n    edit_benchmark_search(Config=Config, Mode='step', Lower=1, Upper=20, Init=10, Step=10, Resolution=1, Ratio=50,\n                          Acceptance=0, Ignore=False, EnableLatency=False, Maxlatency=30)\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', FixedGroup=10, MinGroup=10, MaxGroup=50,\n                                              StartGroup=10, EndGroup=50, StepGroup=10, CustomGroup=(10, 20, 100))\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='Rfc3918MulticastThroughput',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastThroughput')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数;\nedit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组;\nedit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他;\nedit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_ErroredFrameFilter.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的错误帧过滤\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项错误帧过滤;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "Objective: Determine the error frame filtering capability of the LAN switch device  \n\nStep:  \nStep 1: Create ports and reserve ports  \nStep 2: Create RFC2889 wizard, select test item \"Error Frame Filtering\"  \nStep 3: Select ports  \nStep 4: Configure endpoints  \nStep 5: Configure flows  \nStep 6: Configure test options  \nStep 7: Set address rate parameters  \nStep 8: Generate smart script  \nStep 8: Execute smart script test  \n\nCriteria:  \nExpected Result 1: Step 9 correctly measures the device's address cache capacity  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['erroredFrameFilter'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *错误帧过滤参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 错误以太帧、突发和帧长设置\n    edit_benchmark_errored_frame_filtering(Config=Config, CrcTested=True, CrcFrameLength=128,\n                                           UndersizedTested=True, UndersizedFrameLength=58,\n                                           OversizedTested=True, OversizedFrameLength=1600,\n                                           MaxLegalFrameLength=1518, BurstSize=100)\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='erroredFrameFilter',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_errored_frame_filtering:编辑RFC2889测试套件错误帧过滤测试项参数",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with specified product configuration (default 'DarYu' or input argument).\",\n  \"Subtask 2\": \"Reserve two specified physical ports on the tester using location parameters.\",\n  \"Subtask 3\": \"Create RFC2889 benchmark test suite with 'Error Frame Filtering' as the selected test item.\",\n  \"Subtask 4\": \"Assign reserved ports to the benchmark test suite as test endpoints.\",\n  \"Subtask 5\": \"Create Ethernet layer interfaces on both reserved ports.\",\n  \"Subtask 6\": \"Retrieve Ethernet layer objects from created interfaces for stream configuration.\",\n  \"Subtask 7\": \"Create benchmark traffic streams between source and destination Ethernet endpoints.\",\n  \"Subtask 8\": \"Configure benchmark latency settings (FIFO type, 2s delay before test, 10s delay after test).\",\n  \"Subtask 9\": \"Set benchmark result storage path to 'D:/test' directory.\",\n  \"Subtask 10\": \"Configure address learning settings (per-trial frequency, 100 pps rate, 3 repetitions, 5s delay).\",\n  \"Subtask 11\": \"Set test duration parameters (1 trial, burst mode, 100 frames per burst).\",\n  \"Subtask 12\": \"Configure error frame filtering parameters: enable CRC frames (128B), undersized frames (58B), oversized frames (1600B), set max legal frame to 1518B, burst size 100 frames.\",\n  \"Subtask 13\": \"Configure traffic load pattern (step mode from 10% to 20% with 10% increment).\",\n  \"Subtask 14\": \"Set custom result filename to 'erroredFrameFilter' with timestamp appended.\",\n  \"Subtask 15\": \"Expand benchmark configuration to generate executable test scripts.\",\n  \"Subtask 16\": \"Save current test case configuration to .xcfg file in specified directory.\",\n  \"Subtask 17\": \"Execute benchmark test suite with 1200s timeout and analyzer enabled.\",\n  \"Subtask 18\": \"Retrieve test results from benchmark execution database.\",\n  \"Subtask 19\": \"Format benchmark results into tabular output for analysis.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Determine the error frame filtering capability of the LAN switch device  \n\nStep:  \nStep 1: Create ports and reserve ports  \nStep 2: Create RFC2889 wizard, select test item \"Error Frame Filtering\"  \nStep 3: Select ports  \nStep 4: Configure endpoints  \nStep 5: Configure flows  \nStep 6: Configure test options  \nStep 7: Set address rate parameters  \nStep 8: Generate smart script  \nStep 8: Execute smart script test  \n\nCriteria:  \nExpected Result 1: Step 9 correctly measures the device's address cache capacity  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['erroredFrameFilter'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *错误帧过滤参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 错误以太帧、突发和帧长设置\n    edit_benchmark_errored_frame_filtering(Config=Config, CrcTested=True, CrcFrameLength=128,\n                                           UndersizedTested=True, UndersizedFrameLength=58,\n                                           OversizedTested=True, OversizedFrameLength=1600,\n                                           MaxLegalFrameLength=1518, BurstSize=100)\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='erroredFrameFilter',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_errored_frame_filtering:编辑RFC2889测试套件错误帧过滤测试项参数;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_BroadcastLatency.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧时延\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧时延;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Objective: Determine the broadcast frame delay of the LAN switch device\n\nStep         :   Step 1: Create ports and reserve ports\n                   Step 2: Create RFC2889 wizard, select test item: broadcast frame delay\n                   Step 3: Select ports\n                   Step 4: Configure endpoints\n                   Step 5: Configure streams\n                   Step 6: Configure test options\n                   Step 7: Set address rate parameters\n                   Step 8: Generate smart scripts\n                   Step 8: Execute smart script test\n\nCriteria     :   Expected Result 1: Step 9 correctly measures the device's address cache capacity\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastLatency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧时延参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastLatency',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (default: 'DarYu') to prepare the testing environment.\",\n  \"Subtask 2\": \"Reserve two ports using provided locations (default: '//10.0.11.191/1/5' and '//10.0.11.191/1/6') with force reservation enabled.\",\n  \"Subtask 3\": \"Create an RFC2889 benchmark test suite specifically for the 'broadcastLatency' test item.\",\n  \"Subtask 4\": \"Assign the reserved ports to the benchmark configuration for test participation.\",\n  \"Subtask 5\": \"Create Ethernet layer interfaces on both reserved ports to establish communication layers.\",\n  \"Subtask 6\": \"Retrieve Ethernet layer objects from both created interfaces for stream configuration.\",\n  \"Subtask 7\": \"Create unidirectional benchmark traffic streams between source and destination Ethernet layers using the test configuration.\",\n  \"Subtask 8\": \"Configure benchmark latency settings: set measurement type to 'FIFO', delay before measurement to 2 units, and delay after to 10 units.\",\n  \"Subtask 9\": \"Set benchmark result storage path to 'D:/test' for test outputs.\",\n  \"Subtask 10\": \"Configure address learning parameters: enable learning before each trial, set learning rate to 100%, 3 learning repeats, and 5-unit delay before learning.\",\n  \"Subtask 11\": \"Configure test duration: set to 1 trial in burst mode with 100 frames per burst.\",\n  \"Subtask 12\": \"Set frame length to custom size 64 bytes for all test traffic.\",\n  \"Subtask 13\": \"Configure custom result filename as 'broadcastLatency' with timestamp appended for unique identification.\",\n  \"Subtask 14\": \"Expand the benchmark configuration to generate executable smart scripts.\",\n  \"Subtask 15\": \"Save the current test configuration to an .xcfg file in the execution directory.\",\n  \"Subtask 16\": \"Execute the benchmark test with analyzer enabled, allowing up to 1200 seconds completion time.\",\n  \"Subtask 17\": \"Retrieve and parse RFC2889 benchmark results from the generated database.\",\n  \"Subtask 18\": \"Format the benchmark results into a readable two-dimensional table for analysis.\",\n  \"Subtask 19\": \"Validate that broadcast frame delay measurements meet test criteria and handle any execution errors.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Objective: Determine the broadcast frame delay of the LAN switch device\n\nStep         :   Step 1: Create ports and reserve ports\n                   Step 2: Create RFC2889 wizard, select test item: broadcast frame delay\n                   Step 3: Select ports\n                   Step 4: Configure endpoints\n                   Step 5: Configure streams\n                   Step 6: Configure test options\n                   Step 7: Set address rate parameters\n                   Step 8: Generate smart scripts\n                   Step 8: Execute smart script test\n\nCriteria     :   Expected Result 1: Step 9 correctly measures the device's address cache capacity\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastLatency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧时延参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastLatency',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc3918_MulticastJoinLeaveLatency.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定再DUT/SUT收到IGMP陈工加入离开组消息开始，DUT/SUT开始/停止转发多播帧需要的时间\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项加入离开组时延测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置加入离开组时延;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成加入离开组时延测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   To determine the time required from when the DUT/SUT receives an IGMP successful join/leave group message until the DUT/SUT starts/stops forwarding multicast frames.\n\nStep\t\t\t:\tTest Step 1: Create ports and reserve ports;\n                   Test Step 2: Create RFC3918 wizard, select test item: join/leave group delay test;\n                   Test Step 3: Select ports;\n                   Test Step 4: Configure endpoints;\n                   Test Step 5: Configure streams;\n                   Test Step 6: Configure multicast parameters;\n                   Test Step 7: Configure test options;\n                   Test Step 8: Configure join/leave group delay;\n                   Test Step 9: Generate smart scripts;\n\nCriteria    \t:   Expected Result 1: Step 9 correctly generates the join/leave group delay test item;\n\nCreated by   \t:   Tester-001\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastJoinLeaveLatency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='random', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed', DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置加入离开组时延* ===============\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', FixedGroup=10, MinGroup=10, MaxGroup=50,\n                                              StartGroup=10, EndGroup=50, StepGroup=10, CustomGroup=(10, 20, 100))\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 延迟设置\n    edit_benchmark_multicast_join_leave_delay(Config=Config, DelayBetweenJoinAndStartStream=20, DelayBetweenJoinAndLeave=15)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='Rfc3918MixedThroughput',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastThroughput')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数",
      "edit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组",
      "edit_benchmark_multicast_join_leave_delay:RFC3918测试套件-配置加入离开组时延",
      "edit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他",
      "edit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with specified product type (default: 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports at given locations and assign them as port_up and port_down.\",\n  \"Subtask 3\": \"Create RFC3918 benchmark test suite with test item 'multicastJoinLeaveLatency' selected.\",\n  \"Subtask 4\": \"Relate reserved ports (port_up and port_down) to the benchmark configuration.\",\n  \"Subtask 5\": \"Create IPv4 interfaces on both reserved ports.\",\n  \"Subtask 6\": \"Configure IPv4 addresses and gateways for both interfaces (port_up: 1.1.1.1/1.1.1.2, port_down: 1.1.1.2/1.1.1.1).\",\n  \"Subtask 7\": \"Retrieve IPv4 layer objects from both interfaces for stream configuration.\",\n  \"Subtask 8\": \"Create benchmark streams using IPv4 endpoints, unidirectional mode, and multicast-to-multicast transmission.\",\n  \"Subtask 9\": \"Configure multicast base parameters: IGMPv2 version, group address range (225.0.0.1 with step 0.1.0.0), join/leave delay 15ms, and even distribution mode.\",\n  \"Subtask 10\": \"Configure transport layer: UDP header with randomized source/destination ports.\",\n  \"Subtask 11\": \"Configure multicast stream parameters: TOS=2, TTL=11, priority=1.\",\n  \"Subtask 12\": \"Configure address learning: frame-based learning at 1000fps, ARP enabled with 3 retries.\",\n  \"Subtask 13\": \"Configure test duration: 1 trial in burst mode with 1 count.\",\n  \"Subtask 14\": \"Configure frame settings: random lengths between 128-512 bytes.\",\n  \"Subtask 15\": \"Configure latency measurement type as FIFO.\",\n  \"Subtask 16\": \"Configure multicast test options: stop on failure, topology change verification, 2-second duration, 1000fps transmission rate.\",\n  \"Subtask 17\": \"Set result storage path to 'D:/test'.\",\n  \"Subtask 18\": \"Configure 20-second delay after test completion.\",\n  \"Subtask 19\": \"Configure multicast group parameters: random group count between 10-50.\",\n  \"Subtask 20\": \"Configure traffic load: random percentage between 10%-50%.\",\n  \"Subtask 21\": \"Configure join/leave delays: 20ms between join and stream start, 15ms between join and leave.\",\n  \"Subtask 22\": \"Configure custom result filename as 'Rfc3918MixedThroughput' with timestamp.\",\n  \"Subtask 23\": \"Generate smart scripts by expanding the benchmark configuration.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   To determine the time required from when the DUT/SUT receives an IGMP successful join/leave group message until the DUT/SUT starts/stops forwarding multicast frames.\n\nStep\t\t\t:\tTest Step 1: Create ports and reserve ports;\n                   Test Step 2: Create RFC3918 wizard, select test item: join/leave group delay test;\n                   Test Step 3: Select ports;\n                   Test Step 4: Configure endpoints;\n                   Test Step 5: Configure streams;\n                   Test Step 6: Configure multicast parameters;\n                   Test Step 7: Configure test options;\n                   Test Step 8: Configure join/leave group delay;\n                   Test Step 9: Generate smart scripts;\n\nCriteria    \t:   Expected Result 1: Step 9 correctly generates the join/leave group delay test item;\n\nCreated by   \t:   Tester-001\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastJoinLeaveLatency'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='random', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed', DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置加入离开组时延* ===============\n    # 组播组\n    edit_benchmark_multicast_group_count_loop(Config=Config, LoopMode='random', FixedGroup=10, MinGroup=10, MaxGroup=50,\n                                              StartGroup=10, EndGroup=50, StepGroup=10, CustomGroup=(10, 20, 100))\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 延迟设置\n    edit_benchmark_multicast_join_leave_delay(Config=Config, DelayBetweenJoinAndStartStream=20, DelayBetweenJoinAndLeave=15)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='Rfc3918MixedThroughput',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastThroughput')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数;\nedit_benchmark_multicast_group_count_loop:RFC3918测试套件-组播组;\nedit_benchmark_multicast_join_leave_delay:RFC3918测试套件-配置加入离开组时延;\nedit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他;\nedit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_Forwarding.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Determine the forwarding of LAN switch equipment\n\nStep 1: Create ports and reserve ports\nStep 2: Create RFC2889 wizard, select test item: forwarding\nStep 3: Select ports\nStep 4: Configure endpoints\nStep 5: Configure flows\nStep 6: Configure test options\nStep 7: Address rate parameter settings\nStep 8: Generate smart script\nStep 8: Execute smart script test\n\nCriteria: Expected result 1: Step 9 correctly tests the device address cache capacity\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['forwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='forwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with specified product configuration (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve and activate specified ports at given locations (e.g., '//10.0.11.191/1/5', '//10.0.11.191/1/6').\",\n  \"Subtask 3\": \"Create RFC2889 benchmark test suite and select 'forwarding' as the test item.\",\n  \"Subtask 4\": \"Assign reserved ports to the benchmark test suite configuration.\",\n  \"Subtask 5\": \"Create Ethernet interfaces on each reserved port.\",\n  \"Subtask 6\": \"Retrieve Ethernet layer objects from created interfaces for stream configuration.\",\n  \"Subtask 7\": \"Create benchmark traffic streams using Ethernet layer objects as source and destination points.\",\n  \"Subtask 8\": \"Configure benchmark test options: latency settings (FIFO type, 2s delay before, 10s delay after), result storage path (e.g., 'D:/test'), and address learning parameters (enable learning, trial frequency, 100 packets/s rate, 3 repeats, 5s delay before).\",\n  \"Subtask 9\": \"Configure forwarding test parameters: set trial count to 1 with burst mode and 100 iterations, frame length to 64 bytes, load search to step mode (10%-20% range, 10% step), and custom result file naming ('forwarding' with timestamp).\",\n  \"Subtask 10\": \"Generate executable test script by expanding benchmark configuration.\",\n  \"Subtask 11\": \"Save test configuration to specified file path (e.g., current script directory under 'xcfg' folder with .xcfg extension).\",\n  \"Subtask 12\": \"Execute benchmark test with normal mode (0), 1200s timeout, and analyzer enabled.\",\n  \"Subtask 13\": \"Retrieve and format benchmark results from database into readable output.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Determine the forwarding of LAN switch equipment\n\nStep 1: Create ports and reserve ports\nStep 2: Create RFC2889 wizard, select test item: forwarding\nStep 3: Select ports\nStep 4: Configure endpoints\nStep 5: Configure flows\nStep 6: Configure test options\nStep 7: Address rate parameter settings\nStep 8: Generate smart script\nStep 8: Execute smart script test\n\nCriteria: Expected result 1: Step 9 correctly tests the device address cache capacity\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['forwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='forwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TSN/tsn_qcr.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备背靠背测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建TSN Qcr向导;\n                   测试步骤3: 配置Qcr stream;\n                   测试步骤4: 配置Stream identification function;\n                   测试步骤5: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤5 向导配置生成成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   : LAN switch back-to-back test\n\nStep        : Step 1: Create ports and reserve ports\n              Step 2: Create TSN Qcr wizard;\n              Step 3: Configure Qcr stream;\n              Step 4: Configure Stream identification function;\n              Step 5: Generate wizard configuration;\n\nCriteria    : Criteria 1: Step 5 wizard configuration is successfully generated;\n\nCreated by  : Tester-001\n\nBugs        : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(\n    ' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2 = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard = create_tsn_wizard(Type='qcr')\n\n    # =============== *创建Qcr stream* ===============\n    qcr_stream_config = create_tsn_qcr_stream(wizard, TalkerPort=port_1, ListenerPortList=port_2, Priority=3)\n\n    # =============== *配置Stream identification function* ===============\n    config_tsn_qcr_stream_identification_function(qcr_stream_config, StreamIdentificationFunction='IP_OCTUPLE_STREAM',\n                                                  SourceMacAddress='00:01:02:03:00:02',\n                                                  DestinationMacAddress='00:02:02:03:00:02', VlanId=100)\n\n    # =============== *生成向导配置* ===============\n    expand_tsn_wizard(Wizard=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product type (DarYu or command line argument) using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports using reserve_port API with provided locations and Force=True parameter.\",\n  \"Subtask 3\": \"Create a TSN wizard of type 'qcr' using create_tsn_wizard API.\",\n  \"Subtask 4\": \"Create a Qcr stream on the wizard specifying talker port as first reserved port, listener port as second reserved port, and priority=3 using create_tsn_qcr_stream API.\",\n  \"Subtask 5\": \"Configure stream identification function for the Qcr stream with IP_OCTUPLE_STREAM method, source MAC '00:01:02:03:00:02', destination MAC '00:02:02:03:00:02', and VLAN ID 100 using config_tsn_qcr_stream_identification_function API.\",\n  \"Subtask 6\": \"Generate the wizard configuration by expanding the TSN wizard using expand_tsn_wizard API.\",\n  \"Subtask 7\": \"Save the test configuration to an .xcfg file in the script's xcfg directory using save_case API with dynamically generated path matching the script name.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   : LAN switch back-to-back test\n\nStep        : Step 1: Create ports and reserve ports\n              Step 2: Create TSN Qcr wizard;\n              Step 3: Configure Qcr stream;\n              Step 4: Configure Stream identification function;\n              Step 5: Generate wizard configuration;\n\nCriteria    : Criteria 1: Step 5 wizard configuration is successfully generated;\n\nCreated by  : Tester-001\n\nBugs        : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(\n    ' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2 = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard = create_tsn_wizard(Type='qcr')\n\n    # =============== *创建Qcr stream* ===============\n    qcr_stream_config = create_tsn_qcr_stream(wizard, TalkerPort=port_1, ListenerPortList=port_2, Priority=3)\n\n    # =============== *配置Stream identification function* ===============\n    config_tsn_qcr_stream_identification_function(qcr_stream_config, StreamIdentificationFunction='IP_OCTUPLE_STREAM',\n                                                  SourceMacAddress='00:01:02:03:00:02',\n                                                  DestinationMacAddress='00:02:02:03:00:02', VlanId=100)\n\n    # =============== *生成向导配置* ===============\n    expand_tsn_wizard(Wizard=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc3918_MulticastGroupCapacity.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定再DUT/SUT能够正确转发数据包到注册在该DUT/SUT的组播组情况下，DUT/SUT能够支持的最大的组播组数量\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC3918向导, 选择测试项组播组容量测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置组播参数;\n                   测试步骤7: 配置测试选项;\n                   测试步骤8: 配置组播组容量;\n                   测试步骤9: 生成智能脚本;\n\n Criteria    \t:   预期结果1: 步骤9 正确生成配置组播组容量测试项;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Objective: Determine the maximum number of multicast groups supported by the DUT/SUT while ensuring correct packet forwarding to multicast groups registered on the DUT/SUT\n\nStep: Test Step 1: Create ports and reserve ports\nTest Step 2: Create RFC3918 wizard, select test item \"Multicast Group Capacity Test\";\nTest Step 3: Select ports;\nTest Step 4: Configure endpoints;\nTest Step 5: Configure streams;\nTest Step 6: Configure multicast parameters;\nTest Step 7: Configure test options;\nTest Step 8: Configure multicast group capacity;\nTest Step 9: Generate smart scripts;\n\nCriteria: Expected Result 1: Step 9 correctly generates the configuration for the multicast group capacity test item;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastGroupCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed',\n                                   DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置组播组容量* ===============\n    # 组播搜索算法\n    edit_benchmark_search(Config=Config, Mode='binary', Lower=1, Upper=20, Init=10, Step=10, Resolution=1, Ratio=50,\n                          Acceptance=0, Ignore=False, EnableLatency=False, Maxlatency=30)\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True,\n                                    ResultFileName='Rfc3918MulticastGroupCapacity',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastGroupCapacity')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数",
      "edit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他",
      "edit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (e.g., 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports using provided locations through reserve_port API, assigning them to variables port_up and port_down.\",\n  \"Subtask 3\": \"Create RFC3918 benchmark wizard for 'Multicast Group Capacity Test' using create_benchmark API with Type='RFC3918' and Items=['multicastGroupCapacity'].\",\n  \"Subtask 4\": \"Assign reserved ports (port_up and port_down) to benchmark wizard using relate_benchmark_ports API.\",\n  \"Subtask 5\": \"Create IPv4 interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 6\": \"Configure IPv4 interface parameters: set Address='1.1.1.1' and Gateway='1.1.1.2' for port_up interface, and Address='1.1.1.2' and Gateway='1.1.1.1' for port_down interface using edit_interface API.\",\n  \"Subtask 7\": \"Retrieve IPv4 layer objects from both interfaces using get_layer_from_interfaces API.\",\n  \"Subtask 8\": \"Create benchmark streams using create_benchmark_streams API with Type='ipv4', SrcPoints=port_up IPv4 layer, DstPoints=port_down IPv4 layer, Bidirectional=False, and Mode='m2m'.\",\n  \"Subtask 9\": \"Configure multicast base parameters: set Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1', Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1, JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000, GroupDistributeMode='even' using edit_benchmark_multicast_base_parameters API.\",\n  \"Subtask 10\": \"Configure transport layer: set HeaderType='udp', EnableRandomPort=True, SrcPortBase=7, SrcPortStep=1, DstPortBase=7, DstPortStep=1 using edit_benchmark_transport_layer API.\",\n  \"Subtask 11\": \"Configure multicast stream TOS: set Tos=2, TTL=11, Priority=1 using edit_benchmark_multicast_stream_tos API.\",\n  \"Subtask 12\": \"Configure learning parameters: set Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5, DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3 using edit_benchmark_learning API.\",\n  \"Subtask 13\": \"Configure test duration: set Trial=1, Mode='burst', Count=1 using edit_benchmark_duration API.\",\n  \"Subtask 14\": \"Configure frame settings: set Type='step', Min=128, Max=512, Start=128, End=256, Step=128 using edit_benchmark_frame API.\",\n  \"Subtask 15\": \"Configure latency type: set Type='FIFO' using edit_benchmark_latency API.\",\n  \"Subtask 16\": \"Configure multicast other parameters: set StopTestWhenFailed=True, VerifyFreq='topo_changed', DurationMode='second', TimeDurationCount=2, TxFrameRate=1000 using edit_benchmark_multicast_other API.\",\n  \"Subtask 17\": \"Configure results path: set Path='D:/test' using edit_benchmark_path API.\",\n  \"Subtask 18\": \"Configure latency delay: set DelayAfter=20 using edit_benchmark_latency API.\",\n  \"Subtask 19\": \"Configure multicast group capacity search: set Mode='binary', Lower=1, Upper=20, Init=10, Step=10, Resolution=1, Ratio=50, Acceptance=0, Ignore=False, EnableLatency=False, Maxlatency=30 using edit_benchmark_search API.\",\n  \"Subtask 20\": \"Configure traffic load: set LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50 using edit_benchmark_traffic_load_loop API.\",\n  \"Subtask 21\": \"Configure result file name: set EnableCustomResult=True, ResultFileName='Rfc3918MulticastGroupCapacity', AddTimeStamp=True using edit_benchmark_result_file_name API.\",\n  \"Subtask 22\": \"Generate smart scripts for multicast group capacity test using expand_benchmark API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Objective: Determine the maximum number of multicast groups supported by the DUT/SUT while ensuring correct packet forwarding to multicast groups registered on the DUT/SUT\n\nStep: Test Step 1: Create ports and reserve ports\nTest Step 2: Create RFC3918 wizard, select test item \"Multicast Group Capacity Test\";\nTest Step 3: Select ports;\nTest Step 4: Configure endpoints;\nTest Step 5: Configure streams;\nTest Step 6: Configure multicast parameters;\nTest Step 7: Configure test options;\nTest Step 8: Configure multicast group capacity;\nTest Step 9: Generate smart scripts;\n\nCriteria: Expected Result 1: Step 9 correctly generates the configuration for the multicast group capacity test item;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC3918', Items=['multicastGroupCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False, Mode='m2m')\n\n    # =============== *配置组播参数* ===============\n    # 组播客户端版本号、组播组地址和步长、组播加入/离开延迟、组播组分配模式\n    edit_benchmark_multicast_base_parameters(Configs=Config, Version='igmpv2', Ipv4GroupAddressStart='225.0.0.1',\n                                             Ipv4GroupAddressStep='0.1.0.0', Ipv4PrefixLength=32, GroupIncrement=1,\n                                             JoinGroupDelay=15, LeaveGroupDelay=15, JoinLeaveSendRate=1000,\n                                             GroupDistributeMode='even')\n    # 传输层配置\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='udp', EnableRandomPort=True, SrcPortBase=7,\n                                   SrcPortStep=1,\n                                   SrcPortCount=0, DstPortBase=7, DstPortStep=1, DstPortCount=0)\n    # 流配置\n    edit_benchmark_multicast_stream_tos(Configs=Config, Tos=2, TTL=11, Priority=1)\n\n    # =============== *配置测试选项* ===============\n    # 地址学习\n    edit_benchmark_learning(Configs=Config, Frequency='frame', EnableLearning=True, LearningRate=1000, LearningRepeat=5,\n                            DelayBefore=2, EnableArp=True, ArpRate=1000, ArpRepeat=3)\n    # 测试时长\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=1)\n    # 帧长度设置\n    edit_benchmark_frame(Config, Type='step', Min=128, Max=512, Start=128, End=256, Step=128)\n    # 时延类型\n    edit_benchmark_latency(Configs=Config, Type='FIFO')\n    # 其他设置\n    edit_benchmark_multicast_other(Configs=Config, StopTestWhenFailed=True, VerifyFreq='topo_changed',\n                                   DurationMode='second',\n                                   TimeDurationCount=2, TxFrameRate=1000)\n    # 结果\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_latency(Configs=Config, DelayAfter=20)\n\n    # =============== *配置组播组容量* ===============\n    # 组播搜索算法\n    edit_benchmark_search(Config=Config, Mode='binary', Lower=1, Upper=20, Init=10, Step=10, Resolution=1, Ratio=50,\n                          Acceptance=0, Ignore=False, EnableLatency=False, Maxlatency=30)\n    # 负载设置\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit='percent', LoadMode='random', LoadMin=10, LoadMax=50)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True,\n                                    ResultFileName='Rfc3918MulticastGroupCapacity',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=3600, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC3918', Item='multicastGroupCapacity')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_multicast_base_parameters:编辑RFC3918测试套件-组播参数;\nedit_benchmark_multicast_other:编辑RFC3918测试套件-组播参数-其他;\nedit_benchmark_multicast_stream_tos:编辑RFC3918测试套件-组播参数-流配置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TSN/tsn_avb.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备背靠背测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建TSN Avb向导,选择端口;\n                   测试步骤3: 配置Qav;\n                   测试步骤4: 配置gPTP;\n                   测试步骤5: 配置Non-AVB stream;\n                   测试步骤6: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤6 向导配置生成成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Back-to-back testing of LAN switch equipment\n\nStep\t\t\t:\tStep 1: Create ports and reserve ports\n                   Step 2: Create TSN Avb wizard, select ports;\n                   Step 3: Configure Qav;\n                   Step 4: Configure gPTP;\n                   Step 5: Configure Non-AVB stream;\n                   Step 6: Generate wizard configuration;\n\nCriteria    \t:   Expected result 1: Step 6 wizard configuration generated successfully;\n\nCreated by   \t:  \tTester-001\n\nBugs   \t    :  \t None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6', '//10.0.11.191/1/7'] if len(sys.argv) < 2 else sys.argv[1].split(\n    ' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_3 = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard = create_tsn_wizard(Type='avb', TalkerPort=port_1, ListenerPort=port_2, NonAvbPort=port_3, IsAppended=False)\n\n    # =============== *配置Qav* ===============\n    config_tsn_avb_qav(wizard, FrameSize=120, SrClassVid=10, EnableClassA=True, ClassABwRsvPct=50,\n                       ClassAStreamNum=2, ClassAStreamsBwRsvPct=[25, 25], EnableClassB=True, ClassBBwRsvPct=25,\n                       ClassBStreamNum=1, ClassBStreamsBwRsvPct=[25])\n\n    # =============== *配置gPTP* ===============\n    config_tsn_avb_gptp(wizard, Priority1=100, Priority2=101, ClockAccuracy=EnumClockAccuracy.CLOCK_ACCURACY_22,\n                        LogAnnounceInterval=1, LogSyncInterval=1, AnnounceReceiptTimeout=4, PropogationDelay=1000)\n\n    # =============== *配置Non-AVB stream* ===============\n    config_tsn_avb_non_stream(wizard, NonAvbFrameSize=150, LoadRate=10, StreamNumber=1)\n\n    # =============== *生成向导配置* ===============\n    expand_tsn_wizard(Wizard=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform using init_tester API with specified product type (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve three test ports at specified locations using reserve_port API with Force=True parameter.\",\n  \"Subtask 3\": \"Create TSN AVB wizard configuration using create_tsn_wizard API with Type='avb', assigning TalkerPort, ListenerPort, and NonAvbPort to reserved ports.\",\n  \"Subtask 4\": \"Configure Qav settings via config_tsn_avb_qav API with FrameSize=120, SrClassVid=10, enabled ClassA/B streams, and bandwidth reservation percentages as specified.\",\n  \"Subtask 5\": \"Configure gPTP parameters via config_tsn_avb_gptp API with Priority1=100, Priority2=101, ClockAccuracy=22, and specified interval/timeout values.\",\n  \"Subtask 6\": \"Configure Non-AVB stream via config_tsn_avb_non_stream API with NonAvbFrameSize=150, LoadRate=10, and StreamNumber=1.\",\n  \"Subtask 7\": \"Generate TSN wizard configuration by expanding the wizard setup using expand_tsn_wizard API.\",\n  \"Subtask 8\": \"Save the generated test configuration to an XCFG file using save_case API at the specified path.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Back-to-back testing of LAN switch equipment\n\nStep\t\t\t:\tStep 1: Create ports and reserve ports\n                   Step 2: Create TSN Avb wizard, select ports;\n                   Step 3: Configure Qav;\n                   Step 4: Configure gPTP;\n                   Step 5: Configure Non-AVB stream;\n                   Step 6: Generate wizard configuration;\n\nCriteria    \t:   Expected result 1: Step 6 wizard configuration generated successfully;\n\nCreated by   \t:  \tTester-001\n\nBugs   \t    :  \t None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6', '//10.0.11.191/1/7'] if len(sys.argv) < 2 else sys.argv[1].split(\n    ' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_3 = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard = create_tsn_wizard(Type='avb', TalkerPort=port_1, ListenerPort=port_2, NonAvbPort=port_3, IsAppended=False)\n\n    # =============== *配置Qav* ===============\n    config_tsn_avb_qav(wizard, FrameSize=120, SrClassVid=10, EnableClassA=True, ClassABwRsvPct=50,\n                       ClassAStreamNum=2, ClassAStreamsBwRsvPct=[25, 25], EnableClassB=True, ClassBBwRsvPct=25,\n                       ClassBStreamNum=1, ClassBStreamsBwRsvPct=[25])\n\n    # =============== *配置gPTP* ===============\n    config_tsn_avb_gptp(wizard, Priority1=100, Priority2=101, ClockAccuracy=EnumClockAccuracy.CLOCK_ACCURACY_22,\n                        LogAnnounceInterval=1, LogSyncInterval=1, AnnounceReceiptTimeout=4, PropogationDelay=1000)\n\n    # =============== *配置Non-AVB stream* ===============\n    config_tsn_avb_non_stream(wizard, NonAvbFrameSize=150, LoadRate=10, StreamNumber=1)\n\n    # =============== *生成向导配置* ===============\n    expand_tsn_wizard(Wizard=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/ospf_lsa/ospfv3_lsa_wizard.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查Ospfv3 Lsa向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Ospfv3会话;\n                   测试步骤3: 创建Ospfv3 Lsa向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Ospfv3 Lsa向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     :   Test Objective: Verify that the OSPFv3 LSA wizard configuration is generated normally\n\nStep          :   Test Step 1: Create two offline ports: Port_1, Port_2;\n                  Test Step 2: Create an OSPFv3 session;\n                  Test Step 3: Create an OSPFv3 LSA wizard;\n                  Test Step 4: Generate the wizard configuration;\n\nCriteria      :   Expected Result 1: Step 4: The OSPFv3 LSA wizard configuration is generated without exceptions;\n\nCreated by    :   Tester-002\n\nBugs          :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='ipv6')\n    interfaces_2 = create_interface(Port=Port_2, Layers='ipv6')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建Ospfv3会话\n    ospf_1 = create_ospfv3(Port=Port_1)\n    ospf_2 = create_ospfv3(Port=Port_2)\n\n    select_interface(Session=ospf_1, Interface=interfaces_1)\n    select_interface(Session=ospf_2, Interface=interfaces_2)\n\n    # 创建Ospfv3 lsa向导\n    wizard = create_ospfv3_lsa_wizard(Sessions=[ospf_1, ospf_2])\n\n    # 配置Ospfv3拓扑\n    config_ospfv3_lsa_wizard_ospfv3_topo(Wizards=wizard, Type='GRID',\n                                         RowCount=10,\n                                         ColumnCount=20)\n\n    # 配置Ospfv3\n    config_ospfv3_lsa_wizard_ospfv3(Wizards=wizard,\n                                    AreaType='STUB')\n\n    # 配置Ospfv3 intra area route\n    config_ospfv3_lsa_wizard_ospfv3_intra_area_route(Wizards=wizard,\n                                                     IntraAreaEmulated='ALL',\n                                                     IntraAreaSimulated='NONE'\n                                                     )\n\n    # 配置Ospfv3 inter area route\n    config_ospfv3_lsa_wizard_ospfv3_inter_area_route(Wizards=wizard,\n                                                     InterAreaRoutesCount=10)\n\n    # 配置Ospfv3 external network\n    config_ospfv3_lsa_wizard_ospfv3_external_route(Wizards=wizard,\n                                                   ExternalDistributionType='CUSTOM',\n                                                   ExternalCustomPrefixLength=[10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 0.0,\n                                                                               10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0,\n                                                                               10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               10,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               ])\n\n    # 生成Ospfv3 Lsa向导配置\n    expand_ospfv3_lsa_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "create_ospfv3:创建OSPFv3协议会话对象"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester with product specification 'DarYu'.\",\n  \"Subtask 2\": \"Reserve two physical ports (Port_1 and Port_2) at specified locations.\",\n  \"Subtask 3\": \"Create IPv6 interfaces on both reserved ports.\",\n  \"Subtask 4\": \"Configure IPv6 layer parameters for Port_1 interface: Address='2001::1', Gateway='2001::2'.\",\n  \"Subtask 5\": \"Configure IPv6 layer parameters for Port_2 interface: Address='2001::2', Gateway='2001::1'.\",\n  \"Subtask 6\": \"Create OSPFv3 session objects on both ports.\",\n  \"Subtask 7\": \"Bind the created IPv6 interfaces to their respective OSPFv3 sessions.\",\n  \"Subtask 8\": \"Create an OSPFv3 LSA wizard encompassing both OSPFv3 sessions.\",\n  \"Subtask 9\": \"Configure OSPFv3 topology in the wizard: Type='GRID', RowCount=10, ColumnCount=20.\",\n  \"Subtask 10\": \"Configure OSPFv3 area parameters in the wizard: AreaType='STUB'.\",\n  \"Subtask 11\": \"Configure OSPFv3 intra-area routes: IntraAreaEmulated='ALL', IntraAreaSimulated='NONE'.\",\n  \"Subtask 12\": \"Configure OSPFv3 inter-area routes: InterAreaRoutesCount=10.\",\n  \"Subtask 13\": \"Configure OSPFv3 external routes: ExternalDistributionType='CUSTOM' with specified prefix length array.\",\n  \"Subtask 14\": \"Generate OSPFv3 LSA wizard configuration by expanding the wizard.\",\n  \"Subtask 15\": \"Save the generated configuration to a .xcfg file in the designated path.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     :   Test Objective: Verify that the OSPFv3 LSA wizard configuration is generated normally\n\nStep          :   Test Step 1: Create two offline ports: Port_1, Port_2;\n                  Test Step 2: Create an OSPFv3 session;\n                  Test Step 3: Create an OSPFv3 LSA wizard;\n                  Test Step 4: Generate the wizard configuration;\n\nCriteria      :   Expected Result 1: Step 4: The OSPFv3 LSA wizard configuration is generated without exceptions;\n\nCreated by    :   Tester-002\n\nBugs          :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='ipv6')\n    interfaces_2 = create_interface(Port=Port_2, Layers='ipv6')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建Ospfv3会话\n    ospf_1 = create_ospfv3(Port=Port_1)\n    ospf_2 = create_ospfv3(Port=Port_2)\n\n    select_interface(Session=ospf_1, Interface=interfaces_1)\n    select_interface(Session=ospf_2, Interface=interfaces_2)\n\n    # 创建Ospfv3 lsa向导\n    wizard = create_ospfv3_lsa_wizard(Sessions=[ospf_1, ospf_2])\n\n    # 配置Ospfv3拓扑\n    config_ospfv3_lsa_wizard_ospfv3_topo(Wizards=wizard, Type='GRID',\n                                         RowCount=10,\n                                         ColumnCount=20)\n\n    # 配置Ospfv3\n    config_ospfv3_lsa_wizard_ospfv3(Wizards=wizard,\n                                    AreaType='STUB')\n\n    # 配置Ospfv3 intra area route\n    config_ospfv3_lsa_wizard_ospfv3_intra_area_route(Wizards=wizard,\n                                                     IntraAreaEmulated='ALL',\n                                                     IntraAreaSimulated='NONE'\n                                                     )\n\n    # 配置Ospfv3 inter area route\n    config_ospfv3_lsa_wizard_ospfv3_inter_area_route(Wizards=wizard,\n                                                     InterAreaRoutesCount=10)\n\n    # 配置Ospfv3 external network\n    config_ospfv3_lsa_wizard_ospfv3_external_route(Wizards=wizard,\n                                                   ExternalDistributionType='CUSTOM',\n                                                   ExternalCustomPrefixLength=[10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 0.0,\n                                                                               10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0,\n                                                                               10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               10,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                                               ])\n\n    # 生成Ospfv3 Lsa向导配置\n    expand_ospfv3_lsa_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\ncreate_ospfv3:创建OSPFv3协议会话对象\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_Frameloss.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 局域网交换机设备丢包率测试\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2544向导, 选择丢包率测试;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址缓存容量参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "Objective: LAN Switch Packet Loss Rate Test  \n\nStep:  \nStep 1: Create ports and reserve ports  \nStep 2: Create RFC2544 wizard, select packet loss rate test  \nStep 3: Select ports  \nStep 4: Configure endpoints  \nStep 5: Configure flows  \nStep 6: Configure test options  \nStep 7: Set address cache capacity parameters  \nStep 8: Generate smart script  \nStep 8: Execute smart script test  \n\nCriteria:  \nExpected Result 1: Step 9 correctly measures device address cache capacity  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2544', Items=['frameloss'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth', 'ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth', 'ipv4'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置rfc2544* ===============\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_latency(Configs=Config, Type='FILO', DelayBefore=1, DelayAfter=2)\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='tcp')\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *配置丢包率* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[128])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='frameloss',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2544')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "edit_benchmark_transport_layer:编辑测试套件使用已存在流量",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester with specified product type (default 'DarYu').\",\n  \"Subtask 2\": \"Reserve two physical ports using provided locations and force reservation.\",\n  \"Subtask 3\": \"Create RFC2544 benchmark test suite focusing specifically on frame loss (packet loss) measurement.\",\n  \"Subtask 4\": \"Assign reserved ports to the benchmark configuration.\",\n  \"Subtask 5\": \"Create Ethernet and IPv4 interfaces on both reserved ports.\",\n  \"Subtask 6\": \"Extract IPv4 layer objects from created interfaces for endpoint configuration.\",\n  \"Subtask 7\": \"Create unidirectional test streams between IPv4 endpoints using benchmark configuration.\",\n  \"Subtask 8\": \"Configure benchmark learning settings: frequency='once' and ARP disabled.\",\n  \"Subtask 9\": \"Set benchmark latency parameters: type='FILO', delay before=1s, delay after=2s.\",\n  \"Subtask 10\": \"Configure transport layer protocol to TCP for benchmark streams.\",\n  \"Subtask 11\": \"Set benchmark result storage path (default 'D:/test').\",\n  \"Subtask 12\": \"Configure test duration: set trial count to 1.\",\n  \"Subtask 13\": \"Set frame size to custom value of 128 bytes.\",\n  \"Subtask 14\": \"Configure traffic load: step mode from 10% to 20% with 10% increment.\",\n  \"Subtask 15\": \"Set custom result filename as 'frameloss' with timestamp appended.\",\n  \"Subtask 16\": \"Expand benchmark configuration to generate executable smart scripts.\",\n  \"Subtask 17\": \"Save test case configuration to specified file path.\",\n  \"Subtask 18\": \"Execute benchmark test with 1200s timeout and analyzer enabled.\",\n  \"Subtask 19\": \"Retrieve RFC2544 test results from execution database.\",\n  \"Subtask 20\": \"Format and output test results in two-dimensional table format.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: LAN Switch Packet Loss Rate Test  \n\nStep:  \nStep 1: Create ports and reserve ports  \nStep 2: Create RFC2544 wizard, select packet loss rate test  \nStep 3: Select ports  \nStep 4: Configure endpoints  \nStep 5: Configure flows  \nStep 6: Configure test options  \nStep 7: Set address cache capacity parameters  \nStep 8: Generate smart script  \nStep 8: Execute smart script test  \n\nCriteria:  \nExpected Result 1: Step 9 correctly measures device address cache capacity  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2544', Items=['frameloss'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth', 'ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth', 'ipv4'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='ipv4', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置rfc2544* ===============\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_latency(Configs=Config, Type='FILO', DelayBefore=1, DelayAfter=2)\n    edit_benchmark_transport_layer(Configs=Config, HeaderType='tcp')\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n\n    # =============== *配置丢包率* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[128])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='frameloss',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2544')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nedit_benchmark_transport_layer:编辑测试套件使用已存在流量;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/mpls/mpls_ip_vpn.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查MPLS IP VPN向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建MPLS IP VPN向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPN;\n                   测试步骤6: 配置VPN路由;\n                   测试步骤7: 配置VPN流量;\n                   测试步骤8: 配置LSP Ping;\n                   测试步骤9: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤9 MPLS IP VPN向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective : Test Objective: Check that the MPLS IP VPN wizard configuration generates normally\n\nStep : Test Step 1: Create two offline ports Port_1 and Port_2;\n                   Test Step 2: Create MPLS IP VPN wizard;\n                   Test Step 3: Configure client-side port and provider-side port;\n                   Test Step 4: Configure provider-side router;\n                   Test Step 5: Configure VPN;\n                   Test Step 6: Configure VPN routing;\n                   Test Step 7: Configure VPN traffic;\n                   Test Step 8: Configure LSP Ping;\n                   Test Step 9: Generate wizard configuration;\n\nCriteria : Expected Result 1: Step 9 MPLS IP VPN wizard configuration generates without exceptions;\n\nCreated by : Tester-002\n\nBugs : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations[0]], Force=True)\n    Port_provider = reserve_port(Locations=[locations[1]], Force=True)\n\n    # 创建MPLS IP VPN向导\n\n    wizard = create_mpls_wizard(Type='mpls_ip_vpn')\n\n    # 配置客户端侧端口和提供商侧端口\n    edit_mpls_customer_port(Wizard=wizard, Port=Port_customer[0],\n                            EnableSubInterface=True, SubInterfaceCount=250,\n                            DutIpv4Address='1.1.1.1', VlanId=1000)\n    edit_mpls_provider_port(Wizard=wizard, Port=Port_provider[0],\n                            DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='2.2.2.2',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=True,\n                                               PRoutersPerInterface=10,\n                                               TopologyType='Grid',\n                                               PRouterStartIp='3.3.3.3',\n                                               PRouterIdStart='4.4.4.4',\n                                               PeRoutersPerInterface=20,\n                                               PeRouterIdStart='5.5.5.5',\n                                               EnableRouteReflectors=True)\n    edit_mpls_provider_router_isis(Wizard=wizard,\n                                   UseSrcMacAsSystemId=False,\n                                   SystemId='22:22:22:22:22:22',\n                                   Level='L1L2',\n                                   NetworkType='P2P',\n                                   RouterPriority=10,\n                                   MetricMode='WIDE',\n                                   AuthenticationMode='SIMPLE',\n                                   Password='test',\n                                   AreaId=20,\n                                   EnableGracefulRestart=True,\n                                   MultiTopologyId='IPV4',\n                                   EnableBfd=True,\n                                   )\n    edit_mpls_provider_router_ldp(Wizard=wizard,\n                                  HelloType='DIRECT_TARGETED',\n                                  TransportAddressTlvMode='ROUTER_ID',\n                                  LabelAdvertisementMode='DOD',\n                                  EgressLabelMode='IMPLICIT',\n                                  MinLabel=20,\n                                  AuthenticationMode='MD5',\n                                  Password='test')\n    # edit_mpls_provider_route_reflector(Wizard=wizard,\n    #                                    RouteReflectorSource='DutAsRouteReflector',\n    #                                    RrsPerPortOrSubInterface=1,\n    #                                    RrsPerPe=1,\n    #                                    RrRouterIdStart='1.1.1.1',\n    #                                    ClusterIdStart='2.2.2.2')\n    edit_mpls_provider_route_reflector(Wizard=wizard,\n                                       RrRouterIds=['1.1.1.1','2.2.2.2'])\n\n    # 配置VPN\n\n    edit_mpls_vpn_parameters(Wizard=wizard,\n                             NumberOfVpns=10,\n                             RdAssignment='Manual',\n                             RouteTargetStart='2:0')\n\n    edit_mpls_vpn_customer_parameters(Wizard=wizard,\n                                      VpnAssignment='Sequential',\n                                      CeProtocol='Mixed',\n                                      CeProAssignment='BGP=20%,RIP=40%,OSPF=30%,IS-IS=5%,Static=5%',\n                                      CustomerRdStart='3:0',\n                                      CustomerRdStepPerVpn='4:0',\n                                      CustomerRdStepPerCeEnabled=True,\n                                      CustomerRdStepPerCe='5:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            CustomerCeAsNumberStart=10,\n                            CustomerCeAsNumberStepPerVpn=20,\n                            CustomerCeAsNumberStepPerCeEnabled=True,\n                            CustomerCeAsNumberStepPerCe=30)\n\n    edit_mpls_vpn_provider_parameters(Wizard=wizard,\n                                      ProviderDisSel='PEsPerVPN',\n                                      ProviderMeshed=True,\n                                      ProviderRdStart='6:0',\n                                      ProviderRdStepPerVpn='7:0',\n                                      ProviderRdStepPerCeEnabled=True,\n                                      ProviderRdStepPerCe='8:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            ProviderAppendCeAsToPath=True,\n                            ProviderCeAsNumberStart=10,\n                            ProviderCeAsNumberStepPerVpnEnabled=True,\n                            ProviderCeAsNumberStepPerVpn=20,\n                            ProviderCeAsNumberStepPerCeEnabled=True,\n                            ProviderCeAsNumberStepPerCe=30)\n\n    # 配置VPN路由\n\n    edit_mpls_vpn_ipv4_route_customer_parameters(Wizard=wizard,\n                                                 CustomerStartRoute='1.1.1.1',\n                                                 CustomerRouteStep='0.1.0.0',\n                                                 CustomerPrefixLength=16,\n                                                 CustomerRoutesPerCe=10,\n                                                 CustomerOverlapRoutes=True,\n                                                 CustomerRouteType='External')\n    edit_mpls_vpn_ipv4_route_provider_parameters(Wizard=wizard,\n                                                 ProviderStartRoute='2.2.2.2',\n                                                 ProviderRouteStep='0.1.0.0',\n                                                 ProviderPrefixLength=16,\n                                                 ProviderRoutesPerCe=20,\n                                                 ProviderOverlapRoutes=True,\n                                                 ProviderLabelType='LabelPerRoute',\n                                                 ProviderStartLabel=30)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            UseSingleStreamNumber=True,\n                            TrafficLoadPercentProvider=10,\n                            TrafficLoadPercentCustomer=20)\n\n    # 配置Lsp Ping\n\n    edit_lsp_ping(Wizard=wizard,\n                  EnableLspPing=True,\n                  DestinationIpv4Address='1.1.1.1',\n                  PingInterval=10,\n                  PingTimeout=20,\n                  TimeToLive=30,\n                  LspExpValue=7,\n                  ValidateFecStack=True,\n                  PadMode='RequestPeerToDropPadTlv',\n                  PadData=[1,2,3])\n\n    # 生成MPLS IP VPN向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_mpls_wizard:测试仪表创建MPLS向导",
      "edit_lsp_ping:配置MPLS流量LSP Ping参数",
      "edit_mpls_customer_port:配置MPLS向导客户侧端口",
      "edit_mpls_provider_port:配置MPLS向导提供商侧端口",
      "edit_mpls_provider_route_reflector:not_found",
      "edit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由",
      "edit_mpls_provider_router_isis:配置MPLS提供商侧路由路由器OSPF协议",
      "edit_mpls_provider_router_ldp:配置MPLS提供商侧路由路由器LDP协议",
      "edit_mpls_vpn_as_number:not_found",
      "edit_mpls_vpn_customer_parameters:配置MPLS VPN客户侧参数",
      "edit_mpls_vpn_ipv4_route_customer_parameters:配置MPLS VPN路由客户端侧参数",
      "edit_mpls_vpn_ipv4_route_provider_parameters:配置MPLS VPN路由提供商端侧参数",
      "edit_mpls_vpn_parameters:配置MPLS VPN基本参数",
      "edit_mpls_vpn_provider_parameters:配置MPLS VPN提供商侧参数",
      "edit_traffic_parameters:配置MPLS流量",
      "expand_mpls_wizard:生成测试仪表MPLS向导配置"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (e.g., DarYu) using init_tester API.\",\n  \"Subtask 2\": \"Reserve first port (Port_customer) from given location using reserve_port API with Force=True.\",\n  \"Subtask 3\": \"Reserve second port (Port_provider) from given location using reserve_port API with Force=True.\",\n  \"Subtask 4\": \"Create MPLS IP VPN wizard using create_mpls_wizard API with Type='mpls_ip_vpn'.\",\n  \"Subtask 5\": \"Configure customer-side port parameters using edit_mpls_customer_port API with EnableSubInterface=True, SubInterfaceCount=250, DutIpv4Address='1.1.1.1', VlanId=1000.\",\n  \"Subtask 6\": \"Configure provider-side port parameters using edit_mpls_provider_port API with DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24.\",\n  \"Subtask 7\": \"Configure provider-side router basic parameters using edit_mpls_provider_router_basic_parameters API with DutRouterId='2.2.2.2', DutAsNumber=100, IgpProtocol='ISIS', MplsProtocol='LDP', EnablePRouter=True, etc.\",\n  \"Subtask 8\": \"Configure provider-side router ISIS parameters using edit_mpls_provider_router_isis API with SystemId='22:22:22:22:22:22', Level='L1L2', NetworkType='P2P', etc.\",\n  \"Subtask 9\": \"Configure provider-side router LDP parameters using edit_mpls_provider_router_ldp API with HelloType='DIRECT_TARGETED', TransportAddressTlvMode='ROUTER_ID', etc.\",\n  \"Subtask 10\": \"Configure provider-side route reflector using edit_mpls_provider_route_reflector API with RrRouterIds=['1.1.1.1','2.2.2.2'].\",\n  \"Subtask 11\": \"Configure VPN basic parameters using edit_mpls_vpn_parameters API with NumberOfVpns=10, RdAssignment='Manual', RouteTargetStart='2:0'.\",\n  \"Subtask 12\": \"Configure VPN customer parameters using edit_mpls_vpn_customer_parameters API with VpnAssignment='Sequential', CeProtocol='Mixed', etc.\",\n  \"Subtask 13\": \"Configure VPN customer AS numbers using edit_mpls_vpn_as_number API with CustomerCeAsNumberStart=10, CustomerCeAsNumberStepPerVpn=20, etc.\",\n  \"Subtask 14\": \"Configure VPN provider parameters using edit_mpls_vpn_provider_parameters API with ProviderDisSel='PEsPerVPN', ProviderMeshed=True, etc.\",\n  \"Subtask 15\": \"Configure VPN provider AS numbers using edit_mpls_vpn_as_number API with ProviderAppendCeAsToPath=True, ProviderCeAsNumberStart=10, etc.\",\n  \"Subtask 16\": \"Configure VPN IPv4 route customer parameters using edit_mpls_vpn_ipv4_route_customer_parameters API with CustomerStartRoute='1.1.1.1', CustomerPrefixLength=16, etc.\",\n  \"Subtask 17\": \"Configure VPN IPv4 route provider parameters using edit_mpls_vpn_ipv4_route_provider_parameters API with ProviderStartRoute='2.2.2.2', ProviderPrefixLength=16, etc.\",\n  \"Subtask 18\": \"Configure traffic parameters using edit_traffic_parameters API with TrafficFlow='CustomerProviderBoth', TrafficLoadPercentProvider=10, etc.\",\n  \"Subtask 19\": \"Configure LSP Ping parameters using edit_lsp_ping API with EnableLspPing=True, DestinationIpv4Address='1.1.1.1', PingInterval=10, etc.\",\n  \"Subtask 20\": \"Generate MPLS wizard configuration using expand_mpls_wizard API.\",\n  \"Subtask 21\": \"Save test configuration to file using save_case API with specified path.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective : Test Objective: Check that the MPLS IP VPN wizard configuration generates normally\n\nStep : Test Step 1: Create two offline ports Port_1 and Port_2;\n                   Test Step 2: Create MPLS IP VPN wizard;\n                   Test Step 3: Configure client-side port and provider-side port;\n                   Test Step 4: Configure provider-side router;\n                   Test Step 5: Configure VPN;\n                   Test Step 6: Configure VPN routing;\n                   Test Step 7: Configure VPN traffic;\n                   Test Step 8: Configure LSP Ping;\n                   Test Step 9: Generate wizard configuration;\n\nCriteria : Expected Result 1: Step 9 MPLS IP VPN wizard configuration generates without exceptions;\n\nCreated by : Tester-002\n\nBugs : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations[0]], Force=True)\n    Port_provider = reserve_port(Locations=[locations[1]], Force=True)\n\n    # 创建MPLS IP VPN向导\n\n    wizard = create_mpls_wizard(Type='mpls_ip_vpn')\n\n    # 配置客户端侧端口和提供商侧端口\n    edit_mpls_customer_port(Wizard=wizard, Port=Port_customer[0],\n                            EnableSubInterface=True, SubInterfaceCount=250,\n                            DutIpv4Address='1.1.1.1', VlanId=1000)\n    edit_mpls_provider_port(Wizard=wizard, Port=Port_provider[0],\n                            DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='2.2.2.2',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=True,\n                                               PRoutersPerInterface=10,\n                                               TopologyType='Grid',\n                                               PRouterStartIp='3.3.3.3',\n                                               PRouterIdStart='4.4.4.4',\n                                               PeRoutersPerInterface=20,\n                                               PeRouterIdStart='5.5.5.5',\n                                               EnableRouteReflectors=True)\n    edit_mpls_provider_router_isis(Wizard=wizard,\n                                   UseSrcMacAsSystemId=False,\n                                   SystemId='22:22:22:22:22:22',\n                                   Level='L1L2',\n                                   NetworkType='P2P',\n                                   RouterPriority=10,\n                                   MetricMode='WIDE',\n                                   AuthenticationMode='SIMPLE',\n                                   Password='test',\n                                   AreaId=20,\n                                   EnableGracefulRestart=True,\n                                   MultiTopologyId='IPV4',\n                                   EnableBfd=True,\n                                   )\n    edit_mpls_provider_router_ldp(Wizard=wizard,\n                                  HelloType='DIRECT_TARGETED',\n                                  TransportAddressTlvMode='ROUTER_ID',\n                                  LabelAdvertisementMode='DOD',\n                                  EgressLabelMode='IMPLICIT',\n                                  MinLabel=20,\n                                  AuthenticationMode='MD5',\n                                  Password='test')\n    # edit_mpls_provider_route_reflector(Wizard=wizard,\n    #                                    RouteReflectorSource='DutAsRouteReflector',\n    #                                    RrsPerPortOrSubInterface=1,\n    #                                    RrsPerPe=1,\n    #                                    RrRouterIdStart='1.1.1.1',\n    #                                    ClusterIdStart='2.2.2.2')\n    edit_mpls_provider_route_reflector(Wizard=wizard,\n                                       RrRouterIds=['1.1.1.1','2.2.2.2'])\n\n    # 配置VPN\n\n    edit_mpls_vpn_parameters(Wizard=wizard,\n                             NumberOfVpns=10,\n                             RdAssignment='Manual',\n                             RouteTargetStart='2:0')\n\n    edit_mpls_vpn_customer_parameters(Wizard=wizard,\n                                      VpnAssignment='Sequential',\n                                      CeProtocol='Mixed',\n                                      CeProAssignment='BGP=20%,RIP=40%,OSPF=30%,IS-IS=5%,Static=5%',\n                                      CustomerRdStart='3:0',\n                                      CustomerRdStepPerVpn='4:0',\n                                      CustomerRdStepPerCeEnabled=True,\n                                      CustomerRdStepPerCe='5:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            CustomerCeAsNumberStart=10,\n                            CustomerCeAsNumberStepPerVpn=20,\n                            CustomerCeAsNumberStepPerCeEnabled=True,\n                            CustomerCeAsNumberStepPerCe=30)\n\n    edit_mpls_vpn_provider_parameters(Wizard=wizard,\n                                      ProviderDisSel='PEsPerVPN',\n                                      ProviderMeshed=True,\n                                      ProviderRdStart='6:0',\n                                      ProviderRdStepPerVpn='7:0',\n                                      ProviderRdStepPerCeEnabled=True,\n                                      ProviderRdStepPerCe='8:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            ProviderAppendCeAsToPath=True,\n                            ProviderCeAsNumberStart=10,\n                            ProviderCeAsNumberStepPerVpnEnabled=True,\n                            ProviderCeAsNumberStepPerVpn=20,\n                            ProviderCeAsNumberStepPerCeEnabled=True,\n                            ProviderCeAsNumberStepPerCe=30)\n\n    # 配置VPN路由\n\n    edit_mpls_vpn_ipv4_route_customer_parameters(Wizard=wizard,\n                                                 CustomerStartRoute='1.1.1.1',\n                                                 CustomerRouteStep='0.1.0.0',\n                                                 CustomerPrefixLength=16,\n                                                 CustomerRoutesPerCe=10,\n                                                 CustomerOverlapRoutes=True,\n                                                 CustomerRouteType='External')\n    edit_mpls_vpn_ipv4_route_provider_parameters(Wizard=wizard,\n                                                 ProviderStartRoute='2.2.2.2',\n                                                 ProviderRouteStep='0.1.0.0',\n                                                 ProviderPrefixLength=16,\n                                                 ProviderRoutesPerCe=20,\n                                                 ProviderOverlapRoutes=True,\n                                                 ProviderLabelType='LabelPerRoute',\n                                                 ProviderStartLabel=30)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            UseSingleStreamNumber=True,\n                            TrafficLoadPercentProvider=10,\n                            TrafficLoadPercentCustomer=20)\n\n    # 配置Lsp Ping\n\n    edit_lsp_ping(Wizard=wizard,\n                  EnableLspPing=True,\n                  DestinationIpv4Address='1.1.1.1',\n                  PingInterval=10,\n                  PingTimeout=20,\n                  TimeToLive=30,\n                  LspExpValue=7,\n                  ValidateFecStack=True,\n                  PadMode='RequestPeerToDropPadTlv',\n                  PadData=[1,2,3])\n\n    # 生成MPLS IP VPN向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_mpls_wizard:测试仪表创建MPLS向导;\nedit_lsp_ping:配置MPLS流量LSP Ping参数;\nedit_mpls_customer_port:配置MPLS向导客户侧端口;\nedit_mpls_provider_port:配置MPLS向导提供商侧端口;\nedit_mpls_provider_route_reflector:not_found;\nedit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由;\nedit_mpls_provider_router_isis:配置MPLS提供商侧路由路由器OSPF协议;\nedit_mpls_provider_router_ldp:配置MPLS提供商侧路由路由器LDP协议;\nedit_mpls_vpn_as_number:not_found;\nedit_mpls_vpn_customer_parameters:配置MPLS VPN客户侧参数;\nedit_mpls_vpn_ipv4_route_customer_parameters:配置MPLS VPN路由客户端侧参数;\nedit_mpls_vpn_ipv4_route_provider_parameters:配置MPLS VPN路由提供商端侧参数;\nedit_mpls_vpn_parameters:配置MPLS VPN基本参数;\nedit_mpls_vpn_provider_parameters:配置MPLS VPN提供商侧参数;\nedit_traffic_parameters:配置MPLS流量;\nexpand_mpls_wizard:生成测试仪表MPLS向导配置\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/mpls/ldp_vpls.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查LDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify that the LDP VPLS wizard configuration is generated correctly\n\nStep: Test Step 1: Create 8 offline ports: Port_1, Port_2;\n      Test Step 2: Create an LDP VPLS wizard;\n      Test Step 3: Configure client-side ports and provider-side ports;\n      Test Step 4: Configure the provider-side router;\n      Test Step 5: Configure VPLS;\n      Test Step 6: Configure Host;\n      Test Step 7: Configure traffic;\n      Test Step 8: Generate the LDP VPLS wizard configuration;\n\nCriteria: Expected Result 1: Step 8: LDP VPLS wizard configuration is generated without exceptions;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\n# locations_1 = ['//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16']\n# locations_2 = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6']\n\nlocations_1 = locations[0]\nlocations_2 = locations[1]\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations_1], Debug=True)\n    Port_provider = reserve_port(Locations=[locations_2], Debug=True)\n\n    # 创建LDP VPLS向导\n\n    wizard = create_mpls_wizard(Type='ldp_vpls')\n\n    # 配置客户端侧端口和提供商侧端口\n    for port in Port_customer:\n        edit_mpls_customer_port(Wizard=wizard, Port=port, EnableSubInterface=True, SubInterfaceCount=250,\n                                VlanId=1000)\n    for port in Port_provider:\n        edit_mpls_provider_port(Wizard=wizard, Port=port, DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='1.1.1.1',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=False,\n                                               PeRouterIdStart='2.1.1.1',\n                                               PeRouterIdStep='0.0.0.1')\n\n    # 配置VPLS\n\n    edit_mpls_vpls_basic_parameters(Wizard=wizard,\n                                    NumberOfVpls=1000,\n                                    Mtu=9000,\n                                    GroupId=0,\n                                    EnableOverrideEncapsulation=True,\n                                    Encapsulation='EthernetVlan')\n\n    edit_mpls_fec128(Wizard=wizard, StartVcId=1, StepVcId=1)\n\n    # 配置Host\n\n    edit_mpls_host(Wizard=wizard,\n                   HostAssignmentVpls='HostsOrMacsPerVpls',\n                   HostsPerVpls=32,\n                   CustomerHostPercent=50,\n                   ProviderHostPercent=50)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            TrafficLoadPercentProvider=10)\n\n    # 生成LDP VPLS向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_mpls_wizard:测试仪表创建MPLS向导",
      "edit_mpls_customer_port:配置MPLS向导客户侧端口",
      "edit_mpls_fec128:配置MPLS fec128参数",
      "edit_mpls_host:配置MPLS向导Host参数",
      "edit_mpls_provider_port:配置MPLS向导提供商侧端口",
      "edit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由",
      "edit_mpls_vpls_basic_parameters:配置MPLS VPLS参数",
      "edit_traffic_parameters:配置MPLS流量",
      "expand_mpls_wizard:生成测试仪表MPLS向导配置"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product (DarYu or provided argument).\",\n  \"Subtask 2\": \"Reserve the customer-side port at the specified location with debugging enabled.\",\n  \"Subtask 3\": \"Reserve the provider-side port at the specified location with debugging enabled.\",\n  \"Subtask 4\": \"Create an LDP VPLS wizard configuration.\",\n  \"Subtask 5\": \"Configure the customer-side port in the wizard: enable sub-interfaces, set sub-interface count to 250, and VLAN ID to 1000.\",\n  \"Subtask 6\": \"Configure the provider-side port in the wizard: set DUT IPv4 address to '50.1.1.1' and IPv4 prefix length to 24.\",\n  \"Subtask 7\": \"Configure provider router parameters: set DUT router ID to '1.1.1.1', DUT AS number to 100, IGP protocol to ISIS, MPLS protocol to LDP, disable P router, set PE router ID start to '2.1.1.1', and step to '0.0.0.1'.\",\n  \"Subtask 8\": \"Configure VPLS basic parameters: set number of VPLS to 1000, MTU to 9000, group ID to 0, enable override encapsulation, and set encapsulation to EthernetVlan.\",\n  \"Subtask 9\": \"Configure FEC128 parameters: set start VC ID to 1 and step VC ID to 1.\",\n  \"Subtask 10\": \"Configure host parameters: set host assignment to 'HostsOrMacsPerVpls', hosts per VPLS to 32, customer host percentage to 50, and provider host percentage to 50.\",\n  \"Subtask 11\": \"Configure traffic parameters: set traffic flow to 'CustomerProviderBoth', stream block grouping to 'Aggregate', and provider traffic load percentage to 10.\",\n  \"Subtask 12\": \"Generate the LDP VPLS wizard configuration.\",\n  \"Subtask 13\": \"Save the test configuration to a file at the specified path.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify that the LDP VPLS wizard configuration is generated correctly\n\nStep: Test Step 1: Create 8 offline ports: Port_1, Port_2;\n      Test Step 2: Create an LDP VPLS wizard;\n      Test Step 3: Configure client-side ports and provider-side ports;\n      Test Step 4: Configure the provider-side router;\n      Test Step 5: Configure VPLS;\n      Test Step 6: Configure Host;\n      Test Step 7: Configure traffic;\n      Test Step 8: Generate the LDP VPLS wizard configuration;\n\nCriteria: Expected Result 1: Step 8: LDP VPLS wizard configuration is generated without exceptions;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\n# locations_1 = ['//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16']\n# locations_2 = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6']\n\nlocations_1 = locations[0]\nlocations_2 = locations[1]\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations_1], Debug=True)\n    Port_provider = reserve_port(Locations=[locations_2], Debug=True)\n\n    # 创建LDP VPLS向导\n\n    wizard = create_mpls_wizard(Type='ldp_vpls')\n\n    # 配置客户端侧端口和提供商侧端口\n    for port in Port_customer:\n        edit_mpls_customer_port(Wizard=wizard, Port=port, EnableSubInterface=True, SubInterfaceCount=250,\n                                VlanId=1000)\n    for port in Port_provider:\n        edit_mpls_provider_port(Wizard=wizard, Port=port, DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='1.1.1.1',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=False,\n                                               PeRouterIdStart='2.1.1.1',\n                                               PeRouterIdStep='0.0.0.1')\n\n    # 配置VPLS\n\n    edit_mpls_vpls_basic_parameters(Wizard=wizard,\n                                    NumberOfVpls=1000,\n                                    Mtu=9000,\n                                    GroupId=0,\n                                    EnableOverrideEncapsulation=True,\n                                    Encapsulation='EthernetVlan')\n\n    edit_mpls_fec128(Wizard=wizard, StartVcId=1, StepVcId=1)\n\n    # 配置Host\n\n    edit_mpls_host(Wizard=wizard,\n                   HostAssignmentVpls='HostsOrMacsPerVpls',\n                   HostsPerVpls=32,\n                   CustomerHostPercent=50,\n                   ProviderHostPercent=50)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            TrafficLoadPercentProvider=10)\n\n    # 生成LDP VPLS向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_mpls_wizard:测试仪表创建MPLS向导;\nedit_mpls_customer_port:配置MPLS向导客户侧端口;\nedit_mpls_fec128:配置MPLS fec128参数;\nedit_mpls_host:配置MPLS向导Host参数;\nedit_mpls_provider_port:配置MPLS向导提供商侧端口;\nedit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由;\nedit_mpls_vpls_basic_parameters:配置MPLS VPLS参数;\nedit_traffic_parameters:配置MPLS流量;\nexpand_mpls_wizard:生成测试仪表MPLS向导配置\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/bgp_route/bgp_route_wizard.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查Bgp Route向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Bgp会话;\n                   测试步骤3: 创建Bgp Route向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Bgp Route向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     :   Test Objective: Verify that the BGP Route Wizard configuration generates normally.\n\nStep          :   Test Step 1: Create two offline ports Port_1 and Port_2;\n                  Test Step 2: Create a BGP session;\n                  Test Step 3: Create a BGP Route Wizard;\n                  Test Step 4: Generate the wizard configuration;\n\nCriteria      :   Expected Result 1: Step 4 BGP Route Wizard configuration generates without exceptions;\n\nCreated by    :   Tester-002\n\nBugs          :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1 = Port(upper=get_sys_entry())\n    Port_2 = Port(upper=get_sys_entry())\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='eth', Tops=['ipv4', 'ipv6'])\n    interfaces_2 = create_interface(Port=Port_2, Layers='eth', Tops=['ipv4', 'ipv6'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建BGP会话\n    Bgp_1 = create_bgp(Port=Port_1)\n    Bgp_2 = create_bgp(Port=Port_2)\n\n    select_interface(Session=Bgp_1, Interface=interfaces_1)\n    select_interface(Session=Bgp_2, Interface=interfaces_2)\n\n    # 创建BGP Route向导\n    wizard = create_bgp_route_wizard(Sessions=[Bgp_1, Bgp_2],\n                                     BgpRouteType='IPV4_IPV6',\n                                     EnableLinkState=True)\n\n    # 配置ipv4 route\n    config_bgp_route_wizard_ipv4(Wizards=wizard,\n                                 TotalIpv4RouteCount=2,\n                                 IPv4DistributionType='LINEAR',\n                                 PrefixLength=16,\n                                 EndPrefixLength=32)\n\n    # 配置ipv6 route\n    config_bgp_route_wizard_ipv6(Wizards=wizard,\n                                 TotalIpv6RouteCount=10)\n\n    # 配置IGP拓扑\n    config_bgp_route_wizard_igp_topo(Wizards=wizard,\n                                     ProtocolType='ISIS_IPV4')\n\n    # 配置IGP\n    config_bgp_route_wizard_igp(Wizards=wizard,\n                                EnableTeOptions=True)\n    config_bgp_route_wizard_igp_te_option(Wizards=wizard,\n                                          EnableUnreserved=True)\n\n    # 生成BGP Route向导配置\n    expand_bgp_route_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "create_bgp:创建BGP协议会话对象",
      "select_interface:协议绑定测试仪表接口"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with product type 'DarYu' or specified product.\",\n  \"Subtask 2\": \"Create two port objects (Port_1 and Port_2) and reserve corresponding physical ports.\",\n  \"Subtask 3\": \"Create interfaces on Port_1 with Ethernet, IPv4, and IPv6 layers.\",\n  \"Subtask 4\": \"Create interfaces on Port_2 with Ethernet, IPv4, and IPv6 layers.\",\n  \"Subtask 5\": \"Configure IPv4 layer on Port_1 interface: address=192.168.1.2, gateway=192.168.1.3.\",\n  \"Subtask 6\": \"Configure IPv4 layer on Port_2 interface: address=192.168.1.3, gateway=192.168.1.2.\",\n  \"Subtask 7\": \"Configure IPv6 layer on Port_1 interface: address=2001::1, gateway=2001::2.\",\n  \"Subtask 8\": \"Configure IPv6 layer on Port_2 interface: address=2001::2, gateway=2001::1.\",\n  \"Subtask 9\": \"Create BGP session (Bgp_1) on Port_1.\",\n  \"Subtask 10\": \"Create BGP session (Bgp_2) on Port_2.\",\n  \"Subtask 11\": \"Bind Bgp_1 session to the interface on Port_1.\",\n  \"Subtask 12\": \"Bind Bgp_2 session to the interface on Port_2.\",\n  \"Subtask 13\": \"Create BGP Route Wizard on Bgp_1 and Bgp_2 sessions with BgpRouteType='IPV4_IPV6' and EnableLinkState=True.\",\n  \"Subtask 14\": \"Configure IPv4 route in wizard: TotalIpv4RouteCount=2, IPv4DistributionType='LINEAR', PrefixLength=16, EndPrefixLength=32.\",\n  \"Subtask 15\": \"Configure IPv6 route in wizard: TotalIpv6RouteCount=10.\",\n  \"Subtask 16\": \"Configure IGP topology in wizard: ProtocolType='ISIS_IPV4'.\",\n  \"Subtask 17\": \"Configure IGP in wizard: EnableTeOptions=True.\",\n  \"Subtask 18\": \"Configure IGP TE options in wizard: EnableUnreserved=True.\",\n  \"Subtask 19\": \"Generate BGP Route Wizard configuration by expanding the wizard.\",\n  \"Subtask 20\": \"Verify that wizard configuration generation completes without exceptions.\",\n  \"Subtask 21\": \"Save test configuration to file with path derived from current script name.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     :   Test Objective: Verify that the BGP Route Wizard configuration generates normally.\n\nStep          :   Test Step 1: Create two offline ports Port_1 and Port_2;\n                  Test Step 2: Create a BGP session;\n                  Test Step 3: Create a BGP Route Wizard;\n                  Test Step 4: Generate the wizard configuration;\n\nCriteria      :   Expected Result 1: Step 4 BGP Route Wizard configuration generates without exceptions;\n\nCreated by    :   Tester-002\n\nBugs          :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1 = Port(upper=get_sys_entry())\n    Port_2 = Port(upper=get_sys_entry())\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='eth', Tops=['ipv4', 'ipv6'])\n    interfaces_2 = create_interface(Port=Port_2, Layers='eth', Tops=['ipv4', 'ipv6'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建BGP会话\n    Bgp_1 = create_bgp(Port=Port_1)\n    Bgp_2 = create_bgp(Port=Port_2)\n\n    select_interface(Session=Bgp_1, Interface=interfaces_1)\n    select_interface(Session=Bgp_2, Interface=interfaces_2)\n\n    # 创建BGP Route向导\n    wizard = create_bgp_route_wizard(Sessions=[Bgp_1, Bgp_2],\n                                     BgpRouteType='IPV4_IPV6',\n                                     EnableLinkState=True)\n\n    # 配置ipv4 route\n    config_bgp_route_wizard_ipv4(Wizards=wizard,\n                                 TotalIpv4RouteCount=2,\n                                 IPv4DistributionType='LINEAR',\n                                 PrefixLength=16,\n                                 EndPrefixLength=32)\n\n    # 配置ipv6 route\n    config_bgp_route_wizard_ipv6(Wizards=wizard,\n                                 TotalIpv6RouteCount=10)\n\n    # 配置IGP拓扑\n    config_bgp_route_wizard_igp_topo(Wizards=wizard,\n                                     ProtocolType='ISIS_IPV4')\n\n    # 配置IGP\n    config_bgp_route_wizard_igp(Wizards=wizard,\n                                EnableTeOptions=True)\n    config_bgp_route_wizard_igp_te_option(Wizards=wizard,\n                                          EnableUnreserved=True)\n\n    # 生成BGP Route向导配置\n    expand_bgp_route_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\ncreate_bgp:创建BGP协议会话对象;\nselect_interface:协议绑定测试仪表接口\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/ping.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查仪表创建接口正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建各种类型接口;\n\n Criteria    \t:   预期结果1: 步骤2中所有接口创建成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Test Objective: Check that the instrument creation interface functions normally\nStep          : Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n              : Test Step 2: Create various types of interfaces on both ports respectively;\nCriteria      : Expected Result 1: All interfaces in Step 2 are created successfully;\nCreated by    : Tester-001\nBugs          : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n    interface_1 = create_interface(Port=Port_UP, Layers='ipv4')\n    edit_interface(Interface=interface_1, Layer='IPv4Layer', Address='20.0.0.1', Gateway='20.0.0.2')\n    interface_2 = create_interface(Port=Port_Down, Layers='ipv4')\n    edit_interface(Interface=interface_2, Layer='IPv4Layer', Address='20.0.0.2', Gateway='20.0.0.1')\n    ipv4_ping(Interface=interface_1, IpAddr='20.0.0.2', PacketCount=5)\n\n    # 保存配置文件s\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product (default: 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at the specified locations (default: '//10.0.11.191/1/7' and '//10.0.11.191/1/8') using reserve_port API.\",\n  \"Subtask 3\": \"Create an IPv4 interface on the first reserved port (Port_UP) using create_interface API.\",\n  \"Subtask 4\": \"Configure the IPv4 layer of the first interface by setting source address to '20.0.0.1' and gateway to '20.0.0.2' using edit_interface API.\",\n  \"Subtask 5\": \"Create an IPv4 interface on the second reserved port (Port_Down) using create_interface API.\",\n  \"Subtask 6\": \"Configure the IPv4 layer of the second interface by setting source address to '20.0.0.2' and gateway to '20.0.0.1' using edit_interface API.\",\n  \"Subtask 7\": \"Verify interface functionality by performing IPv4 ping from the first interface to the second interface's address ('20.0.0.2') with 5 packets.\",\n  \"Subtask 8\": \"Save the test configuration to a file in the 'xcfg' subdirectory of the script's directory using save_case API, preserving the original script's base filename with .xcfg extension.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Test Objective: Check that the instrument creation interface functions normally\nStep          : Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n              : Test Step 2: Create various types of interfaces on both ports respectively;\nCriteria      : Expected Result 1: All interfaces in Step 2 are created successfully;\nCreated by    : Tester-001\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n    interface_1 = create_interface(Port=Port_UP, Layers='ipv4')\n    edit_interface(Interface=interface_1, Layer='IPv4Layer', Address='20.0.0.1', Gateway='20.0.0.2')\n    interface_2 = create_interface(Port=Port_Down, Layers='ipv4')\n    edit_interface(Interface=interface_2, Layer='IPv4Layer', Address='20.0.0.2', Gateway='20.0.0.1')\n    ipv4_ping(Interface=interface_1, IpAddr='20.0.0.2', PacketCount=5)\n\n    # 保存配置文件s\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/isis_lsp/isis_lsp_wizard.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查Isis Lsp向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Isis会话;\n                   测试步骤3: 创建Isis Lsp向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Isis Lsp向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Purpose: Check that the ISIS LSP Wizard configuration is generated normally\n\nStep         :   Test Step 1: Create two offline ports: Port_1 and Port_2;\n                Test Step 2: Create an ISIS session;\n                Test Step 3: Create an ISIS LSP Wizard;\n                Test Step 4: Generate the wizard configuration;\n\nCriteria     :   Expected Result 1: In Step 4, the ISIS LSP Wizard configuration is generated without exceptions;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='eth', Tops=['ipv4', 'ipv6'])\n    interfaces_2 = create_interface(Port=Port_2, Layers='eth', Tops=['ipv4', 'ipv6'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建Isis会话\n    Isis_1 = create_isis(Port=Port_1, IpVersion='IPV4IPV6')\n    Isis_2 = create_isis(Port=Port_2, IpVersion='IPV4IPV6')\n\n    select_interface(Session=Isis_1, Interface=interfaces_1)\n    select_interface(Session=Isis_2, Interface=interfaces_2)\n\n    # 创建Isis Lsp向导\n    wizard = create_isis_lsp_wizard(Sessions=[Isis_1, Isis_2])\n\n    # 配置组网拓扑\n    config_isis_lsp_wizard_network_topo(Wizards=wizard, Type='GRID',\n                                        GridNumberOfRows=10,\n                                        GridNumberOfColumns=20)\n\n    # 配置isis\n    config_isis_lsp_wizard_isis(Wizards=wizard,\n                                EnableTrafficEngine=True,\n                                EnableSegmentRouting=True,\n                                EnableSegmentRoutingIPv6=True,\n                                EnableFlexAlgo=True)\n    te = config_isis_lsp_wizard_isis_te(Wizards=wizard,\n                                        EnableTeGroup=True,\n                                        TeGroup=10)\n    sr = config_isis_lsp_wizard_isis_sr(Wizards=wizard,\n                                        ValueType='BIT32')\n    srv6 = config_isis_lsp_wizard_isis_srv6(Wizards=wizard,\n                                            MtId=10)\n    flex_algo = config_isis_lsp_wizard_isis_flex_algo(Wizards=wizard,\n                                                      FlexAlgo=255)\n\n    # 配置ipv4 internal route\n    config_isis_lsp_wizard_ipv4_internal_route(Wizards=wizard,\n                                               Ipv4InternalRoutesPrefixLenType='CUSTOM',\n                                               Ipv4InternalRoutesPrefixLenCustom=\n                                               [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 30, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                0.0, 0.0, 50]\n                                                )\n\n    # 配置ipv4 external route\n    config_isis_lsp_wizard_ipv4_external_route(Wizards=wizard,\n                                               Ipv4ExternalRoutesPrefixLenType='LINEAR',\n                                               Ipv4ExternalRoutesPrefixLenStart=10,\n                                               Ipv4ExternalRoutesPrefixLenEnd=20)\n\n    # 配置ipv6 internal route\n    config_isis_lsp_wizard_ipv6_internal_route(Wizards=wizard,\n                                               Ipv6InternalWideMetric=20)\n\n    # 配置ipv6 external route\n    config_isis_lsp_wizard_ipv6_external_route(Wizards=wizard,\n                                               Ipv6ExternalAdvEmulatedRouters=True\n                                               )\n\n    # 生成Isis Lsp向导配置\n    expand_isis_lsp_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "create_isis:创建ISIS协议会话对象"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (default 'DarYu').\",\n  \"Subtask 2\": \"Reserve two physical ports (Port_1 and Port_2) at given locations.\",\n  \"Subtask 3\": \"Create Ethernet interfaces on both ports with IPv4 and IPv6 protocol layers.\",\n  \"Subtask 4\": \"Configure IPv4 addresses and gateways on both interfaces (bidirectional connectivity: 192.168.1.2<->192.168.1.3).\",\n  \"Subtask 5\": \"Configure IPv6 addresses and gateways on both interfaces (bidirectional connectivity: 2001::1<->2001::2).\",\n  \"Subtask 6\": \"Create ISIS sessions on both ports supporting dual-stack (IPv4/IPv6).\",\n  \"Subtask 7\": \"Bind the created interfaces to their respective ISIS sessions.\",\n  \"Subtask 8\": \"Create ISIS LSP Wizard object associating both ISIS sessions.\",\n  \"Subtask 9\": \"Configure wizard network topology as 10x20 grid.\",\n  \"Subtask 10\": \"Enable and configure ISIS features: Traffic Engineering (TE group 10), Segment Routing (32-bit SIDs), SRv6 (MT-ID 10), and FlexAlgo (algorithm 255).\",\n  \"Subtask 11\": \"Configure IPv4 internal routes with custom prefix length distribution pattern.\",\n  \"Subtask 12\": \"Configure IPv4 external routes with linear prefix length range (10-20).\",\n  \"Subtask 13\": \"Configure IPv6 internal routes with wide metric value (20).\",\n  \"Subtask 14\": \"Configure IPv6 external routes to advertise emulated routers.\",\n  \"Subtask 15\": \"Generate ISIS LSP Wizard configuration and verify successful completion without exceptions.\",\n  \"Subtask 16\": \"Save test configuration to file in xcfg format at specified path.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Purpose: Check that the ISIS LSP Wizard configuration is generated normally\n\nStep         :   Test Step 1: Create two offline ports: Port_1 and Port_2;\n                Test Step 2: Create an ISIS session;\n                Test Step 3: Create an ISIS LSP Wizard;\n                Test Step 4: Generate the wizard configuration;\n\nCriteria     :   Expected Result 1: In Step 4, the ISIS LSP Wizard configuration is generated without exceptions;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='eth', Tops=['ipv4', 'ipv6'])\n    interfaces_2 = create_interface(Port=Port_2, Layers='eth', Tops=['ipv4', 'ipv6'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建Isis会话\n    Isis_1 = create_isis(Port=Port_1, IpVersion='IPV4IPV6')\n    Isis_2 = create_isis(Port=Port_2, IpVersion='IPV4IPV6')\n\n    select_interface(Session=Isis_1, Interface=interfaces_1)\n    select_interface(Session=Isis_2, Interface=interfaces_2)\n\n    # 创建Isis Lsp向导\n    wizard = create_isis_lsp_wizard(Sessions=[Isis_1, Isis_2])\n\n    # 配置组网拓扑\n    config_isis_lsp_wizard_network_topo(Wizards=wizard, Type='GRID',\n                                        GridNumberOfRows=10,\n                                        GridNumberOfColumns=20)\n\n    # 配置isis\n    config_isis_lsp_wizard_isis(Wizards=wizard,\n                                EnableTrafficEngine=True,\n                                EnableSegmentRouting=True,\n                                EnableSegmentRoutingIPv6=True,\n                                EnableFlexAlgo=True)\n    te = config_isis_lsp_wizard_isis_te(Wizards=wizard,\n                                        EnableTeGroup=True,\n                                        TeGroup=10)\n    sr = config_isis_lsp_wizard_isis_sr(Wizards=wizard,\n                                        ValueType='BIT32')\n    srv6 = config_isis_lsp_wizard_isis_srv6(Wizards=wizard,\n                                            MtId=10)\n    flex_algo = config_isis_lsp_wizard_isis_flex_algo(Wizards=wizard,\n                                                      FlexAlgo=255)\n\n    # 配置ipv4 internal route\n    config_isis_lsp_wizard_ipv4_internal_route(Wizards=wizard,\n                                               Ipv4InternalRoutesPrefixLenType='CUSTOM',\n                                               Ipv4InternalRoutesPrefixLenCustom=\n                                               [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 30, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                0.0, 0.0, 50]\n                                                )\n\n    # 配置ipv4 external route\n    config_isis_lsp_wizard_ipv4_external_route(Wizards=wizard,\n                                               Ipv4ExternalRoutesPrefixLenType='LINEAR',\n                                               Ipv4ExternalRoutesPrefixLenStart=10,\n                                               Ipv4ExternalRoutesPrefixLenEnd=20)\n\n    # 配置ipv6 internal route\n    config_isis_lsp_wizard_ipv6_internal_route(Wizards=wizard,\n                                               Ipv6InternalWideMetric=20)\n\n    # 配置ipv6 external route\n    config_isis_lsp_wizard_ipv6_external_route(Wizards=wizard,\n                                               Ipv6ExternalAdvEmulatedRouters=True\n                                               )\n\n    # 生成Isis Lsp向导配置\n    expand_isis_lsp_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\ncreate_isis:创建ISIS协议会话对象\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/vxlan-h3c.py",
    "intent": "=================================================================================",
    "intent_en": "=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/9', '//10.0.11.191/1/10', '//10.0.11.191/1/11', '//10.0.11.191/1/12',\n             '//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16',\n             '//10.0.11.191/1/5', '//10.0.11.191/1/6', '//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(\n    sys.argv) < 2 else sys.argv[\n    1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port1, Port2, Port3, Port4, Port5, Port6, Port7, Port8, Port9, Port10, Port11, Port12 = reserve_port(\n        Locations=locations, Force=True)\n\n    # 创建接口\n    vxlans_1 = []\n    vxlans_2 = []\n    vxlans_3 = []\n    vxlans_4 = []\n    vxlans_5 = []\n    vxlans_6 = []\n    vxlans_7 = []\n    vxlans_8 = []\n    stream_names = ['L3 dut3-stc_T11-30']\n    stream_names_TC4_V6 = ['L3 dut3-dut4-v6_T11-30']\n    Interface_TC4_T_All = []\n    Interface_TC4_V6_1 = []\n    Interface_TC4_V6_2 = []\n    Interface_TC4_V6_All = []\n    Interface_TC5_T_All = []\n    Interface_TC5_All = []\n    Interface_TC5_V6_1 = []\n    Interface_TC5_V6_2 = []\n    Interface_TC5_V6_All = []\n    udplayer = ['udp']\n    headerlayers = ['eth', 'vlan']\n    headerlayers_ipv4 = ['ipv4']\n    headerlayers_ipv6 = ['ipv6']\n\n    for num in range(1, 21):\n        h = hex(num)[2:]\n        i = num + 1\n        interfaces_vtep1 = create_interface(Port=Port1, Layers='ipv4', Name=\"VTEP Device 1-\" + str(num))\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='EthIILayer',\n                       Address='10:00:00:50:00:' + h)\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='IPv4Layer',\n                       Address='13.6.1.' + str(i),\n                       Gateway='13.6.1.1')\n        Session_vxlan = create_vxlan(Port=Port1, Name=\"VTEP Device 1-\" + str(num))\n        vxlans_1.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep1)\n\n        T1 = 20 + num\n        interfaces_vtep2 = create_interface(Port=Port4, Layers='ipv4', Name=\"VTEP Device 1-\" + str(T1))\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='EthIILayer',\n                       Address='10:00:00:51:00:' + h)\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='IPv4Layer',\n                       Address='13.6.2.' + str(i),\n                       Gateway='13.6.2.1')\n        Session_vxlan = create_vxlan(Port=Port4, Name=\"VTEP Device 1-\" + str(T1))\n        vxlans_3.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep2)\n\n        T2 = 40 + num\n        interfaces_vtep3 = create_interface(Port=Port7, Layers='ipv4', Name=\"VTEP Device 1-\" + str(T2))\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='EthIILayer',\n                       Address='10:00:00:52:00:' + h)\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='IPv4Layer',\n                       Address='13.6.3.' + str(i),\n                       Gateway='13.6.3.1')\n        Session_vxlan = create_vxlan(Port=Port7, Name=\"VTEP Device 1-\" + str(T2))\n        vxlans_5.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep3)\n\n        T3 = 60 + num\n        interfaces_vtep4 = create_interface(Port=Port10, Layers='ipv4', Name=\"VTEP Device 1-\" + str(T3))\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='EthIILayer',\n                       Address='10:00:00:53:00:' + h)\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='IPv4Layer',\n                       Address='13.6.4.' + str(i),\n                       Gateway='13.6.4.1')\n        Session_vxlan = create_vxlan(Port=Port10, Name=\"VTEP Device 1-\" + str(T3))\n        vxlans_7.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep4)\n\n    for num in range(1, 21):\n        h = hex(num)[2:]\n        i = num + 1\n        interfaces_vtep1 = create_interface(Port=Port1, Layers='ipv4', Name=\"VTEP Device 2-\" + str(num))\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='EthIILayer',\n                       Address='10:00:00:50:00:' + h)\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='IPv4Layer',\n                       Address='13.6.1.' + str(i),\n                       Gateway='13.6.1.1')\n        Session_vxlan = create_vxlan(Port=Port1, Name=\"VTEP Device 2-\" + str(num))\n        vxlans_2.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep1)\n\n        T1 = 20 + num\n        interfaces_vtep2 = create_interface(Port=Port4, Layers='ipv4', Name=\"VTEP Device 2-\" + str(T1))\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='EthIILayer',\n                       Address='10:00:00:51:00:' + h)\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='IPv4Layer',\n                       Address='13.6.2.' + str(i),\n                       Gateway='13.6.2.1')\n        Session_vxlan = create_vxlan(Port=Port4, Name=\"VTEP Device 2-\" + str(T1))\n        vxlans_4.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep2)\n\n        T2 = 40 + num\n        interfaces_vtep3 = create_interface(Port=Port7, Layers='ipv4', Name=\"VTEP Device 2-\" + str(T2))\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='EthIILayer',\n                       Address='10:00:00:52:00:' + h)\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='IPv4Layer',\n                       Address='13.6.3.' + str(i),\n                       Gateway='13.6.3.1')\n        Session_vxlan = create_vxlan(Port=Port7, Name=\"VTEP Device 2-\" + str(T2))\n        vxlans_6.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep3)\n\n        T3 = 60 + num\n        interfaces_vtep4 = create_interface(Port=Port10, Layers='ipv4', Name=\"VTEP Device 2-\" + str(T3))\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='EthIILayer',\n                       Address='10:00:00:53:00:' + h)\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='IPv4Layer',\n                       Address='13.6.4.' + str(i),\n                       Gateway='13.6.4.1')\n        Session_vxlan = create_vxlan(Port=Port10, Name=\"VTEP Device 2-\" + str(T3))\n        vxlans_8.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep4)\n\n    count = 1\n    xin = 0\n    number = 0\n    l3vni = 10011\n    e = 200\n    f = 11\n    for num in range(1, 41):\n        a = hex(num - 1)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device ' + str(num))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(num))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port1, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.' + str(count) + '.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port1, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.' + str(count) + '.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port1, Layers='ipv6', Count=10, Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:' + hex(count)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port1, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:' + hex(count)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.2',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC4_T_All.append(interfaces_host_1)\n            interfaces_host_2 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC4_V6_1.append(interfaces_host_2)\n            interfaces_host_3 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.102',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC5_T_All.append(interfaces_host_3)\n            interfaces_host_4 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC5_V6_1.append(interfaces_host_4)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_rt5_4)\n\n\n        else:\n            number = number + 1\n            e = e + 1\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device ' + str(num))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(num))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.2',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC4_T_All.append(interfaces_host_1)\n            interfaces_host_2 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC4_V6_2.append(interfaces_host_2)\n            interfaces_host_3 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.102',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC5_T_All.append(interfaces_host_3)\n            interfaces_host_4 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC5_V6_2.append(interfaces_host_4)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    count = 21\n    xin = 0\n    number = 0\n    l3vni = 10031\n    e = 240\n    f = 31\n    for num in range(1, 41):\n        a = hex(num + 39)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            T = 40 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port4, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port4, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port4, Layers='ipv6', Count=10, Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port4, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_rt5_4)\n\n        else:\n            number = number + 1\n            e = e + 1\n            T = 40 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    count = 41\n    xin = 0\n    number = 0\n    l3vni = 10051\n    e = 280\n    f = 51\n    for num in range(1, 41):\n        a = hex(num + 79)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            T = 80 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port7, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port7, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port7, Layers='ipv6', Count=10, Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port7, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_rt5_4)\n\n        else:\n            number = number + 1\n            e = e + 1\n            T = 80 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    count = 61\n    xin = 0\n    number = 0\n    l3vni = 10071\n    e = 320\n    f = 71\n    for num in range(1, 41):\n        a = hex(num + 119)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            T = 120 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port10, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port10, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port10, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port10, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_rt5_4)\n\n        else:\n            number = number + 1\n            e = e + 1\n            T = 120 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    Points_TC4_T_All = get_layer_from_interfaces(Interfaces=Interface_TC4_T_All, Layer='ipv4')\n    Points_TC5_T_All = get_layer_from_interfaces(Interfaces=Interface_TC5_T_All, Layer='ipv4')\n    stream_TC4_T_TC5_T = add_stream(Type='binding', Names=stream_names, SrcPoints=Points_TC4_T_All,\n                                    DstPoints=Points_TC5_T_All,\n                                    TrafficMeshMode='ONE_TO_ONE', Layer='IPV4')\n    create_stream_header(Stream=stream_TC4_T_TC5_T, Index=0, HeaderTypes=udplayer)\n    edit_header_udp(Stream=stream_TC4_T_TC5_T, Level=0, SourcePort=20000, DestPort=10000)\n    edit_modifier(Stream=stream_TC4_T_TC5_T, Attribute='SourcePort', Level=0, Type='Increment', Count=1000,\n                  HeaderType='udp')\n    edit_modifier(Stream=stream_TC4_T_TC5_T, Attribute='DestPort', Level=0, Type='Increment', Count=100,\n                  HeaderType='udp')\n\n    Interface_TC4_V6_All = Interface_TC4_V6_1 + Interface_TC4_V6_2\n    Interface_TC5_V6_All = Interface_TC5_V6_2 + Interface_TC5_V6_1\n    Points_TC4_V6_All = get_layer_from_interfaces(Interfaces=Interface_TC4_V6_All, Layer='ipv6')\n    Points_TC5_V6_All = get_layer_from_interfaces(Interfaces=Interface_TC5_V6_All, Layer='ipv6')\n    stream_TC4_V6_TC5_V6 = add_stream(Type='binding', Names=stream_names_TC4_V6, SrcPoints=Points_TC4_V6_All,\n                                      DstPoints=Points_TC5_V6_All,\n                                      TrafficMeshMode='ONE_TO_ONE', Layer='IPV6')\n    create_stream_header(Stream=stream_TC4_V6_TC5_V6, Index=0, HeaderTypes=udplayer)\n    edit_header_udp(Stream=stream_TC4_V6_TC5_V6, Level=0, SourcePort=20000, DestPort=10000)\n    edit_modifier(Stream=stream_TC4_V6_TC5_V6, Attribute='SourcePort', Level=0, Type='Increment', Count=1000,\n                  HeaderType='udp')\n    edit_modifier(Stream=stream_TC4_V6_TC5_V6, Attribute='DestPort', Level=0, Type='Increment', Count=100,\n                  HeaderType='udp')\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "binding_vxlan_vm:绑定 Vxlan Vm 对象",
      "binding_vxlan_vtep:绑定 Vxlan Vtep 对象",
      "create_vxlan:创建Vxlan协议会话对象",
      "create_vxlan_segment:创建Vxlan Segment对象",
      "edit_header_udp:修改测试仪表流量模板中UDP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester with specified product configuration (default 'DarYu' or command-line input).\",\n  \"Subtask 2\": \"Reserve 12 test ports using provided locations (default or command-line input) with force option enabled.\",\n  \"Subtask 3\": \"Create and configure VTEP Device 1 interfaces on Port1, Port4, Port7, Port10 with IPv4 layers, including MAC and IP address settings.\",\n  \"Subtask 4\": \"Create VXLAN sessions for VTEP Device 1 interfaces and bind each session to its corresponding interface.\",\n  \"Subtask 5\": \"Create and configure VTEP Device 2 interfaces on Port1, Port4, Port7, Port10 with IPv4 layers, including MAC and IP address settings.\",\n  \"Subtask 6\": \"Create VXLAN sessions for VTEP Device 2 interfaces and bind each session to its corresponding interface.\",\n  \"Subtask 7\": \"For Port1 group (Port1-3): Create 40 VXLAN segments with L3VNI enabled, then create and configure VM interfaces (IPv4/IPv6), RT5 interfaces (IPv4/IPv6), and host interfaces (TC4/TC5 IPv4/IPv6) with VLAN settings.\",\n  \"Subtask 8\": \"Bind VM interfaces, RT5 interfaces, and host interfaces to VXLAN segments and VTEP sessions for Port1 group.\",\n  \"Subtask 9\": \"For Port4 group (Port4-6): Create 40 VXLAN segments with L3VNI enabled, then create and configure VM interfaces (IPv4/IPv6), RT5 interfaces (IPv4/IPv6), and host interfaces (TC4/TC5 IPv4/IPv6) with VLAN settings.\",\n  \"Subtask 10\": \"Bind VM interfaces, RT5 interfaces, and host interfaces to VXLAN segments and VTEP sessions for Port4 group.\",\n  \"Subtask 11\": \"For Port7 group (Port7-9): Create 40 VXLAN segments with L3VNI enabled, then create and configure VM interfaces (IPv4/IPv6), RT5 interfaces (IPv4/IPv6), and host interfaces (TC4/TC5 IPv4/IPv6) with VLAN settings.\",\n  \"Subtask 12\": \"Bind VM interfaces, RT5 interfaces, and host interfaces to VXLAN segments and VTEP sessions for Port7 group.\",\n  \"Subtask 13\": \"For Port10 group (Port10-12): Create 40 VXLAN segments with L3VNI enabled, then create and configure VM interfaces (IPv4/IPv6), RT5 interfaces (IPv4/IPv6), and host interfaces (TC4/TC5 IPv4/IPv6) with VLAN settings.\",\n  \"Subtask 14\": \"Bind VM interfaces, RT5 interfaces, and host interfaces to VXLAN segments and VTEP sessions for Port10 group.\",\n  \"Subtask 15\": \"Extract IPv4 layer points from TC4_T_All and TC5_T_All host interfaces.\",\n  \"Subtask 16\": \"Create IPv4 traffic stream between TC4_T_All and TC5_T_All points with UDP headers and port modifiers (incremental source/dest ports).\",\n  \"Subtask 17\": \"Extract IPv6 layer points from TC4_V6_All and TC5_V6_All host interfaces.\",\n  \"Subtask 18\": \"Create IPv6 traffic stream between TC4_V6_All and TC5_V6_All points with UDP headers and port modifiers (incremental source/dest ports).\",\n  \"Subtask 19\": \"Save test case configuration to file using current script path and name.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/9', '//10.0.11.191/1/10', '//10.0.11.191/1/11', '//10.0.11.191/1/12',\n             '//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16',\n             '//10.0.11.191/1/5', '//10.0.11.191/1/6', '//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(\n    sys.argv) < 2 else sys.argv[\n    1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port1, Port2, Port3, Port4, Port5, Port6, Port7, Port8, Port9, Port10, Port11, Port12 = reserve_port(\n        Locations=locations, Force=True)\n\n    # 创建接口\n    vxlans_1 = []\n    vxlans_2 = []\n    vxlans_3 = []\n    vxlans_4 = []\n    vxlans_5 = []\n    vxlans_6 = []\n    vxlans_7 = []\n    vxlans_8 = []\n    stream_names = ['L3 dut3-stc_T11-30']\n    stream_names_TC4_V6 = ['L3 dut3-dut4-v6_T11-30']\n    Interface_TC4_T_All = []\n    Interface_TC4_V6_1 = []\n    Interface_TC4_V6_2 = []\n    Interface_TC4_V6_All = []\n    Interface_TC5_T_All = []\n    Interface_TC5_All = []\n    Interface_TC5_V6_1 = []\n    Interface_TC5_V6_2 = []\n    Interface_TC5_V6_All = []\n    udplayer = ['udp']\n    headerlayers = ['eth', 'vlan']\n    headerlayers_ipv4 = ['ipv4']\n    headerlayers_ipv6 = ['ipv6']\n\n    for num in range(1, 21):\n        h = hex(num)[2:]\n        i = num + 1\n        interfaces_vtep1 = create_interface(Port=Port1, Layers='ipv4', Name=\"VTEP Device 1-\" + str(num))\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='EthIILayer',\n                       Address='10:00:00:50:00:' + h)\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='IPv4Layer',\n                       Address='13.6.1.' + str(i),\n                       Gateway='13.6.1.1')\n        Session_vxlan = create_vxlan(Port=Port1, Name=\"VTEP Device 1-\" + str(num))\n        vxlans_1.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep1)\n\n        T1 = 20 + num\n        interfaces_vtep2 = create_interface(Port=Port4, Layers='ipv4', Name=\"VTEP Device 1-\" + str(T1))\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='EthIILayer',\n                       Address='10:00:00:51:00:' + h)\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='IPv4Layer',\n                       Address='13.6.2.' + str(i),\n                       Gateway='13.6.2.1')\n        Session_vxlan = create_vxlan(Port=Port4, Name=\"VTEP Device 1-\" + str(T1))\n        vxlans_3.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep2)\n\n        T2 = 40 + num\n        interfaces_vtep3 = create_interface(Port=Port7, Layers='ipv4', Name=\"VTEP Device 1-\" + str(T2))\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='EthIILayer',\n                       Address='10:00:00:52:00:' + h)\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='IPv4Layer',\n                       Address='13.6.3.' + str(i),\n                       Gateway='13.6.3.1')\n        Session_vxlan = create_vxlan(Port=Port7, Name=\"VTEP Device 1-\" + str(T2))\n        vxlans_5.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep3)\n\n        T3 = 60 + num\n        interfaces_vtep4 = create_interface(Port=Port10, Layers='ipv4', Name=\"VTEP Device 1-\" + str(T3))\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='EthIILayer',\n                       Address='10:00:00:53:00:' + h)\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='IPv4Layer',\n                       Address='13.6.4.' + str(i),\n                       Gateway='13.6.4.1')\n        Session_vxlan = create_vxlan(Port=Port10, Name=\"VTEP Device 1-\" + str(T3))\n        vxlans_7.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep4)\n\n    for num in range(1, 21):\n        h = hex(num)[2:]\n        i = num + 1\n        interfaces_vtep1 = create_interface(Port=Port1, Layers='ipv4', Name=\"VTEP Device 2-\" + str(num))\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='EthIILayer',\n                       Address='10:00:00:50:00:' + h)\n        edit_interface(Interface=interfaces_vtep1,\n                       Layer='IPv4Layer',\n                       Address='13.6.1.' + str(i),\n                       Gateway='13.6.1.1')\n        Session_vxlan = create_vxlan(Port=Port1, Name=\"VTEP Device 2-\" + str(num))\n        vxlans_2.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep1)\n\n        T1 = 20 + num\n        interfaces_vtep2 = create_interface(Port=Port4, Layers='ipv4', Name=\"VTEP Device 2-\" + str(T1))\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='EthIILayer',\n                       Address='10:00:00:51:00:' + h)\n        edit_interface(Interface=interfaces_vtep2,\n                       Layer='IPv4Layer',\n                       Address='13.6.2.' + str(i),\n                       Gateway='13.6.2.1')\n        Session_vxlan = create_vxlan(Port=Port4, Name=\"VTEP Device 2-\" + str(T1))\n        vxlans_4.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep2)\n\n        T2 = 40 + num\n        interfaces_vtep3 = create_interface(Port=Port7, Layers='ipv4', Name=\"VTEP Device 2-\" + str(T2))\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='EthIILayer',\n                       Address='10:00:00:52:00:' + h)\n        edit_interface(Interface=interfaces_vtep3,\n                       Layer='IPv4Layer',\n                       Address='13.6.3.' + str(i),\n                       Gateway='13.6.3.1')\n        Session_vxlan = create_vxlan(Port=Port7, Name=\"VTEP Device 2-\" + str(T2))\n        vxlans_6.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep3)\n\n        T3 = 60 + num\n        interfaces_vtep4 = create_interface(Port=Port10, Layers='ipv4', Name=\"VTEP Device 2-\" + str(T3))\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='EthIILayer',\n                       Address='10:00:00:53:00:' + h)\n        edit_interface(Interface=interfaces_vtep4,\n                       Layer='IPv4Layer',\n                       Address='13.6.4.' + str(i),\n                       Gateway='13.6.4.1')\n        Session_vxlan = create_vxlan(Port=Port10, Name=\"VTEP Device 2-\" + str(T3))\n        vxlans_8.append(Session_vxlan)\n        select_interface(Session=Session_vxlan, Interface=interfaces_vtep4)\n\n    count = 1\n    xin = 0\n    number = 0\n    l3vni = 10011\n    e = 200\n    f = 11\n    for num in range(1, 41):\n        a = hex(num - 1)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device ' + str(num))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(num))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port1, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.' + str(count) + '.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port1, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.' + str(count) + '.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port1, Layers='ipv6', Count=10, Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:' + hex(count)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port1, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:' + hex(count)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.2',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC4_T_All.append(interfaces_host_1)\n            interfaces_host_2 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC4_V6_1.append(interfaces_host_2)\n            interfaces_host_3 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.102',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC5_T_All.append(interfaces_host_3)\n            interfaces_host_4 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC5_V6_1.append(interfaces_host_4)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_rt5_4)\n\n\n        else:\n            number = number + 1\n            e = e + 1\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device ' + str(num))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port1, Layers='ipv4', Count=30, Name='VM Device 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(num))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port1, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(num))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.2',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC4_T_All.append(interfaces_host_1)\n            interfaces_host_2 = create_interface(Port=Port2, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC4_V6_2.append(interfaces_host_2)\n            interfaces_host_3 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(num) + '.102',\n                           Gateway='2.1.' + str(num) + '.1')\n            Interface_TC5_T_All.append(interfaces_host_3)\n            interfaces_host_4 = create_interface(Port=Port3, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:00:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(num)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(num)[2:] + ':1::1')\n            Interface_TC5_V6_2.append(interfaces_host_4)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_1[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_2[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    count = 21\n    xin = 0\n    number = 0\n    l3vni = 10031\n    e = 240\n    f = 31\n    for num in range(1, 41):\n        a = hex(num + 39)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            T = 40 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port4, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port4, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port4, Layers='ipv6', Count=10, Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port4, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_rt5_4)\n\n        else:\n            number = number + 1\n            e = e + 1\n            T = 40 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port4, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port4, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port5, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port6, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:01:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_3[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_4[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    count = 41\n    xin = 0\n    number = 0\n    l3vni = 10051\n    e = 280\n    f = 51\n    for num in range(1, 41):\n        a = hex(num + 79)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            T = 80 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port7, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port7, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port7, Layers='ipv6', Count=10, Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port7, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_rt5_4)\n\n        else:\n            number = number + 1\n            e = e + 1\n            T = 80 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port7, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port7, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port8, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port9, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:02:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_5[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_6[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    count = 61\n    xin = 0\n    number = 0\n    l3vni = 10071\n    e = 320\n    f = 71\n    for num in range(1, 41):\n        a = hex(num + 119)[2:]\n        b = hex(count)[2:]\n        c = 1\n        d = 2\n        h = hex(count)[2:]\n        i = count + 1\n        g = hex(num)[2:]\n        if number % 2 == 0:\n            number = number + 1\n            e = e + 1\n            T = 120 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n            interfaces_vm_1 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(c) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(c) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(c) + '::2',\n                           Gateway='4:' + b + ':' + str(c) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_rt5_1 = create_interface(Port=Port10, Layers='ipv4', Count=10, Name=\"RT5 Device \" + str(count))\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_1,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_1)\n            interfaces_rt5_2 = create_interface(Port=Port10, Layers='ipv4', Count=10, Name=\"RT5 Device 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:8F')\n            edit_interface(Interface=interfaces_rt5_2,\n                           Layer='IPv4Layer',\n                           Address='5.' + str(count) + '.1.2',\n                           Gateway='5.1.1.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_2)\n            interfaces_rt5_3 = create_interface(Port=Port10, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 \" + str(count))\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_3,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_3)\n            interfaces_rt5_4 = create_interface(Port=Port10, Layers='ipv6', Count=10,\n                                                Name=\"RT5 Device V6 2-\" + str(count))\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='EthIILayer',\n                           Address='00:10:94:00:30:91')\n            edit_interface(Interface=interfaces_rt5_4,\n                           Layer='IPv6Layer',\n                           Address='5:' + hex(count)[2:] + ':1::2',\n                           Gateway='5:1:1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_rt5_4)\n            interfaces_host_1 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(c))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_4)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_rt5_1)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_rt5_3)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_rt5_2)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_rt5_4)\n\n        else:\n            number = number + 1\n            e = e + 1\n            T = 120 + num\n            Segment = create_vxlan_segment(Name='Seg ' + str(e),\n                                           StartVni=str(e),\n                                           CommunicationType=2,\n                                           EnableL3Vni=True,\n                                           StartL3Vni=str(l3vni),\n                                           VniTrafficType=1)\n\n            interfaces_vm_1 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device ' + str(T))\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_1,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_1)\n            interfaces_vm_2 = create_interface(Port=Port10, Layers='ipv4', Count=30, Name='VM Device 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_2,\n                           Layer='IPv4Layer',\n                           Address='4.' + str(count) + '.' + str(d) + '.2',\n                           Gateway='4.' + str(count) + '.' + str(d) + '.1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_2)\n            interfaces_vm_3 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 ' + str(T))\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_3,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_3)\n            interfaces_vm_4 = create_interface(Port=Port10, Layers='ipv6', Count=6, Name='VM Device v6 2-' + str(T))\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='EthIILayer',\n                           Address='00:00:10:' + b + ':' + a + ':00')\n            edit_interface(Interface=interfaces_vm_4,\n                           Layer='IPv6Layer',\n                           Address='4:' + b + ':' + str(d) + '::2',\n                           Gateway='4:' + b + ':' + str(d) + '::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_vm_4)\n            interfaces_host_1 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC4-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_1,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.2',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_2 = create_interface(Port=Port11, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC4-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='EthIILayer',\n                           Address='00:10:80:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_2,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::2',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            interfaces_host_3 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv4, Count=20,\n                                                 Name='TC5-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_3,\n                           Layer='IPv4Layer',\n                           Address='2.1.' + str(T) + '.102',\n                           Gateway='2.1.' + str(T) + '.1')\n            interfaces_host_4 = create_interface(Port=Port12, Layers=headerlayers, Tops=headerlayers_ipv6, Count=20,\n                                                 Name='TC5-V6-T' + str(f) + '-' + str(d))\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='EthIILayer',\n                           Address='00:10:81:03:' + g + ':01')\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='VLANLayer',\n                           VlanId=e,\n                           Step=0,\n                           Priority=7)\n            edit_interface(Interface=interfaces_host_4,\n                           Layer='IPv6Layer',\n                           Address='2:1:' + hex(T)[2:] + ':1::102',\n                           Gateway='2:1:' + hex(T)[2:] + ':1::1')\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_1)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_2)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_3)\n            binding_vxlan_vm(Segments=Segment, Interfaces=interfaces_host_4)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_1)\n            binding_vxlan_vtep(Vteps=vxlans_7[xin], Interfaces=interfaces_vm_3)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_2)\n            binding_vxlan_vtep(Vteps=vxlans_8[xin], Interfaces=interfaces_vm_4)\n            l3vni = l3vni + 1\n            count = count + 1\n            xin = xin + 1\n            f = f + 1\n\n    Points_TC4_T_All = get_layer_from_interfaces(Interfaces=Interface_TC4_T_All, Layer='ipv4')\n    Points_TC5_T_All = get_layer_from_interfaces(Interfaces=Interface_TC5_T_All, Layer='ipv4')\n    stream_TC4_T_TC5_T = add_stream(Type='binding', Names=stream_names, SrcPoints=Points_TC4_T_All,\n                                    DstPoints=Points_TC5_T_All,\n                                    TrafficMeshMode='ONE_TO_ONE', Layer='IPV4')\n    create_stream_header(Stream=stream_TC4_T_TC5_T, Index=0, HeaderTypes=udplayer)\n    edit_header_udp(Stream=stream_TC4_T_TC5_T, Level=0, SourcePort=20000, DestPort=10000)\n    edit_modifier(Stream=stream_TC4_T_TC5_T, Attribute='SourcePort', Level=0, Type='Increment', Count=1000,\n                  HeaderType='udp')\n    edit_modifier(Stream=stream_TC4_T_TC5_T, Attribute='DestPort', Level=0, Type='Increment', Count=100,\n                  HeaderType='udp')\n\n    Interface_TC4_V6_All = Interface_TC4_V6_1 + Interface_TC4_V6_2\n    Interface_TC5_V6_All = Interface_TC5_V6_2 + Interface_TC5_V6_1\n    Points_TC4_V6_All = get_layer_from_interfaces(Interfaces=Interface_TC4_V6_All, Layer='ipv6')\n    Points_TC5_V6_All = get_layer_from_interfaces(Interfaces=Interface_TC5_V6_All, Layer='ipv6')\n    stream_TC4_V6_TC5_V6 = add_stream(Type='binding', Names=stream_names_TC4_V6, SrcPoints=Points_TC4_V6_All,\n                                      DstPoints=Points_TC5_V6_All,\n                                      TrafficMeshMode='ONE_TO_ONE', Layer='IPV6')\n    create_stream_header(Stream=stream_TC4_V6_TC5_V6, Index=0, HeaderTypes=udplayer)\n    edit_header_udp(Stream=stream_TC4_V6_TC5_V6, Level=0, SourcePort=20000, DestPort=10000)\n    edit_modifier(Stream=stream_TC4_V6_TC5_V6, Attribute='SourcePort', Level=0, Type='Increment', Count=1000,\n                  HeaderType='udp')\n    edit_modifier(Stream=stream_TC4_V6_TC5_V6, Attribute='DestPort', Level=0, Type='Increment', Count=100,\n                  HeaderType='udp')\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nbinding_vxlan_vm:绑定 Vxlan Vm 对象;\nbinding_vxlan_vtep:绑定 Vxlan Vtep 对象;\ncreate_vxlan:创建Vxlan协议会话对象;\ncreate_vxlan_segment:创建Vxlan Segment对象;\nedit_header_udp:修改测试仪表流量模板中UDP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/rip_route/rip_route_wizard.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查Rip Route向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Rip会话;\n                   测试步骤3: 创建Rip Route向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Rip Route向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Verify that the Rip Route wizard configuration is generated correctly.\n\nStep          : Step 1: Create two offline ports, Port_1 and Port_2;\n               Step 2: Create a Rip session;\n               Step 3: Create a Rip Route wizard;\n               Step 4: Generate the wizard configuration;\n\nCriteria      : Expected Result 1: In Step 4, the Rip Route wizard configuration is generated without any exceptions;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='eth', Tops=['ipv4', 'ipv6'])\n    interfaces_2 = create_interface(Port=Port_2, Layers='eth', Tops=['ipv4', 'ipv6'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建Rip会话\n    rip_1 = create_rip(Port=Port_1)\n    rip_2 = create_rip(Port=Port_2, Version='RIPNG')\n\n    select_interface(Session=rip_1, Interface=interfaces_1)\n    select_interface(Session=rip_2, Interface=interfaces_2)\n\n    # 创建Rip Route向导\n    wizard = create_rip_route_wizard(Sessions=[rip_1, rip_2])\n\n    # 配置ipv4 route\n    config_rip_route_wizard_ipv4(Wizards=wizard,\n                                 Ipv4RoutesPrefixLenType='LINEAR',\n                                 Ipv4RoutesPrefixLenStart=8,\n                                 Ipv4RoutesPrefixLenEnd=24)\n\n    # 配置ipv6 route\n    config_rip_route_wizard_ipv6(Wizards=wizard,\n                                 Ipv6StartRoutesPrefix='2022::',\n                                 Ipv6EndRoutesPrefix='2033::')\n\n    # 生成Rip Route向导配置\n    expand_rip_route_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "create_rip:创建RIP协议会话对象"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product (default 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two physical ports (Port_1 and Port_2) at given locations using reserve_port API.\",\n  \"Subtask 3\": \"Create an Ethernet interface with IPv4 and IPv6 layers on Port_1 using create_interface API.\",\n  \"Subtask 4\": \"Configure IPv4 parameters for Port_1 interface: address 192.168.1.2, gateway 192.168.1.3 using edit_interface API.\",\n  \"Subtask 5\": \"Configure IPv6 parameters for Port_1 interface: address 2001::1, gateway 2001::2 using edit_interface API.\",\n  \"Subtask 6\": \"Create an Ethernet interface with IPv4 and IPv6 layers on Port_2 using create_interface API.\",\n  \"Subtask 7\": \"Configure IPv4 parameters for Port_2 interface: address 192.168.1.3, gateway 192.168.1.2 using edit_interface API.\",\n  \"Subtask 8\": \"Configure IPv6 parameters for Port_2 interface: address 2001::2, gateway 2001::1 using edit_interface API.\",\n  \"Subtask 9\": \"Create a RIP session on Port_1 using create_rip API (default IPv4 version).\",\n  \"Subtask 10\": \"Create a RIPNG session on Port_2 using create_rip API with version='RIPNG'.\",\n  \"Subtask 11\": \"Bind the Port_1 interface to its RIP session using select_interface API.\",\n  \"Subtask 12\": \"Bind the Port_2 interface to its RIPNG session using select_interface API.\",\n  \"Subtask 13\": \"Create a RIP Route wizard associating both RIP sessions.\",\n  \"Subtask 14\": \"Configure IPv4 route parameters in wizard: prefix length type=LINEAR, start=8, end=24.\",\n  \"Subtask 15\": \"Configure IPv6 route parameters in wizard: start prefix=2022::, end prefix=2033::.\",\n  \"Subtask 16\": \"Expand the RIP Route wizard to generate the configuration.\",\n  \"Subtask 17\": \"Verify successful generation of RIP Route wizard configuration without exceptions.\",\n  \"Subtask 18\": \"Save the test configuration to a file using save_case API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Verify that the Rip Route wizard configuration is generated correctly.\n\nStep          : Step 1: Create two offline ports, Port_1 and Port_2;\n               Step 2: Create a Rip session;\n               Step 3: Create a Rip Route wizard;\n               Step 4: Generate the wizard configuration;\n\nCriteria      : Expected Result 1: In Step 4, the Rip Route wizard configuration is generated without any exceptions;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='eth', Tops=['ipv4', 'ipv6'])\n    interfaces_2 = create_interface(Port=Port_2, Layers='eth', Tops=['ipv4', 'ipv6'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建Rip会话\n    rip_1 = create_rip(Port=Port_1)\n    rip_2 = create_rip(Port=Port_2, Version='RIPNG')\n\n    select_interface(Session=rip_1, Interface=interfaces_1)\n    select_interface(Session=rip_2, Interface=interfaces_2)\n\n    # 创建Rip Route向导\n    wizard = create_rip_route_wizard(Sessions=[rip_1, rip_2])\n\n    # 配置ipv4 route\n    config_rip_route_wizard_ipv4(Wizards=wizard,\n                                 Ipv4RoutesPrefixLenType='LINEAR',\n                                 Ipv4RoutesPrefixLenStart=8,\n                                 Ipv4RoutesPrefixLenEnd=24)\n\n    # 配置ipv6 route\n    config_rip_route_wizard_ipv6(Wizards=wizard,\n                                 Ipv6StartRoutesPrefix='2022::',\n                                 Ipv6EndRoutesPrefix='2033::')\n\n    # 生成Rip Route向导配置\n    expand_rip_route_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\ncreate_rip:创建RIP协议会话对象\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/mpls/pwe.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查PWE向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建PWE向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置PWE;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 配置LSP Ping;\n                   测试步骤9: 生成PWE向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 PWE向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective      : Test Objective: Check that the PWE wizard configuration is generated normally\n\nStep           : Test Step 1: Create 8 offline ports: Port_1, Port_2;\n                Test Step 2: Create a PWE wizard;\n                Test Step 3: Configure client-side port and provider-side port;\n                Test Step 4: Configure provider-side router;\n                Test Step 5: Configure PWE;\n                Test Step 6: Configure Host;\n                Test Step 7: Configure traffic;\n                Test Step 8: Configure LSP Ping;\n                Test Step 9: Generate PWE wizard configuration;\n\nCriteria       : Expected Result 1: Step 8: PWE wizard configuration is generated without exception;\n\nCreated by     : Tester-002\n\nBugs           : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\n# locations_1 = ['//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16']\n# locations_2 = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6']\n\nlocations_1 = locations[0]\nlocations_2 = locations[1]\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations_1], Debug=True)\n    Port_provider = reserve_port(Locations=[locations_2], Debug=True)\n\n    # 创建PWE向导\n\n    wizard = create_mpls_wizard(Type='pwe')\n\n    # 配置客户端侧端口和提供商侧端口\n    for port in Port_customer:\n        edit_mpls_customer_port(Wizard=wizard, Port=port, EnableSubInterface=True, SubInterfaceCount=250,\n                                VlanId=1000)\n    for port in Port_provider:\n        edit_mpls_provider_port(Wizard=wizard, Port=port, DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='1.1.1.1',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=False,\n                                               PeRouterIdStart='2.1.1.1',\n                                               PeRouterIdStep='0.0.0.1')\n\n    # 配置PWE\n\n    edit_mpls_pwe_basic_parameters(Wizard=wizard,\n                                   NumberOfPseudoWire=10,\n                                   Mtu=1518,\n                                   GroupId=20,\n                                   EnableCBit=True,\n                                   IncludeStatusTlv=True,\n                                   StatusCode='LocalAttachmentCircuitReceiveFault',\n                                   EnableOverrideEncapsulation=True,\n                                   Encapsulation='Ethernet',\n                                   EnableOverlapVcidsOnDifferentPes=True,\n                                   EnableCreateProviderHostsForUnusedVpls=True,\n                                   FecType='FEC129')\n\n    edit_mpls_fec129(Wizard=wizard,\n                     Agi='10:1',\n                     AgiIncrement='0:2',\n                     Saii='1.1.1.1',\n                     SaiiIncrement='0.0.0.2',\n                     Taii='2.2.2.2',\n                     TaiiIncrement='0.0.0.3',\n                     EnableBgpAutoDiscovery=True,\n                     DutAsNumber=10,\n                     RdAssignment='Manual',\n                     AgiAssignment='Manual',\n                     Rt='20:0',\n                     RtIncrement='0:2',\n                     Rd='30:0',\n                     RdIncrement='0:3')\n\n    # 配置Host\n\n    edit_mpls_host(Wizard=wizard,\n                   HostAssignmentVpls='HostsOrMacsPerVpls',\n                   HostsPerVpls=32,\n                   CustomerHostPercent=50,\n                   ProviderHostPercent=50)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            TrafficLoadPercentProvider=10)\n\n    # LSP Ping\n    edit_lsp_ping(Wizard=wizard,\n                  EnableLspPing=True,\n                  DestinationIpv4Address='1.1.1.1',\n                  PingInterval=10,\n                  PingTimeout=20,\n                  TimeToLive=30,\n                  LspExpValue=7,\n                  ValidateFecStack=True,\n                  PadMode='RequestPeerToDropPadTlv',\n                  PadData=[1, 2, 3])\n\n    # 生成PWE向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_mpls_wizard:测试仪表创建MPLS向导",
      "edit_lsp_ping:配置MPLS流量LSP Ping参数",
      "edit_mpls_customer_port:配置MPLS向导客户侧端口",
      "edit_mpls_fec129:配置MPLS fec129参数",
      "edit_mpls_host:配置MPLS向导Host参数",
      "edit_mpls_provider_port:配置MPLS向导提供商侧端口",
      "edit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由",
      "edit_mpls_pwe_basic_parameters:配置MPLS pwe参数",
      "edit_traffic_parameters:配置MPLS流量",
      "expand_mpls_wizard:生成测试仪表MPLS向导配置"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu' to prepare the testing environment.\",\n  \"Subtask 2\": \"Reserve a customer-side port at the specified location (e.g., //10.0.11.191/1/5) for testing.\",\n  \"Subtask 3\": \"Reserve a provider-side port at the specified location (e.g., //10.0.11.191/1/6) for testing.\",\n  \"Subtask 4\": \"Create an MPLS wizard of type 'pwe' to start PWE configuration.\",\n  \"Subtask 5\": \"Configure the reserved customer-side port in the wizard: enable sub-interface, set sub-interface count to 250, and VLAN ID to 1000.\",\n  \"Subtask 6\": \"Configure the reserved provider-side port in the wizard: set DUT IPv4 address to 50.1.1.1 and prefix length to 24.\",\n  \"Subtask 7\": \"Configure provider router parameters: set DUT router ID to 1.1.1.1, AS number to 100, IGP protocol to ISIS, MPLS protocol to LDP, PE router start to 2.1.1.1, and disable P-router.\",\n  \"Subtask 8\": \"Configure basic PWE parameters: set number of pseudo-wires to 10, MTU to 1518, group ID to 20, enable C-bit and status TLV with fault code, set encapsulation to Ethernet, and enable FEC129.\",\n  \"Subtask 9\": \"Configure FEC129 parameters: set AGI to 10:1, SAII to 1.1.1.1, TAII to 2.2.2.2, enable BGP auto-discovery, set DUT AS to 10, and configure manual RD/RT assignments with increments.\",\n  \"Subtask 10\": \"Configure host parameters: set host assignment to 'HostsOrMacsPerVpls', hosts per VPLS to 32, and customer/provider host distribution to 50% each.\",\n  \"Subtask 11\": \"Configure traffic parameters: set flow direction to bidirectional, stream grouping to aggregate, and provider traffic load to 10%.\",\n  \"Subtask 12\": \"Configure LSP Ping: enable LSP ping, set destination IP to 1.1.1.1, interval to 10s, timeout to 20s, TTL to 30, EXP to 7, enable FEC validation, and configure pad mode with data [1,2,3].\",\n  \"Subtask 13\": \"Expand the MPLS wizard to generate the final PWE configuration.\",\n  \"Subtask 14\": \"Save the generated configuration to a file in the specified path for test verification.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective      : Test Objective: Check that the PWE wizard configuration is generated normally\n\nStep           : Test Step 1: Create 8 offline ports: Port_1, Port_2;\n                Test Step 2: Create a PWE wizard;\n                Test Step 3: Configure client-side port and provider-side port;\n                Test Step 4: Configure provider-side router;\n                Test Step 5: Configure PWE;\n                Test Step 6: Configure Host;\n                Test Step 7: Configure traffic;\n                Test Step 8: Configure LSP Ping;\n                Test Step 9: Generate PWE wizard configuration;\n\nCriteria       : Expected Result 1: Step 8: PWE wizard configuration is generated without exception;\n\nCreated by     : Tester-002\n\nBugs           : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\n# locations_1 = ['//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16']\n# locations_2 = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6']\n\nlocations_1 = locations[0]\nlocations_2 = locations[1]\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations_1], Debug=True)\n    Port_provider = reserve_port(Locations=[locations_2], Debug=True)\n\n    # 创建PWE向导\n\n    wizard = create_mpls_wizard(Type='pwe')\n\n    # 配置客户端侧端口和提供商侧端口\n    for port in Port_customer:\n        edit_mpls_customer_port(Wizard=wizard, Port=port, EnableSubInterface=True, SubInterfaceCount=250,\n                                VlanId=1000)\n    for port in Port_provider:\n        edit_mpls_provider_port(Wizard=wizard, Port=port, DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='1.1.1.1',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=False,\n                                               PeRouterIdStart='2.1.1.1',\n                                               PeRouterIdStep='0.0.0.1')\n\n    # 配置PWE\n\n    edit_mpls_pwe_basic_parameters(Wizard=wizard,\n                                   NumberOfPseudoWire=10,\n                                   Mtu=1518,\n                                   GroupId=20,\n                                   EnableCBit=True,\n                                   IncludeStatusTlv=True,\n                                   StatusCode='LocalAttachmentCircuitReceiveFault',\n                                   EnableOverrideEncapsulation=True,\n                                   Encapsulation='Ethernet',\n                                   EnableOverlapVcidsOnDifferentPes=True,\n                                   EnableCreateProviderHostsForUnusedVpls=True,\n                                   FecType='FEC129')\n\n    edit_mpls_fec129(Wizard=wizard,\n                     Agi='10:1',\n                     AgiIncrement='0:2',\n                     Saii='1.1.1.1',\n                     SaiiIncrement='0.0.0.2',\n                     Taii='2.2.2.2',\n                     TaiiIncrement='0.0.0.3',\n                     EnableBgpAutoDiscovery=True,\n                     DutAsNumber=10,\n                     RdAssignment='Manual',\n                     AgiAssignment='Manual',\n                     Rt='20:0',\n                     RtIncrement='0:2',\n                     Rd='30:0',\n                     RdIncrement='0:3')\n\n    # 配置Host\n\n    edit_mpls_host(Wizard=wizard,\n                   HostAssignmentVpls='HostsOrMacsPerVpls',\n                   HostsPerVpls=32,\n                   CustomerHostPercent=50,\n                   ProviderHostPercent=50)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            TrafficLoadPercentProvider=10)\n\n    # LSP Ping\n    edit_lsp_ping(Wizard=wizard,\n                  EnableLspPing=True,\n                  DestinationIpv4Address='1.1.1.1',\n                  PingInterval=10,\n                  PingTimeout=20,\n                  TimeToLive=30,\n                  LspExpValue=7,\n                  ValidateFecStack=True,\n                  PadMode='RequestPeerToDropPadTlv',\n                  PadData=[1, 2, 3])\n\n    # 生成PWE向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_mpls_wizard:测试仪表创建MPLS向导;\nedit_lsp_ping:配置MPLS流量LSP Ping参数;\nedit_mpls_customer_port:配置MPLS向导客户侧端口;\nedit_mpls_fec129:配置MPLS fec129参数;\nedit_mpls_host:配置MPLS向导Host参数;\nedit_mpls_provider_port:配置MPLS向导提供商侧端口;\nedit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由;\nedit_mpls_pwe_basic_parameters:配置MPLS pwe参数;\nedit_traffic_parameters:配置MPLS流量;\nexpand_mpls_wizard:生成测试仪表MPLS向导配置\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/mpls/bgp_vpls.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查BGP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建BGP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成BGP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 BGP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify normal generation of BGP VPLS wizard configuration\n\nStep: Test Step 1: Create 8 offline ports Port_1, Port_2;\nTest Step 2: Create BGP VPLS wizard;\nTest Step 3: Configure client-side ports and provider-side ports;\nTest Step 4: Configure provider-side router;\nTest Step 5: Configure VPLS;\nTest Step 6: Configure Host;\nTest Step 7: Configure traffic;\nTest Step 8: Generate BGP VPLS wizard configuration;\n\nCriteria: Expected Result 1: Step 8 BGP VPLS wizard configuration generated without exceptions;\n\nCreated by: Tester-002\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\n# locations_1 = ['//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16']\n# locations_2 = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6']\n\nlocations_1 = locations[0]\nlocations_2 = locations[1]\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations_1], Debug=True)\n    Port_provider = reserve_port(Locations=[locations_2], Debug=True)\n\n    # 创建BGP VPLS向导\n\n    wizard = create_mpls_wizard(Type='bgp_vpls', enable_vpls_scalability=True)\n\n    # 配置客户端侧端口和提供商侧端口\n    for port in Port_customer:\n        edit_mpls_customer_port(Wizard=wizard, Port=port, EnableSubInterface=True, SubInterfaceCount=250,\n                                VlanId=1000)\n    for port in Port_provider:\n        edit_mpls_provider_port(Wizard=wizard, Port=port, DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='1.1.1.1',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=False,\n                                               PeRouterIdStart='2.1.1.1',\n                                               PeRouterIdStep='0.0.0.1')\n    edit_mpls_provider_router_isis(Wizard=wizard,\n                                   UseSrcMacAsSystemId=False,\n                                   SystemId='22:11:11:11:11:11',\n                                   SystemIdStep='00:00:00:00:00:02',\n                                   Level='L1L2',\n                                   NetworkType='P2P',\n                                   RouterPriority=10,\n                                   MetricMode='WIDE',\n                                   AuthenticationMode='SIMPLE',\n                                   Password='passwd',\n                                   AreaId=20,\n                                   EnableGracefulRestart=True,\n                                   MultiTopologyId='IPV4',\n                                   EnableBfd=True,\n                                   HelloPadding=False,\n                                   Algorithm=30,\n                                   SidLabelBase=40,\n                                   SidLabelRange=50,\n                                   NodeSidIndex=60,\n                                   NodeSidIdnexStep=2)\n\n    edit_mpls_provider_router_ldp(Wizard=wizard,\n                                  HelloType='TARGETED',\n                                  TransportAddressTlvMode='ROUTER_ID',\n                                  LabelAdvertisementMode='DOD',\n                                  EgressLabelMode='IMPLICIT',\n                                  MinLabel=20,\n                                  AuthenticationMode='MD5',\n                                  Password='test')\n    # 配置VPLS\n\n    edit_bgp_vpls(Wizard=wizard,\n                  NumberOfVplss=10,\n                  RdAssignment='Manual',\n                  RouteTargetStart='2:0',\n                  RouteTargetStep='3:0',\n                  Mtu=1518,\n                  VplsAssignment='Sequential',\n                  CustomerRdStart='4:0',\n                  CustomerVeIdStart=20,\n                  CustomerStepPerVplsEnabled=True,\n                  CustomerRdStepPerVpls='5:0',\n                  CustomerStepPerCeEnabled=True,\n                  CustomerRdStepPerCe='6:0',\n                  CustomerVeIdStepPerCe=30,\n                  CustomerOverlapEnabled=True,\n                  ProviderDistributionSelector='PEsPerVPLS',\n                  ProviderDistributionSelectorCount=40,\n                  ProviderMeshed=False,\n                  ProviderRdStart='7:0',\n                  ProviderVeIdStart=50,\n                  ProviderStepPerVplsEnabled=True,\n                  ProviderRdStepPerVpls='8:0',\n                  ProviderStepPerCeEnabled=True,\n                  ProviderRdStepPerCe='9:0',\n                  ProviderVeIdStepPerCe=60,\n                  ProviderOverlapEnabled=True)\n\n    # 配置Host\n\n    edit_mpls_host(Wizard=wizard,\n                   HostAssignmentVpls='HostsOrMacsPerVpls',\n                   HostsPerVpls=32,\n                   CustomerHostPercent=50,\n                   ProviderHostPercent=50)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            TrafficLoadPercentProvider=10)\n\n    # 生成BGP VPLS向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_mpls_wizard:测试仪表创建MPLS向导",
      "edit_mpls_customer_port:配置MPLS向导客户侧端口",
      "edit_mpls_host:配置MPLS向导Host参数",
      "edit_mpls_provider_port:配置MPLS向导提供商侧端口",
      "edit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由",
      "edit_mpls_provider_router_isis:配置MPLS提供商侧路由路由器OSPF协议",
      "edit_mpls_provider_router_ldp:配置MPLS提供商侧路由路由器LDP协议",
      "edit_traffic_parameters:配置MPLS流量",
      "expand_mpls_wizard:生成测试仪表MPLS向导配置"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type.\",\n  \"Subtask 2\": \"Reserve two ports: one for customer side (Port_1) and one for provider side (Port_2).\",\n  \"Subtask 3\": \"Create BGP VPLS wizard with type 'bgp_vpls' and enable VPLS scalability.\",\n  \"Subtask 4\": \"Configure customer-side port(s) with sub-interfaces enabled, sub-interface count set to 250, and VLAN ID 1000.\",\n  \"Subtask 5\": \"Configure provider-side port(s) with DUT IPv4 address '50.1.1.1' and prefix length 24.\",\n  \"Subtask 6\": \"Configure provider router basic parameters: DUT router ID '1.1.1.1', AS number 100, IGP protocol ISIS, MPLS protocol LDP, PE router ID start '2.1.1.1'.\",\n  \"Subtask 7\": \"Configure provider router ISIS parameters: system ID '22:11:11:11:11:11', level L1L2, network type P2P, authentication mode SIMPLE with password 'passwd'.\",\n  \"Subtask 8\": \"Configure provider router LDP parameters: hello type TARGETED, authentication mode MD5 with password 'test', label advertisement mode DOD.\",\n  \"Subtask 9\": \"Configure VPLS parameters: number of VPLSs 10, RD assignment Manual, route target start '2:0', MTU 1518, VPLS assignment Sequential.\",\n  \"Subtask 10\": \"Configure host parameters: host assignment 'HostsOrMacsPerVpls', hosts per VPLS 32, customer host percentage 50, provider host percentage 50.\",\n  \"Subtask 11\": \"Configure traffic parameters: traffic flow 'CustomerProviderBoth', stream block grouping 'Aggregate', provider traffic load 10%.\",\n  \"Subtask 12\": \"Generate BGP VPLS wizard configuration by expanding the wizard.\",\n  \"Subtask 13\": \"Save the generated configuration to a file.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify normal generation of BGP VPLS wizard configuration\n\nStep: Test Step 1: Create 8 offline ports Port_1, Port_2;\nTest Step 2: Create BGP VPLS wizard;\nTest Step 3: Configure client-side ports and provider-side ports;\nTest Step 4: Configure provider-side router;\nTest Step 5: Configure VPLS;\nTest Step 6: Configure Host;\nTest Step 7: Configure traffic;\nTest Step 8: Generate BGP VPLS wizard configuration;\n\nCriteria: Expected Result 1: Step 8 BGP VPLS wizard configuration generated without exceptions;\n\nCreated by: Tester-002\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\n# locations_1 = ['//10.0.11.191/1/13', '//10.0.11.191/1/14', '//10.0.11.191/1/15', '//10.0.11.191/1/16']\n# locations_2 = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6']\n\nlocations_1 = locations[0]\nlocations_2 = locations[1]\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations_1], Debug=True)\n    Port_provider = reserve_port(Locations=[locations_2], Debug=True)\n\n    # 创建BGP VPLS向导\n\n    wizard = create_mpls_wizard(Type='bgp_vpls', enable_vpls_scalability=True)\n\n    # 配置客户端侧端口和提供商侧端口\n    for port in Port_customer:\n        edit_mpls_customer_port(Wizard=wizard, Port=port, EnableSubInterface=True, SubInterfaceCount=250,\n                                VlanId=1000)\n    for port in Port_provider:\n        edit_mpls_provider_port(Wizard=wizard, Port=port, DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='1.1.1.1',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=False,\n                                               PeRouterIdStart='2.1.1.1',\n                                               PeRouterIdStep='0.0.0.1')\n    edit_mpls_provider_router_isis(Wizard=wizard,\n                                   UseSrcMacAsSystemId=False,\n                                   SystemId='22:11:11:11:11:11',\n                                   SystemIdStep='00:00:00:00:00:02',\n                                   Level='L1L2',\n                                   NetworkType='P2P',\n                                   RouterPriority=10,\n                                   MetricMode='WIDE',\n                                   AuthenticationMode='SIMPLE',\n                                   Password='passwd',\n                                   AreaId=20,\n                                   EnableGracefulRestart=True,\n                                   MultiTopologyId='IPV4',\n                                   EnableBfd=True,\n                                   HelloPadding=False,\n                                   Algorithm=30,\n                                   SidLabelBase=40,\n                                   SidLabelRange=50,\n                                   NodeSidIndex=60,\n                                   NodeSidIdnexStep=2)\n\n    edit_mpls_provider_router_ldp(Wizard=wizard,\n                                  HelloType='TARGETED',\n                                  TransportAddressTlvMode='ROUTER_ID',\n                                  LabelAdvertisementMode='DOD',\n                                  EgressLabelMode='IMPLICIT',\n                                  MinLabel=20,\n                                  AuthenticationMode='MD5',\n                                  Password='test')\n    # 配置VPLS\n\n    edit_bgp_vpls(Wizard=wizard,\n                  NumberOfVplss=10,\n                  RdAssignment='Manual',\n                  RouteTargetStart='2:0',\n                  RouteTargetStep='3:0',\n                  Mtu=1518,\n                  VplsAssignment='Sequential',\n                  CustomerRdStart='4:0',\n                  CustomerVeIdStart=20,\n                  CustomerStepPerVplsEnabled=True,\n                  CustomerRdStepPerVpls='5:0',\n                  CustomerStepPerCeEnabled=True,\n                  CustomerRdStepPerCe='6:0',\n                  CustomerVeIdStepPerCe=30,\n                  CustomerOverlapEnabled=True,\n                  ProviderDistributionSelector='PEsPerVPLS',\n                  ProviderDistributionSelectorCount=40,\n                  ProviderMeshed=False,\n                  ProviderRdStart='7:0',\n                  ProviderVeIdStart=50,\n                  ProviderStepPerVplsEnabled=True,\n                  ProviderRdStepPerVpls='8:0',\n                  ProviderStepPerCeEnabled=True,\n                  ProviderRdStepPerCe='9:0',\n                  ProviderVeIdStepPerCe=60,\n                  ProviderOverlapEnabled=True)\n\n    # 配置Host\n\n    edit_mpls_host(Wizard=wizard,\n                   HostAssignmentVpls='HostsOrMacsPerVpls',\n                   HostsPerVpls=32,\n                   CustomerHostPercent=50,\n                   ProviderHostPercent=50)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            TrafficLoadPercentProvider=10)\n\n    # 生成BGP VPLS向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_mpls_wizard:测试仪表创建MPLS向导;\nedit_mpls_customer_port:配置MPLS向导客户侧端口;\nedit_mpls_host:配置MPLS向导Host参数;\nedit_mpls_provider_port:配置MPLS向导提供商侧端口;\nedit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由;\nedit_mpls_provider_router_isis:配置MPLS提供商侧路由路由器OSPF协议;\nedit_mpls_provider_router_ldp:配置MPLS提供商侧路由路由器LDP协议;\nedit_traffic_parameters:配置MPLS流量;\nexpand_mpls_wizard:生成测试仪表MPLS向导配置\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/Dot1ag/Dot1ag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查802.1ag协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建802.1ag协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================  \nObjective    :   Purpose: Verify the 802.1ag protocol bound flow transmission is normal  \n\nStep         :   Step 1: Reserve two loopback ports Port_1 and Port_2;  \n                 Step 2: Create 802.1ag protocols on both ports respectively;  \n                 Step 3: Start the protocols and check protocol statistics;  \n\nCriteria     :   Expected Result 1: In Step 6, all traffic sent/received packets are equal;  \n\nCreated by   :   Tester-003  \n\nBugs         :   None  \n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface_stack(Interfaces=interfaces_1)\n    edit_interface_stack(Interfaces=interfaces_2)\n\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建802.1ag协议会话\n\n    session_1 = create_dot1ag(Port=Port_UP)\n    session_2 = create_dot1ag(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建802.1ag ma\n    config_ma = create_dot1ag_ma()\n\n    # 创建802.1ag mp\n    create_dot1ag_mp(Session=[session_1, session_2], SelectMa=config_ma)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Dot1agMpStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待802.1ag协议会话达到RUNNING状态\n\n    wait_dot1ag_state(Sessions=[session_1, session_2], State='RUNNING')\n\n    time.sleep(5)\n\n    # 获取802.1ag会话1统计\n    import pandas\n    result = get_dot1ag_mp_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dot1ag_mp_stats(Session=session_1)\n    print(result)\n    result = get_dot1ag_mp_stats(Session=session_2)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "edit_interface_stack:修改测试仪表接口的结构",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports (Port_UP and Port_Down) using provided locations.\",\n  \"Subtask 3\": \"Create network interfaces on both reserved ports.\",\n  \"Subtask 4\": \"Modify interface stack configurations for both interfaces.\",\n  \"Subtask 5\": \"Configure IPv4 parameters (address and gateway) for each interface.\",\n  \"Subtask 6\": \"Create 802.1ag protocol sessions on both ports.\",\n  \"Subtask 7\": \"Bind each 802.1ag session to its corresponding network interface.\",\n  \"Subtask 8\": \"Create an 802.1ag Maintenance Association (MA) configuration.\",\n  \"Subtask 9\": \"Create Maintenance Points (MPs) for both sessions and associate them with the MA.\",\n  \"Subtask 10\": \"Subscribe to Dot1agMpStats for protocol statistics monitoring.\",\n  \"Subtask 11\": \"Save the current test configuration to a file.\",\n  \"Subtask 12\": \"Start all configured protocols.\",\n  \"Subtask 13\": \"Wait until both 802.1ag sessions reach RUNNING state.\",\n  \"Subtask 14\": \"Allow 5 seconds for protocol traffic transmission.\",\n  \"Subtask 15\": \"Retrieve and analyze Dot1agMpStats for both sessions.\",\n  \"Subtask 16\": \"Verify that sent and received packet counts match for all traffic flows.\",\n  \"Subtask 17\": \"Stop all running protocols.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================  \nObjective    :   Purpose: Verify the 802.1ag protocol bound flow transmission is normal  \n\nStep         :   Step 1: Reserve two loopback ports Port_1 and Port_2;  \n                 Step 2: Create 802.1ag protocols on both ports respectively;  \n                 Step 3: Start the protocols and check protocol statistics;  \n\nCriteria     :   Expected Result 1: In Step 6, all traffic sent/received packets are equal;  \n\nCreated by   :   Tester-003  \n\nBugs         :   None  \n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface_stack(Interfaces=interfaces_1)\n    edit_interface_stack(Interfaces=interfaces_2)\n\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建802.1ag协议会话\n\n    session_1 = create_dot1ag(Port=Port_UP)\n    session_2 = create_dot1ag(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建802.1ag ma\n    config_ma = create_dot1ag_ma()\n\n    # 创建802.1ag mp\n    create_dot1ag_mp(Session=[session_1, session_2], SelectMa=config_ma)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Dot1agMpStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待802.1ag协议会话达到RUNNING状态\n\n    wait_dot1ag_state(Sessions=[session_1, session_2], State='RUNNING')\n\n    time.sleep(5)\n\n    # 获取802.1ag会话1统计\n    import pandas\n    result = get_dot1ag_mp_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dot1ag_mp_stats(Session=session_1)\n    print(result)\n    result = get_dot1ag_mp_stats(Session=session_2)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nedit_interface_stack:修改测试仪表接口的结构;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/OpenFlow/openflow.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查openflow统计获取正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建switch / controller;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    : Check that openflow statistics are obtained correctly\n\nStep         : Step 1: Reserve two loopback ports, Port_1 and Port_2;\n              : Step 2: Create a switch and a controller on each port respectively;\n              : Step 3: Start the protocol and view protocol statistics;\n\nCriteria     : Expected Result 1: Statistics are obtained correctly in Step 3;\n\nCreated by   : Tester-002\n\nBugs         : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    # 创建协议会话\n\n    switch = create_openflow_switch(Port=Port_UP)\n    controller = create_openflow_controller(Port=Port_Down)\n\n    select_interface(Session=switch, Interface=interfaces_1)\n    select_interface(Session=controller, Interface=interfaces_2)\n\n    # 创建desc\n    controller_desc = edit_controller_desc(Sessions=switch)\n    switch_desc = edit_switch_desc(Sessions=controller)\n\n    # 订阅统计\n\n    subscribe_result(Types=['OfpControllerStats', 'OfpSwitchDescStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n    time.sleep(5)\n\n    # 获取统计\n    result = get_openflow_controller_statistic(Controller=controller)\n    print(result)\n\n    result = get_openflow_switch_statistic(Switch=switch_desc)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with product specification 'DarYu' using init_tester function.\",\n  \"Subtask 2\": \"Reserve two ports specified by locations using reserve_port function, assigning to Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create network interfaces on Port_UP and Port_Down using create_interface function.\",\n  \"Subtask 4\": \"Create OpenFlow switch session on Port_UP and OpenFlow controller session on Port_Down using create_openflow_switch and create_openflow_controller functions.\",\n  \"Subtask 5\": \"Bind created interfaces to respective switch and controller sessions using select_interface function.\",\n  \"Subtask 6\": \"Edit controller description in switch session and switch description in controller session using edit_controller_desc and edit_switch_desc functions.\",\n  \"Subtask 7\": \"Subscribe to OfpControllerStats and OfpSwitchDescStats statistics using subscribe_result function.\",\n  \"Subtask 8\": \"Save current configuration to file using save_case function with generated path.\",\n  \"Subtask 9\": \"Start protocol operation using start_protocol function and wait 5 seconds for stabilization.\",\n  \"Subtask 10\": \"Retrieve OpenFlow controller statistics from controller session using get_openflow_controller_statistic function and output results.\",\n  \"Subtask 11\": \"Retrieve OpenFlow switch statistics from switch description object using get_openflow_switch_statistic function and output results.\",\n  \"Subtask 12\": \"Stop protocol operation using stop_protocol function.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    : Check that openflow statistics are obtained correctly\n\nStep         : Step 1: Reserve two loopback ports, Port_1 and Port_2;\n              : Step 2: Create a switch and a controller on each port respectively;\n              : Step 3: Start the protocol and view protocol statistics;\n\nCriteria     : Expected Result 1: Statistics are obtained correctly in Step 3;\n\nCreated by   : Tester-002\n\nBugs         : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    # 创建协议会话\n\n    switch = create_openflow_switch(Port=Port_UP)\n    controller = create_openflow_controller(Port=Port_Down)\n\n    select_interface(Session=switch, Interface=interfaces_1)\n    select_interface(Session=controller, Interface=interfaces_2)\n\n    # 创建desc\n    controller_desc = edit_controller_desc(Sessions=switch)\n    switch_desc = edit_switch_desc(Sessions=controller)\n\n    # 订阅统计\n\n    subscribe_result(Types=['OfpControllerStats', 'OfpSwitchDescStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n    time.sleep(5)\n\n    # 获取统计\n    result = get_openflow_controller_statistic(Controller=controller)\n    print(result)\n\n    result = get_openflow_switch_statistic(Switch=switch_desc)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/L2TP/L2TP.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查L2TP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建L2TP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Objective: Verify that bound L2TP protocol streams are transmitted correctly\n\nStep        :   Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                Test Step 2: Create L2TP protocols on both ports respectively and configure routing;\n                Test Step 3: Create bound streams;\n                Test Step 4: Subscribe to StreamBlockStats statistics;\n                Test Step 5: Transmit all streams and wait for a period;\n                Test Step 6: Stop all streams and examine StreamBlockStats statistics;\n\nCriteria    :   Expected Result 1: In step 6, transmitted and received packet counts are equal for all streams;\n\nCreated by  :   Tester-002\n\nBugs        :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    \n    edit_interface_stack(Interfaces=interfaces_1, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    edit_interface_stack(Interfaces=interfaces_2, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    \n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Level=0, Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Level=0, Address='1.1.1.2', Gateway='1.1.1.1')\n\n\n    # 创建L2TP协议会话\n\n    l2tp_1 = create_l2tp(Port=Port_UP)\n    l2tp_2 = create_l2tp(Port=Port_Down, EmulationMode='LNS')\n\n    select_interface(Session=l2tp_1, Interface=interfaces_1)\n    select_interface(Session=l2tp_2, Interface=interfaces_2)\n\n    pppoe_1 = create_pppoe(Port=Port_UP, EmulationMode='CLIENT')\n    pppoe_2 = create_pppoe(Port=Port_Down, EmulationMode='SERVER')\n    pppoe_1.EmulationMode = 'PPPOL2TP'\n    pppoe_2.EmulationMode = 'PPPOL2TP'\n    select_interface(Session=pppoe_1, Interface=interfaces_1)\n    select_interface(Session=pppoe_2, Interface=interfaces_2)\n\n\n    # 获取接口绑定流端点对象\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    # 创建接口绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['L2tpPortStatistic', 'L2tpBlockStatistic', 'L2tpSessionStatistic', 'L2tpTunnelStatistic', 'PppoeClientStatistic', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PPPoE协议会话达到CONNECTED状态\n\n    wait_l2tp_state(Sessions=[l2tp_1, l2tp_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取L2TP会话1统计\n    import pandas\n    result = get_l2tp_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_l2tp_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_l2tp_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_session_statistic(Session=l2tp_1, NodeIndexInBlock=1)\n    print(result)\n    result = get_l2tp_session_statistic(Session=l2tp_2, NodeIndexInBlock=1)\n    print(result)\n\n    result = get_l2tp_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_block_statistic(Session=l2tp_1)\n    print(result)\n    result = get_l2tp_block_statistic(Session=l2tp_2)\n    print(result)\n\n    result = get_l2tp_tunnel_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_tunnel_statistic(Session=l2tp_1, NodeIndexInBlock=1)\n    print(result)\n    result = get_l2tp_tunnel_statistic(Session=l2tp_2, NodeIndexInBlock=1)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "edit_interface_stack:修改测试仪表接口的结构",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_l2tp:创建L2tp协议会话对象",
      "get_l2tp_block_statistic:获取L2tp Block Statistic统计结果",
      "get_l2tp_port_statistic:获取L2tp Session Statistic统计结果",
      "get_l2tp_session_statistic:获取L2tp Session Statistic统计结果",
      "get_l2tp_tunnel_statistic:获取L2tp Tunnel Statistic统计结果",
      "wait_l2tp_state:等待L2tp协议会话达到指定状态",
      "create_pppoe:创建PPPoE协议会话对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two test ports (Port_1 and Port_2) using reserve_port API.\",\n  \"Subtask 2\": \"Create interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 3\": \"Configure interface stacks with Ethernet, L2TP, and IPv4 layers using edit_interface_stack API, setting IPv4 as top layer.\",\n  \"Subtask 4\": \"Set IPv4 addresses and gateways for both interfaces using edit_interface API (e.g., Port_1: 1.1.1.1/1.1.1.2, Port_2: 1.1.1.2/1.1.1.1).\",\n  \"Subtask 5\": \"Create L2TP sessions on both ports using create_l2tp API (Port_1 as LAC, Port_2 as LNS) and bind to interfaces using select_interface API.\",\n  \"Subtask 6\": \"Obtain L2TP layer objects from interfaces using get_layer_from_interfaces API for stream creation.\",\n  \"Subtask 7\": \"Create bidirectional binding streams between L2TP layers using add_stream API with Bidirection=True.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 9\": \"Start L2TP protocols using start_protocol API and wait for sessions to reach connected state using wait_l2tp_state API.\",\n  \"Subtask 10\": \"Start stream transmission using start_stream API, wait 10 seconds, then stop streams using stop_stream API.\",\n  \"Subtask 11\": \"Stop L2TP protocols using stop_protocol API.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats for each stream using get_streamblock_statistic API.\",\n  \"Subtask 13\": \"Verify transmitted packet count (TxStreamFrames) equals received packet count (RxStreamFrames) for all streams.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Objective: Verify that bound L2TP protocol streams are transmitted correctly\n\nStep        :   Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                Test Step 2: Create L2TP protocols on both ports respectively and configure routing;\n                Test Step 3: Create bound streams;\n                Test Step 4: Subscribe to StreamBlockStats statistics;\n                Test Step 5: Transmit all streams and wait for a period;\n                Test Step 6: Stop all streams and examine StreamBlockStats statistics;\n\nCriteria    :   Expected Result 1: In step 6, transmitted and received packet counts are equal for all streams;\n\nCreated by  :   Tester-002\n\nBugs        :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    \n    edit_interface_stack(Interfaces=interfaces_1, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    edit_interface_stack(Interfaces=interfaces_2, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    \n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Level=0, Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Level=0, Address='1.1.1.2', Gateway='1.1.1.1')\n\n\n    # 创建L2TP协议会话\n\n    l2tp_1 = create_l2tp(Port=Port_UP)\n    l2tp_2 = create_l2tp(Port=Port_Down, EmulationMode='LNS')\n\n    select_interface(Session=l2tp_1, Interface=interfaces_1)\n    select_interface(Session=l2tp_2, Interface=interfaces_2)\n\n    pppoe_1 = create_pppoe(Port=Port_UP, EmulationMode='CLIENT')\n    pppoe_2 = create_pppoe(Port=Port_Down, EmulationMode='SERVER')\n    pppoe_1.EmulationMode = 'PPPOL2TP'\n    pppoe_2.EmulationMode = 'PPPOL2TP'\n    select_interface(Session=pppoe_1, Interface=interfaces_1)\n    select_interface(Session=pppoe_2, Interface=interfaces_2)\n\n\n    # 获取接口绑定流端点对象\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    # 创建接口绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['L2tpPortStatistic', 'L2tpBlockStatistic', 'L2tpSessionStatistic', 'L2tpTunnelStatistic', 'PppoeClientStatistic', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PPPoE协议会话达到CONNECTED状态\n\n    wait_l2tp_state(Sessions=[l2tp_1, l2tp_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取L2TP会话1统计\n    import pandas\n    result = get_l2tp_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_l2tp_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_l2tp_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_session_statistic(Session=l2tp_1, NodeIndexInBlock=1)\n    print(result)\n    result = get_l2tp_session_statistic(Session=l2tp_2, NodeIndexInBlock=1)\n    print(result)\n\n    result = get_l2tp_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_block_statistic(Session=l2tp_1)\n    print(result)\n    result = get_l2tp_block_statistic(Session=l2tp_2)\n    print(result)\n\n    result = get_l2tp_tunnel_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_l2tp_tunnel_statistic(Session=l2tp_1, NodeIndexInBlock=1)\n    print(result)\n    result = get_l2tp_tunnel_statistic(Session=l2tp_2, NodeIndexInBlock=1)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nedit_interface_stack:修改测试仪表接口的结构;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_l2tp:创建L2tp协议会话对象;\nget_l2tp_block_statistic:获取L2tp Block Statistic统计结果;\nget_l2tp_port_statistic:获取L2tp Session Statistic统计结果;\nget_l2tp_session_statistic:获取L2tp Session Statistic统计结果;\nget_l2tp_tunnel_statistic:获取L2tp Tunnel Statistic统计结果;\nwait_l2tp_state:等待L2tp协议会话达到指定状态;\ncreate_pppoe:创建PPPoE协议会话对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/Dot3ah/Dot3ah.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查802.3ah协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建802.3ah协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Verify normal transmission of 802.3ah protocol binding flow\n\nStep: Test Step 1: Reserve two self-loop ports Port_1 and Port_2;\nTest Step 2: Create 802.3ah protocol on both ports separately;\nTest Step 3: Start the protocol and check protocol statistics;\n\nCriteria: Expected Result 1: All traffic packet reception and transmission are equal in Step 6;\n\nCreated by: Tester-003\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/9', '//10.0.11.191/1/10'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface_stack(Interfaces=interfaces_1)\n    edit_interface_stack(Interfaces=interfaces_2)\n\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建802.3ah协议会话\n\n    session_1 = create_dot3ah(Port=Port_UP)\n    session_2 = create_dot3ah(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n\n    # 订阅统计\n\n    subscribe_result(Types=['Dot3ahErrorEventStats', 'Dot3ahSessionStatistic'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待802.3ah协议会话达到COMPLETED状态\n\n    wait_dot3ah_state(Sessions=[session_1, session_2], State='COMPLETED')\n\n    time.sleep(5)\n\n    # 获取802.3ah会话1统计\n    import pandas\n    result = get_dot3ah_error_event_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dot3ah_error_event_stats(Session=session_1)\n    print(result)\n    result = get_dot3ah_error_event_stats(Session=session_2)\n    print(result)\n\n    result = get_dot3ah_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dot3ah_session_statistic(Session=session_1)\n    print(result)\n    result = get_dot3ah_session_statistic(Session=session_2)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "edit_interface_stack:修改测试仪表接口的结构",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with specified product type (default 'DarYu').\",\n  \"Subtask 2\": \"Reserve two physical ports using provided locations (e.g. '//10.0.11.191/1/9' and '//10.0.11.191/1/10').\",\n  \"Subtask 3\": \"Create network interfaces on both reserved ports.\",\n  \"Subtask 4\": \"Configure protocol stacks for both interfaces using edit_interface_stack.\",\n  \"Subtask 5\": \"Set IPv4 parameters for both interfaces (address and gateway in reciprocal configuration).\",\n  \"Subtask 6\": \"Create 802.3ah protocol sessions on each reserved port.\",\n  \"Subtask 7\": \"Bind each protocol session to its corresponding network interface.\",\n  \"Subtask 8\": \"Subscribe to Dot3ahErrorEventStats and Dot3ahSessionStatistic metrics.\",\n  \"Subtask 9\": \"Save current configuration to .xcfg file in designated path.\",\n  \"Subtask 10\": \"Start all configured protocols using start_protocol API.\",\n  \"Subtask 11\": \"Wait until both 802.3ah sessions reach 'COMPLETED' state.\",\n  \"Subtask 12\": \"Retrieve and validate Dot3ahErrorEventStats for both individual sessions and aggregate.\",\n  \"Subtask 13\": \"Retrieve and validate Dot3ahSessionStatistic for both individual sessions and aggregate.\",\n  \"Subtask 14\": \"Verify packet transmission count equals reception count in all session statistics.\",\n  \"Subtask 15\": \"Stop all running protocols using stop_protocol API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Verify normal transmission of 802.3ah protocol binding flow\n\nStep: Test Step 1: Reserve two self-loop ports Port_1 and Port_2;\nTest Step 2: Create 802.3ah protocol on both ports separately;\nTest Step 3: Start the protocol and check protocol statistics;\n\nCriteria: Expected Result 1: All traffic packet reception and transmission are equal in Step 6;\n\nCreated by: Tester-003\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/9', '//10.0.11.191/1/10'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface_stack(Interfaces=interfaces_1)\n    edit_interface_stack(Interfaces=interfaces_2)\n\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建802.3ah协议会话\n\n    session_1 = create_dot3ah(Port=Port_UP)\n    session_2 = create_dot3ah(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n\n    # 订阅统计\n\n    subscribe_result(Types=['Dot3ahErrorEventStats', 'Dot3ahSessionStatistic'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待802.3ah协议会话达到COMPLETED状态\n\n    wait_dot3ah_state(Sessions=[session_1, session_2], State='COMPLETED')\n\n    time.sleep(5)\n\n    # 获取802.3ah会话1统计\n    import pandas\n    result = get_dot3ah_error_event_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dot3ah_error_event_stats(Session=session_1)\n    print(result)\n    result = get_dot3ah_error_event_stats(Session=session_2)\n    print(result)\n\n    result = get_dot3ah_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dot3ah_session_statistic(Session=session_1)\n    print(result)\n    result = get_dot3ah_session_statistic(Session=session_2)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nedit_interface_stack:修改测试仪表接口的结构;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/IEEE8021As/IEEE8021As.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查IEEE802.1As协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建Ieee802.1As协议，并且绑定接口;\n                   测试步骤3: 订阅Ieee802.1As相关统计;\n                   测试步骤4: 启动会话，等待一段时间;\n                   测试步骤5: 查看统计信息;\n\n Criteria    \t:   预期结果1: 步骤5中所有统计结果均有数据;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Check that the IEEE802.1As protocol bound stream is transmitted normally\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create IEEE802.1As protocols on both ports respectively and bind the interfaces;\n                   Step 3: Subscribe to IEEE802.1As related statistics;\n                   Step 4: Start the session and wait for a period of time;\n                   Step 5: View statistical information;\n\nCriteria    \t:   Expected Result 1: All statistical results in Step 5 contain data;\n\nCreated by   \t:   Tester-001\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IEEE802.1As协议会话\n    session_1 = create_ieee8021as(Port=Port_UP)\n    session_2 = create_ieee8021as(Port=Port_Down)\n\n    # IEEE802.1As协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 订阅统计\n    subscribe_result(\n        Types=['Ieee8021asClockStatistic', 'Ieee8021asClockSyncStatistic', 'Ieee8021asMessageRateStatistic',\n               'Ieee8021asParentClockInfoStatistic', 'Ieee8021asStateSummaryStatistic',\n               'Ieee8021asTimePropertiesStatistic'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n    start_protocol()\n\n    # 等待IEEE802.1As协议会话达到RUNNING状态\n    time.sleep(3)\n    wait_ieee8021as_state(Sessions=[session_1, session_2])\n    wait_ieee8021as_clock_state(Sessions=[session_1, session_2])\n\n    time.sleep(10)\n\n    import pandas\n\n    result = get_ieee8021as_clock_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_clock_sync_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_message_rate_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_parent_clock_info_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_state_summary_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_time_properties_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    stop_protocol()\n    time.sleep(3)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester API with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using reserve_port API with provided locations.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 4\": \"Configure IPv4 parameters for both interfaces using edit_interface API: set Port_1 interface address to 192.168.1.2/gateway 192.168.1.3 and Port_2 interface address to 192.168.1.3/gateway 192.168.1.2.\",\n  \"Subtask 5\": \"Create IEEE802.1As protocol sessions on both ports using create_ieee8021as API.\",\n  \"Subtask 6\": \"Bind each IEEE802.1As session to its respective interface using select_interface API.\",\n  \"Subtask 7\": \"Subscribe to IEEE802.1As statistics using subscribe_result API for all required statistic types: Clock, ClockSync, MessageRate, ParentClockInfo, StateSummary, and TimeProperties.\",\n  \"Subtask 8\": \"Save current configuration to file using save_case API with generated file path.\",\n  \"Subtask 9\": \"Start protocol sessions using start_protocol API.\",\n  \"Subtask 10\": \"Wait for IEEE802.1As sessions to reach RUNNING state and clock synchronization state using wait functions.\",\n  \"Subtask 11\": \"Wait additional 10 seconds for statistics accumulation.\",\n  \"Subtask 12\": \"Retrieve and display IEEE802.1As Clock statistics data.\",\n  \"Subtask 13\": \"Retrieve and display IEEE802.1As Clock Sync statistics data.\",\n  \"Subtask 14\": \"Retrieve and display IEEE802.1As Message Rate statistics data.\",\n  \"Subtask 15\": \"Retrieve and display IEEE802.1As Parent Clock Info statistics data.\",\n  \"Subtask 16\": \"Retrieve and display IEEE802.1As State Summary statistics data.\",\n  \"Subtask 17\": \"Retrieve and display IEEE802.1As Time Properties statistics data.\",\n  \"Subtask 18\": \"Verify all retrieved statistics contain non-empty data entries.\",\n  \"Subtask 19\": \"Stop protocol sessions using stop_protocol API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Check that the IEEE802.1As protocol bound stream is transmitted normally\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create IEEE802.1As protocols on both ports respectively and bind the interfaces;\n                   Step 3: Subscribe to IEEE802.1As related statistics;\n                   Step 4: Start the session and wait for a period of time;\n                   Step 5: View statistical information;\n\nCriteria    \t:   Expected Result 1: All statistical results in Step 5 contain data;\n\nCreated by   \t:   Tester-001\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IEEE802.1As协议会话\n    session_1 = create_ieee8021as(Port=Port_UP)\n    session_2 = create_ieee8021as(Port=Port_Down)\n\n    # IEEE802.1As协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 订阅统计\n    subscribe_result(\n        Types=['Ieee8021asClockStatistic', 'Ieee8021asClockSyncStatistic', 'Ieee8021asMessageRateStatistic',\n               'Ieee8021asParentClockInfoStatistic', 'Ieee8021asStateSummaryStatistic',\n               'Ieee8021asTimePropertiesStatistic'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n    start_protocol()\n\n    # 等待IEEE802.1As协议会话达到RUNNING状态\n    time.sleep(3)\n    wait_ieee8021as_state(Sessions=[session_1, session_2])\n    wait_ieee8021as_clock_state(Sessions=[session_1, session_2])\n\n    time.sleep(10)\n\n    import pandas\n\n    result = get_ieee8021as_clock_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_clock_sync_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_message_rate_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_parent_clock_info_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_state_summary_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    result = get_ieee8021as_time_properties_statistic()\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    stop_protocol()\n    time.sleep(3)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/Lacp/lacp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查lacp统计获取正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建lacp;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Check that the LACP statistics are obtained correctly\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create LACP on each port respectively;\n      Step 3: Start the protocol and check the protocol statistics;\n\nCriteria: Expected Result 1: In step 3, the statistics are obtained correctly;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建协议会话\n\n    lacp_1 = create_lacp(Ports=Port_UP)\n    lacp_2 = create_lacp(Ports=Port_Down)\n\n    # 订阅统计\n\n    subscribe_result(Types=['LacpPortStats', 'LagPortStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_lacp_port(Ports=[Port_UP, Port_Down])\n    time.sleep(5)\n\n    # 获取统计\n    result = get_lacp_port_statistic(Port=Port_UP)\n    print(result)\n\n    result = get_lag_port_statistic(Lacp=lacp_1)\n    print(result)\n\n    stop_lacp_port(Ports=[Port_UP, Port_Down])\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform specified in the Product parameter.\",\n  \"Subtask 2\": \"Reserve two physical ports using the provided locations for testing.\",\n  \"Subtask 3\": \"Create LACP protocol sessions on each reserved port.\",\n  \"Subtask 4\": \"Subscribe to both LACP port statistics and LAG port statistics collection.\",\n  \"Subtask 5\": \"Save the current configuration state to a file in xcfg format.\",\n  \"Subtask 6\": \"Activate LACP protocol on both reserved ports simultaneously.\",\n  \"Subtask 7\": \"Wait 5 seconds for protocol negotiation and statistics generation.\",\n  \"Subtask 8\": \"Retrieve and display LACP port statistics for the first reserved port.\",\n  \"Subtask 9\": \"Retrieve and display LAG port statistics for the LACP session on the first port.\",\n  \"Subtask 10\": \"Terminate LACP protocol on both ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Check that the LACP statistics are obtained correctly\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create LACP on each port respectively;\n      Step 3: Start the protocol and check the protocol statistics;\n\nCriteria: Expected Result 1: In step 3, the statistics are obtained correctly;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建协议会话\n\n    lacp_1 = create_lacp(Ports=Port_UP)\n    lacp_2 = create_lacp(Ports=Port_Down)\n\n    # 订阅统计\n\n    subscribe_result(Types=['LacpPortStats', 'LagPortStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_lacp_port(Ports=[Port_UP, Port_Down])\n    time.sleep(5)\n\n    # 获取统计\n    result = get_lacp_port_statistic(Port=Port_UP)\n    print(result)\n\n    result = get_lag_port_statistic(Lacp=lacp_1)\n    print(result)\n\n    stop_lacp_port(Ports=[Port_UP, Port_Down])\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/VXLAN/VXLAN.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查VXLAN协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 创建VXLAN协议及组播组;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     :   Purpose: Verify that the VXLAN protocol bound stream is transmitted correctly\n\nStep          :   Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                   Test Step 2: Create VXLAN protocol and multicast group;\n                   Test Step 3: Create bound traffic;\n                   Test Step 4: Subscribe to StreamBlockStats;\n                   Test Step 5: Transmit all traffic and wait for a period;\n                   Test Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In step 6, all traffic sent and received packets are equal;\n\nCreated by    :   Tester-002\n\nBugs          :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    interfaces_3 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_4 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    edit_interface(Interface=interfaces_3,\n                   Layer='IPv4Layer',\n                   Address='2.2.2.1',\n                   Gateway='2.2.2.2')\n\n    edit_interface(Interface=interfaces_4,\n                   Layer='IPv4Layer',\n                   Address='2.2.2.2',\n                   Gateway='2.2.2.1')\n    # 创建VXLAN协议会话\n\n    session_1 = create_vxlan(Port=Port_UP)\n\n    session_2 = create_vxlan(Port=Port_Down)\n\n    # VXLAN协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建VXLAN Segment\n\n    segment = create_vxlan_segment(StartVni=10)\n\n    # 绑定VXLAN VM\n\n    binding_vxlan_vm(Segments=segment, Interfaces=interfaces_3)\n\n    binding_vxlan_vm(Segments=segment, Interfaces=interfaces_4)\n\n    binding_vxlan_vtep(Vteps=session_1, Interfaces=interfaces_3)\n\n    binding_vxlan_vtep(Vteps=session_2, Interfaces=interfaces_4)\n\n    # 创建VXLAN绑定流\n\n    point_1 = get_vxlan_vm_point(Vxlan=session_1)\n\n    point_2 = get_vxlan_vm_point(Vxlan=session_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['VxlanBindingStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待VXLAN协议会话达到STARTED状态\n\n    wait_vxlan_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    import pandas\n    result = get_vxlan_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    # 获取VXLAN会话1统计\n\n    result = get_vxlan_statistic(Session=session_1)\n    print(result)\n\n    # 获取VXLAN会话2统计\n\n    result = get_vxlan_statistic(Session=session_2)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "binding_vxlan_vm:绑定 Vxlan Vm 对象",
      "binding_vxlan_vtep:绑定 Vxlan Vtep 对象",
      "create_vxlan:创建Vxlan协议会话对象",
      "create_vxlan_segment:创建Vxlan Segment对象",
      "get_vxlan_statistic:获取测试仪表vxlan统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (default 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports using provided locations and assign to Port_UP and Port_Down via reserve_port API.\",\n  \"Subtask 3\": \"Create four interfaces: two on Port_UP (interfaces_1, interfaces_3) and two on Port_Down (interfaces_2, interfaces_4), all with IPv4 layer using create_interface API.\",\n  \"Subtask 4\": \"Configure IPv4 parameters for interfaces_1 (Address='1.1.1.1', Gateway='1.1.1.2'), interfaces_2 (Address='1.1.1.2', Gateway='1.1.1.1'), interfaces_3 (Address='2.2.2.1', Gateway='2.2.2.2'), and interfaces_4 (Address='2.2.2.2', Gateway='2.2.2.1') using edit_interface API.\",\n  \"Subtask 5\": \"Create VXLAN sessions on Port_UP (session_1) and Port_Down (session_2) using create_vxlan API.\",\n  \"Subtask 6\": \"Bind session_1 to interfaces_1 and session_2 to interfaces_2 using select_interface API.\",\n  \"Subtask 7\": \"Create VXLAN segment with StartVni=10 using create_vxlan_segment API.\",\n  \"Subtask 8\": \"Bind VXLAN VM to segment for interfaces_3 and interfaces_4 using binding_vxlan_vm API.\",\n  \"Subtask 9\": \"Bind VXLAN VTEP sessions to interfaces: session_1 to interfaces_3 and session_2 to interfaces_4 using binding_vxlan_vtep API.\",\n  \"Subtask 10\": \"Retrieve VXLAN VM points for session_1 (point_1) and session_2 (point_2) using get_vxlan_vm_point API.\",\n  \"Subtask 11\": \"Create bidirectional binding streams between point_1 and point_2 using add_stream API with Type='binding' and Bidirection=True.\",\n  \"Subtask 12\": \"Subscribe to VxlanBindingStats and StreamBlockStats statistics views using subscribe_result API.\",\n  \"Subtask 13\": \"Save test configuration to file in xcfg directory with same base name as script using save_case API.\",\n  \"Subtask 14\": \"Start VXLAN protocol using start_protocol API and wait until sessions reach STARTED state.\",\n  \"Subtask 15\": \"Wait 5 seconds after protocol startup for stabilization.\",\n  \"Subtask 16\": \"Start all traffic streams using start_stream API and transmit for 10 seconds.\",\n  \"Subtask 17\": \"Stop all traffic streams using stop_stream API.\",\n  \"Subtask 18\": \"Wait 5 seconds after stopping traffic.\",\n  \"Subtask 19\": \"Stop VXLAN protocol using stop_protocol API and wait 3 seconds.\",\n  \"Subtask 20\": \"Retrieve StreamBlockStats for each created stream using get_streamblock_statistic API.\",\n  \"Subtask 21\": \"For each stream, verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames). Mark test as fail if any mismatch occurs.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     :   Purpose: Verify that the VXLAN protocol bound stream is transmitted correctly\n\nStep          :   Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                   Test Step 2: Create VXLAN protocol and multicast group;\n                   Test Step 3: Create bound traffic;\n                   Test Step 4: Subscribe to StreamBlockStats;\n                   Test Step 5: Transmit all traffic and wait for a period;\n                   Test Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In step 6, all traffic sent and received packets are equal;\n\nCreated by    :   Tester-002\n\nBugs          :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    interfaces_3 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_4 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    edit_interface(Interface=interfaces_3,\n                   Layer='IPv4Layer',\n                   Address='2.2.2.1',\n                   Gateway='2.2.2.2')\n\n    edit_interface(Interface=interfaces_4,\n                   Layer='IPv4Layer',\n                   Address='2.2.2.2',\n                   Gateway='2.2.2.1')\n    # 创建VXLAN协议会话\n\n    session_1 = create_vxlan(Port=Port_UP)\n\n    session_2 = create_vxlan(Port=Port_Down)\n\n    # VXLAN协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建VXLAN Segment\n\n    segment = create_vxlan_segment(StartVni=10)\n\n    # 绑定VXLAN VM\n\n    binding_vxlan_vm(Segments=segment, Interfaces=interfaces_3)\n\n    binding_vxlan_vm(Segments=segment, Interfaces=interfaces_4)\n\n    binding_vxlan_vtep(Vteps=session_1, Interfaces=interfaces_3)\n\n    binding_vxlan_vtep(Vteps=session_2, Interfaces=interfaces_4)\n\n    # 创建VXLAN绑定流\n\n    point_1 = get_vxlan_vm_point(Vxlan=session_1)\n\n    point_2 = get_vxlan_vm_point(Vxlan=session_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['VxlanBindingStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待VXLAN协议会话达到STARTED状态\n\n    wait_vxlan_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    import pandas\n    result = get_vxlan_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    # 获取VXLAN会话1统计\n\n    result = get_vxlan_statistic(Session=session_1)\n    print(result)\n\n    # 获取VXLAN会话2统计\n\n    result = get_vxlan_statistic(Session=session_2)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nbinding_vxlan_vm:绑定 Vxlan Vm 对象;\nbinding_vxlan_vtep:绑定 Vxlan Vtep 对象;\ncreate_vxlan:创建Vxlan协议会话对象;\ncreate_vxlan_segment:创建Vxlan Segment对象;\nget_vxlan_statistic:获取测试仪表vxlan统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/ospf_lsa/ospfv2_lsa_wizard.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查Ospfv2 Lsa向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建Ospfv2会话;\n                   测试步骤3: 创建Ospfv2 Lsa向导;\n                   测试步骤4: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤4 Ospfv2 Lsa向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Check that the OSPFv2 LSA wizard configuration is generated normally\n\nStep: Step 1: Create two offline ports: Port_1 and Port_2;\n      Step 2: Create an OSPFv2 session;\n      Step 3: Create an OSPFv2 LSA wizard;\n      Step 4: Generate the wizard configuration;\n\nCriteria: Expected Result 1: Step 4: The OSPFv2 LSA wizard configuration is generated without any exceptions;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='ipv4')\n    interfaces_2 = create_interface(Port=Port_2, Layers='ipv4')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建Ospfv2会话\n    ospf_1 = create_ospf(Port=Port_1)\n    ospf_2 = create_ospf(Port=Port_2)\n\n    select_interface(Session=ospf_1, Interface=interfaces_1)\n    select_interface(Session=ospf_2, Interface=interfaces_2)\n\n    # 创建Ospfv2 lsa向导\n    wizard = create_ospfv2_lsa_wizard(Sessions=[ospf_1, ospf_2])\n\n    # 配置ospfv2拓扑\n    config_ospfv2_lsa_wizard_ospfv2_topo(Wizards=wizard, Type='GRID',\n                                         RowCount=10,\n                                         ColumnCount=20)\n\n    # 配置ospfv2\n    config_ospfv2_lsa_wizard_ospfv2(Wizards=wizard,\n                                    EnableTeOption=True,\n                                    EnableSegmentRouting=True)\n    te = config_ospfv2_lsa_wizard_ospfv2_te_option(Wizards=wizard,\n                                                   EnableGroup=True,\n                                                   Group=10)\n    sr = config_ospfv2_lsa_wizard_ospfv2_sr(Wizards=wizard,\n                                            SidLabelType='BIT32')\n\n    # 配置ospfv2 stub network\n    config_ospfv2_lsa_wizard_ospfv2_stub_network(Wizards=wizard,\n                                                 StubDistributionType='INTERNET',\n                                                 StubInternetPrefixLength=\n                                                 [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                  0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 30, 0.0, 0.0, 0.0, 0.0,\n                                                  0.0, 0.0, 0.0, 50]\n                                                 )\n\n    # 配置ospfv2 summary network\n    config_ospfv2_lsa_wizard_ospfv2_summary_route(Wizards=wizard,\n                                                  SummaryEmulated='NONE',\n                                                  SummarySimulated='ALL')\n\n    # 配置ospfv2 external network\n    config_ospfv2_lsa_wizard_ospfv2_external_route(Wizards=wizard,\n                                                   ExternalPrimaryMetric=20)\n\n    # 生成Ospfv2 Lsa向导配置\n    expand_ospfv2_lsa_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "create_ospf:创建OSPFv2协议会话对象"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu' to set up the testing environment.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) at specified locations for offline testing.\",\n  \"Subtask 3\": \"Create an IPv4 interface on Port_1 and configure with address '192.168.1.2' and gateway '192.168.1.3'.\",\n  \"Subtask 4\": \"Create an IPv4 interface on Port_2 and configure with address '192.168.1.3' and gateway '192.168.1.2'.\",\n  \"Subtask 5\": \"Create an OSPFv2 session on Port_1 and bind it to the IPv4 interface.\",\n  \"Subtask 6\": \"Create an OSPFv2 session on Port_2 and bind it to the IPv4 interface.\",\n  \"Subtask 7\": \"Create an OSPFv2 LSA wizard for both OSPFv2 sessions.\",\n  \"Subtask 8\": \"Configure the OSPFv2 LSA wizard topology as GRID with 10 rows and 20 columns.\",\n  \"Subtask 9\": \"Configure the OSPFv2 LSA wizard to enable TE Option and Segment Routing.\",\n  \"Subtask 10\": \"Configure TE Option parameters: enable group and set group ID to 10.\",\n  \"Subtask 11\": \"Configure Segment Routing parameters: set SID label type to BIT32.\",\n  \"Subtask 12\": \"Configure stub network distribution type as INTERNET with specified prefix length array.\",\n  \"Subtask 13\": \"Configure summary routes: set emulated to NONE and simulated to ALL.\",\n  \"Subtask 14\": \"Configure external routes with primary metric set to 20.\",\n  \"Subtask 15\": \"Generate OSPFv2 LSA wizard configuration by expanding the wizard.\",\n  \"Subtask 16\": \"Save the generated configuration to an XCFG file for verification.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Check that the OSPFv2 LSA wizard configuration is generated normally\n\nStep: Step 1: Create two offline ports: Port_1 and Port_2;\n      Step 2: Create an OSPFv2 session;\n      Step 3: Create an OSPFv2 LSA wizard;\n      Step 4: Generate the wizard configuration;\n\nCriteria: Expected Result 1: Step 4: The OSPFv2 LSA wizard configuration is generated without any exceptions;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2], Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='ipv4')\n    interfaces_2 = create_interface(Port=Port_2, Layers='ipv4')\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建Ospfv2会话\n    ospf_1 = create_ospf(Port=Port_1)\n    ospf_2 = create_ospf(Port=Port_2)\n\n    select_interface(Session=ospf_1, Interface=interfaces_1)\n    select_interface(Session=ospf_2, Interface=interfaces_2)\n\n    # 创建Ospfv2 lsa向导\n    wizard = create_ospfv2_lsa_wizard(Sessions=[ospf_1, ospf_2])\n\n    # 配置ospfv2拓扑\n    config_ospfv2_lsa_wizard_ospfv2_topo(Wizards=wizard, Type='GRID',\n                                         RowCount=10,\n                                         ColumnCount=20)\n\n    # 配置ospfv2\n    config_ospfv2_lsa_wizard_ospfv2(Wizards=wizard,\n                                    EnableTeOption=True,\n                                    EnableSegmentRouting=True)\n    te = config_ospfv2_lsa_wizard_ospfv2_te_option(Wizards=wizard,\n                                                   EnableGroup=True,\n                                                   Group=10)\n    sr = config_ospfv2_lsa_wizard_ospfv2_sr(Wizards=wizard,\n                                            SidLabelType='BIT32')\n\n    # 配置ospfv2 stub network\n    config_ospfv2_lsa_wizard_ospfv2_stub_network(Wizards=wizard,\n                                                 StubDistributionType='INTERNET',\n                                                 StubInternetPrefixLength=\n                                                 [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                                  0.0, 0.0, 0.0, 0.0, 0.0, 10, 0.0, 0.0, 0.0, 30, 0.0, 0.0, 0.0, 0.0,\n                                                  0.0, 0.0, 0.0, 50]\n                                                 )\n\n    # 配置ospfv2 summary network\n    config_ospfv2_lsa_wizard_ospfv2_summary_route(Wizards=wizard,\n                                                  SummaryEmulated='NONE',\n                                                  SummarySimulated='ALL')\n\n    # 配置ospfv2 external network\n    config_ospfv2_lsa_wizard_ospfv2_external_route(Wizards=wizard,\n                                                   ExternalPrimaryMetric=20)\n\n    # 生成Ospfv2 Lsa向导配置\n    expand_ospfv2_lsa_wizard(Wizards=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\ncreate_ospf:创建OSPFv2协议会话对象\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/RIP/RIP.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查RIP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 创建RIP协议及组播组;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective : Test Objective: Verify that RIP protocol binding flow transmission is normal\n\nStep : Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n       Test Step 2: Create RIP protocol and multicast group;\n       Test Step 3: Create binding traffic;\n       Test Step 4: Subscribe to StreamBlockStats statistics;\n       Test Step 5: Send all traffic, wait for a period of time;\n       Test Step 6: Stop all traffic, view StreamBlockStats statistical information;\n\nCriteria : Expected Result 1: In Step 6, all traffic packets sent and received are equal;\n\nCreated by : Tester-002\n\nBugs : None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建RIP协议会话\n\n    session_1 = create_rip(Port=Port_UP)\n\n    session_2 = create_rip(Port=Port_Down)\n\n    # RIP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # RIP协议会话1创建IPv4 Route\n\n    ipv4_route_1 = create_rip_ipv4_route(Session=session_1)\n\n    # RIP协议会话2创建IPv4 Route\n\n    ipv4_route_2 = create_rip_ipv4_route(Session=session_2)\n\n    # 获取RIP协议绑定流端点对象\n\n    point_1 = get_rip_router_from_route(Route=ipv4_route_1)\n\n    point_2 = get_rip_router_from_route(Route=ipv4_route_2)\n\n    # 创建RIP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['RipSessionBlockStats', 'RipSessionStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待RIP协议会话达到Full状态\n\n    wait_rip_state(Sessions=[session_1, session_2])\n\n    advertise_rip(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    withdraw_rip(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    import pandas\n    result = get_rip_session_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    # 获取RIP会话1统计\n\n    result = get_rip_session_block_statistic(Session=session_1)\n    print(result)\n    TxAdvertised = result['TxAdvertised']\n    RxAdvertised = result['RxAdvertised']\n    print('TxAdvertised:', TxAdvertised)\n    print('RxAdvertised:', RxAdvertised)\n    TxWithdrawn = result['TxWithdrawn']\n    RxWithdrawn = result['RxWithdrawn']\n    print('TxWithdrawn:', TxWithdrawn)\n    print('RxWithdrawn:', RxWithdrawn)\n\n    # 获取RIP会话2统计\n\n    result = get_rip_session_block_statistic(Session=session_2)\n    print(result)\n    TxAdvertised = result['TxAdvertised']\n    RxAdvertised = result['RxAdvertised']\n    print('TxAdvertised:', TxAdvertised)\n    print('RxAdvertised:', RxAdvertised)\n    TxWithdrawn = result['TxWithdrawn']\n    RxWithdrawn = result['RxWithdrawn']\n    print('TxWithdrawn:', TxWithdrawn)\n    print('RxWithdrawn:', RxWithdrawn)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_rip:通告RIP协议路由",
      "create_rip:创建RIP协议会话对象",
      "create_rip_ipv4_route:创建RIP IPv4路由对象",
      "get_rip_router_from_route:获取OSPF LSA对应的绑定流源或目的端点对象",
      "get_rip_session_block_statistic:获取RIP协议会话统计结果",
      "wait_rip_state:等待RIP协议会话达到指定状态",
      "withdraw_rip:撤销 RIP 协议通告路由",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two physical ports and assign them as Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both reserved ports.\",\n  \"Subtask 4\": \"Configure IPv4 addresses and gateways on Port_UP interface (Address: 192.168.1.2, Gateway: 192.168.1.3).\",\n  \"Subtask 5\": \"Configure IPv4 addresses and gateways on Port_Down interface (Address: 192.168.1.3, Gateway: 192.168.1.2).\",\n  \"Subtask 6\": \"Create RIP protocol sessions on both ports.\",\n  \"Subtask 7\": \"Bind the RIP sessions to their respective IPv4 interfaces.\",\n  \"Subtask 8\": \"Create RIP IPv4 routes for each RIP session.\",\n  \"Subtask 9\": \"Retrieve RIP router endpoints from the created routes for stream binding.\",\n  \"Subtask 10\": \"Create bidirectional binding traffic streams between the two RIP router endpoints.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats, RipSessionBlockStats, and RipSessionStats statistics.\",\n  \"Subtask 12\": \"Save the current test configuration to a file.\",\n  \"Subtask 13\": \"Start all RIP protocols.\",\n  \"Subtask 14\": \"Wait until both RIP sessions reach Full state.\",\n  \"Subtask 15\": \"Advertise RIP routes on both sessions.\",\n  \"Subtask 16\": \"Wait 5 seconds for protocol stabilization.\",\n  \"Subtask 17\": \"Start all traffic streams.\",\n  \"Subtask 18\": \"Wait 10 seconds for traffic transmission.\",\n  \"Subtask 19\": \"Stop all traffic streams.\",\n  \"Subtask 20\": \"Withdraw RIP advertised routes on both sessions.\",\n  \"Subtask 21\": \"Wait 5 seconds for route withdrawal.\",\n  \"Subtask 22\": \"Stop all RIP protocols.\",\n  \"Subtask 23\": \"Retrieve StreamBlockStats for the first traffic stream.\",\n  \"Subtask 24\": \"Verify transmitted frames equal received frames for the first stream.\",\n  \"Subtask 25\": \"Retrieve StreamBlockStats for the second traffic stream.\",\n  \"Subtask 26\": \"Verify transmitted frames equal received frames for the second stream.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective : Test Objective: Verify that RIP protocol binding flow transmission is normal\n\nStep : Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n       Test Step 2: Create RIP protocol and multicast group;\n       Test Step 3: Create binding traffic;\n       Test Step 4: Subscribe to StreamBlockStats statistics;\n       Test Step 5: Send all traffic, wait for a period of time;\n       Test Step 6: Stop all traffic, view StreamBlockStats statistical information;\n\nCriteria : Expected Result 1: In Step 6, all traffic packets sent and received are equal;\n\nCreated by : Tester-002\n\nBugs : None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建RIP协议会话\n\n    session_1 = create_rip(Port=Port_UP)\n\n    session_2 = create_rip(Port=Port_Down)\n\n    # RIP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # RIP协议会话1创建IPv4 Route\n\n    ipv4_route_1 = create_rip_ipv4_route(Session=session_1)\n\n    # RIP协议会话2创建IPv4 Route\n\n    ipv4_route_2 = create_rip_ipv4_route(Session=session_2)\n\n    # 获取RIP协议绑定流端点对象\n\n    point_1 = get_rip_router_from_route(Route=ipv4_route_1)\n\n    point_2 = get_rip_router_from_route(Route=ipv4_route_2)\n\n    # 创建RIP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['RipSessionBlockStats', 'RipSessionStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待RIP协议会话达到Full状态\n\n    wait_rip_state(Sessions=[session_1, session_2])\n\n    advertise_rip(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    withdraw_rip(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    import pandas\n    result = get_rip_session_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    # 获取RIP会话1统计\n\n    result = get_rip_session_block_statistic(Session=session_1)\n    print(result)\n    TxAdvertised = result['TxAdvertised']\n    RxAdvertised = result['RxAdvertised']\n    print('TxAdvertised:', TxAdvertised)\n    print('RxAdvertised:', RxAdvertised)\n    TxWithdrawn = result['TxWithdrawn']\n    RxWithdrawn = result['RxWithdrawn']\n    print('TxWithdrawn:', TxWithdrawn)\n    print('RxWithdrawn:', RxWithdrawn)\n\n    # 获取RIP会话2统计\n\n    result = get_rip_session_block_statistic(Session=session_2)\n    print(result)\n    TxAdvertised = result['TxAdvertised']\n    RxAdvertised = result['RxAdvertised']\n    print('TxAdvertised:', TxAdvertised)\n    print('RxAdvertised:', RxAdvertised)\n    TxWithdrawn = result['TxWithdrawn']\n    RxWithdrawn = result['RxWithdrawn']\n    print('TxWithdrawn:', TxWithdrawn)\n    print('RxWithdrawn:', RxWithdrawn)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_rip:通告RIP协议路由;\ncreate_rip:创建RIP协议会话对象;\ncreate_rip_ipv4_route:创建RIP IPv4路由对象;\nget_rip_router_from_route:获取OSPF LSA对应的绑定流源或目的端点对象;\nget_rip_session_block_statistic:获取RIP协议会话统计结果;\nwait_rip_state:等待RIP协议会话达到指定状态;\nwithdraw_rip:撤销 RIP 协议通告路由;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/OvsDb/ovsdb.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查ovsdb统计获取正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 创建ovsdb;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Check that ovsdb statistics are obtained correctly  \n\nStep 1: Reserve two loopback ports Port_1 and Port_2;  \nStep 2: Create ovsdb;  \nStep 3: Start the protocol and view protocol statistics;  \n\nCriteria:  \nExpected Result 1: Statistics are obtained correctly in Step 3;  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.3')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.3', Gateway='1.1.1.2')\n\n    # 创建协议会话\n\n    ovsdb = create_ovsdb(Port=Port_UP)\n    select_interface(Session=ovsdb, Interface=interfaces_1)\n\n\n    # 订阅统计\n\n    subscribe_result(Types=['OvsdbResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n    wait_ovsdb_state(Sessions=ovsdb)\n    time.sleep(2)\n\n    # 获取统计\n    result = get_ovsdb_statistic(Sessions=ovsdb)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product.\",\n  \"Subtask 2\": \"Reserve two ports (Port_UP and Port_Down) using the provided locations.\",\n  \"Subtask 3\": \"Create interfaces on both reserved ports.\",\n  \"Subtask 4\": \"Configure IPv4 addresses and gateways for both interfaces: set Port_UP interface address to '1.1.1.2' with gateway '1.1.1.3', and Port_Down interface address to '1.1.1.3' with gateway '1.1.1.2'.\",\n  \"Subtask 5\": \"Create an OVSDB session on Port_UP.\",\n  \"Subtask 6\": \"Bind the configured Port_UP interface to the OVSDB session.\",\n  \"Subtask 7\": \"Subscribe to OVSDB result statistics.\",\n  \"Subtask 8\": \"Save the current test configuration to a file.\",\n  \"Subtask 9\": \"Start the protocol.\",\n  \"Subtask 10\": \"Wait for the OVSDB session to reach established state and stabilize.\",\n  \"Subtask 11\": \"Retrieve OVSDB session statistics.\",\n  \"Subtask 12\": \"Stop the protocol.\",\n  \"Subtask 13\": \"Verify that OVSDB statistics were successfully obtained and contain expected data.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Check that ovsdb statistics are obtained correctly  \n\nStep 1: Reserve two loopback ports Port_1 and Port_2;  \nStep 2: Create ovsdb;  \nStep 3: Start the protocol and view protocol statistics;  \n\nCriteria:  \nExpected Result 1: Statistics are obtained correctly in Step 3;  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.3')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.3', Gateway='1.1.1.2')\n\n    # 创建协议会话\n\n    ovsdb = create_ovsdb(Port=Port_UP)\n    select_interface(Session=ovsdb, Interface=interfaces_1)\n\n\n    # 订阅统计\n\n    subscribe_result(Types=['OvsdbResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n    wait_ovsdb_state(Sessions=ovsdb)\n    time.sleep(2)\n\n    # 获取统计\n    result = get_ovsdb_statistic(Sessions=ovsdb)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/DHCP/DHCPv6_5000session.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查DHCPv6协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建DHCPv4协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify DHCPv6 protocol binding traffic transmission is normal  \n\nStep:  \nTest Step 1: Reserve two loopback ports: Port_1, Port_2;  \nTest Step 2: Create DHCPv4 protocols and configure routing on both ports;  \nTest Step 3: Create binding traffic;  \nTest Step 4: Subscribe to StreamBlockStats;  \nTest Step 5: Transmit all traffic and wait for a period;  \nTest Step 6: Stop all traffic and check StreamBlockStats;  \n\nCriteria:  \nExpected Result 1: Packets sent equal packets received in Step 6;  \n\nCreated by: Tester-004  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Ports = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Ports[0], Layers=['ipv6'])\n    edit_interface(Interface=interfaces_1, Count=5000)\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='12:12:12::2',\n                   PrefixLength=64,\n                   Gateway='12:12:12::1')\n    interfaces_2 = create_interface(Port=Ports[1], Layers=['ipv6'])\n    # 保证MAC地址不冲突\n    edit_interface(Interface=interfaces_2,\n                   Layer='EthIILayer',\n                   Address='12:12:12:12:12:12')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='12:12:12::1',\n                   PrefixLength=64,\n                   Gateway='12:12:12::2')\n\n    # 创建DHCPv6协议会话\n    client = create_dhcpv6_client(Port=Ports[0])\n    server = create_dhcpv6_server(Port=Ports[1])\n    # DHCPv6协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_1)\n    select_interface(Session=server, Interface=interfaces_2)\n    # 获取DHCP Server地址池\n    pool = create_dhcpv6_server_address_pool(Sessions=server, StartAddress='12:12:12::2',PrefixLength=64,AddressCount=5100)\n    # 获取接口绑定流端点对象\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1,Layer='ipv6')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2,Layer='ipv6')\n    # 创建DHCPV6绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv6PortStatistics', 'Dhcpv6ClientBlockStatistics',\n                            'Dhcpv6ServerStatistics'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动协议\n    start_protocol()\n    # 等待DHCP协议协议会话状态正确\n    wait_dhcpv6_client_state(Sessions=client)\n    wait_dhcpv6_server_state(Sessions=server)\n    time.sleep(5)\n    # 发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取DHCP端口统计\n    result = get_dhcpv6_port_statistic(Port=Ports[0])\n    print(result)\n    CurrentBound = result['CurrentlyBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP客户端统计\n    result = get_dhcpv6_client_block_statistic(Session=client)\n    print(result)\n    CurrentBound = result['CurrentlyBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP服务器统计\n    result = get_dhcpv6_server_statistic(Session=server)\n    print(result)\n    CurrentBound = result['CurrentlyBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取流量1统计\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 获取流量2统计\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "create_dhcpv6_client:创建DHCPv6客户端会话对象",
      "create_dhcpv6_server:创建DHCPv6服务端会话对象",
      "create_dhcpv6_server_address_pool:创建DHCPv6 Server Address Pool对象",
      "get_dhcpv6_client_block_statistic:获取 Dhcpv6 Client Block Statistic 统计结果",
      "get_dhcpv6_port_statistic:获取Dhcpv6 Port Statistic统计结果",
      "get_dhcpv6_server_statistic:获取Dhcpv6 Server Statistic统计结果",
      "wait_dhcpv6_client_state:等待Dhcpv6客户端会话达到指定状态",
      "wait_dhcpv6_server_state:等待Dhcpv6服务端会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with specified product configuration (default 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports using provided locations, applying force reservation if necessary.\",\n  \"Subtask 3\": \"Create IPv6 interfaces on both reserved ports with base configurations.\",\n  \"Subtask 4\": \"Configure first interface with 5000 instances, IPv6 address '12:12:12::2', prefix length 64, and gateway '12:12:12::1'.\",\n  \"Subtask 5\": \"Configure second interface with MAC address '12:12:12:12:12:12', IPv6 address '12:12:12::1', prefix length 64, and gateway '12:12:12::2'.\",\n  \"Subtask 6\": \"Create DHCPv6 client session on first port and DHCPv6 server session on second port.\",\n  \"Subtask 7\": \"Bind DHCPv6 client session to first interface and server session to second interface.\",\n  \"Subtask 8\": \"Create DHCPv6 server address pool with start address '12:12:12::2', prefix length 64, and address count 5100.\",\n  \"Subtask 9\": \"Extract IPv6 layer objects from both configured interfaces.\",\n  \"Subtask 10\": \"Create bidirectional binding traffic streams between the IPv6 endpoints of both interfaces.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats, Dhcpv6PortStatistics, Dhcpv6ClientBlockStatistics, and Dhcpv6ServerStatistics views.\",\n  \"Subtask 12\": \"Save current test configuration to file in specified path format.\",\n  \"Subtask 13\": \"Start DHCPv6 protocol sessions on both ports.\",\n  \"Subtask 14\": \"Wait until DHCPv6 client reaches bound state and server reaches active state.\",\n  \"Subtask 15\": \"Pause execution for 5 seconds to stabilize protocol sessions.\",\n  \"Subtask 16\": \"Start transmission of all created traffic streams.\",\n  \"Subtask 17\": \"Pause execution for 10 seconds during traffic transmission.\",\n  \"Subtask 18\": \"Stop all traffic streams.\",\n  \"Subtask 19\": \"Pause execution for 3 seconds to finalize statistics collection.\",\n  \"Subtask 20\": \"Retrieve and verify DHCPv6 port statistics: assert CurrentlyBound equals TotalBound equals 5000.\",\n  \"Subtask 21\": \"Retrieve and verify DHCPv6 client block statistics: assert CurrentlyBound equals TotalBound equals 5000.\",\n  \"Subtask 22\": \"Retrieve and verify DHCPv6 server statistics: assert CurrentlyBound equals TotalBound equals 5000.\",\n  \"Subtask 23\": \"Retrieve and verify StreamBlock statistics for first stream: assert TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 24\": \"Retrieve and verify StreamBlock statistics for second stream: assert TxStreamFrames equals RxStreamFrames.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify DHCPv6 protocol binding traffic transmission is normal  \n\nStep:  \nTest Step 1: Reserve two loopback ports: Port_1, Port_2;  \nTest Step 2: Create DHCPv4 protocols and configure routing on both ports;  \nTest Step 3: Create binding traffic;  \nTest Step 4: Subscribe to StreamBlockStats;  \nTest Step 5: Transmit all traffic and wait for a period;  \nTest Step 6: Stop all traffic and check StreamBlockStats;  \n\nCriteria:  \nExpected Result 1: Packets sent equal packets received in Step 6;  \n\nCreated by: Tester-004  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Ports = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Ports[0], Layers=['ipv6'])\n    edit_interface(Interface=interfaces_1, Count=5000)\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='12:12:12::2',\n                   PrefixLength=64,\n                   Gateway='12:12:12::1')\n    interfaces_2 = create_interface(Port=Ports[1], Layers=['ipv6'])\n    # 保证MAC地址不冲突\n    edit_interface(Interface=interfaces_2,\n                   Layer='EthIILayer',\n                   Address='12:12:12:12:12:12')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='12:12:12::1',\n                   PrefixLength=64,\n                   Gateway='12:12:12::2')\n\n    # 创建DHCPv6协议会话\n    client = create_dhcpv6_client(Port=Ports[0])\n    server = create_dhcpv6_server(Port=Ports[1])\n    # DHCPv6协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_1)\n    select_interface(Session=server, Interface=interfaces_2)\n    # 获取DHCP Server地址池\n    pool = create_dhcpv6_server_address_pool(Sessions=server, StartAddress='12:12:12::2',PrefixLength=64,AddressCount=5100)\n    # 获取接口绑定流端点对象\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1,Layer='ipv6')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2,Layer='ipv6')\n    # 创建DHCPV6绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv6PortStatistics', 'Dhcpv6ClientBlockStatistics',\n                            'Dhcpv6ServerStatistics'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动协议\n    start_protocol()\n    # 等待DHCP协议协议会话状态正确\n    wait_dhcpv6_client_state(Sessions=client)\n    wait_dhcpv6_server_state(Sessions=server)\n    time.sleep(5)\n    # 发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取DHCP端口统计\n    result = get_dhcpv6_port_statistic(Port=Ports[0])\n    print(result)\n    CurrentBound = result['CurrentlyBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP客户端统计\n    result = get_dhcpv6_client_block_statistic(Session=client)\n    print(result)\n    CurrentBound = result['CurrentlyBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP服务器统计\n    result = get_dhcpv6_server_statistic(Session=server)\n    print(result)\n    CurrentBound = result['CurrentlyBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取流量1统计\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 获取流量2统计\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\ncreate_dhcpv6_client:创建DHCPv6客户端会话对象;\ncreate_dhcpv6_server:创建DHCPv6服务端会话对象;\ncreate_dhcpv6_server_address_pool:创建DHCPv6 Server Address Pool对象;\nget_dhcpv6_client_block_statistic:获取 Dhcpv6 Client Block Statistic 统计结果;\nget_dhcpv6_port_statistic:获取Dhcpv6 Port Statistic统计结果;\nget_dhcpv6_server_statistic:获取Dhcpv6 Server Statistic统计结果;\nwait_dhcpv6_client_state:等待Dhcpv6客户端会话达到指定状态;\nwait_dhcpv6_server_state:等待Dhcpv6服务端会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/SAA/Saa.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查Saa协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建Saa协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Objective: Check that the Saa protocol binding flow is sent normally\n\nStep         :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                  Step 2: Create Saa protocol on each port respectively;\n                  Step 3: Start the protocol and view protocol statistics;\n\nCriteria     :   Expected Result 1: Statistics are obtained correctly in step 3;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='eth', Tops='ipv6')\n    interfaces_2 = create_interface(Port=Port_Down, Layers='eth', Tops='ipv6')\n    edit_interface(Interface=interfaces_1, Layer='IPv6Layer', Address='2022::2', Gateway='2022::3')\n    edit_interface(Interface=interfaces_2, Layer='IPv6Layer', Address='2022::3', Gateway='2022::2')\n\n    # 创建协议会话\n\n    session_1 = create_saa(Port=Port_UP)\n    session_2 = create_saa(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 订阅统计\n\n    subscribe_result(Types=['SaaPortStatistics', 'SaaSessionBlockStatistics', 'SaaSessionStatistics'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待协议会话达到状态\n\n    wait_saa_state(Sessions=[session_1, session_2], State='IDLE')\n\n    time.sleep(1)\n\n    # 获取统计\n    import pandas\n    result = get_saa_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_saa_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_saa_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_saa_session_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_saa_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_saa_session_block_statistic(Session=session_2)\n    print(result)\n\n    result = get_saa_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_saa_session_statistic(Session=session_1, SessionId=1)\n    print(result)\n    result = get_saa_session_statistic(Session=session_2, SessionId=1)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (default 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports using reserve_port API with default locations or command-line input.\",\n  \"Subtask 3\": \"Create Ethernet and IPv6 interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 4\": \"Configure IPv6 addresses and gateways on both interfaces using edit_interface API (Port_1: address='2022::2', gateway='2022::3'; Port_2: address='2022::3', gateway='2022::2').\",\n  \"Subtask 5\": \"Create SAA protocol sessions on both ports using create_saa API.\",\n  \"Subtask 6\": \"Bind the created interfaces to their respective SAA sessions using select_interface API.\",\n  \"Subtask 7\": \"Subscribe to SaaPortStatistics, SaaSessionBlockStatistics, and SaaSessionStatistics using subscribe_result API.\",\n  \"Subtask 8\": \"Save the current configuration to an xcfg file in the script directory using save_case API.\",\n  \"Subtask 9\": \"Start the protocol using start_protocol API.\",\n  \"Subtask 10\": \"Wait until both SAA sessions reach 'IDLE' state and pause for 1 second.\",\n  \"Subtask 11\": \"Retrieve and verify SAA port statistics: overall statistics and per-port statistics, confirming results are pandas DataFrames.\",\n  \"Subtask 12\": \"Retrieve and verify SAA session block statistics: overall statistics and per-session statistics, confirming results are pandas DataFrames.\",\n  \"Subtask 13\": \"Retrieve and verify SAA session statistics: overall statistics and per-session statistics with SessionId=1, confirming results are pandas DataFrames.\",\n  \"Subtask 14\": \"Stop the protocol using stop_protocol API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Objective: Check that the Saa protocol binding flow is sent normally\n\nStep         :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                  Step 2: Create Saa protocol on each port respectively;\n                  Step 3: Start the protocol and view protocol statistics;\n\nCriteria     :   Expected Result 1: Statistics are obtained correctly in step 3;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='eth', Tops='ipv6')\n    interfaces_2 = create_interface(Port=Port_Down, Layers='eth', Tops='ipv6')\n    edit_interface(Interface=interfaces_1, Layer='IPv6Layer', Address='2022::2', Gateway='2022::3')\n    edit_interface(Interface=interfaces_2, Layer='IPv6Layer', Address='2022::3', Gateway='2022::2')\n\n    # 创建协议会话\n\n    session_1 = create_saa(Port=Port_UP)\n    session_2 = create_saa(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 订阅统计\n\n    subscribe_result(Types=['SaaPortStatistics', 'SaaSessionBlockStatistics', 'SaaSessionStatistics'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待协议会话达到状态\n\n    wait_saa_state(Sessions=[session_1, session_2], State='IDLE')\n\n    time.sleep(1)\n\n    # 获取统计\n    import pandas\n    result = get_saa_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_saa_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_saa_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_saa_session_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_saa_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_saa_session_block_statistic(Session=session_2)\n    print(result)\n\n    result = get_saa_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_saa_session_statistic(Session=session_1, SessionId=1)\n    print(result)\n    result = get_saa_session_statistic(Session=session_2, SessionId=1)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/DHCP/DHCPv4.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查DHCPv4协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建DHCPv4协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     :   Test Objective: Verify normal transmission of DHCPv4 protocol binding flow\n\nStep          :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Create DHCPv4 protocols on both ports and configure routing;\n                 Step 3: Generate binding traffic;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Transmit all traffic and wait for a duration;\n                 Step 6: Stop all traffic and inspect StreamBlockStats;\n\nCriteria      :   Expected Result 1: In Step 6, all traffic shows equal sent/received packets;\n\nCreated by    :   Tester-001\n\nBugs          :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='2.1.1.2',\n                   Gateway='2.1.1.1')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='2.1.2.2',\n                   Gateway='2.1.1.1')\n\n    # 创建DHCPv4协议会话\n\n    client = create_dhcp_client(Port=Port_UP)\n\n    server = create_dhcp_server(Port=Port_Down)\n\n    # DHCPv4协议会话与接口绑定\n\n    select_interface(Session=client, Interface=interfaces_1)\n\n    select_interface(Session=server, Interface=interfaces_2)\n\n    # 获取DHCP Server地址池\n    configDict = get_configs(Configs='Dhcpv4AddressPool')\n    dhcpv4AddressPool = list(configDict.values())[0]\n    edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='2.1.2.3')\n\n    # 获取接口绑定流端点对象\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    # 创建OSPFv2绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv4ServerStats', 'Dhcpv4ClientBlockStats', 'Dhcpv4ClientStats',\n                            'Dhcpv4PortStats', 'Dhcpv4LeaseStats', ])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待DHCP协议协议会话状态正确\n\n    wait_dhcp_client_state(Sessions=client)\n    wait_dhcp_server_state(Sessions=server)\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取DHCP端口统计\n    import pandas\n    result = get_dhcp_port_statistic()\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dhcp_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_dhcp_port_statistic(Port=Port_Down)\n    print(result)\n\n    # 获取DHCP客户端统计\n    result = get_dhcp_client_statistic()\n    print(result)\n    result = get_dhcp_client_statistic(Session=client)\n    print(result)\n\n    result = get_dhcp_client_block_statistic(Session=client)\n    print(result)\n\n    # 获取DHCP服务器统计\n    result = get_dhcp_server_statistic()\n    print(result)\n    result = get_dhcp_server_statistic(Session=server)\n    print(result)\n\n    result = get_dhcp_server_lease_statistic(Session=server, ClientId='00:00:02:01:01:02')\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "edit_configs:not_found",
      "get_configs:获取测试仪表指定对象",
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_dhcp_client:创建DHCPv4客户端协议会话对象",
      "create_dhcp_server:创建DHCP Server会话对象",
      "get_dhcp_client_block_statistic:获取Dhcp Client Block Statistic统计结果",
      "get_dhcp_client_statistic:获取Dhcp Client Statistic统计结果",
      "get_dhcp_port_statistic:获取Dhcp Port Statistic统计结果",
      "get_dhcp_server_lease_statistic:获取Dhcp Server Lease Statistic统计结果",
      "get_dhcp_server_statistic:获取 Dhcp Server Statistic 统计结果",
      "wait_dhcp_client_state:等待DHCP协议会话达到指定状态",
      "wait_dhcp_server_state:等待DHCP服务器协议会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (default: 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports (Port_UP and Port_Down) using provided locations.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both reserved ports with specified IP addresses and gateways.\",\n  \"Subtask 4\": \"Create DHCPv4 client session on Port_UP and DHCPv4 server session on Port_Down.\",\n  \"Subtask 5\": \"Bind created interfaces to respective DHCP sessions.\",\n  \"Subtask 6\": \"Configure DHCPv4 server address pool with start address '2.1.2.3'.\",\n  \"Subtask 7\": \"Retrieve IPv4 layer objects from both interfaces for traffic endpoints.\",\n  \"Subtask 8\": \"Create bidirectional binding traffic streams between source and destination endpoints.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats and other DHCP-related statistics.\",\n  \"Subtask 10\": \"Save current test configuration to specified file path.\",\n  \"Subtask 11\": \"Start DHCP protocols on both ports.\",\n  \"Subtask 12\": \"Wait for DHCP client to reach bound state and server to reach running state, then pause 5 seconds.\",\n  \"Subtask 13\": \"Start all traffic streams and wait 10 seconds for transmission.\",\n  \"Subtask 14\": \"Stop all traffic streams and DHCP protocols, then pause 3 seconds.\",\n  \"Subtask 15\": \"Retrieve StreamBlock statistics for both traffic streams.\",\n  \"Subtask 16\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) for each stream.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     :   Test Objective: Verify normal transmission of DHCPv4 protocol binding flow\n\nStep          :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Create DHCPv4 protocols on both ports and configure routing;\n                 Step 3: Generate binding traffic;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Transmit all traffic and wait for a duration;\n                 Step 6: Stop all traffic and inspect StreamBlockStats;\n\nCriteria      :   Expected Result 1: In Step 6, all traffic shows equal sent/received packets;\n\nCreated by    :   Tester-001\n\nBugs          :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='2.1.1.2',\n                   Gateway='2.1.1.1')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='2.1.2.2',\n                   Gateway='2.1.1.1')\n\n    # 创建DHCPv4协议会话\n\n    client = create_dhcp_client(Port=Port_UP)\n\n    server = create_dhcp_server(Port=Port_Down)\n\n    # DHCPv4协议会话与接口绑定\n\n    select_interface(Session=client, Interface=interfaces_1)\n\n    select_interface(Session=server, Interface=interfaces_2)\n\n    # 获取DHCP Server地址池\n    configDict = get_configs(Configs='Dhcpv4AddressPool')\n    dhcpv4AddressPool = list(configDict.values())[0]\n    edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='2.1.2.3')\n\n    # 获取接口绑定流端点对象\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    # 创建OSPFv2绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv4ServerStats', 'Dhcpv4ClientBlockStats', 'Dhcpv4ClientStats',\n                            'Dhcpv4PortStats', 'Dhcpv4LeaseStats', ])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待DHCP协议协议会话状态正确\n\n    wait_dhcp_client_state(Sessions=client)\n    wait_dhcp_server_state(Sessions=server)\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取DHCP端口统计\n    import pandas\n    result = get_dhcp_port_statistic()\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dhcp_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_dhcp_port_statistic(Port=Port_Down)\n    print(result)\n\n    # 获取DHCP客户端统计\n    result = get_dhcp_client_statistic()\n    print(result)\n    result = get_dhcp_client_statistic(Session=client)\n    print(result)\n\n    result = get_dhcp_client_block_statistic(Session=client)\n    print(result)\n\n    # 获取DHCP服务器统计\n    result = get_dhcp_server_statistic()\n    print(result)\n    result = get_dhcp_server_statistic(Session=server)\n    print(result)\n\n    result = get_dhcp_server_lease_statistic(Session=server, ClientId='00:00:02:01:01:02')\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  edit_configs:not_found;\nget_configs:获取测试仪表指定对象;\ninit_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_dhcp_client:创建DHCPv4客户端协议会话对象;\ncreate_dhcp_server:创建DHCP Server会话对象;\nget_dhcp_client_block_statistic:获取Dhcp Client Block Statistic统计结果;\nget_dhcp_client_statistic:获取Dhcp Client Statistic统计结果;\nget_dhcp_port_statistic:获取Dhcp Port Statistic统计结果;\nget_dhcp_server_lease_statistic:获取Dhcp Server Lease Statistic统计结果;\nget_dhcp_server_statistic:获取 Dhcp Server Statistic 统计结果;\nwait_dhcp_client_state:等待DHCP协议会话达到指定状态;\nwait_dhcp_server_state:等待DHCP服务器协议会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/ISIS/ISIS_IPv4.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查ISIS协议IPv4绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建ISIS协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     :   Test Objective: Verify normal transmission of ISIS protocol IPv4 binding flow\n\nStep          :   Test Step 1: Reserve two loopback ports Port_1, Port_2;\n                  Test Step 2: Configure ISIS protocol on both ports and create routes;\n                  Test Step 3: Create binding flow;\n                  Test Step 4: Subscribe to StreamBlockStats;\n                  Test Step 5: Transmit all traffic and wait;\n                  Test Step 6: Stop all traffic and check StreamBlockStats;\n\nCriteria      :   Expected Result 1: All traffic shows equal Tx/Rx packet counts in Step 6;\n\nCreated by    :   Tester-001\n\nBugs          :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                          Layer='IPv4Layer',\n                          Address='192.168.1.2',\n                          Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                          Layer='IPv4Layer',\n                          Address='192.168.1.3',\n                          Gateway='192.168.1.2')\n\n    # 创建ISIS协议会话\n\n    session_1 = create_isis(Port=Port_UP)\n    session_2 = create_isis(Port=Port_Down)\n\n    edit_isis(Session=session_1, Level='L1L2', MtParams=2, PerPduAuthentication=4)\n    edit_isis(Session=session_2, Level='L1L2', MtParams=2, PerPduAuthentication=4)\n\n    # 修改ISIS Mt参数\n\n    edit_isis_mt_params(Session=session_1, Index=0, MtId='IPV4', MtFlags='NOSHOW')\n    edit_isis_mt_params(Session=session_1, Index=1, MtId='IPV6', MtFlags=['ABIT', 'OBIT'])\n    mt = get_isis_mt_params(Session=session_1, Index=0)\n    print(mt)\n    mt = get_isis_mt_params(Session=session_1, Index=1)\n    print(mt)\n\n    edit_isis_mt_params(Session=session_2, Index=0, MtId='IPV4', MtFlags='NOSHOW')\n    edit_isis_mt_params(Session=session_2, Index=1, MtId='IPV6', MtFlags=['ABIT', 'OBIT'])\n    mt = get_isis_mt_params(Session=session_2, Index=0)\n    print(mt)\n    mt = get_isis_mt_params(Session=session_2, Index=1)\n    print(mt)\n\n    # 修改ISIS PerPduAuthentication参数\n\n    edit_isis_per_pdu(Session=session_1, Index=0, PdusType='L1_HELLO', AuthMethod='NONE')\n    edit_isis_per_pdu(Session=session_1, Index=1, PdusType='L2_HELLO', AuthMethod='SIMPLE', Password='test')\n    edit_isis_per_pdu(Session=session_1, Index=2, PdusType='L1_AREA_PDUS', AuthMethod='MD5', Password='test')\n    edit_isis_per_pdu(Session=session_1, Index=3, PdusType='L2_DOMAIN_PDUS', AuthMethod='NONE')\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=0)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=1)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=2)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=3)\n    print(per_pdu)\n\n    edit_isis_per_pdu(Session=session_2, Index=0, PdusType='L1_HELLO', AuthMethod='NONE')\n    edit_isis_per_pdu(Session=session_2, Index=1, PdusType='L2_HELLO', AuthMethod='SIMPLE', Password='test')\n    edit_isis_per_pdu(Session=session_2, Index=2, PdusType='L1_AREA_PDUS', AuthMethod='MD5', Password='test')\n    edit_isis_per_pdu(Session=session_2, Index=3, PdusType='L2_DOMAIN_PDUS', AuthMethod='NONE')\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=0)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=1)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=2)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=3)\n    print(per_pdu)\n\n    # ISIS协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # ISIS协议会话创建LSP\n\n    ipv4_lsp_1 = create_isis_lsp(Session=session_1, Level='L1')\n    ipv4_lsp_2 = create_isis_lsp(Session=session_2, Level='L1')\n\n    # ISIS协议会话LSP创建IPv4 TLV\n\n    ipv4_tlv_1 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_1, RouteCount=10)\n    ipv4_tlv_2 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_2, RouteCount=10)\n\n    # 获取ISIS协议绑定流端点对象\n\n    point_1 = get_isis_router_from_tlv(Configs=ipv4_tlv_1)\n    point_2 = get_isis_router_from_tlv(Configs=ipv4_tlv_2)\n\n    # 创建ISIS绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['IsisSessionStats', 'IsisTlvStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待ISIS协议会话稳定状态\n\n    wait_isis_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    import pandas\n    result = get_isis_session_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_isis_tlv_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_isis:创建ISIS协议会话对象",
      "create_isis_ipv4_tlv:创建ISIS IPv4 TLV对象",
      "create_isis_lsp:创建ISIS LSP对象",
      "edit_isis:编辑ISIS协议会话对象参数",
      "edit_isis_mt_params:编辑ISIS协议会话MT参数",
      "edit_isis_per_pdu:编辑ISIS协议会话Per Pdu Authentication参数",
      "get_isis_mt_params:获取ISIS协议会话MT参数",
      "get_isis_per_pdu:获取ISIS协议会话Per Pdu Authentication参数",
      "get_isis_router_from_tlv:获取 ISIS TLV 对应的绑定流源或目的端点对象",
      "get_isis_session_stats:获取 Isis Session 统计结果",
      "get_isis_tlv_stats:获取 Isis Session 统计结果",
      "wait_isis_state:等待ISIS协议会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two test ports using reserve_port API with specified locations.\",\n  \"Subtask 2\": \"Create IPv4 interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 3\": \"Configure IPv4 addresses and gateways for both interfaces using edit_interface API.\",\n  \"Subtask 4\": \"Create ISIS protocol sessions on both ports using create_isis API.\",\n  \"Subtask 5\": \"Edit ISIS session parameters (Level, MT Params, Per PDU Authentication) for both sessions using edit_isis, edit_isis_mt_params, and edit_isis_per_pdu APIs.\",\n  \"Subtask 6\": \"Bind ISIS sessions to their respective interfaces using select_interface API.\",\n  \"Subtask 7\": \"Create ISIS LSP objects for both sessions at L1 level using create_isis_lsp API.\",\n  \"Subtask 8\": \"Create ISIS IPv4 TLV objects with 10 routes for both LSPs using create_isis_ipv4_tlv API.\",\n  \"Subtask 9\": \"Retrieve binding flow endpoints from created IPv4 TLVs using get_isis_router_from_tlv API.\",\n  \"Subtask 10\": \"Create bidirectional binding flow between endpoints using add_stream API.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats, IsisSessionStats, and IsisTlvStats using subscribe_result API.\",\n  \"Subtask 12\": \"Save test configuration using save_case API.\",\n  \"Subtask 13\": \"Start ISIS protocol using start_protocol API and wait for sessions to reach stable state using wait_isis_state API.\",\n  \"Subtask 14\": \"Start traffic transmission using start_stream API and wait for 10 seconds.\",\n  \"Subtask 15\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 16\": \"Stop ISIS protocol using stop_protocol API.\",\n  \"Subtask 17\": \"Retrieve StreamBlock statistics for first stream using get_streamblock_statistic API.\",\n  \"Subtask 18\": \"Verify TxStreamFrames equals RxStreamFrames for first stream.\",\n  \"Subtask 19\": \"Retrieve StreamBlock statistics for second stream using get_streamblock_statistic API.\",\n  \"Subtask 20\": \"Verify TxStreamFrames equals RxStreamFrames for second stream.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     :   Test Objective: Verify normal transmission of ISIS protocol IPv4 binding flow\n\nStep          :   Test Step 1: Reserve two loopback ports Port_1, Port_2;\n                  Test Step 2: Configure ISIS protocol on both ports and create routes;\n                  Test Step 3: Create binding flow;\n                  Test Step 4: Subscribe to StreamBlockStats;\n                  Test Step 5: Transmit all traffic and wait;\n                  Test Step 6: Stop all traffic and check StreamBlockStats;\n\nCriteria      :   Expected Result 1: All traffic shows equal Tx/Rx packet counts in Step 6;\n\nCreated by    :   Tester-001\n\nBugs          :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                          Layer='IPv4Layer',\n                          Address='192.168.1.2',\n                          Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                          Layer='IPv4Layer',\n                          Address='192.168.1.3',\n                          Gateway='192.168.1.2')\n\n    # 创建ISIS协议会话\n\n    session_1 = create_isis(Port=Port_UP)\n    session_2 = create_isis(Port=Port_Down)\n\n    edit_isis(Session=session_1, Level='L1L2', MtParams=2, PerPduAuthentication=4)\n    edit_isis(Session=session_2, Level='L1L2', MtParams=2, PerPduAuthentication=4)\n\n    # 修改ISIS Mt参数\n\n    edit_isis_mt_params(Session=session_1, Index=0, MtId='IPV4', MtFlags='NOSHOW')\n    edit_isis_mt_params(Session=session_1, Index=1, MtId='IPV6', MtFlags=['ABIT', 'OBIT'])\n    mt = get_isis_mt_params(Session=session_1, Index=0)\n    print(mt)\n    mt = get_isis_mt_params(Session=session_1, Index=1)\n    print(mt)\n\n    edit_isis_mt_params(Session=session_2, Index=0, MtId='IPV4', MtFlags='NOSHOW')\n    edit_isis_mt_params(Session=session_2, Index=1, MtId='IPV6', MtFlags=['ABIT', 'OBIT'])\n    mt = get_isis_mt_params(Session=session_2, Index=0)\n    print(mt)\n    mt = get_isis_mt_params(Session=session_2, Index=1)\n    print(mt)\n\n    # 修改ISIS PerPduAuthentication参数\n\n    edit_isis_per_pdu(Session=session_1, Index=0, PdusType='L1_HELLO', AuthMethod='NONE')\n    edit_isis_per_pdu(Session=session_1, Index=1, PdusType='L2_HELLO', AuthMethod='SIMPLE', Password='test')\n    edit_isis_per_pdu(Session=session_1, Index=2, PdusType='L1_AREA_PDUS', AuthMethod='MD5', Password='test')\n    edit_isis_per_pdu(Session=session_1, Index=3, PdusType='L2_DOMAIN_PDUS', AuthMethod='NONE')\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=0)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=1)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=2)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_1, Index=3)\n    print(per_pdu)\n\n    edit_isis_per_pdu(Session=session_2, Index=0, PdusType='L1_HELLO', AuthMethod='NONE')\n    edit_isis_per_pdu(Session=session_2, Index=1, PdusType='L2_HELLO', AuthMethod='SIMPLE', Password='test')\n    edit_isis_per_pdu(Session=session_2, Index=2, PdusType='L1_AREA_PDUS', AuthMethod='MD5', Password='test')\n    edit_isis_per_pdu(Session=session_2, Index=3, PdusType='L2_DOMAIN_PDUS', AuthMethod='NONE')\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=0)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=1)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=2)\n    print(per_pdu)\n    per_pdu = get_isis_per_pdu(Session=session_2, Index=3)\n    print(per_pdu)\n\n    # ISIS协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # ISIS协议会话创建LSP\n\n    ipv4_lsp_1 = create_isis_lsp(Session=session_1, Level='L1')\n    ipv4_lsp_2 = create_isis_lsp(Session=session_2, Level='L1')\n\n    # ISIS协议会话LSP创建IPv4 TLV\n\n    ipv4_tlv_1 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_1, RouteCount=10)\n    ipv4_tlv_2 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_2, RouteCount=10)\n\n    # 获取ISIS协议绑定流端点对象\n\n    point_1 = get_isis_router_from_tlv(Configs=ipv4_tlv_1)\n    point_2 = get_isis_router_from_tlv(Configs=ipv4_tlv_2)\n\n    # 创建ISIS绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['IsisSessionStats', 'IsisTlvStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待ISIS协议会话稳定状态\n\n    wait_isis_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    import pandas\n    result = get_isis_session_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_isis_tlv_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_isis:创建ISIS协议会话对象;\ncreate_isis_ipv4_tlv:创建ISIS IPv4 TLV对象;\ncreate_isis_lsp:创建ISIS LSP对象;\nedit_isis:编辑ISIS协议会话对象参数;\nedit_isis_mt_params:编辑ISIS协议会话MT参数;\nedit_isis_per_pdu:编辑ISIS协议会话Per Pdu Authentication参数;\nget_isis_mt_params:获取ISIS协议会话MT参数;\nget_isis_per_pdu:获取ISIS协议会话Per Pdu Authentication参数;\nget_isis_router_from_tlv:获取 ISIS TLV 对应的绑定流源或目的端点对象;\nget_isis_session_stats:获取 Isis Session 统计结果;\nget_isis_tlv_stats:获取 Isis Session 统计结果;\nwait_isis_state:等待ISIS协议会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/BGP/BGP.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查BGP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建BGP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Objective: To verify that the bound flow of BGP protocol is transmitted correctly.\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                Step 2: Create BGP protocols and establish routes on both ports respectively;\n                Step 3: Create bound traffic;\n                Step 4: Subscribe to StreamBlockStats;\n                Step 5: Transmit all traffic and wait for a period;\n                Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In step 6, transmitted and received packets are equal for all traffic;\n\nCreated by   :   Tester-001\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建BGP协议会话\n    session_1 = create_bgp(Port=Port_UP)\n    session_2 = create_bgp(Port=Port_Down)\n\n    edit_bgp(Session=session_1, AsNumber=100, DutAsNumber=200)\n    edit_bgp(Session=session_2, AsNumber=200, DutAsNumber=100)\n\n    # BGP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # BGP协议会话1创建ipv4 route pool\n\n    ipv4_route_1 = create_bgp_ipv4_route_pool(Session=session_1, FirstRoute='100.0.0.1')\n    ipv4_route_2 = create_bgp_ipv4_route_pool(Session=session_2, FirstRoute='200.0.0.1')\n\n    component_type = ['Type1']\n    flow_specs = create_bgp_ipv4_flow_specs(Session=session_1, Origin='INCOMPLETE', ComponentType=component_type)\n    flow_spec_conponent_type = create_bgp_flow_spec_conponent_type(FlowSpec=flow_specs, Types=1, IpValue='71.2.0.0',\n                                                                   PrefixLength='32', Count='1000')\n    flow_specs_actions = create_bgp_flow_specs_actions(FlowSpec=flow_specs, EnableTrafficRate=True, TrafficRate=100000,\n                                                       EnableRedirectToIpNextHop=True, NextHop='13.21.4.2')\n\n    # 获取BGP协议绑定流端点对象\n\n    point_1 = get_bgp_router_from_route_pool(Configs=ipv4_route_1)\n    point_2 = get_bgp_router_from_route_pool(Configs=ipv4_route_2)\n\n    # 创建BGP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['BgpSessionStatistic', 'BgpSessionBlockStatistic', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待BGP协议会话达到Full状态\n\n    wait_bgp_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取流量1统计\n    result = get_bgp_session_statistic(Session=session_1, Id=1)\n    print(result)\n    result = get_bgp_session_statistic(Session=session_2, Id=1)\n    print(result)\n    result = get_bgp_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_bgp_session_block_statistic(Session=session_2)\n    print(result)\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "create_bgp:创建BGP协议会话对象",
      "create_bgp_flow_spec_conponent_type:创建Bgp Flow Specs Conponent Type对象, 类型为：object / list",
      "create_bgp_flow_specs_actions:创建Bgp Ipv4 Flow Specs Actions对象, 类型为：object / list",
      "create_bgp_ipv4_flow_specs:创建Bgp Ipv4 Flow Specs对象, 类型为：object / list",
      "create_bgp_ipv4_route_pool:创建BGP IPv4路由对象",
      "edit_bgp:编辑Bgp协议会话对象参数",
      "get_bgp_router_from_route_pool:获取 BGP Route Pool 对应的绑定流源或目的端点对象",
      "get_bgp_session_block_statistic:获取Bgp Session Block统计结果",
      "get_bgp_session_statistic:获取Bgp Session统计结果",
      "wait_bgp_state:等待BGP协议会话达到指定状态",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (default 'DarYu').\",\n  \"Subtask 2\": \"Reserve two physical ports and assign them as Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both reserved ports.\",\n  \"Subtask 4\": \"Configure IPv4 addresses and gateways for both interfaces (Port_UP: 192.168.1.2/192.168.1.3, Port_Down: 192.168.1.3/192.168.1.2).\",\n  \"Subtask 5\": \"Create BGP sessions on both ports.\",\n  \"Subtask 6\": \"Configure BGP session parameters (Port_UP: AS 100/DUT AS 200, Port_Down: AS 200/DUT AS 100).\",\n  \"Subtask 7\": \"Bind BGP sessions to their respective IPv4 interfaces.\",\n  \"Subtask 8\": \"Create BGP IPv4 route pools on both sessions (Port_UP: '100.0.0.1', Port_Down: '200.0.0.1').\",\n  \"Subtask 9\": \"Create BGP IPv4 flow specs on Port_UP session with origin 'INCOMPLETE' and component type 'Type1'.\",\n  \"Subtask 10\": \"Configure flow spec component type with IP '71.2.0.0', prefix length 32, and count 1000.\",\n  \"Subtask 11\": \"Configure flow spec actions enabling traffic rate (100000) and redirect to next hop (13.21.4.2).\",\n  \"Subtask 12\": \"Retrieve BGP router endpoints from both route pools for traffic binding.\",\n  \"Subtask 13\": \"Create bidirectional bound streams between the source and destination endpoints.\",\n  \"Subtask 14\": \"Subscribe to BgpSessionStatistic, BgpSessionBlockStatistic, and StreamBlockStats views.\",\n  \"Subtask 15\": \"Save test configuration to file.\",\n  \"Subtask 16\": \"Start BGP protocol sessions.\",\n  \"Subtask 17\": \"Wait until both BGP sessions reach Full state, then pause 5 seconds.\",\n  \"Subtask 18\": \"Start all traffic streams.\",\n  \"Subtask 19\": \"Wait 10 seconds during traffic transmission.\",\n  \"Subtask 20\": \"Stop all traffic streams.\",\n  \"Subtask 21\": \"Stop BGP protocol sessions.\",\n  \"Subtask 22\": \"Wait 3 seconds for statistics finalization.\",\n  \"Subtask 23\": \"Retrieve StreamBlockStats for each bound stream and verify transmitted frames equal received frames.\",\n  \"Subtask 24\": \"Record test failure if any stream shows packet count mismatch.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Objective: To verify that the bound flow of BGP protocol is transmitted correctly.\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                Step 2: Create BGP protocols and establish routes on both ports respectively;\n                Step 3: Create bound traffic;\n                Step 4: Subscribe to StreamBlockStats;\n                Step 5: Transmit all traffic and wait for a period;\n                Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In step 6, transmitted and received packets are equal for all traffic;\n\nCreated by   :   Tester-001\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建BGP协议会话\n    session_1 = create_bgp(Port=Port_UP)\n    session_2 = create_bgp(Port=Port_Down)\n\n    edit_bgp(Session=session_1, AsNumber=100, DutAsNumber=200)\n    edit_bgp(Session=session_2, AsNumber=200, DutAsNumber=100)\n\n    # BGP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # BGP协议会话1创建ipv4 route pool\n\n    ipv4_route_1 = create_bgp_ipv4_route_pool(Session=session_1, FirstRoute='100.0.0.1')\n    ipv4_route_2 = create_bgp_ipv4_route_pool(Session=session_2, FirstRoute='200.0.0.1')\n\n    component_type = ['Type1']\n    flow_specs = create_bgp_ipv4_flow_specs(Session=session_1, Origin='INCOMPLETE', ComponentType=component_type)\n    flow_spec_conponent_type = create_bgp_flow_spec_conponent_type(FlowSpec=flow_specs, Types=1, IpValue='71.2.0.0',\n                                                                   PrefixLength='32', Count='1000')\n    flow_specs_actions = create_bgp_flow_specs_actions(FlowSpec=flow_specs, EnableTrafficRate=True, TrafficRate=100000,\n                                                       EnableRedirectToIpNextHop=True, NextHop='13.21.4.2')\n\n    # 获取BGP协议绑定流端点对象\n\n    point_1 = get_bgp_router_from_route_pool(Configs=ipv4_route_1)\n    point_2 = get_bgp_router_from_route_pool(Configs=ipv4_route_2)\n\n    # 创建BGP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['BgpSessionStatistic', 'BgpSessionBlockStatistic', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待BGP协议会话达到Full状态\n\n    wait_bgp_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取流量1统计\n    result = get_bgp_session_statistic(Session=session_1, Id=1)\n    print(result)\n    result = get_bgp_session_statistic(Session=session_2, Id=1)\n    print(result)\n    result = get_bgp_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_bgp_session_block_statistic(Session=session_2)\n    print(result)\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\ncreate_bgp:创建BGP协议会话对象;\ncreate_bgp_flow_spec_conponent_type:创建Bgp Flow Specs Conponent Type对象, 类型为：object / list;\ncreate_bgp_flow_specs_actions:创建Bgp Ipv4 Flow Specs Actions对象, 类型为：object / list;\ncreate_bgp_ipv4_flow_specs:创建Bgp Ipv4 Flow Specs对象, 类型为：object / list;\ncreate_bgp_ipv4_route_pool:创建BGP IPv4路由对象;\nedit_bgp:编辑Bgp协议会话对象参数;\nget_bgp_router_from_route_pool:获取 BGP Route Pool 对应的绑定流源或目的端点对象;\nget_bgp_session_block_statistic:获取Bgp Session Block统计结果;\nget_bgp_session_statistic:获取Bgp Session统计结果;\nwait_bgp_state:等待BGP协议会话达到指定状态;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/DHCP/DHCPv6.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查DHCPv6协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建DHCPv6协议;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Verify normal transmission of DHCPv6 binding traffic  \n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;  \nTest Step 2: Configure DHCPv6 protocol on both ports respectively;  \nTest Step 3: Create binding traffic;  \nTest Step 4: Subscribe to StreamBlockStats;  \nTest Step 5: Transmit all traffic and wait for a period;  \nTest Step 6: Stop all traffic and check StreamBlockStats;  \n\nCriteria: Expected Result 1: In Step 6, all sent and received packets are equal;  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2011::2',\n                   Gateway='2011::1')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2011::1',\n                   Gateway='2011::2')\n\n    # 创建DHCPv6协议会话\n\n    client = create_dhcpv6_client(Port=Port_UP, Name='Client')\n\n    server = create_dhcpv6_server(Port=Port_Down, Name='Server')\n\n    # DHCPv6协议会话与接口绑定\n\n    select_interface(Session=client, Interface=interfaces_1)\n\n    select_interface(Session=server, Interface=interfaces_2)\n\n    # 获取DHCP Server地址池\n    pool = create_dhcpv6_server_address_pool(Sessions=server, StartAddress='2011::2')\n\n    # 获取接口绑定流端点对象\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv6')\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv6')\n\n    # 创建DHCP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv6PortStatistics', 'Dhcpv6ClientBlockStatistics',\n                            'Dhcpv6ServerStatistics', 'Dhcpv6LeaseStatistics'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待DHCP协议协议会话状态正确\n\n    wait_dhcpv6_client_state(Sessions=client)\n    wait_dhcpv6_server_state(Sessions=server)\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取DHCP端口统计\n    import pandas\n    result = get_dhcpv6_port_statistic()\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dhcpv6_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_dhcpv6_port_statistic(Port=Port_Down)\n    print(result)\n\n    # 获取DHCP客户端统计\n    result = get_dhcpv6_client_block_statistic()\n    print(result)\n    result = get_dhcpv6_client_block_statistic(Session=client)\n    print(result)\n\n    # 获取DHCP服务器统计\n    result = get_dhcpv6_server_statistic()\n    print(result)\n    result = get_dhcpv6_server_statistic(Session=server)\n    print(result)\n\n    result = get_dhcpv6_server_lease_statistic()\n    print(result)\n    result = get_dhcpv6_server_lease_statistic(Session=server, Pool=pool)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_dhcpv6_client:创建DHCPv6客户端会话对象",
      "create_dhcpv6_server:创建DHCPv6服务端会话对象",
      "create_dhcpv6_server_address_pool:创建DHCPv6 Server Address Pool对象",
      "get_dhcpv6_client_block_statistic:获取 Dhcpv6 Client Block Statistic 统计结果",
      "get_dhcpv6_port_statistic:获取Dhcpv6 Port Statistic统计结果",
      "get_dhcpv6_server_lease_statistic:获取Dhcpv6 Server Lease Statistic统计结果",
      "get_dhcpv6_server_statistic:获取Dhcpv6 Server Statistic统计结果",
      "wait_dhcpv6_client_state:等待Dhcpv6客户端会话达到指定状态",
      "wait_dhcpv6_server_state:等待Dhcpv6服务端会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) for testing.\",\n  \"Subtask 3\": \"Create IPv6 interfaces on both reserved ports and configure IPv6 addresses/gateways (Port_1: 2011::2/2011::1, Port_2: 2011::1/2011::2).\",\n  \"Subtask 4\": \"Create DHCPv6 client session on Port_1 and DHCPv6 server session on Port_2.\",\n  \"Subtask 5\": \"Bind both DHCPv6 sessions to their respective IPv6 interfaces.\",\n  \"Subtask 6\": \"Create DHCPv6 server address pool with start address 2011::2.\",\n  \"Subtask 7\": \"Retrieve IPv6 layer objects from both interfaces for traffic endpoint configuration.\",\n  \"Subtask 8\": \"Create bidirectional binding traffic streams between the IPv6 endpoints of Port_1 and Port_2.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats and DHCPv6 statistics (port, client block, server, lease).\",\n  \"Subtask 10\": \"Save test configuration to file.\",\n  \"Subtask 11\": \"Start DHCPv6 protocol sessions and wait until both client and server reach operational state.\",\n  \"Subtask 12\": \"Start all traffic streams and wait 10 seconds for transmission.\",\n  \"Subtask 13\": \"Stop all traffic streams.\",\n  \"Subtask 14\": \"Stop DHCPv6 protocol sessions.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats for each traffic stream and verify TxStreamFrames equals RxStreamFrames for both streams.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Verify normal transmission of DHCPv6 binding traffic  \n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;  \nTest Step 2: Configure DHCPv6 protocol on both ports respectively;  \nTest Step 3: Create binding traffic;  \nTest Step 4: Subscribe to StreamBlockStats;  \nTest Step 5: Transmit all traffic and wait for a period;  \nTest Step 6: Stop all traffic and check StreamBlockStats;  \n\nCriteria: Expected Result 1: In Step 6, all sent and received packets are equal;  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2011::2',\n                   Gateway='2011::1')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2011::1',\n                   Gateway='2011::2')\n\n    # 创建DHCPv6协议会话\n\n    client = create_dhcpv6_client(Port=Port_UP, Name='Client')\n\n    server = create_dhcpv6_server(Port=Port_Down, Name='Server')\n\n    # DHCPv6协议会话与接口绑定\n\n    select_interface(Session=client, Interface=interfaces_1)\n\n    select_interface(Session=server, Interface=interfaces_2)\n\n    # 获取DHCP Server地址池\n    pool = create_dhcpv6_server_address_pool(Sessions=server, StartAddress='2011::2')\n\n    # 获取接口绑定流端点对象\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv6')\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv6')\n\n    # 创建DHCP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv6PortStatistics', 'Dhcpv6ClientBlockStatistics',\n                            'Dhcpv6ServerStatistics', 'Dhcpv6LeaseStatistics'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待DHCP协议协议会话状态正确\n\n    wait_dhcpv6_client_state(Sessions=client)\n    wait_dhcpv6_server_state(Sessions=server)\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取DHCP端口统计\n    import pandas\n    result = get_dhcpv6_port_statistic()\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dhcpv6_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_dhcpv6_port_statistic(Port=Port_Down)\n    print(result)\n\n    # 获取DHCP客户端统计\n    result = get_dhcpv6_client_block_statistic()\n    print(result)\n    result = get_dhcpv6_client_block_statistic(Session=client)\n    print(result)\n\n    # 获取DHCP服务器统计\n    result = get_dhcpv6_server_statistic()\n    print(result)\n    result = get_dhcpv6_server_statistic(Session=server)\n    print(result)\n\n    result = get_dhcpv6_server_lease_statistic()\n    print(result)\n    result = get_dhcpv6_server_lease_statistic(Session=server, Pool=pool)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_dhcpv6_client:创建DHCPv6客户端会话对象;\ncreate_dhcpv6_server:创建DHCPv6服务端会话对象;\ncreate_dhcpv6_server_address_pool:创建DHCPv6 Server Address Pool对象;\nget_dhcpv6_client_block_statistic:获取 Dhcpv6 Client Block Statistic 统计结果;\nget_dhcpv6_port_statistic:获取Dhcpv6 Port Statistic统计结果;\nget_dhcpv6_server_lease_statistic:获取Dhcpv6 Server Lease Statistic统计结果;\nget_dhcpv6_server_statistic:获取Dhcpv6 Server Statistic统计结果;\nwait_dhcpv6_client_state:等待Dhcpv6客户端会话达到指定状态;\nwait_dhcpv6_server_state:等待Dhcpv6服务端会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/DHCP/DHCPv4_5000session.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查DHCPv4协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建DHCPv4协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify normal transmission of DHCPv4 protocol binding flow\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create DHCPv4 protocols on both ports respectively and establish routes;\n      Step 3: Create binding traffic;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a duration;\n      Step 6: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for all traffic are equal;\n\nCreated by: Tester-004\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Ports = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Ports[0], Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Count=5000)\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='12.12.12.2',\n                   PrefixLength=19,\n                   Gateway='12.12.12.1')\n    interfaces_2 = create_interface(Port=Ports[1], Layers=['ipv4'])\n    # 保证MAC地址不冲突\n    edit_interface(Interface=interfaces_2,\n                   Layer='EthIILayer',\n                   Address='12:12:12:12:12:12')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='12.12.12.1',\n                   PrefixLength=19,\n                   Gateway='12.12.12.2')\n\n    # 创建DHCPv4协议会话\n    client = create_dhcp_client(Port=Ports[0])\n    server = create_dhcp_server(Port=Ports[1])\n    # DHCPv4协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_1)\n    select_interface(Session=server, Interface=interfaces_2)\n    # 获取DHCP Server地址池\n    configDict = get_configs(Configs='Dhcpv4AddressPool')\n    dhcpv4AddressPool = list(configDict.values())[0]\n    edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='12.12.12.2', PrefixLength=19, PoolAddressCount=5100)\n    # 获取接口绑定流端点对象\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n    # 创建DHCPV4绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv4ServerStats', 'Dhcpv4ClientBlockStats',\n                            'Dhcpv4PortStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动协议\n    start_protocol()\n    # 等待DHCP协议协议会话状态正确\n    wait_dhcp_client_state(Sessions=client)\n    wait_dhcp_server_state(Sessions=server)\n    time.sleep(5)\n    # 发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取DHCP端口统计\n    result = get_dhcp_port_statistic(Port=Ports[0])\n    CurrentBound = result['CurrentBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP客户端统计\n    result = get_dhcp_client_block_statistic(Session=client)\n    CurrentBound = result['CurrentBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP服务器统计\n    result = get_dhcp_server_statistic(Session=server)\n    CurrentBound = result['CurrentBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取流量1统计\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 获取流量2统计\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "edit_configs:not_found",
      "get_configs:获取测试仪表指定对象",
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "create_dhcp_client:创建DHCPv4客户端协议会话对象",
      "create_dhcp_server:创建DHCP Server会话对象",
      "get_dhcp_client_block_statistic:获取Dhcp Client Block Statistic统计结果",
      "get_dhcp_port_statistic:获取Dhcp Port Statistic统计结果",
      "get_dhcp_server_statistic:获取 Dhcp Server Statistic 统计结果",
      "wait_dhcp_client_state:等待DHCP协议会话达到指定状态",
      "wait_dhcp_server_state:等待DHCP服务器协议会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations using reserve_port API with Force=True parameter.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 4\": \"Configure first interface with 5000 counts, IP address 12.12.12.2/19, and gateway 12.12.12.1 using edit_interface API.\",\n  \"Subtask 5\": \"Configure second interface with MAC address 12:12:12:12:12:12, IP address 12.12.12.1/19, and gateway 12.12.12.2 using edit_interface API.\",\n  \"Subtask 6\": \"Create DHCPv4 client session on first port and DHCPv4 server session on second port using create_dhcp_client and create_dhcp_server APIs.\",\n  \"Subtask 7\": \"Bind created interfaces to DHCP sessions using select_interface API.\",\n  \"Subtask 8\": \"Configure DHCP server address pool with start address 12.12.12.2, prefix length 19, and 5100 addresses using edit_configs API.\",\n  \"Subtask 9\": \"Retrieve layer objects from both interfaces using get_layer_from_interfaces API.\",\n  \"Subtask 10\": \"Create bidirectional binding traffic between layer objects using add_stream API with Bidirection=True.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats, Dhcpv4ServerStats, Dhcpv4ClientBlockStats, and Dhcpv4PortStats using subscribe_result API.\",\n  \"Subtask 12\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 13\": \"Start DHCP protocols using start_protocol API.\",\n  \"Subtask 14\": \"Wait for DHCP client and server sessions to reach bound state using wait_dhcp_client_state and wait_dhcp_server_state APIs.\",\n  \"Subtask 15\": \"Start traffic transmission using start_stream API and wait 10 seconds.\",\n  \"Subtask 16\": \"Stop traffic transmission using stop_stream API and wait 3 seconds.\",\n  \"Subtask 17\": \"Validate DHCP port statistics: verify CurrentBound and TotalBound both equal 5000 using get_dhcp_port_statistic API and assert.\",\n  \"Subtask 18\": \"Validate DHCP client statistics: verify CurrentBound and TotalBound both equal 5000 using get_dhcp_client_block_statistic API and assert.\",\n  \"Subtask 19\": \"Validate DHCP server statistics: verify CurrentBound and TotalBound both equal 5000 using get_dhcp_server_statistic API and assert.\",\n  \"Subtask 20\": \"Validate first stream statistics: verify TxStreamFrames equals RxStreamFrames using get_streamblock_statistic API and assert.\",\n  \"Subtask 21\": \"Validate second stream statistics: verify TxStreamFrames equals RxStreamFrames using get_streamblock_statistic API and assert.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify normal transmission of DHCPv4 protocol binding flow\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create DHCPv4 protocols on both ports respectively and establish routes;\n      Step 3: Create binding traffic;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a duration;\n      Step 6: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for all traffic are equal;\n\nCreated by: Tester-004\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Ports = reserve_port(Locations=locations, Force=True)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Ports[0], Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1, Count=5000)\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='12.12.12.2',\n                   PrefixLength=19,\n                   Gateway='12.12.12.1')\n    interfaces_2 = create_interface(Port=Ports[1], Layers=['ipv4'])\n    # 保证MAC地址不冲突\n    edit_interface(Interface=interfaces_2,\n                   Layer='EthIILayer',\n                   Address='12:12:12:12:12:12')\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='12.12.12.1',\n                   PrefixLength=19,\n                   Gateway='12.12.12.2')\n\n    # 创建DHCPv4协议会话\n    client = create_dhcp_client(Port=Ports[0])\n    server = create_dhcp_server(Port=Ports[1])\n    # DHCPv4协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_1)\n    select_interface(Session=server, Interface=interfaces_2)\n    # 获取DHCP Server地址池\n    configDict = get_configs(Configs='Dhcpv4AddressPool')\n    dhcpv4AddressPool = list(configDict.values())[0]\n    edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='12.12.12.2', PrefixLength=19, PoolAddressCount=5100)\n    # 获取接口绑定流端点对象\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n    # 创建DHCPV4绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'Dhcpv4ServerStats', 'Dhcpv4ClientBlockStats',\n                            'Dhcpv4PortStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动协议\n    start_protocol()\n    # 等待DHCP协议协议会话状态正确\n    wait_dhcp_client_state(Sessions=client)\n    wait_dhcp_server_state(Sessions=server)\n    time.sleep(5)\n    # 发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取DHCP端口统计\n    result = get_dhcp_port_statistic(Port=Ports[0])\n    CurrentBound = result['CurrentBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP客户端统计\n    result = get_dhcp_client_block_statistic(Session=client)\n    CurrentBound = result['CurrentBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取DHCP服务器统计\n    result = get_dhcp_server_statistic(Session=server)\n    CurrentBound = result['CurrentBound']\n    TotalBound = result['TotalBound']\n    assert CurrentBound == TotalBound == 5000\n    # 获取流量1统计\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 获取流量2统计\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  edit_configs:not_found;\nget_configs:获取测试仪表指定对象;\ninit_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\ncreate_dhcp_client:创建DHCPv4客户端协议会话对象;\ncreate_dhcp_server:创建DHCP Server会话对象;\nget_dhcp_client_block_statistic:获取Dhcp Client Block Statistic统计结果;\nget_dhcp_port_statistic:获取Dhcp Port Statistic统计结果;\nget_dhcp_server_statistic:获取 Dhcp Server Statistic 统计结果;\nwait_dhcp_client_state:等待DHCP协议会话达到指定状态;\nwait_dhcp_server_state:等待DHCP服务器协议会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/LDP/LDP.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查LDP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建LDP协议;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Check that the LDP protocol bound flow is sent normally\n\nStep 1: Reserve two loopback ports Port_1 and Port_2;\nStep 2: Create LDP protocol on each port respectively;\nStep 3: Create bound traffic;\nStep 4: Subscribe to StreamBlockStats statistics;\nStep 5: Send all traffic and wait for a period of time;\nStep 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, sent and received packets for all traffic are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建LDP协议会话\n\n    session_1 = create_ldp(Port=Port_UP, DutIpv4Address='1.1.1.2')\n\n    session_2 = create_ldp(Port=Port_Down, DutIpv4Address='1.1.1.1')\n\n    # LDP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建LSP\n\n    lsp_1 = create_ldp_ipv4_egress(Session=session_1)\n\n    lsp_2 = create_ldp_ipv4_egress(Session=session_2)\n\n    # 获取接口绑定流端点对象\n\n    point_1, point_2 = get_ldp_point_from_lsp(Configs=[lsp_1, lsp_2])\n\n    # 创建LDP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'LdpSessionStatistic', 'LdpLspStatistic'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待LDP协议协议会话状态正确\n\n    wait_ldp_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取LDP端口统计\n    import pandas\n\n    result = get_ldp_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ldp_session_statistic(Session=session_1)\n    print(result)\n    result = get_ldp_session_statistic(Session=session_2)\n    print(result)\n\n    # 获取LDP客户端统计\n    result = get_ldp_lsp_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ldp_lsp_statistic(Session=session_1)\n    print(result)\n    result = get_ldp_lsp_statistic(Session=session_2)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_ldp:创建LDP协议会话对象",
      "create_ldp_ipv4_egress:创建LDP IPv4 Egress对象",
      "get_ldp_lsp_statistic:获取Ldp Lsp统计结果",
      "get_ldp_point_from_lsp:获取LDP LSP对应的绑定流源或目的端点对象",
      "get_ldp_session_statistic:获取Ldp Session统计结果",
      "wait_ldp_state:等待LDP协议会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two ports (Port_UP and Port_Down) using reserve_port API with specified locations.\",\n  \"Subtask 2\": \"Create interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 3\": \"Configure IPv4 parameters (address and gateway) for both interfaces using edit_interface API.\",\n  \"Subtask 4\": \"Create LDP sessions on each port using create_ldp API with peer IP addresses.\",\n  \"Subtask 5\": \"Bind LDP sessions to their respective interfaces using select_interface API.\",\n  \"Subtask 6\": \"Create LDP IPv4 Egress objects (LSPs) for both sessions using create_ldp_ipv4_egress API.\",\n  \"Subtask 7\": \"Retrieve LDP stream endpoints from created LSPs using get_ldp_point_from_lsp API.\",\n  \"Subtask 8\": \"Create bidirectional bound traffic streams between endpoints using add_stream API with type='binding' and Bidirection=True.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 10\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 11\": \"Start LDP protocols using start_protocol API.\",\n  \"Subtask 12\": \"Wait for LDP sessions to reach established state using wait_ldp_state API.\",\n  \"Subtask 13\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 14\": \"Wait for 10 seconds to allow traffic flow.\",\n  \"Subtask 15\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 16\": \"Stop LDP protocols using stop_protocol API.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats for first traffic stream using get_streamblock_statistic API and verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats for second traffic stream using get_streamblock_statistic API and verify TxStreamFrames equals RxStreamFrames.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Check that the LDP protocol bound flow is sent normally\n\nStep 1: Reserve two loopback ports Port_1 and Port_2;\nStep 2: Create LDP protocol on each port respectively;\nStep 3: Create bound traffic;\nStep 4: Subscribe to StreamBlockStats statistics;\nStep 5: Send all traffic and wait for a period of time;\nStep 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, sent and received packets for all traffic are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建LDP协议会话\n\n    session_1 = create_ldp(Port=Port_UP, DutIpv4Address='1.1.1.2')\n\n    session_2 = create_ldp(Port=Port_Down, DutIpv4Address='1.1.1.1')\n\n    # LDP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建LSP\n\n    lsp_1 = create_ldp_ipv4_egress(Session=session_1)\n\n    lsp_2 = create_ldp_ipv4_egress(Session=session_2)\n\n    # 获取接口绑定流端点对象\n\n    point_1, point_2 = get_ldp_point_from_lsp(Configs=[lsp_1, lsp_2])\n\n    # 创建LDP绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'LdpSessionStatistic', 'LdpLspStatistic'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待LDP协议协议会话状态正确\n\n    wait_ldp_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取LDP端口统计\n    import pandas\n\n    result = get_ldp_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ldp_session_statistic(Session=session_1)\n    print(result)\n    result = get_ldp_session_statistic(Session=session_2)\n    print(result)\n\n    # 获取LDP客户端统计\n    result = get_ldp_lsp_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ldp_lsp_statistic(Session=session_1)\n    print(result)\n    result = get_ldp_lsp_statistic(Session=session_2)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_ldp:创建LDP协议会话对象;\ncreate_ldp_ipv4_egress:创建LDP IPv4 Egress对象;\nget_ldp_lsp_statistic:获取Ldp Lsp统计结果;\nget_ldp_point_from_lsp:获取LDP LSP对应的绑定流源或目的端点对象;\nget_ldp_session_statistic:获取Ldp Session统计结果;\nwait_ldp_state:等待LDP协议会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/PPPoE/PPPoE.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查PPPoe协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建PPPoe协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     :   Objective: Check that the PPPoE protocol bound stream is transmitted normally\n\nStep          :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                  Step 2: Create PPPoE protocols on both ports respectively and establish routes;\n                  Step 3: Create bound traffic;\n                  Step 4: Subscribe to StreamBlockStats statistics;\n                  Step 5: Transmit all traffic and wait for a period;\n                  Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In Step 6, all traffic shows equal transmitted and received packets;\n\nCreated by    :   Tester-001\n\nBugs          :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    # 修改接口类型\n\n    edit_interface_stack(Interfaces=[interfaces_1, interfaces_2], Layers=['eth', 'pppoe'], Tops=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建PPPoe协议会话\n\n    session_1 = create_pppoe(Port=Port_UP, EmulationMode='client')\n\n    session_2 = create_pppoe(Port=Port_Down, EmulationMode='server')\n\n    # PPPoe协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 获取接口绑定流端点对象\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    # 创建接口绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['PppoePortStatistic', 'PppoeServerBlockStatistic', 'PppoeServerStatistic', 'PppoeClientBlockStatistic', 'PppoeClientStatistic', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PPPoE协议会话达到CONNECTED状态\n\n    wait_pppoe_ipcp_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取PPPOE会话1统计\n    import pandas\n    result = get_pppoe_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pppoe_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_pppoe_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_pppoe_client_block_statistic()\n    print(result)\n\n    result = get_pppoe_client_block_statistic(Session=session_1)\n    print(result)\n\n    result = get_pppoe_client_statistic()\n    print(result)\n\n    result = get_pppoe_client_statistic(Session=session_1)\n    print(result)\n\n    result = get_pppoe_server_block_statistic()\n    print(result)\n\n    result = get_pppoe_server_block_statistic(Session=session_2)\n    print(result)\n\n    result = get_pppoe_server_statistic()\n    print(result)\n    result = get_pppoe_server_statistic(Session=session_2)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                      RxStreamFrames)\n\n    # 释放端口资源\n    result = release_port(Locations=locations)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "edit_interface_stack:修改测试仪表接口的结构",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_pppoe:创建PPPoE协议会话对象",
      "get_pppoe_client_block_statistic:获取PPPoE Server Block Statistic统计结果",
      "get_pppoe_client_statistic:获取PPPoE Client Statistic统计结果",
      "get_pppoe_port_statistic:获取PPPoE Port Statistic统计结果",
      "get_pppoe_server_block_statistic:获取PPPoE Server Block Statistic统计结果",
      "get_pppoe_server_statistic:获取PPPoE Server Statistic统计结果",
      "wait_pppoe_ipcp_state:等待PPPoE IPCP达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (default 'DarYu') and reserve two ports using provided locations.\",\n  \"Subtask 2\": \"Create IPv4 interfaces on both reserved ports and configure their network stacks to include Ethernet and PPPoE layers above IPv4.\",\n  \"Subtask 3\": \"Configure IPv4 addresses and gateways on both interfaces (192.168.1.2/192.168.1.3 for Port_UP, 192.168.1.3/192.168.1.2 for Port_Down).\",\n  \"Subtask 4\": \"Create PPPoE client session on Port_UP and PPPoE server session on Port_Down.\",\n  \"Subtask 5\": \"Bind the created interfaces to their respective PPPoE sessions.\",\n  \"Subtask 6\": \"Retrieve layer endpoint objects from both interfaces for stream configuration.\",\n  \"Subtask 7\": \"Create bidirectional bound traffic streams between the source and destination endpoints.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats and PPPoE-related statistics for monitoring.\",\n  \"Subtask 9\": \"Save the test configuration to a specified file path.\",\n  \"Subtask 10\": \"Start PPPoE protocols and wait until both sessions reach CONNECTED state (IPCP), then wait 5 seconds.\",\n  \"Subtask 11\": \"Start all traffic streams and transmit for 10 seconds.\",\n  \"Subtask 12\": \"Stop all traffic streams and PPPoE protocols.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats for each traffic stream and verify transmitted frames equal received frames.\",\n  \"Subtask 14\": \"Release reserved ports and clean up resources.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     :   Objective: Check that the PPPoE protocol bound stream is transmitted normally\n\nStep          :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                  Step 2: Create PPPoE protocols on both ports respectively and establish routes;\n                  Step 3: Create bound traffic;\n                  Step 4: Subscribe to StreamBlockStats statistics;\n                  Step 5: Transmit all traffic and wait for a period;\n                  Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In Step 6, all traffic shows equal transmitted and received packets;\n\nCreated by    :   Tester-001\n\nBugs          :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    # 修改接口类型\n\n    edit_interface_stack(Interfaces=[interfaces_1, interfaces_2], Layers=['eth', 'pppoe'], Tops=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建PPPoe协议会话\n\n    session_1 = create_pppoe(Port=Port_UP, EmulationMode='client')\n\n    session_2 = create_pppoe(Port=Port_Down, EmulationMode='server')\n\n    # PPPoe协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 获取接口绑定流端点对象\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    # 创建接口绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['PppoePortStatistic', 'PppoeServerBlockStatistic', 'PppoeServerStatistic', 'PppoeClientBlockStatistic', 'PppoeClientStatistic', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PPPoE协议会话达到CONNECTED状态\n\n    wait_pppoe_ipcp_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取PPPOE会话1统计\n    import pandas\n    result = get_pppoe_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pppoe_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_pppoe_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_pppoe_client_block_statistic()\n    print(result)\n\n    result = get_pppoe_client_block_statistic(Session=session_1)\n    print(result)\n\n    result = get_pppoe_client_statistic()\n    print(result)\n\n    result = get_pppoe_client_statistic(Session=session_1)\n    print(result)\n\n    result = get_pppoe_server_block_statistic()\n    print(result)\n\n    result = get_pppoe_server_block_statistic(Session=session_2)\n    print(result)\n\n    result = get_pppoe_server_statistic()\n    print(result)\n    result = get_pppoe_server_statistic(Session=session_2)\n    print(result)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                      RxStreamFrames)\n\n    # 释放端口资源\n    result = release_port(Locations=locations)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nedit_interface_stack:修改测试仪表接口的结构;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_pppoe:创建PPPoE协议会话对象;\nget_pppoe_client_block_statistic:获取PPPoE Server Block Statistic统计结果;\nget_pppoe_client_statistic:获取PPPoE Client Statistic统计结果;\nget_pppoe_port_statistic:获取PPPoE Port Statistic统计结果;\nget_pppoe_server_block_statistic:获取PPPoE Server Block Statistic统计结果;\nget_pppoe_server_statistic:获取PPPoE Server Statistic统计结果;\nwait_pppoe_ipcp_state:等待PPPoE IPCP达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/BFD/BFD.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查BFD与ISIS协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建ISIS协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Verify that the binding flow between BFD and ISIS protocol is transmitted correctly.  \n\nStep 1: Reserve two loopback ports, Port_1 and Port_2;  \nStep 2: Configure ISIS protocol on both ports and create routes;  \nStep 3: Create binding traffic;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Transmit all traffic and wait for a period;  \nStep 6: Stop all traffic and check StreamBlockStats statistics;  \n\nCriteria 1: In Step 6, transmitted and received packets for all traffic are equal.  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建BFD协议会话\n\n    bfd_1 = create_bfd(Port=Port_UP)\n    bfd_2 = create_bfd(Port=Port_Down, RouterRole='PASSIVE')\n\n    select_interface(Session=bfd_1, Interface=interfaces_1)\n    select_interface(Session=bfd_2, Interface=interfaces_2)\n\n    # 创建ISIS协议会话及Tlv\n    isis_1 = create_isis(Port=Port_UP, EnableBFD=True)\n    isis_2 = create_isis(Port=Port_Down, EnableBFD=True)\n\n    select_interface(Session=isis_1, Interface=interfaces_1)\n    select_interface(Session=isis_2, Interface=interfaces_2)\n\n    ipv4_lsp_1 = create_isis_lsp(Session=isis_1, Level='L1')\n    ipv4_lsp_2 = create_isis_lsp(Session=isis_2, Level='L1')\n\n    ipv4_tlv_1 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_1, RouteCount=10, StartIpv4Prefix='2.0.0.1')\n    ipv4_tlv_2 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_2, RouteCount=10, StartIpv4Prefix='3.0.0.1')\n\n\n    # 获取接口绑定流端点对象\n    point_1 = get_isis_router_from_tlv(Configs=ipv4_tlv_1)\n    point_2 = get_isis_router_from_tlv(Configs=ipv4_tlv_2)\n\n\n    # 创建数据流量\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IsisBfdSessionResult'])\n\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待ISIS协议协议会话状态正确\n\n    wait_isis_state(Sessions=[isis_1, isis_2], State='UP')\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取BFD ISIS统计\n\n    bfd_isis_ipv4_result_1 = get_bfd_isis_session_result(BfdSession=bfd_1, IsisSession=isis_1, SessionId=1)\n    print(bfd_isis_ipv4_result_1)\n    bfd_isis_ipv4_result_2 = get_bfd_isis_session_result(BfdSession=bfd_2, IsisSession=isis_2, SessionId=1)\n    print(bfd_isis_ipv4_result_2)\n\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "create_bfd:创建BFD协议会话对象",
      "get_bfd_isis_session_result:获取ISIS BFD会话统计结果",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_isis:创建ISIS协议会话对象",
      "create_isis_ipv4_tlv:创建ISIS IPv4 TLV对象",
      "create_isis_lsp:创建ISIS LSP对象",
      "get_isis_router_from_tlv:获取 ISIS TLV 对应的绑定流源或目的端点对象",
      "wait_isis_state:等待ISIS协议会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform and reserve two ports (Port_UP and Port_Down) using reserve_port.\",\n  \"Subtask 2\": \"Create IPv4 interfaces on both reserved ports and configure their IP addresses and gateways using create_interface and edit_interface.\",\n  \"Subtask 3\": \"Create BFD sessions on both ports with appropriate roles (active and passive) using create_bfd and bind them to the interfaces using select_interface.\",\n  \"Subtask 4\": \"Create ISIS sessions on both ports with BFD enabled using create_isis and bind them to the interfaces using select_interface.\",\n  \"Subtask 5\": \"Create ISIS LSP objects at Level 1 for both ISIS sessions using create_isis_lsp.\",\n  \"Subtask 6\": \"Create ISIS IPv4 TLVs for both LSPs with specified route counts and starting prefixes using create_isis_ipv4_tlv.\",\n  \"Subtask 7\": \"Retrieve ISIS router endpoints from the created IPv4 TLVs using get_isis_router_from_tlv for traffic binding.\",\n  \"Subtask 8\": \"Create bidirectional binding traffic between the source and destination ISIS endpoints using add_stream.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats and IsisBfdSessionResult statistics using subscribe_result.\",\n  \"Subtask 10\": \"Save the test configuration using save_case.\",\n  \"Subtask 11\": \"Start all protocols (BFD and ISIS) using start_protocol.\",\n  \"Subtask 12\": \"Wait until both ISIS sessions reach the 'UP' state using wait_isis_state.\",\n  \"Subtask 13\": \"Start transmitting all created traffic streams using start_stream.\",\n  \"Subtask 14\": \"Wait for 10 seconds while traffic is being transmitted.\",\n  \"Subtask 15\": \"Stop all traffic transmission using stop_stream.\",\n  \"Subtask 16\": \"Stop all protocols using stop_protocol.\",\n  \"Subtask 17\": \"Retrieve BFD-ISIS session results for both sessions using get_bfd_isis_session_result.\",\n  \"Subtask 18\": \"For each traffic stream, retrieve StreamBlockStats using get_streamblock_statistic.\",\n  \"Subtask 19\": \"Verify that TxStreamFrames equals RxStreamFrames for both traffic streams. If unequal, mark test as failed.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Verify that the binding flow between BFD and ISIS protocol is transmitted correctly.  \n\nStep 1: Reserve two loopback ports, Port_1 and Port_2;  \nStep 2: Configure ISIS protocol on both ports and create routes;  \nStep 3: Create binding traffic;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Transmit all traffic and wait for a period;  \nStep 6: Stop all traffic and check StreamBlockStats statistics;  \n\nCriteria 1: In Step 6, transmitted and received packets for all traffic are equal.  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建BFD协议会话\n\n    bfd_1 = create_bfd(Port=Port_UP)\n    bfd_2 = create_bfd(Port=Port_Down, RouterRole='PASSIVE')\n\n    select_interface(Session=bfd_1, Interface=interfaces_1)\n    select_interface(Session=bfd_2, Interface=interfaces_2)\n\n    # 创建ISIS协议会话及Tlv\n    isis_1 = create_isis(Port=Port_UP, EnableBFD=True)\n    isis_2 = create_isis(Port=Port_Down, EnableBFD=True)\n\n    select_interface(Session=isis_1, Interface=interfaces_1)\n    select_interface(Session=isis_2, Interface=interfaces_2)\n\n    ipv4_lsp_1 = create_isis_lsp(Session=isis_1, Level='L1')\n    ipv4_lsp_2 = create_isis_lsp(Session=isis_2, Level='L1')\n\n    ipv4_tlv_1 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_1, RouteCount=10, StartIpv4Prefix='2.0.0.1')\n    ipv4_tlv_2 = create_isis_ipv4_tlv(Lsp=ipv4_lsp_2, RouteCount=10, StartIpv4Prefix='3.0.0.1')\n\n\n    # 获取接口绑定流端点对象\n    point_1 = get_isis_router_from_tlv(Configs=ipv4_tlv_1)\n    point_2 = get_isis_router_from_tlv(Configs=ipv4_tlv_2)\n\n\n    # 创建数据流量\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IsisBfdSessionResult'])\n\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待ISIS协议协议会话状态正确\n\n    wait_isis_state(Sessions=[isis_1, isis_2], State='UP')\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取BFD ISIS统计\n\n    bfd_isis_ipv4_result_1 = get_bfd_isis_session_result(BfdSession=bfd_1, IsisSession=isis_1, SessionId=1)\n    print(bfd_isis_ipv4_result_1)\n    bfd_isis_ipv4_result_2 = get_bfd_isis_session_result(BfdSession=bfd_2, IsisSession=isis_2, SessionId=1)\n    print(bfd_isis_ipv4_result_2)\n\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\ncreate_bfd:创建BFD协议会话对象;\nget_bfd_isis_session_result:获取ISIS BFD会话统计结果;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_isis:创建ISIS协议会话对象;\ncreate_isis_ipv4_tlv:创建ISIS IPv4 TLV对象;\ncreate_isis_lsp:创建ISIS LSP对象;\nget_isis_router_from_tlv:获取 ISIS TLV 对应的绑定流源或目的端点对象;\nwait_isis_state:等待ISIS协议会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/MLD/MLDv2.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查MLD协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建MLD协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Objective: Verify normal transmission of MLD protocol bound traffic\n\nStep        :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Step 2: Create MLD protocols and establish routing on both ports;\n                Step 3: Create bound traffic;\n                Step 4: Subscribe to StreamBlockStats;\n                Step 5: Transmit all traffic and wait for a period;\n                Step 6: Stop all traffic and check StreamBlockStats;\n\nCriteria    :   Expected Result 1: In step 6, all traffic shows equal transmitted/received packets;\n\nCreated by  :   Tester-001\n\nBugs        :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2000::3',\n                   Gateway='2000::2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2000::2',\n                   Gateway='2000::3')\n\n    # 创建MLD协议会话\n\n    mld = create_mld(Port=Port_UP)\n\n    edit_mld(Session=mld, Version='MLDV2')\n\n    # MLD协议会话与接口绑定\n\n    select_interface(Session=mld, Interface=interfaces_1)\n\n    # MLD协议会话1创建Summary Lsa\n\n    multicast_group = create_multicast_group(Start='ff1e::2', Version=\"IPv6\")\n\n    # MLD协议会话2创建External Lsa\n\n    memberships = create_memberships(Session=mld,\n                                     DeviceGroupMapping='ROUNDROBIN',\n                                     UserDefinedSources=False)\n\n    # 获取MLD协议绑定流端点对象\n\n    binding_multicast_group(Session=mld, Memberships=memberships, MulticastGroup=multicast_group)\n\n    select_source_interface(Session=mld, Memberships=memberships, Interface=interfaces_2)\n\n    # 创建MLD Querier协议会话\n\n    mld_querier = create_mld_querier(Port=Port_Down, Version='MLDV1')\n\n    edit_mld_querier(Session=mld_querier, RobustnessVariable=3)\n\n    # MLD Querier协议会话与接口绑定\n\n    select_interface(Session=mld_querier, Interface=interfaces_2)\n\n    # 创建MLD绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv6')\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'MldHostResults', 'MldPortAggregatedResults', 'MldQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待MLD协议会话稳定状态\n\n    wait_mld_state(Sessions=[mld])\n    wait_mld_querier_state(Sessions=[mld_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取MLD Host统计\n\n    result = get_mld_host_statistic(Session=mld)\n    print(result)\n\n    # 获取MLD Port统计\n\n    result = get_mld_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取MLD Querier统计\n\n    result = get_mld_querier_statistic(Session=mld_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "select_source_interface:将协议会话组播组过滤源地址绑定到指定接口",
      "create_mld:创建MLD协议会话对象",
      "create_mld_querier:创建MLD Querier协议会话对象",
      "edit_mld:创建MLD协议会话对象",
      "edit_mld_querier:编辑MLD Querier协议会话对象",
      "get_mld_host_statistic:获取Mld协议会话统计结果",
      "get_mld_port_statistic:获取Mld Port统计结果",
      "get_mld_querier_statistic:获取Mld Querier协议会话统计结果",
      "wait_mld_querier_state:等待Mld Querier协议会话达到指定状态",
      "wait_mld_state:等待Mld协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (default 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two physical ports using reserve_port API with provided locations (default '//10.0.11.191/1/15' and '//10.0.11.191/1/16').\",\n  \"Subtask 3\": \"Create IPv6 interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 4\": \"Configure IPv6 addresses and gateways for both interfaces using edit_interface API (Port_1: 2000::3/2000::2, Port_2: 2000::2/2000::3).\",\n  \"Subtask 5\": \"Create MLD session on first port and set version to MLDV2 using create_mld and edit_mld APIs.\",\n  \"Subtask 6\": \"Bind MLD session to first port's interface using select_interface API.\",\n  \"Subtask 7\": \"Create IPv6 multicast group starting at 'ff1e::2' using create_multicast_group API.\",\n  \"Subtask 8\": \"Create MLD memberships with ROUNDROBIN mapping using create_memberships API.\",\n  \"Subtask 9\": \"Bind multicast group to MLD memberships using binding_multicast_group API.\",\n  \"Subtask 10\": \"Bind source interface for MLD memberships to second port's interface using select_source_interface API.\",\n  \"Subtask 11\": \"Create MLD Querier on second port with version MLDV1 and RobustnessVariable=3 using create_mld_querier and edit_mld_querier APIs.\",\n  \"Subtask 12\": \"Bind MLD Querier session to second port's interface using select_interface API.\",\n  \"Subtask 13\": \"Retrieve IPv6 layer object from second port's interface using get_layer_from_interfaces API.\",\n  \"Subtask 14\": \"Create unidirectional binding traffic stream from second port's IPv6 layer to multicast group using add_stream API.\",\n  \"Subtask 15\": \"Subscribe to StreamBlockStats, MldHostResults, MldPortAggregatedResults, and MldQuerierResults statistics using subscribe_result API.\",\n  \"Subtask 16\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 17\": \"Start all protocols using start_protocol API.\",\n  \"Subtask 18\": \"Wait for MLD session and MLD Querier to reach stable state using wait_mld_state and wait_mld_querier_state APIs, then wait 5 seconds.\",\n  \"Subtask 19\": \"Start traffic transmission using start_stream API and wait 60 seconds.\",\n  \"Subtask 20\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 21\": \"Stop all protocols using stop_protocol API and wait 3 seconds.\",\n  \"Subtask 22\": \"Retrieve and analyze MLD Host statistics using get_mld_host_statistic API.\",\n  \"Subtask 23\": \"Retrieve and analyze MLD Port statistics using get_mld_port_statistic API.\",\n  \"Subtask 24\": \"Retrieve and analyze MLD Querier statistics using get_mld_querier_statistic API.\",\n  \"Subtask 25\": \"Retrieve StreamBlockStats for traffic stream using get_streamblock_statistic API and verify TxStreamFrames equals RxStreamFrames.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Objective: Verify normal transmission of MLD protocol bound traffic\n\nStep        :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Step 2: Create MLD protocols and establish routing on both ports;\n                Step 3: Create bound traffic;\n                Step 4: Subscribe to StreamBlockStats;\n                Step 5: Transmit all traffic and wait for a period;\n                Step 6: Stop all traffic and check StreamBlockStats;\n\nCriteria    :   Expected Result 1: In step 6, all traffic shows equal transmitted/received packets;\n\nCreated by  :   Tester-001\n\nBugs        :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2000::3',\n                   Gateway='2000::2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2000::2',\n                   Gateway='2000::3')\n\n    # 创建MLD协议会话\n\n    mld = create_mld(Port=Port_UP)\n\n    edit_mld(Session=mld, Version='MLDV2')\n\n    # MLD协议会话与接口绑定\n\n    select_interface(Session=mld, Interface=interfaces_1)\n\n    # MLD协议会话1创建Summary Lsa\n\n    multicast_group = create_multicast_group(Start='ff1e::2', Version=\"IPv6\")\n\n    # MLD协议会话2创建External Lsa\n\n    memberships = create_memberships(Session=mld,\n                                     DeviceGroupMapping='ROUNDROBIN',\n                                     UserDefinedSources=False)\n\n    # 获取MLD协议绑定流端点对象\n\n    binding_multicast_group(Session=mld, Memberships=memberships, MulticastGroup=multicast_group)\n\n    select_source_interface(Session=mld, Memberships=memberships, Interface=interfaces_2)\n\n    # 创建MLD Querier协议会话\n\n    mld_querier = create_mld_querier(Port=Port_Down, Version='MLDV1')\n\n    edit_mld_querier(Session=mld_querier, RobustnessVariable=3)\n\n    # MLD Querier协议会话与接口绑定\n\n    select_interface(Session=mld_querier, Interface=interfaces_2)\n\n    # 创建MLD绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv6')\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'MldHostResults', 'MldPortAggregatedResults', 'MldQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待MLD协议会话稳定状态\n\n    wait_mld_state(Sessions=[mld])\n    wait_mld_querier_state(Sessions=[mld_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取MLD Host统计\n\n    result = get_mld_host_statistic(Session=mld)\n    print(result)\n\n    # 获取MLD Port统计\n\n    result = get_mld_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取MLD Querier统计\n\n    result = get_mld_querier_statistic(Session=mld_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nselect_source_interface:将协议会话组播组过滤源地址绑定到指定接口;\ncreate_mld:创建MLD协议会话对象;\ncreate_mld_querier:创建MLD Querier协议会话对象;\nedit_mld:创建MLD协议会话对象;\nedit_mld_querier:编辑MLD Querier协议会话对象;\nget_mld_host_statistic:获取Mld协议会话统计结果;\nget_mld_port_statistic:获取Mld Port统计结果;\nget_mld_querier_statistic:获取Mld Querier协议会话统计结果;\nwait_mld_querier_state:等待Mld Querier协议会话达到指定状态;\nwait_mld_state:等待Mld协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/mpls/6pe_6vpe.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查6PE/6VPE向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建6PE/6VPE向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPN;\n                   测试步骤6: 配置VPN路由;\n                   测试步骤7: 配置VPN流量;\n                   测试步骤8: 生成向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 6PE/6VPE向导配置生成无异常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify that the 6PE/6VPE wizard configuration is generated normally\n\nStep: Step 1: Create two offline ports, Port_1 and Port_2;\n      Step 2: Create a 6PE/6VPE wizard;\n      Step 3: Configure the client-side port and provider-side port;\n      Step 4: Configure the provider-side router;\n      Step 5: Configure the VPN;\n      Step 6: Configure VPN routing;\n      Step 7: Configure VPN traffic;\n      Step 8: Generate the wizard configuration;\n\nCriteria: Expected Result 1: Step 8 - The 6PE/6VPE wizard configuration is generated without exceptions;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations[0]], Force=True)\n    Port_provider = reserve_port(Locations=[locations[1]], Force=True)\n\n    # 创建6PE/6VPE向导\n\n    wizard = create_mpls_wizard(Type='mpls_6vpe')\n\n    # 配置客户端侧端口和提供商侧端口\n    edit_mpls_customer_port(Wizard=wizard, Port=Port_customer[0],\n                            EnableSubInterface=True, SubInterfaceCount=250,\n                            DutIpv4Address='1.1.1.1', VlanId=1000)\n    edit_mpls_provider_port(Wizard=wizard, Port=Port_provider[0],\n                            DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='2.2.2.2',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=True,\n                                               PRoutersPerInterface=10,\n                                               TopologyType='Grid',\n                                               PRouterStartIp='3.3.3.3',\n                                               PRouterIdStart='4.4.4.4',\n                                               PeRoutersPerInterface=20,\n                                               PeRouterIdStart='5.5.5.5',\n                                               EnableRouteReflectors=True,\n                                               Enable6Vpe=True)\n    edit_mpls_provider_router_isis(Wizard=wizard,\n                                   UseSrcMacAsSystemId=False,\n                                   SystemId='22:22:22:22:22:22',\n                                   Level='L1L2',\n                                   NetworkType='P2P',\n                                   RouterPriority=10,\n                                   MetricMode='WIDE',\n                                   AuthenticationMode='SIMPLE',\n                                   Password='test',\n                                   AreaId=20,\n                                   EnableGracefulRestart=True,\n                                   MultiTopologyId='IPV4',\n                                   EnableBfd=True,\n                                   )\n    edit_mpls_provider_router_ldp(Wizard=wizard,\n                                  HelloType='DIRECT_TARGETED',\n                                  TransportAddressTlvMode='ROUTER_ID',\n                                  LabelAdvertisementMode='DOD',\n                                  EgressLabelMode='IMPLICIT',\n                                  MinLabel=20,\n                                  AuthenticationMode='MD5',\n                                  Password='test')\n    # edit_mpls_provider_route_reflector(Wizard=wizard,\n    #                                    RouteReflectorSource='DutAsRouteReflector',\n    #                                    RrsPerPortOrSubInterface=1,\n    #                                    RrsPerPe=1,\n    #                                    RrRouterIdStart='1.1.1.1',\n    #                                    ClusterIdStart='2.2.2.2')\n    edit_mpls_provider_route_reflector(Wizard=wizard,\n                                       RrRouterIds=['1.1.1.1','2.2.2.2'])\n\n    # 配置VPN\n\n    edit_mpls_vpn_parameters(Wizard=wizard,\n                             NumberOfVpns=10,\n                             RdAssignment='Manual',\n                             RouteTargetStart='2:0')\n\n    edit_mpls_vpn_customer_parameters(Wizard=wizard,\n                                      VpnAssignment='Sequential',\n                                      CeProtocol='Mixed',\n                                      CeProAssignment='BGP=20%,RIP=40%,OSPF=30%,IS-IS=5%,Static=5%',\n                                      CustomerRdStart='3:0',\n                                      CustomerRdStepPerVpn='4:0',\n                                      CustomerRdStepPerCeEnabled=True,\n                                      CustomerRdStepPerCe='5:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            CustomerCeAsNumberStart=10,\n                            CustomerCeAsNumberStepPerVpn=20,\n                            CustomerCeAsNumberStepPerCeEnabled=True,\n                            CustomerCeAsNumberStepPerCe=30)\n\n    edit_mpls_vpn_provider_parameters(Wizard=wizard,\n                                      ProviderDisSel='PEsPerVPN',\n                                      ProviderMeshed=True,\n                                      ProviderRdStart='6:0',\n                                      ProviderRdStepPerVpn='7:0',\n                                      ProviderRdStepPerCeEnabled=True,\n                                      ProviderRdStepPerCe='8:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            ProviderAppendCeAsToPath=True,\n                            ProviderCeAsNumberStart=10,\n                            ProviderCeAsNumberStepPerVpnEnabled=True,\n                            ProviderCeAsNumberStepPerVpn=20,\n                            ProviderCeAsNumberStepPerCeEnabled=True,\n                            ProviderCeAsNumberStepPerCe=30)\n\n    # 配置VPN路由\n\n    edit_mpls_vpn_ipv6_route_customer_parameters(Wizard=wizard,\n                                                 CustomerStartRoute='2022::',\n                                                 CustomerRouteStep='0:1::',\n                                                 CustomerPrefixLength=32,\n                                                 CustomerRoutesPerCe=10,\n                                                 CustomerOverlapRoutes=True,\n                                                 CustomerRouteType='External')\n    edit_mpls_vpn_ipv6_route_provider_parameters(Wizard=wizard,\n                                                 ProviderStartRoute='2033::',\n                                                 ProviderRouteStep='0:1::',\n                                                 ProviderPrefixLength=32,\n                                                 ProviderRoutesPerCe=20,\n                                                 ProviderOverlapRoutes=True,\n                                                 ProviderLabelType='LabelPerRoute',\n                                                 ProviderStartLabel=20)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            UseSingleStreamNumber=True,\n                            TrafficLoadPercentProvider=10,\n                            TrafficLoadPercentCustomer=20)\n\n    # 生成6PE/6VPE向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_mpls_wizard:测试仪表创建MPLS向导",
      "edit_mpls_customer_port:配置MPLS向导客户侧端口",
      "edit_mpls_provider_port:配置MPLS向导提供商侧端口",
      "edit_mpls_provider_route_reflector:not_found",
      "edit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由",
      "edit_mpls_provider_router_isis:配置MPLS提供商侧路由路由器OSPF协议",
      "edit_mpls_provider_router_ldp:配置MPLS提供商侧路由路由器LDP协议",
      "edit_mpls_vpn_as_number:not_found",
      "edit_mpls_vpn_customer_parameters:配置MPLS VPN客户侧参数",
      "edit_mpls_vpn_ipv6_route_customer_parameters:配置MPLS VPN路由客户端侧IPv6参数",
      "edit_mpls_vpn_ipv6_route_provider_parameters:配置MPLS VPN路由提供商端侧IPv6参数",
      "edit_mpls_vpn_parameters:配置MPLS VPN基本参数",
      "edit_mpls_vpn_provider_parameters:配置MPLS VPN提供商侧参数",
      "edit_traffic_parameters:配置MPLS流量",
      "expand_mpls_wizard:生成测试仪表MPLS向导配置"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (e.g., 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_customer and Port_provider) at specified locations using reserve_port API with Force=True.\",\n  \"Subtask 3\": \"Create an MPLS wizard of type 'mpls_6vpe' using create_mpls_wizard API.\",\n  \"Subtask 4\": \"Configure customer-side port parameters: EnableSubInterface=True, SubInterfaceCount=250, DutIpv4Address='1.1.1.1', VlanId=1000 using edit_mpls_customer_port API.\",\n  \"Subtask 5\": \"Configure provider-side port parameters: DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24 using edit_mpls_provider_port API.\",\n  \"Subtask 6\": \"Configure provider router basic parameters: DutRouterId='2.2.2.2', DutAsNumber=100, IgpProtocol='ISIS', MplsProtocol='LDP', EnablePRouter=True, PRoutersPerInterface=10, TopologyType='Grid', PRouterStartIp='3.3.3.3', PRouterIdStart='4.4.4.4', PeRoutersPerInterface=20, PeRouterIdStart='5.5.5.5', EnableRouteReflectors=True, Enable6Vpe=True using edit_mpls_provider_router_basic_parameters API.\",\n  \"Subtask 7\": \"Configure provider router ISIS parameters: UseSrcMacAsSystemId=False, SystemId='22:22:22:22:22:22', Level='L1L2', NetworkType='P2P', RouterPriority=10, MetricMode='WIDE', AuthenticationMode='SIMPLE', Password='test', AreaId=20, EnableGracefulRestart=True, MultiTopologyId='IPV4', EnableBfd=True using edit_mpls_provider_router_isis API.\",\n  \"Subtask 8\": \"Configure provider router LDP parameters: HelloType='DIRECT_TARGETED', TransportAddressTlvMode='ROUTER_ID', LabelAdvertisementMode='DOD', EgressLabelMode='IMPLICIT', MinLabel=20, AuthenticationMode='MD5', Password='test' using edit_mpls_provider_router_ldp API.\",\n  \"Subtask 9\": \"Configure provider route reflector with RR router IDs ['1.1.1.1','2.2.2.2'] using edit_mpls_provider_route_reflector API.\",\n  \"Subtask 10\": \"Configure VPN basic parameters: NumberOfVpns=10, RdAssignment='Manual', RouteTargetStart='2:0' using edit_mpls_vpn_parameters API.\",\n  \"Subtask 11\": \"Configure VPN customer parameters: VpnAssignment='Sequential', CeProtocol='Mixed', CeProAssignment='BGP=20%,RIP=40%,OSPF=30%,IS-IS=5%,Static=5%', CustomerRdStart='3:0', CustomerRdStepPerVpn='4:0', CustomerRdStepPerCeEnabled=True, CustomerRdStepPerCe='5:0' using edit_mpls_vpn_customer_parameters API.\",\n  \"Subtask 12\": \"Configure VPN customer AS numbers: CustomerCeAsNumberStart=10, CustomerCeAsNumberStepPerVpn=20, CustomerCeAsNumberStepPerCeEnabled=True, CustomerCeAsNumberStepPerCe=30 using edit_mpls_vpn_as_number API.\",\n  \"Subtask 13\": \"Configure VPN provider parameters: ProviderDisSel='PEsPerVPN', ProviderMeshed=True, ProviderRdStart='6:0', ProviderRdStepPerVpn='7:0', ProviderRdStepPerCeEnabled=True, ProviderRdStepPerCe='8:0' using edit_mpls_vpn_provider_parameters API.\",\n  \"Subtask 14\": \"Configure VPN provider AS numbers: ProviderAppendCeAsToPath=True, ProviderCeAsNumberStart=10, ProviderCeAsNumberStepPerVpnEnabled=True, ProviderCeAsNumberStepPerVpn=20, ProviderCeAsNumberStepPerCeEnabled=True, ProviderCeAsNumberStepPerCe=30 using edit_mpls_vpn_as_number API.\",\n  \"Subtask 15\": \"Configure VPN customer IPv6 route parameters: CustomerStartRoute='2022::', CustomerRouteStep='0:1::', CustomerPrefixLength=32, CustomerRoutesPerCe=10, CustomerOverlapRoutes=True, CustomerRouteType='External' using edit_mpls_vpn_ipv6_route_customer_parameters API.\",\n  \"Subtask 16\": \"Configure VPN provider IPv6 route parameters: ProviderStartRoute='2033::', ProviderRouteStep='0:1::', ProviderPrefixLength=32, ProviderRoutesPerCe=20, ProviderOverlapRoutes=True, ProviderLabelType='LabelPerRoute', ProviderStartLabel=20 using edit_mpls_vpn_ipv6_route_provider_parameters API.\",\n  \"Subtask 17\": \"Configure traffic parameters: TrafficFlow='CustomerProviderBoth', StreamBlockGrouping='Aggregate', UseSingleStreamNumber=True, TrafficLoadPercentProvider=10, TrafficLoadPercentCustomer=20 using edit_traffic_parameters API.\",\n  \"Subtask 18\": \"Generate the wizard configuration by expanding the MPLS wizard using expand_mpls_wizard API.\",\n  \"Subtask 19\": \"Save the generated configuration to a file using save_case API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify that the 6PE/6VPE wizard configuration is generated normally\n\nStep: Step 1: Create two offline ports, Port_1 and Port_2;\n      Step 2: Create a 6PE/6VPE wizard;\n      Step 3: Configure the client-side port and provider-side port;\n      Step 4: Configure the provider-side router;\n      Step 5: Configure the VPN;\n      Step 6: Configure VPN routing;\n      Step 7: Configure VPN traffic;\n      Step 8: Generate the wizard configuration;\n\nCriteria: Expected Result 1: Step 8 - The 6PE/6VPE wizard configuration is generated without exceptions;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_customer = reserve_port(Locations=[locations[0]], Force=True)\n    Port_provider = reserve_port(Locations=[locations[1]], Force=True)\n\n    # 创建6PE/6VPE向导\n\n    wizard = create_mpls_wizard(Type='mpls_6vpe')\n\n    # 配置客户端侧端口和提供商侧端口\n    edit_mpls_customer_port(Wizard=wizard, Port=Port_customer[0],\n                            EnableSubInterface=True, SubInterfaceCount=250,\n                            DutIpv4Address='1.1.1.1', VlanId=1000)\n    edit_mpls_provider_port(Wizard=wizard, Port=Port_provider[0],\n                            DutIpv4Address='50.1.1.1', Ipv4PrefixLength=24)\n\n    # 配置提供商侧路由器\n\n    edit_mpls_provider_router_basic_parameters(Wizard=wizard,\n                                               DutRouterId='2.2.2.2',\n                                               DutAsNumber=100,\n                                               IgpProtocol='ISIS',\n                                               MplsProtocol='LDP',\n                                               EnablePRouter=True,\n                                               PRoutersPerInterface=10,\n                                               TopologyType='Grid',\n                                               PRouterStartIp='3.3.3.3',\n                                               PRouterIdStart='4.4.4.4',\n                                               PeRoutersPerInterface=20,\n                                               PeRouterIdStart='5.5.5.5',\n                                               EnableRouteReflectors=True,\n                                               Enable6Vpe=True)\n    edit_mpls_provider_router_isis(Wizard=wizard,\n                                   UseSrcMacAsSystemId=False,\n                                   SystemId='22:22:22:22:22:22',\n                                   Level='L1L2',\n                                   NetworkType='P2P',\n                                   RouterPriority=10,\n                                   MetricMode='WIDE',\n                                   AuthenticationMode='SIMPLE',\n                                   Password='test',\n                                   AreaId=20,\n                                   EnableGracefulRestart=True,\n                                   MultiTopologyId='IPV4',\n                                   EnableBfd=True,\n                                   )\n    edit_mpls_provider_router_ldp(Wizard=wizard,\n                                  HelloType='DIRECT_TARGETED',\n                                  TransportAddressTlvMode='ROUTER_ID',\n                                  LabelAdvertisementMode='DOD',\n                                  EgressLabelMode='IMPLICIT',\n                                  MinLabel=20,\n                                  AuthenticationMode='MD5',\n                                  Password='test')\n    # edit_mpls_provider_route_reflector(Wizard=wizard,\n    #                                    RouteReflectorSource='DutAsRouteReflector',\n    #                                    RrsPerPortOrSubInterface=1,\n    #                                    RrsPerPe=1,\n    #                                    RrRouterIdStart='1.1.1.1',\n    #                                    ClusterIdStart='2.2.2.2')\n    edit_mpls_provider_route_reflector(Wizard=wizard,\n                                       RrRouterIds=['1.1.1.1','2.2.2.2'])\n\n    # 配置VPN\n\n    edit_mpls_vpn_parameters(Wizard=wizard,\n                             NumberOfVpns=10,\n                             RdAssignment='Manual',\n                             RouteTargetStart='2:0')\n\n    edit_mpls_vpn_customer_parameters(Wizard=wizard,\n                                      VpnAssignment='Sequential',\n                                      CeProtocol='Mixed',\n                                      CeProAssignment='BGP=20%,RIP=40%,OSPF=30%,IS-IS=5%,Static=5%',\n                                      CustomerRdStart='3:0',\n                                      CustomerRdStepPerVpn='4:0',\n                                      CustomerRdStepPerCeEnabled=True,\n                                      CustomerRdStepPerCe='5:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            CustomerCeAsNumberStart=10,\n                            CustomerCeAsNumberStepPerVpn=20,\n                            CustomerCeAsNumberStepPerCeEnabled=True,\n                            CustomerCeAsNumberStepPerCe=30)\n\n    edit_mpls_vpn_provider_parameters(Wizard=wizard,\n                                      ProviderDisSel='PEsPerVPN',\n                                      ProviderMeshed=True,\n                                      ProviderRdStart='6:0',\n                                      ProviderRdStepPerVpn='7:0',\n                                      ProviderRdStepPerCeEnabled=True,\n                                      ProviderRdStepPerCe='8:0')\n    edit_mpls_vpn_as_number(Wizard=wizard,\n                            ProviderAppendCeAsToPath=True,\n                            ProviderCeAsNumberStart=10,\n                            ProviderCeAsNumberStepPerVpnEnabled=True,\n                            ProviderCeAsNumberStepPerVpn=20,\n                            ProviderCeAsNumberStepPerCeEnabled=True,\n                            ProviderCeAsNumberStepPerCe=30)\n\n    # 配置VPN路由\n\n    edit_mpls_vpn_ipv6_route_customer_parameters(Wizard=wizard,\n                                                 CustomerStartRoute='2022::',\n                                                 CustomerRouteStep='0:1::',\n                                                 CustomerPrefixLength=32,\n                                                 CustomerRoutesPerCe=10,\n                                                 CustomerOverlapRoutes=True,\n                                                 CustomerRouteType='External')\n    edit_mpls_vpn_ipv6_route_provider_parameters(Wizard=wizard,\n                                                 ProviderStartRoute='2033::',\n                                                 ProviderRouteStep='0:1::',\n                                                 ProviderPrefixLength=32,\n                                                 ProviderRoutesPerCe=20,\n                                                 ProviderOverlapRoutes=True,\n                                                 ProviderLabelType='LabelPerRoute',\n                                                 ProviderStartLabel=20)\n\n    # 配置流量\n\n    edit_traffic_parameters(Wizard=wizard,\n                            TrafficFlow='CustomerProviderBoth',\n                            StreamBlockGrouping='Aggregate',\n                            UseSingleStreamNumber=True,\n                            TrafficLoadPercentProvider=10,\n                            TrafficLoadPercentCustomer=20)\n\n    # 生成6PE/6VPE向导配置\n\n    expand_mpls_wizard(Wizard=wizard)\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_mpls_wizard:测试仪表创建MPLS向导;\nedit_mpls_customer_port:配置MPLS向导客户侧端口;\nedit_mpls_provider_port:配置MPLS向导提供商侧端口;\nedit_mpls_provider_route_reflector:not_found;\nedit_mpls_provider_router_basic_parameters:配置MPLS提供商侧路由;\nedit_mpls_provider_router_isis:配置MPLS提供商侧路由路由器OSPF协议;\nedit_mpls_provider_router_ldp:配置MPLS提供商侧路由路由器LDP协议;\nedit_mpls_vpn_as_number:not_found;\nedit_mpls_vpn_customer_parameters:配置MPLS VPN客户侧参数;\nedit_mpls_vpn_ipv6_route_customer_parameters:配置MPLS VPN路由客户端侧IPv6参数;\nedit_mpls_vpn_ipv6_route_provider_parameters:配置MPLS VPN路由提供商端侧IPv6参数;\nedit_mpls_vpn_parameters:配置MPLS VPN基本参数;\nedit_mpls_vpn_provider_parameters:配置MPLS VPN提供商侧参数;\nedit_traffic_parameters:配置MPLS流量;\nexpand_mpls_wizard:生成测试仪表MPLS向导配置\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/OSPF/OSPFv3.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查OSPFv3协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建OSPFv3协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify that the OSPFv3 protocol bound stream is transmitted correctly\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Step 2: Create OSPFv3 protocols and routes on both ports respectively;\n      Step 3: Create bound traffic;\n      Step 4: Subscribe to StreamBlockStats;\n      Step 5: Send all traffic and wait for a period;\n      Step 6: Stop all traffic and check StreamBlockStats;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets are equal for all traffic;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建OSPFv3协议会话\n\n    session_1 = create_ospfv3(Port=Port_UP, Priority=1)\n\n    session_2 = create_ospfv3(Port=Port_Down, Priority=2)\n\n    # OSPFv3协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # OSPFv3协议会话1创建Summary Lsa\n\n    inter_lsa_1 = create_ospfv3_inter_area_prefix_lsa(Session=session_1)\n\n    # OSPFv3协议会话2创建External Lsa\n\n    inter_lsa_2 = create_ospfv3_inter_area_prefix_lsa(Session=session_2)\n\n    # 获取OSPFv3协议绑定流端点对象\n\n    point_1 = get_ospf_router_from_lsa(Lsa=inter_lsa_1)\n\n    point_2 = get_ospf_router_from_lsa(Lsa=inter_lsa_2)\n\n    # 创建OSPFv3绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv3SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待OSPFv3协议会话达到Full状态\n\n    wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n\n    advertise_ospf_lsa(Lsa=[inter_lsa_1, inter_lsa_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    withdraw_ospf_lsa(Lsa=[inter_lsa_1, inter_lsa_2])\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取OSPFv3会话1统计\n    import pandas\n    result = get_ospfv3_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ospfv3_statistic(Session=session_1)\n    print(result)\n    Tx = result['TxInterAreaPrefixLsa']\n    Rx = result['RxInterAreaPrefixLsa']\n    print('TxInterAreaPrefixLsa:', Tx)\n    print('RxInterAreaPrefixLsa:', Rx)\n\n    # 获取OSPFv3会话2统计\n\n    result = get_ospfv3_statistic(Session=session_2)\n    print(result)\n    Tx = result['TxInterAreaPrefixLsa']\n    Rx = result['RxInterAreaPrefixLsa']\n    print('TxInterAreaPrefixLsa:', Tx)\n    print('RxInterAreaPrefixLsa:', Rx)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_ospf_lsa:通告 OSPFv2 协议会话 lsa",
      "get_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象",
      "wait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态",
      "withdraw_ospf_lsa:撤销OSPFv2协议会话lsa",
      "create_ospfv3:创建OSPFv3协议会话对象",
      "create_ospfv3_inter_area_prefix_lsa:创建OSPFv3 Inter Area Prefix LSA对象",
      "get_ospfv3_statistic:获取OSPFv3协议会话统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (DarYu or provided argument).\",\n  \"Subtask 2\": \"Reserve two ports using provided locations and assign to Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create IPv6 interfaces on Port_1 and Port_2 with respective IPv6 addresses and gateways.\",\n  \"Subtask 4\": \"Create OSPFv3 sessions on Port_1 (priority 1) and Port_2 (priority 2).\",\n  \"Subtask 5\": \"Bind the created IPv6 interfaces to their respective OSPFv3 sessions.\",\n  \"Subtask 6\": \"Create OSPFv3 Inter-Area Prefix LSAs on both OSPFv3 sessions.\",\n  \"Subtask 7\": \"Retrieve OSPF router endpoints from the created LSAs for traffic binding.\",\n  \"Subtask 8\": \"Create bidirectional bound streams between the source and destination endpoints.\",\n  \"Subtask 9\": \"Subscribe to Ospfv3SessionResultPropertySet and StreamBlockStats statistics views.\",\n  \"Subtask 10\": \"Save the test configuration to a file.\",\n  \"Subtask 11\": \"Start OSPFv3 protocol on both ports.\",\n  \"Subtask 12\": \"Wait until both OSPFv3 sessions reach full adjacency state.\",\n  \"Subtask 13\": \"Advertise the created LSAs and wait 5 seconds for route propagation.\",\n  \"Subtask 14\": \"Start all traffic streams and wait 10 seconds for transmission.\",\n  \"Subtask 15\": \"Stop all traffic streams.\",\n  \"Subtask 16\": \"Withdraw the advertised LSAs and wait 5 seconds.\",\n  \"Subtask 17\": \"Stop OSPFv3 protocol on both ports and wait 3 seconds.\",\n  \"Subtask 18\": \"Retrieve OSPFv3 session statistics for Port_1 and print Tx/Rx Inter-Area Prefix LSA counts.\",\n  \"Subtask 19\": \"Retrieve OSPFv3 session statistics for Port_2 and print Tx/Rx Inter-Area Prefix LSA counts.\",\n  \"Subtask 20\": \"Retrieve stream statistics for first bound stream and verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 21\": \"Retrieve stream statistics for second bound stream (bidirectional) and verify TxStreamFrames equals RxStreamFrames.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify that the OSPFv3 protocol bound stream is transmitted correctly\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Step 2: Create OSPFv3 protocols and routes on both ports respectively;\n      Step 3: Create bound traffic;\n      Step 4: Subscribe to StreamBlockStats;\n      Step 5: Send all traffic and wait for a period;\n      Step 6: Stop all traffic and check StreamBlockStats;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets are equal for all traffic;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2001::1',\n                   Gateway='2001::2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2001::2',\n                   Gateway='2001::1')\n\n    # 创建OSPFv3协议会话\n\n    session_1 = create_ospfv3(Port=Port_UP, Priority=1)\n\n    session_2 = create_ospfv3(Port=Port_Down, Priority=2)\n\n    # OSPFv3协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # OSPFv3协议会话1创建Summary Lsa\n\n    inter_lsa_1 = create_ospfv3_inter_area_prefix_lsa(Session=session_1)\n\n    # OSPFv3协议会话2创建External Lsa\n\n    inter_lsa_2 = create_ospfv3_inter_area_prefix_lsa(Session=session_2)\n\n    # 获取OSPFv3协议绑定流端点对象\n\n    point_1 = get_ospf_router_from_lsa(Lsa=inter_lsa_1)\n\n    point_2 = get_ospf_router_from_lsa(Lsa=inter_lsa_2)\n\n    # 创建OSPFv3绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv3SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待OSPFv3协议会话达到Full状态\n\n    wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n\n    advertise_ospf_lsa(Lsa=[inter_lsa_1, inter_lsa_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    withdraw_ospf_lsa(Lsa=[inter_lsa_1, inter_lsa_2])\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取OSPFv3会话1统计\n    import pandas\n    result = get_ospfv3_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ospfv3_statistic(Session=session_1)\n    print(result)\n    Tx = result['TxInterAreaPrefixLsa']\n    Rx = result['RxInterAreaPrefixLsa']\n    print('TxInterAreaPrefixLsa:', Tx)\n    print('RxInterAreaPrefixLsa:', Rx)\n\n    # 获取OSPFv3会话2统计\n\n    result = get_ospfv3_statistic(Session=session_2)\n    print(result)\n    Tx = result['TxInterAreaPrefixLsa']\n    Rx = result['RxInterAreaPrefixLsa']\n    print('TxInterAreaPrefixLsa:', Tx)\n    print('RxInterAreaPrefixLsa:', Rx)\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_ospf_lsa:通告 OSPFv2 协议会话 lsa;\nget_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象;\nwait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态;\nwithdraw_ospf_lsa:撤销OSPFv2协议会话lsa;\ncreate_ospfv3:创建OSPFv3协议会话对象;\ncreate_ospfv3_inter_area_prefix_lsa:创建OSPFv3 Inter Area Prefix LSA对象;\nget_ospfv3_statistic:获取OSPFv3协议会话统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/PCEP/PCEP.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 配置PCEP协议，检查统计\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建PCEP协议;\n                   测试步骤4: 订阅PCEP相关统计;\n                   测试步骤5: 启动协议;\n                   测试步骤6: 查看统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中统计获取正常;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Configure PCEP protocol and check statistics\n\nStep          : Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Step 2: Create PCEP protocol on both ports respectively;\n               Step 4: Subscribe to PCEP-related statistics;\n               Step 5: Start the protocol;\n               Step 6: View statistical information;\n\nCriteria      : Expected Result 1: Statistics are obtained normally in Step 6;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建PCEP协议会话\n\n    session_1 = create_pcep(Port=Port_UP, Role='PCC', Negotiation=True)\n\n    session_2 = create_pcep(Port=Port_Down, Role='PCE', Negotiation=False)\n\n    # PCEP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建LSP\n\n    lsp_1 = create_pcep_pcc_lsp(Sessions=session_1)\n\n    lsp_2 = create_pcep_pce_lsp(Sessions=session_2)\n\n    # 订阅统计\n\n    subscribe_result(Types=['PcepLspStatistic', 'PcepLspBlockStatistic', 'PcepPortStatistic',\n                            'PcepSessionStatistic', 'PcepSessionBlockStatistic'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PCEP协议协议会话状态正确\n\n    wait_pcep_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取PCEP端口统计\n    import pandas\n    result = get_pcep_lsp_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_lsp_statistic(Session=session_1, SessionId=1, Lsp=lsp_1, LspId=1)\n    print(result)\n    result = get_pcep_lsp_statistic(Session=session_2, SessionId=1, Lsp=lsp_2, LspId=1)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_lsp_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_lsp_block_statistic(Session=session_1, SessionId=1, Lsp=lsp_1)\n    print(result)\n    result = get_pcep_lsp_block_statistic(Session=session_2, SessionId=1, Lsp=lsp_2)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_pcep_port_statistic(Port=Port_Down)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_session_statistic(Session=session_1, SessionId=1)\n    print(result)\n    result = get_pcep_session_statistic(Session=session_2, SessionId=1)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_session_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_pcep_session_block_statistic(Session=session_2)\n    print(result)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_pcep:创建PCEP协议会话对象",
      "create_pcep_pcc_lsp:创建PCEP PCC LSP对象",
      "create_pcep_pce_lsp:创建PCEP PCE LSP对象",
      "get_pcep_lsp_block_statistic:获取PCEP LSP BLOCK统计结果",
      "get_pcep_lsp_statistic:获取PCEP LSP统计结果",
      "get_pcep_port_statistic:获取PCEP Port统计结果",
      "get_pcep_session_block_statistic:获取PCEP session block统计结果",
      "get_pcep_session_statistic:获取PCEP session统计结果",
      "wait_pcep_state:等待PCEP协议会话达到指定状态",
      "subscribe_result:订阅测试仪表统计视图",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with product type 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports using reserve_port API with specified locations.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 4\": \"Configure IPv4 addresses and gateways for both interfaces using edit_interface API (Port_UP: 1.1.1.1/1.1.1.2, Port_Down: 1.1.1.2/1.1.1.1).\",\n  \"Subtask 5\": \"Create PCEP sessions on both ports with specified roles using create_pcep API (Port_UP as PCC with negotiation, Port_Down as PCE without negotiation).\",\n  \"Subtask 6\": \"Bind each PCEP session to its corresponding interface using select_interface API.\",\n  \"Subtask 7\": \"Create PCC LSP on first session and PCE LSP on second session using create_pcep_pcc_lsp and create_pcep_pce_lsp APIs.\",\n  \"Subtask 8\": \"Subscribe to PCEP statistics including LSP, LSP block, port, session, and session block statistics using subscribe_result API.\",\n  \"Subtask 9\": \"Save current configuration to file using save_case API with path derived from script name.\",\n  \"Subtask 10\": \"Start PCEP protocol using start_protocol API.\",\n  \"Subtask 11\": \"Wait until both PCEP sessions reach established state using wait_pcep_state API.\",\n  \"Subtask 12\": \"Start traffic streams using start_stream API.\",\n  \"Subtask 13\": \"Wait 10 seconds for traffic transmission.\",\n  \"Subtask 14\": \"Stop traffic streams using stop_stream API.\",\n  \"Subtask 15\": \"Stop PCEP protocol using stop_protocol API.\",\n  \"Subtask 16\": \"Retrieve and validate PCEP LSP statistics at global, session, and LSP levels using get_pcep_lsp_statistic API.\",\n  \"Subtask 17\": \"Retrieve and validate PCEP LSP block statistics at global and session levels using get_pcep_lsp_block_statistic API.\",\n  \"Subtask 18\": \"Retrieve and validate PCEP port statistics at global and port-specific levels using get_pcep_port_statistic API.\",\n  \"Subtask 19\": \"Retrieve and validate PCEP session statistics at global and session-specific levels using get_pcep_session_statistic API.\",\n  \"Subtask 20\": \"Retrieve and validate PCEP session block statistics at global and session-specific levels using get_pcep_session_block_statistic API.\",\n  \"Subtask 21\": \"Verify all statistics are returned as pandas DataFrame objects for successful validation.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Configure PCEP protocol and check statistics\n\nStep          : Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Step 2: Create PCEP protocol on both ports respectively;\n               Step 4: Subscribe to PCEP-related statistics;\n               Step 5: Start the protocol;\n               Step 6: View statistical information;\n\nCriteria      : Expected Result 1: Statistics are obtained normally in Step 6;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建PCEP协议会话\n\n    session_1 = create_pcep(Port=Port_UP, Role='PCC', Negotiation=True)\n\n    session_2 = create_pcep(Port=Port_Down, Role='PCE', Negotiation=False)\n\n    # PCEP协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # 创建LSP\n\n    lsp_1 = create_pcep_pcc_lsp(Sessions=session_1)\n\n    lsp_2 = create_pcep_pce_lsp(Sessions=session_2)\n\n    # 订阅统计\n\n    subscribe_result(Types=['PcepLspStatistic', 'PcepLspBlockStatistic', 'PcepPortStatistic',\n                            'PcepSessionStatistic', 'PcepSessionBlockStatistic'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PCEP协议协议会话状态正确\n\n    wait_pcep_state(Sessions=[session_1, session_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取PCEP端口统计\n    import pandas\n    result = get_pcep_lsp_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_lsp_statistic(Session=session_1, SessionId=1, Lsp=lsp_1, LspId=1)\n    print(result)\n    result = get_pcep_lsp_statistic(Session=session_2, SessionId=1, Lsp=lsp_2, LspId=1)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_lsp_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_lsp_block_statistic(Session=session_1, SessionId=1, Lsp=lsp_1)\n    print(result)\n    result = get_pcep_lsp_block_statistic(Session=session_2, SessionId=1, Lsp=lsp_2)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_pcep_port_statistic(Port=Port_Down)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_session_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_session_statistic(Session=session_1, SessionId=1)\n    print(result)\n    result = get_pcep_session_statistic(Session=session_2, SessionId=1)\n    print(result)\n\n    # 获取PCEP客户端统计\n    result = get_pcep_session_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pcep_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_pcep_session_block_statistic(Session=session_2)\n    print(result)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_pcep:创建PCEP协议会话对象;\ncreate_pcep_pcc_lsp:创建PCEP PCC LSP对象;\ncreate_pcep_pce_lsp:创建PCEP PCE LSP对象;\nget_pcep_lsp_block_statistic:获取PCEP LSP BLOCK统计结果;\nget_pcep_lsp_statistic:获取PCEP LSP统计结果;\nget_pcep_port_statistic:获取PCEP Port统计结果;\nget_pcep_session_block_statistic:获取PCEP session block统计结果;\nget_pcep_session_statistic:获取PCEP session统计结果;\nwait_pcep_state:等待PCEP协议会话达到指定状态;\nsubscribe_result:订阅测试仪表统计视图;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/Y1731/y1731.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查y.1731协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建y1731协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Objective: Verify that the y.1731 protocol bound flow is transmitted normally\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Create the y1731 protocol on each port;\n                 Step 3: Start the protocol and check protocol statistics;\n\nCriteria     :   Expected Result 1: Statistics are obtained correctly in Step 3;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.3')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.3', Gateway='1.1.1.2')\n\n    # 创建协议会话\n\n    session_1 = create_y1731(Port=Port_UP)\n    session_2 = create_y1731(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    mp_1 = create_y1731_mp(Sessions=session_1)\n    mp_2 = create_y1731_mp(Sessions=session_2)\n\n    meg = create_y1731_meg()\n\n    edit_y1731_mp(mp_1, Meg=meg)\n    edit_y1731_mp(mp_2, Meg=meg)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Y1731MegStats', 'Y1731MpStats', 'Y1731PortStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待协议会话达到状态\n\n    wait_y1731_state(Sessions=[session_1, session_2])\n\n    time.sleep(1)\n\n    # 获取统计\n    import pandas\n    result = get_y1731_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_y1731_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_y1731_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_y1731_meg_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_y1731_meg_statistic(Meg=meg, Port=Port_UP)\n    print(result)\n    result = get_y1731_meg_statistic(Meg=meg, Port=Port_Down)\n    print(result)\n\n    result = get_y1731_mp_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_y1731_mp_statistic(Mp=mp_1)\n    print(result)\n    result = get_y1731_mp_statistic(Mp=mp_2)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester for the specified product platform.\",\n  \"Subtask 2\": \"Reserve two physical ports (Port_UP and Port_Down) for testing.\",\n  \"Subtask 3\": \"Create network interfaces on both reserved ports.\",\n  \"Subtask 4\": \"Configure IPv4 addresses and gateways on both interfaces.\",\n  \"Subtask 5\": \"Create Y.1731 protocol sessions on both ports.\",\n  \"Subtask 6\": \"Bind the configured interfaces to the Y.1731 sessions.\",\n  \"Subtask 7\": \"Create Y.1731 Maintenance Points (MPs) for both sessions.\",\n  \"Subtask 8\": \"Create a Y.1731 Maintenance Entity Group (MEG).\",\n  \"Subtask 9\": \"Assign both MPs to the created MEG.\",\n  \"Subtask 10\": \"Subscribe to Y.1731 statistics types (MegStats, MpStats, PortStats).\",\n  \"Subtask 11\": \"Save the test configuration to a file.\",\n  \"Subtask 12\": \"Start all configured protocols.\",\n  \"Subtask 13\": \"Wait until Y.1731 sessions reach operational state.\",\n  \"Subtask 14\": \"Obtain and verify Y.1731 port statistics for both ports individually and collectively, ensuring results are in expected format.\",\n  \"Subtask 15\": \"Obtain and verify Y.1731 MEG statistics for the created MEG on both ports individually and collectively, ensuring results are in expected format.\",\n  \"Subtask 16\": \"Obtain and verify Y.1731 MP statistics for both MPs individually and collectively, ensuring results are in expected format.\",\n  \"Subtask 17\": \"Stop all running protocols.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Objective: Verify that the y.1731 protocol bound flow is transmitted normally\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Create the y1731 protocol on each port;\n                 Step 3: Start the protocol and check protocol statistics;\n\nCriteria     :   Expected Result 1: Statistics are obtained correctly in Step 3;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.3')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.3', Gateway='1.1.1.2')\n\n    # 创建协议会话\n\n    session_1 = create_y1731(Port=Port_UP)\n    session_2 = create_y1731(Port=Port_Down)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    mp_1 = create_y1731_mp(Sessions=session_1)\n    mp_2 = create_y1731_mp(Sessions=session_2)\n\n    meg = create_y1731_meg()\n\n    edit_y1731_mp(mp_1, Meg=meg)\n    edit_y1731_mp(mp_2, Meg=meg)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Y1731MegStats', 'Y1731MpStats', 'Y1731PortStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待协议会话达到状态\n\n    wait_y1731_state(Sessions=[session_1, session_2])\n\n    time.sleep(1)\n\n    # 获取统计\n    import pandas\n    result = get_y1731_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_y1731_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_y1731_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_y1731_meg_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_y1731_meg_statistic(Meg=meg, Port=Port_UP)\n    print(result)\n    result = get_y1731_meg_statistic(Meg=meg, Port=Port_Down)\n    print(result)\n\n    result = get_y1731_mp_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_y1731_mp_statistic(Mp=mp_1)\n    print(result)\n    result = get_y1731_mp_statistic(Mp=mp_2)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/Dot1x/Dot1x.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查802.1x协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建802.1x协议;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Check that the 802.1x protocol bound flow is transmitted normally  \n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;  \n      Test Step 2: Create an 802.1x protocol on each port respectively;  \n      Test Step 3: Start the protocol and view protocol statistics;  \n\nCriteria: Expected Result 1: In step 6, all traffic sent and received packets are equal;  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface_stack(Interfaces=interfaces_1)\n    edit_interface_stack(Interfaces=interfaces_2)\n\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建802.1x协议会话\n\n    session_1 = create_dot1x(Port=Port_UP, Name='Dot1x_1')\n    session_2 = create_dot1x(Port=Port_Down, Name='Dot1x_2')\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n\n    # 订阅统计\n\n    subscribe_result(Types=['Dot1xBlockStatistics', 'Dot1xPortStatistics', 'Dot1xStatistics'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PPPoE协议会话达到CONNECTED状态\n\n    wait_dot1x_state(Sessions=[session_1, session_2], State='AUTHENTICATING')\n\n    time.sleep(5)\n\n    # 获取802.1x会话1统计\n    import pandas\n    result = get_dot1x_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dot1x_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_dot1x_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_dot1x_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dot1x_block_statistic(Session=session_1)\n    print(result)\n    result = get_dot1x_block_statistic(Session=session_2)\n    print(result)\n\n    result = get_dot1x_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dot1x_statistic(Session=session_1, Index=1)\n    print(result)\n    result = get_dot1x_statistic(Session=session_2, Index=1)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "edit_interface_stack:修改测试仪表接口的结构",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_dot1x:创建802.1x会话对象",
      "get_dot1x_block_statistic:获取802.1x session block统计结果",
      "get_dot1x_port_statistic:获取802.1x port block统计结果",
      "get_dot1x_statistic:获取802.1x统计结果",
      "wait_dot1x_state:等待802.1x会话达到指定状态",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform for Product 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve two physical ports using reserve_port API with specified locations.\",\n  \"Subtask 3\": \"Create network interfaces on each reserved port using create_interface API.\",\n  \"Subtask 4\": \"Configure protocol stacks for both interfaces using edit_interface_stack API.\",\n  \"Subtask 5\": \"Set IPv4 parameters (Address and Gateway) for both interfaces using edit_interface API.\",\n  \"Subtask 6\": \"Create 802.1x protocol sessions on each port using create_dot1x API with unique names.\",\n  \"Subtask 7\": \"Bind network interfaces to corresponding 802.1x sessions using select_interface API.\",\n  \"Subtask 8\": \"Subscribe to 802.1x statistics views (Dot1xBlockStatistics, Dot1xPortStatistics, Dot1xStatistics) using subscribe_result API.\",\n  \"Subtask 9\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 10\": \"Start 802.1x protocol sessions using start_protocol API.\",\n  \"Subtask 11\": \"Wait until both 802.1x sessions reach AUTHENTICATING state using wait_dot1x_state API.\",\n  \"Subtask 12\": \"Allow 5 seconds traffic transmission time after protocol state achievement.\",\n  \"Subtask 13\": \"Retrieve and verify 802.1x port statistics for both ports collectively and individually using get_dot1x_port_statistic API.\",\n  \"Subtask 14\": \"Retrieve and verify 802.1x block statistics for both sessions collectively and individually using get_dot1x_block_statistic API.\",\n  \"Subtask 15\": \"Retrieve and verify 802.1x session statistics for both sessions collectively and individually using get_dot1x_statistic API.\",\n  \"Subtask 16\": \"Validate that sent packet counts equal received packet counts across all statistics views.\",\n  \"Subtask 17\": \"Stop 802.1x protocol sessions using stop_protocol API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Check that the 802.1x protocol bound flow is transmitted normally  \n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;  \n      Test Step 2: Create an 802.1x protocol on each port respectively;  \n      Test Step 3: Start the protocol and view protocol statistics;  \n\nCriteria: Expected Result 1: In step 6, all traffic sent and received packets are equal;  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface_stack(Interfaces=interfaces_1)\n    edit_interface_stack(Interfaces=interfaces_2)\n\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建802.1x协议会话\n\n    session_1 = create_dot1x(Port=Port_UP, Name='Dot1x_1')\n    session_2 = create_dot1x(Port=Port_Down, Name='Dot1x_2')\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n\n    # 订阅统计\n\n    subscribe_result(Types=['Dot1xBlockStatistics', 'Dot1xPortStatistics', 'Dot1xStatistics'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待PPPoE协议会话达到CONNECTED状态\n\n    wait_dot1x_state(Sessions=[session_1, session_2], State='AUTHENTICATING')\n\n    time.sleep(5)\n\n    # 获取802.1x会话1统计\n    import pandas\n    result = get_dot1x_port_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_dot1x_port_statistic(Port=Port_UP)\n    print(result)\n    result = get_dot1x_port_statistic(Port=Port_Down)\n    print(result)\n\n    result = get_dot1x_block_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dot1x_block_statistic(Session=session_1)\n    print(result)\n    result = get_dot1x_block_statistic(Session=session_2)\n    print(result)\n\n    result = get_dot1x_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n    result = get_dot1x_statistic(Session=session_1, Index=1)\n    print(result)\n    result = get_dot1x_statistic(Session=session_2, Index=1)\n    print(result)\n\n    stop_protocol()\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nedit_interface_stack:修改测试仪表接口的结构;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_dot1x:创建802.1x会话对象;\nget_dot1x_block_statistic:获取802.1x session block统计结果;\nget_dot1x_port_statistic:获取802.1x port block统计结果;\nget_dot1x_statistic:获取802.1x统计结果;\nwait_dot1x_state:等待802.1x会话达到指定状态;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/TWAMP/twamp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查twamp统计获取正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建client / server;\n                   测试步骤3: 启动协议，查看协议统计;\n\n Criteria    \t:   预期结果1: 步骤3中统计获取正确;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Check that twamp statistics are obtained correctly\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\nStep 2: Create client and server respectively on the two ports;\nStep 3: Start the protocol and view protocol statistics;\n\nCriteria: Expected result 1: Statistics are obtained correctly in step 3;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建协议会话\n\n    client = create_twamp(Port=Port_UP,\n                          ActiveClient=True,\n                          PeerIpv4Address='1.1.1.2')\n    server = create_twamp(Port=Port_Down,\n                          ActiveServer=True)\n\n    select_interface(Session=client, Interface=interfaces_1)\n    select_interface(Session=server, Interface=interfaces_2)\n\n    # 创建test session\n    session_1 = edit_twamp_test_session(Twamps=client)\n    session_2 = edit_twamp_test_session(Twamps=client)\n\n    # 订阅统计\n\n    subscribe_result(Types=['TwampClientStats', 'TwampServerStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    twamp_start(Sessions=[client, server])\n    wait_twamp_state(Sessions=client)\n    wait_twamp_state(Sessions=server, State='STARTED')\n    time.sleep(2)\n\n    # 获取统计\n    result = get_twamp_client_statistic(Sessions=client)\n    print(result)\n\n    result = get_twamp_server_statistic(Sessions=server)\n    print(result)\n\n    twamp_stop(Sessions=[client, server])\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product parameters.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using their location addresses.\",\n  \"Subtask 3\": \"Create an IPv4 interface on Port_1 with address '1.1.1.1' and gateway '1.1.1.2'.\",\n  \"Subtask 4\": \"Create an IPv4 interface on Port_2 with address '1.1.1.2' and gateway '1.1.1.1'.\",\n  \"Subtask 5\": \"Create a TWAMP client session on Port_1 with active mode enabled and peer IP set to '1.1.1.2'.\",\n  \"Subtask 6\": \"Create a TWAMP server session on Port_2 with active mode enabled.\",\n  \"Subtask 7\": \"Bind the IPv4 interface to the TWAMP client session.\",\n  \"Subtask 8\": \"Bind the IPv4 interface to the TWAMP server session.\",\n  \"Subtask 9\": \"Configure TWAMP test sessions for the client.\",\n  \"Subtask 10\": \"Subscribe to TWAMP client and server statistics views.\",\n  \"Subtask 11\": \"Save the current configuration to a file.\",\n  \"Subtask 12\": \"Start both TWAMP client and server sessions.\",\n  \"Subtask 13\": \"Wait until the TWAMP client session reaches active state.\",\n  \"Subtask 14\": \"Wait until the TWAMP server session reaches 'STARTED' state.\",\n  \"Subtask 15\": \"Allow 2 seconds for statistics accumulation after session activation.\",\n  \"Subtask 16\": \"Retrieve and display TWAMP client session statistics.\",\n  \"Subtask 17\": \"Retrieve and display TWAMP server session statistics.\",\n  \"Subtask 18\": \"Stop both TWAMP client and server sessions.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Check that twamp statistics are obtained correctly\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\nStep 2: Create client and server respectively on the two ports;\nStep 3: Start the protocol and view protocol statistics;\n\nCriteria: Expected result 1: Statistics are obtained correctly in step 3;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_UP)\n    interfaces_2 = create_interface(Port=Port_Down)\n    edit_interface(Interface=interfaces_1, Layer='IPv4Layer', Address='1.1.1.1', Gateway='1.1.1.2')\n    edit_interface(Interface=interfaces_2, Layer='IPv4Layer', Address='1.1.1.2', Gateway='1.1.1.1')\n\n    # 创建协议会话\n\n    client = create_twamp(Port=Port_UP,\n                          ActiveClient=True,\n                          PeerIpv4Address='1.1.1.2')\n    server = create_twamp(Port=Port_Down,\n                          ActiveServer=True)\n\n    select_interface(Session=client, Interface=interfaces_1)\n    select_interface(Session=server, Interface=interfaces_2)\n\n    # 创建test session\n    session_1 = edit_twamp_test_session(Twamps=client)\n    session_2 = edit_twamp_test_session(Twamps=client)\n\n    # 订阅统计\n\n    subscribe_result(Types=['TwampClientStats', 'TwampServerStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    twamp_start(Sessions=[client, server])\n    wait_twamp_state(Sessions=client)\n    wait_twamp_state(Sessions=server, State='STARTED')\n    time.sleep(2)\n\n    # 获取统计\n    result = get_twamp_client_statistic(Sessions=client)\n    print(result)\n\n    result = get_twamp_server_statistic(Sessions=server)\n    print(result)\n\n    twamp_stop(Sessions=[client, server])\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/IGMP/IGMPv2.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查IGMP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建IGMP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective    :   Test Objective: Verify that the IGMP protocol bound stream is transmitted correctly\n\nStep        :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                Step 2: Create IGMP protocols on both ports and establish routing;\n                Step 3: Create bound traffic;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Transmit all traffic and wait for a duration;\n                Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria    :   Expected Result 1: In Step 6, all traffic shows equal transmitted and received packets;\n\nCreated by  :   Tester-001\n\nBugs        :   None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IGMP协议会话\n\n    igmp = create_igmp(Port=Port_UP)\n\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n\n    select_interface(Session=igmp, Interface=interfaces_1)\n\n    # 创建组播组\n\n    multicast_group = create_multicast_group(Start='225.0.1.2')\n\n    # IGMP协议会话创建组成员关系\n\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # 将组播组和IGMP组成员关系绑定\n\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=Port_Down, Version='IGMPV2')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_2)\n\n    # 创建IGMP绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待IGMP协议会话稳定状态\n\n    wait_igmp_state(Sessions=[igmp])\n    wait_igmp_querier_state(Sessions=[igmp_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取IGMP Host统计\n\n    result = get_igmp_host_statistic(Session=igmp)\n    print(result)\n\n    # 获取IGMP Port统计\n\n    result = get_igmp_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取IGMP Querier统计\n\n    result = get_igmp_querier_statistic(Session=igmp_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_igmp:创建IGMP协议会话对象",
      "create_igmp_querier:创建IGMP Querier协议会话对象",
      "edit_igmp:编辑IGMP协议会话对象",
      "edit_igmp_querier:编辑IGMP Querier协议会话对象",
      "get_igmp_host_statistic:获取Igmp协议会话统计结果",
      "get_igmp_port_statistic:获取Igmp Port统计结果",
      "get_igmp_querier_statistic:获取Igmp Querier协议会话统计结果",
      "wait_igmp_querier_state:等待Igmp Querier协议会话达到指定状态",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two test ports labeled Port_UP and Port_Down using the reserve_port API function.\",\n  \"Subtask 2\": \"Create IPv4 interfaces on both reserved ports with create_interface API, then configure IP addresses and gateways using edit_interface API.\",\n  \"Subtask 3\": \"Create an IGMP host session on Port_UP using create_igmp API, configure it with InitialJoin=True via edit_igmp, and bind it to the interface using select_interface.\",\n  \"Subtask 4\": \"Create an IGMP querier session on Port_Down using create_igmp_querier API with version IGMPV2, set RobustnessVariable=3 via edit_igmp_querier, and bind it to the interface.\",\n  \"Subtask 5\": \"Create a multicast group starting at '225.0.1.2' using create_multicast_group API.\",\n  \"Subtask 6\": \"Create memberships for the IGMP session using create_memberships API with ROUNDROBIN mapping, then bind the multicast group to the session using binding_multicast_group API.\",\n  \"Subtask 7\": \"Create bound traffic using add_stream API, sourcing from Port_Down's interface layer (obtained via get_layer_from_interfaces) and targeting the multicast group.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 9\": \"Save the test configuration using save_case API.\",\n  \"Subtask 10\": \"Start all protocols using start_protocol API.\",\n  \"Subtask 11\": \"Wait for IGMP host session to reach stable state using wait_igmp_state API and IGMP querier session using wait_igmp_querier_state API.\",\n  \"Subtask 12\": \"Start traffic transmission using start_stream API and let it run for 60 seconds.\",\n  \"Subtask 13\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 14\": \"Stop all protocols using stop_protocol API.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats for the bound traffic using get_streamblock_statistic API.\",\n  \"Subtask 16\": \"Verify that TxStreamFrames equals RxStreamFrames in the StreamBlockStats results.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective    :   Test Objective: Verify that the IGMP protocol bound stream is transmitted correctly\n\nStep        :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                Step 2: Create IGMP protocols on both ports and establish routing;\n                Step 3: Create bound traffic;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Transmit all traffic and wait for a duration;\n                Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria    :   Expected Result 1: In Step 6, all traffic shows equal transmitted and received packets;\n\nCreated by  :   Tester-001\n\nBugs        :   None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IGMP协议会话\n\n    igmp = create_igmp(Port=Port_UP)\n\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n\n    select_interface(Session=igmp, Interface=interfaces_1)\n\n    # 创建组播组\n\n    multicast_group = create_multicast_group(Start='225.0.1.2')\n\n    # IGMP协议会话创建组成员关系\n\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # 将组播组和IGMP组成员关系绑定\n\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=Port_Down, Version='IGMPV2')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_2)\n\n    # 创建IGMP绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待IGMP协议会话稳定状态\n\n    wait_igmp_state(Sessions=[igmp])\n    wait_igmp_querier_state(Sessions=[igmp_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取IGMP Host统计\n\n    result = get_igmp_host_statistic(Session=igmp)\n    print(result)\n\n    # 获取IGMP Port统计\n\n    result = get_igmp_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取IGMP Querier统计\n\n    result = get_igmp_querier_statistic(Session=igmp_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_igmp:创建IGMP协议会话对象;\ncreate_igmp_querier:创建IGMP Querier协议会话对象;\nedit_igmp:编辑IGMP协议会话对象;\nedit_igmp_querier:编辑IGMP Querier协议会话对象;\nget_igmp_host_statistic:获取Igmp协议会话统计结果;\nget_igmp_port_statistic:获取Igmp Port统计结果;\nget_igmp_querier_statistic:获取Igmp Querier协议会话统计结果;\nwait_igmp_querier_state:等待Igmp Querier协议会话达到指定状态;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/MLD/MLDv1.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查MLD协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建MLD协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify that MLD protocol binding flow is sent normally\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                    Test Step 2: Create MLD protocols on both ports respectively and create routes;\n                    Test Step 3: Create binding traffic;\n                    Test Step 4: Subscribe to StreamBlockStats statistics;\n                    Test Step 5: Send all traffic, wait for a period of time;\n                    Test Step 6: Stop all traffic, view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, all traffic sent and received packets are equal;\n\nCreated by   \t:  \tTester-001\n\nBugs   \t    :  \tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2000::3',\n                   Gateway='2000::2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2000::2',\n                   Gateway='2000::3')\n\n    # 创建MLD协议会话\n\n    mld = create_mld(Port=Port_UP)\n\n    edit_mld(Session=mld, Version='MLDV1', InitialJoin=True)\n\n    # MLD协议会话与接口绑定\n\n    select_interface(Session=mld, Interface=interfaces_1)\n\n    # MLD协议会话1创建Summary Lsa\n\n    multicast_group = create_multicast_group(Start='ff1e::2', Version=\"IPv6\")\n\n    # MLD协议会话2创建External Lsa\n\n    memberships = create_memberships(Session=mld, DeviceGroupMapping='ROUNDROBIN')\n\n    # 获取MLD协议绑定流端点对象\n\n    binding_multicast_group(Session=mld, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建MLD Querier协议会话\n\n    mld_querier = create_mld_querier(Port=Port_Down, Version='MLDV1')\n\n    edit_mld_querier(Session=mld_querier, RobustnessVariable=3)\n\n    # MLD Querier协议会话与接口绑定\n\n    select_interface(Session=mld_querier, Interface=interfaces_2)\n\n    # 创建MLD绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv6')\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'MldHostResults', 'MldPortAggregatedResults', 'MldQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待MLD协议会话稳定状态\n\n    wait_mld_state(Sessions=[mld])\n    wait_mld_querier_state(Sessions=[mld_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取MLD Host统计\n    result = get_mld_host_statistic()\n    print(result)\n\n    result = get_mld_host_statistic(Session=mld)\n    print(result)\n\n    # 获取MLD Port统计\n    result = get_mld_port_statistic()\n    print(result)\n\n    result = get_mld_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取MLD Querier统计\n    result = get_mld_querier_statistic()\n    print(result)\n\n    result = get_mld_querier_statistic(Session=mld_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_mld:创建MLD协议会话对象",
      "create_mld_querier:创建MLD Querier协议会话对象",
      "edit_mld:创建MLD协议会话对象",
      "edit_mld_querier:编辑MLD Querier协议会话对象",
      "get_mld_host_statistic:获取Mld协议会话统计结果",
      "get_mld_port_statistic:获取Mld Port统计结果",
      "get_mld_querier_statistic:获取Mld Querier协议会话统计结果",
      "wait_mld_querier_state:等待Mld Querier协议会话达到指定状态",
      "wait_mld_state:等待Mld协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu' to prepare the testing environment.\",\n  \"Subtask 2\": \"Reserve two ports using specified locations for Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create IPv6 interfaces on both reserved ports and configure their IPv6 addresses and gateways.\",\n  \"Subtask 4\": \"Create an MLD session on Port_UP and configure it with version MLDv1 and initial join enabled.\",\n  \"Subtask 5\": \"Bind the MLD session to the IPv6 interface on Port_UP.\",\n  \"Subtask 6\": \"Create an IPv6 multicast group starting at 'ff1e::2'.\",\n  \"Subtask 7\": \"Create memberships for the MLD session and bind them to the multicast group.\",\n  \"Subtask 8\": \"Create an MLD Querier session on Port_Down and set robustness variable to 3.\",\n  \"Subtask 9\": \"Bind the MLD Querier session to the IPv6 interface on Port_Down.\",\n  \"Subtask 10\": \"Get the IPv6 layer object from the interface on Port_Down for traffic source.\",\n  \"Subtask 11\": \"Create unidirectional binding traffic stream from Port_Down IPv6 layer to multicast group.\",\n  \"Subtask 12\": \"Subscribe to StreamBlockStats, MldHostResults, MldPortAggregatedResults, and MldQuerier statistics.\",\n  \"Subtask 13\": \"Save test configuration to specified file path.\",\n  \"Subtask 14\": \"Start MLD and MLD Querier protocols.\",\n  \"Subtask 15\": \"Wait until MLD session and MLD Querier session reach stable state, then wait 5 seconds.\",\n  \"Subtask 16\": \"Start traffic streams and wait 60 seconds for transmission.\",\n  \"Subtask 17\": \"Stop all traffic streams.\",\n  \"Subtask 18\": \"Stop MLD and MLD Querier protocols, then wait 3 seconds.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats for the created traffic stream.\",\n  \"Subtask 20\": \"Verify that transmitted frame count equals received frame count in StreamBlockStats.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify that MLD protocol binding flow is sent normally\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                    Test Step 2: Create MLD protocols on both ports respectively and create routes;\n                    Test Step 3: Create binding traffic;\n                    Test Step 4: Subscribe to StreamBlockStats statistics;\n                    Test Step 5: Send all traffic, wait for a period of time;\n                    Test Step 6: Stop all traffic, view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, all traffic sent and received packets are equal;\n\nCreated by   \t:  \tTester-001\n\nBugs   \t    :  \tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv6'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv6'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv6Layer',\n                   Address='2000::3',\n                   Gateway='2000::2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv6Layer',\n                   Address='2000::2',\n                   Gateway='2000::3')\n\n    # 创建MLD协议会话\n\n    mld = create_mld(Port=Port_UP)\n\n    edit_mld(Session=mld, Version='MLDV1', InitialJoin=True)\n\n    # MLD协议会话与接口绑定\n\n    select_interface(Session=mld, Interface=interfaces_1)\n\n    # MLD协议会话1创建Summary Lsa\n\n    multicast_group = create_multicast_group(Start='ff1e::2', Version=\"IPv6\")\n\n    # MLD协议会话2创建External Lsa\n\n    memberships = create_memberships(Session=mld, DeviceGroupMapping='ROUNDROBIN')\n\n    # 获取MLD协议绑定流端点对象\n\n    binding_multicast_group(Session=mld, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建MLD Querier协议会话\n\n    mld_querier = create_mld_querier(Port=Port_Down, Version='MLDV1')\n\n    edit_mld_querier(Session=mld_querier, RobustnessVariable=3)\n\n    # MLD Querier协议会话与接口绑定\n\n    select_interface(Session=mld_querier, Interface=interfaces_2)\n\n    # 创建MLD绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv6')\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'MldHostResults', 'MldPortAggregatedResults', 'MldQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待MLD协议会话稳定状态\n\n    wait_mld_state(Sessions=[mld])\n    wait_mld_querier_state(Sessions=[mld_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取MLD Host统计\n    result = get_mld_host_statistic()\n    print(result)\n\n    result = get_mld_host_statistic(Session=mld)\n    print(result)\n\n    # 获取MLD Port统计\n    result = get_mld_port_statistic()\n    print(result)\n\n    result = get_mld_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取MLD Querier统计\n    result = get_mld_querier_statistic()\n    print(result)\n\n    result = get_mld_querier_statistic(Session=mld_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_mld:创建MLD协议会话对象;\ncreate_mld_querier:创建MLD Querier协议会话对象;\nedit_mld:创建MLD协议会话对象;\nedit_mld_querier:编辑MLD Querier协议会话对象;\nget_mld_host_statistic:获取Mld协议会话统计结果;\nget_mld_port_statistic:获取Mld Port统计结果;\nget_mld_querier_statistic:获取Mld Querier协议会话统计结果;\nwait_mld_querier_state:等待Mld Querier协议会话达到指定状态;\nwait_mld_state:等待Mld协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Overall/smart_scripter_control_while_if_break.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 使用智能脚本控制命令while if elseif else break\n\n Step\t\t\t:\t测试步骤1: 创建端口;\n                   测试步骤2: 创建bgp会话及路由;\n                   测试步骤3: 启动协议发送流量;\n                   测试步骤4: 检查统计;\n\n Criteria    \t:   预期结果1: 步骤4 判断端口发送报文数量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Use intelligent script control commands while, if, elseif, else, break\n\nStep: Test Step 1: Create ports;\nTest Step 2: Create BGP sessions and routes;\nTest Step 3: Start protocol to send traffic;\nTest Step 4: Check statistics;\n\nCriteria: Expected Result 1: Step 4 verifies port transmitted packet count;\n\nCreated by: Tester-002\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.192/1/1', '//10.0.11.192/1/2', '//10.0.11.192/1/3'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'BigTao' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_3 = reserve_port(Locations=locations[:3])\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_1, Layers='ipv4')\n    interfaces_2 = create_interface(Port=port_2, Layers='ipv4')\n    interfaces_3 = create_interface(Port=port_3, Layers='ipv4')\n\n    # 创建BGP协议会话\n    session_1 = create_bgp(Port=port_1)\n    session_2 = create_bgp(Port=port_2)\n    session_3 = create_bgp(Port=port_3)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n    select_interface(Session=session_3, Interface=interfaces_3)\n\n    # BGP协议会话1创建ipv4 route pool\n    ipv4_route_1 = create_bgp_ipv4_route_pool(Session=session_1, FirstRoute='1.0.0.1')\n    ipv4_route_2 = create_bgp_ipv4_route_pool(Session=session_2, FirstRoute='2.0.0.1')\n    ipv4_route_3 = create_bgp_ipv4_route_pool(Session=session_3, FirstRoute='3.0.0.1')\n\n    # 创建raw stream\n    stream_1 = add_stream(Ports=port_1)\n    stream_2 = add_stream(Ports=port_2)\n    stream_3 = add_stream(Ports=port_3)\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats'])\n\n    # 使用智能脚本的while if elseif else break命令\n    ggroup = smart_scripter_global_group()\n\n    whilecommand = smart_scripter_command(ParentGroup=ggroup,\n                                          Command='WhileCommand')\n    bgp_handles = get_object_attrs([session_1, session_2, session_3])\n    whilecontrol = smart_scripter_control_condition(ControlCommand=whilecommand,\n                                                    ControlConditionName='StartProtocolCommand',\n                                                    ConditionResult='PASS',\n                                                    ProtocolList=bgp_handles)\n\n    ifcommand = smart_scripter_command(ParentGroup=whilecommand,\n                                       Command='IfCommand')\n    stream_handle_1 = get_object_attrs(stream_1)\n    startstreamcommand_1 = smart_scripter_command(ParentGroup=ifcommand,\n                                                  Command='StartStreamCommand',\n                                                  StreamList=stream_handle_1)\n\n    bgp_route_1 = get_object_attrs(ipv4_route_1)\n    ifcontrol = smart_scripter_control_condition(ControlCommand=ifcommand,\n                                                 ControlConditionName='AdvertiseBgpRouteBlockCommand',\n                                                 ConditionResult='PASS',\n                                                 BgpRouteBlockHandles=bgp_route_1)\n    breakcommand = smart_scripter_command(ParentGroup=ifcommand,\n                                          Command='BreakCommand')\n\n    elseifcommand = smart_scripter_command(ParentGroup=whilecommand,\n                                           Command='ElseIfCommand')\n    stream_handle_2 = get_object_attrs(stream_2)\n    startstreamcommand_2 = smart_scripter_command(ParentGroup=elseifcommand,\n                                                  Command='StartStreamCommand',\n                                                  StreamList=stream_handle_2)\n    bgp_route_2 = get_object_attrs(ipv4_route_2)\n    elseifcontrol = smart_scripter_control_condition(ControlCommand=elseifcommand,\n                                                     ControlConditionName='AdvertiseBgpRouteBlockCommand',\n                                                     ConditionResult='PASS',\n                                                     BgpRouteBlockHandles=bgp_route_2)\n\n    elsecommand = smart_scripter_command(ParentGroup=whilecommand,\n                                         Command='ElseCommand')\n    stream_handle_3 = get_object_attrs(stream_3)\n    startstreamcommand_3 = smart_scripter_command(ParentGroup=elsecommand,\n                                                  Command='StartStreamCommand',\n                                                  StreamList=stream_handle_3)\n\n    run_benchmark()\n    # 获取统计\n    time.sleep(5)\n    result = get_port_statistic()\n    print(result)\n    assert result['TxStreamFrames'][0] > 0\n    stop_stream()\n    clear_result()\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "create_bgp:创建BGP协议会话对象",
      "create_bgp_ipv4_route_pool:创建BGP IPv4路由对象",
      "select_interface:协议绑定测试仪表接口",
      "clear_result:清除测试仪表统计",
      "get_port_statistic:获取测试仪表端口统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "stop_stream:测试仪表停止发送数据流",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (default 'BigTao')\",\n  \"Subtask 2\": \"Reserve three ports using provided locations\",\n  \"Subtask 3\": \"Create IPv4 interfaces on each reserved port\",\n  \"Subtask 4\": \"Create BGP sessions on each port\",\n  \"Subtask 5\": \"Bind each BGP session to its corresponding IPv4 interface\",\n  \"Subtask 6\": \"Create BGP IPv4 route pools for each session with initial routes (1.0.0.1, 2.0.0.1, 3.0.0.1)\",\n  \"Subtask 7\": \"Create raw traffic streams on each port\",\n  \"Subtask 8\": \"Subscribe to port statistics view\",\n  \"Subtask 9\": \"Create global smart script group for control commands\",\n  \"Subtask 10\": \"Configure WhileCommand condition: loop while BGP sessions start successfully\",\n  \"Subtask 11\": \"Configure IfCommand condition: when first route pool advertises successfully, start port 1 stream and break loop\",\n  \"Subtask 12\": \"Configure ElseIfCommand condition: when second route pool advertises successfully, start port 2 stream\",\n  \"Subtask 13\": \"Configure ElseCommand: when other conditions fail, start port 3 stream\",\n  \"Subtask 14\": \"Execute benchmark to run configured test suite with control commands\",\n  \"Subtask 15\": \"Wait 5 seconds for traffic transmission\",\n  \"Subtask 16\": \"Retrieve port statistics results\",\n  \"Subtask 17\": \"Verify transmitted packet count (TxStreamFrames) on first port exceeds 0\",\n  \"Subtask 18\": \"Stop all active traffic streams\",\n  \"Subtask 19\": \"Clear statistics results from tester\",\n  \"Subtask 20\": \"Save test case configuration to file\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Use intelligent script control commands while, if, elseif, else, break\n\nStep: Test Step 1: Create ports;\nTest Step 2: Create BGP sessions and routes;\nTest Step 3: Start protocol to send traffic;\nTest Step 4: Check statistics;\n\nCriteria: Expected Result 1: Step 4 verifies port transmitted packet count;\n\nCreated by: Tester-002\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.192/1/1', '//10.0.11.192/1/2', '//10.0.11.192/1/3'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'BigTao' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_3 = reserve_port(Locations=locations[:3])\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_1, Layers='ipv4')\n    interfaces_2 = create_interface(Port=port_2, Layers='ipv4')\n    interfaces_3 = create_interface(Port=port_3, Layers='ipv4')\n\n    # 创建BGP协议会话\n    session_1 = create_bgp(Port=port_1)\n    session_2 = create_bgp(Port=port_2)\n    session_3 = create_bgp(Port=port_3)\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n    select_interface(Session=session_3, Interface=interfaces_3)\n\n    # BGP协议会话1创建ipv4 route pool\n    ipv4_route_1 = create_bgp_ipv4_route_pool(Session=session_1, FirstRoute='1.0.0.1')\n    ipv4_route_2 = create_bgp_ipv4_route_pool(Session=session_2, FirstRoute='2.0.0.1')\n    ipv4_route_3 = create_bgp_ipv4_route_pool(Session=session_3, FirstRoute='3.0.0.1')\n\n    # 创建raw stream\n    stream_1 = add_stream(Ports=port_1)\n    stream_2 = add_stream(Ports=port_2)\n    stream_3 = add_stream(Ports=port_3)\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats'])\n\n    # 使用智能脚本的while if elseif else break命令\n    ggroup = smart_scripter_global_group()\n\n    whilecommand = smart_scripter_command(ParentGroup=ggroup,\n                                          Command='WhileCommand')\n    bgp_handles = get_object_attrs([session_1, session_2, session_3])\n    whilecontrol = smart_scripter_control_condition(ControlCommand=whilecommand,\n                                                    ControlConditionName='StartProtocolCommand',\n                                                    ConditionResult='PASS',\n                                                    ProtocolList=bgp_handles)\n\n    ifcommand = smart_scripter_command(ParentGroup=whilecommand,\n                                       Command='IfCommand')\n    stream_handle_1 = get_object_attrs(stream_1)\n    startstreamcommand_1 = smart_scripter_command(ParentGroup=ifcommand,\n                                                  Command='StartStreamCommand',\n                                                  StreamList=stream_handle_1)\n\n    bgp_route_1 = get_object_attrs(ipv4_route_1)\n    ifcontrol = smart_scripter_control_condition(ControlCommand=ifcommand,\n                                                 ControlConditionName='AdvertiseBgpRouteBlockCommand',\n                                                 ConditionResult='PASS',\n                                                 BgpRouteBlockHandles=bgp_route_1)\n    breakcommand = smart_scripter_command(ParentGroup=ifcommand,\n                                          Command='BreakCommand')\n\n    elseifcommand = smart_scripter_command(ParentGroup=whilecommand,\n                                           Command='ElseIfCommand')\n    stream_handle_2 = get_object_attrs(stream_2)\n    startstreamcommand_2 = smart_scripter_command(ParentGroup=elseifcommand,\n                                                  Command='StartStreamCommand',\n                                                  StreamList=stream_handle_2)\n    bgp_route_2 = get_object_attrs(ipv4_route_2)\n    elseifcontrol = smart_scripter_control_condition(ControlCommand=elseifcommand,\n                                                     ControlConditionName='AdvertiseBgpRouteBlockCommand',\n                                                     ConditionResult='PASS',\n                                                     BgpRouteBlockHandles=bgp_route_2)\n\n    elsecommand = smart_scripter_command(ParentGroup=whilecommand,\n                                         Command='ElseCommand')\n    stream_handle_3 = get_object_attrs(stream_3)\n    startstreamcommand_3 = smart_scripter_command(ParentGroup=elsecommand,\n                                                  Command='StartStreamCommand',\n                                                  StreamList=stream_handle_3)\n\n    run_benchmark()\n    # 获取统计\n    time.sleep(5)\n    result = get_port_statistic()\n    print(result)\n    assert result['TxStreamFrames'][0] > 0\n    stop_stream()\n    clear_result()\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\ncreate_bgp:创建BGP协议会话对象;\ncreate_bgp_ipv4_route_pool:创建BGP IPv4路由对象;\nselect_interface:协议绑定测试仪表接口;\nclear_result:清除测试仪表统计;\nget_port_statistic:获取测试仪表端口统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstop_stream:测试仪表停止发送数据流;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/IGMP/IGMPv3.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查IGMP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建IGMP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     :   Objective: Verify that the IGMP protocol bound stream transmits correctly\n\nStep          :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                  Step 2: Create IGMP protocols and establish routing on both ports;\n                  Step 3: Create bound traffic;\n                  Step 4: Subscribe to StreamBlockStats statistics;\n                  Step 5: Transmit all traffic and wait for a period;\n                  Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In step 6, all traffic shows equal packets sent/received;\n\nCreated by    :   Tester-001\n\nBugs          :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IGMP协议会话\n\n    igmp = create_igmp(Port=Port_UP)\n\n    edit_igmp(Session=igmp, Version='IGMPV3')\n\n    # IGMP协议会话与接口绑定\n\n    select_interface(Session=igmp, Interface=interfaces_1)\n\n    # IGMP协议会话1创建Summary Lsa\n\n    multicast_group = create_multicast_group(Start='225.0.1.2')\n\n    # IGMP协议会话2创建External Lsa\n\n    memberships = create_memberships(Session=igmp,\n                                     DeviceGroupMapping='ROUNDROBIN',\n                                     UserDefinedSources=False)\n\n    # 获取IGMP协议绑定流端点对象\n\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    select_source_interface(Session=igmp, Memberships=memberships, Interface=interfaces_2)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=Port_Down, Version='IGMPV3')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_2)\n\n    # 创建IGMP绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待IGMP协议会话稳定状态\n\n    wait_igmp_state(Sessions=[igmp])\n    wait_igmp_querier_state(Sessions=[igmp_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取IGMP Host统计\n\n    result = get_igmp_host_statistic(Session=igmp)\n    print(result)\n\n    # 获取IGMP Port统计\n\n    result = get_igmp_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取IGMP Querier统计\n\n    result = get_igmp_querier_statistic(Session=igmp_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_igmp:创建IGMP协议会话对象",
      "create_igmp_querier:创建IGMP Querier协议会话对象",
      "edit_igmp:编辑IGMP协议会话对象",
      "edit_igmp_querier:编辑IGMP Querier协议会话对象",
      "get_igmp_host_statistic:获取Igmp协议会话统计结果",
      "get_igmp_port_statistic:获取Igmp Port统计结果",
      "get_igmp_querier_statistic:获取Igmp Querier协议会话统计结果",
      "select_source_interface:将协议会话组播组过滤源地址绑定到指定接口",
      "wait_igmp_querier_state:等待Igmp Querier协议会话达到指定状态",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (default 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports using provided locations and assign as Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both ports: configure Port_UP with IP 192.168.1.2/gateway 192.168.1.3, and Port_Down with IP 192.168.1.3/gateway 192.168.1.2.\",\n  \"Subtask 4\": \"Create IGMP session on Port_UP, set version to IGMPv3, and bind to Port_UP's interface.\",\n  \"Subtask 5\": \"Create multicast group starting at 225.0.1.2.\",\n  \"Subtask 6\": \"Create memberships for IGMP session with DeviceGroupMapping='ROUNDROBIN' and UserDefinedSources=False.\",\n  \"Subtask 7\": \"Bind multicast group to IGMP memberships and set source interface to Port_Down's interface.\",\n  \"Subtask 8\": \"Create IGMP Querier on Port_Down with version IGMPv3, set robustness variable to 3, and bind to Port_Down's interface.\",\n  \"Subtask 9\": \"Create unidirectional binding stream from IPv4 layer of Port_Down's interface to multicast group.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats, IgmpHostResults, IgmpPortAggregatedResults, and IgmpQuerierResult statistics.\",\n  \"Subtask 11\": \"Save current configuration to file in script directory with .xcfg extension.\",\n  \"Subtask 12\": \"Start IGMP and IGMP Querier protocols.\",\n  \"Subtask 13\": \"Wait for IGMP session and IGMP Querier session to reach stable state, then wait 5 seconds.\",\n  \"Subtask 14\": \"Start all traffic streams and run for 60 seconds.\",\n  \"Subtask 15\": \"Stop all traffic streams.\",\n  \"Subtask 16\": \"Stop all protocols and wait 3 seconds.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats for created stream, compare TxStreamFrames and RxStreamFrames values, and fail test if unequal.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     :   Objective: Verify that the IGMP protocol bound stream transmits correctly\n\nStep          :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                  Step 2: Create IGMP protocols and establish routing on both ports;\n                  Step 3: Create bound traffic;\n                  Step 4: Subscribe to StreamBlockStats statistics;\n                  Step 5: Transmit all traffic and wait for a period;\n                  Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In step 6, all traffic shows equal packets sent/received;\n\nCreated by    :   Tester-001\n\nBugs          :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IGMP协议会话\n\n    igmp = create_igmp(Port=Port_UP)\n\n    edit_igmp(Session=igmp, Version='IGMPV3')\n\n    # IGMP协议会话与接口绑定\n\n    select_interface(Session=igmp, Interface=interfaces_1)\n\n    # IGMP协议会话1创建Summary Lsa\n\n    multicast_group = create_multicast_group(Start='225.0.1.2')\n\n    # IGMP协议会话2创建External Lsa\n\n    memberships = create_memberships(Session=igmp,\n                                     DeviceGroupMapping='ROUNDROBIN',\n                                     UserDefinedSources=False)\n\n    # 获取IGMP协议绑定流端点对象\n\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    select_source_interface(Session=igmp, Memberships=memberships, Interface=interfaces_2)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=Port_Down, Version='IGMPV3')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_2)\n\n    # 创建IGMP绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待IGMP协议会话稳定状态\n\n    wait_igmp_state(Sessions=[igmp])\n    wait_igmp_querier_state(Sessions=[igmp_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取IGMP Host统计\n\n    result = get_igmp_host_statistic(Session=igmp)\n    print(result)\n\n    # 获取IGMP Port统计\n\n    result = get_igmp_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取IGMP Querier统计\n\n    result = get_igmp_querier_statistic(Session=igmp_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_igmp:创建IGMP协议会话对象;\ncreate_igmp_querier:创建IGMP Querier协议会话对象;\nedit_igmp:编辑IGMP协议会话对象;\nedit_igmp_querier:编辑IGMP Querier协议会话对象;\nget_igmp_host_statistic:获取Igmp协议会话统计结果;\nget_igmp_port_statistic:获取Igmp Port统计结果;\nget_igmp_querier_statistic:获取Igmp Querier协议会话统计结果;\nselect_source_interface:将协议会话组播组过滤源地址绑定到指定接口;\nwait_igmp_querier_state:等待Igmp Querier协议会话达到指定状态;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Overall/smart_scripter_control_loop.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 使用智能脚本控制命令loop\n\n Step\t\t\t:\t测试步骤1: 创建端口;\n                   测试步骤2: 创建流量;\n                   测试步骤3: 检查统计;\n\n Criteria    \t:   预期结果1: 步骤3 判断端口发送报文数量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test purpose: Use intelligent script to control command loop\n\nStep: Step 1: Create port;\n      Step 2: Create traffic;\n      Step 3: Check statistics;\n\nCriteria: Expected result 1: Step 3: Determine the number of packets sent by the port;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.192/1/1', '//10.0.11.192/1/2'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'BigTao' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2 = reserve_port(Locations=locations[:2])\n\n    # 创建raw stream\n    stream_1 = add_stream(Ports=port_1)\n    stream_2 = add_stream(Ports=port_2)\n    edit_port_load_profile(Ports=[port_1, port_2],\n                           TransmitMode='BURST',\n                           BurstSize=100)\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats'])\n\n    ggroup = smart_scripter_global_group()\n\n    # 使用智能脚本的loop命令\n    loopcommand = smart_scripter_command(ParentGroup=ggroup,\n                                         Command='LoopCommand',\n                                         LoopCount=2)\n    stream_handle_1 = get_object_attrs(stream_1)\n    start_stream_1 = smart_scripter_command(ParentGroup=loopcommand,\n                                            Command='StartStreamCommand',\n                                            StreamList=stream_handle_1)\n    stream_handle_2 = get_object_attrs(stream_2)\n    start_stream_2 = smart_scripter_command(ParentGroup=loopcommand,\n                                            Command='StartStreamCommand',\n                                            StreamList=stream_handle_2)\n    run_benchmark()\n    result = get_port_statistic()\n    print(result)\n    assert result['TxStreamFrames'][0] == 100\n    assert result['TxStreamFrames'][1] == 100\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (default 'BigTao' or from command line argument).\",\n  \"Subtask 2\": \"Reserve two ports using provided locations (default or from command line).\",\n  \"Subtask 3\": \"Create a raw stream on the first reserved port.\",\n  \"Subtask 4\": \"Create a raw stream on the second reserved port.\",\n  \"Subtask 5\": \"Configure both ports with burst transmission mode and burst size of 100 frames.\",\n  \"Subtask 6\": \"Subscribe to port statistics results.\",\n  \"Subtask 7\": \"Create a global command group for smart scripter operations.\",\n  \"Subtask 8\": \"Create a loop command within the global group with loop count set to 2.\",\n  \"Subtask 9\": \"Get handle of the first stream and create start stream command under the loop group.\",\n  \"Subtask 10\": \"Get handle of the second stream and create start stream command under the loop group.\",\n  \"Subtask 11\": \"Execute the benchmark to run configured commands (including loop and stream starts).\",\n  \"Subtask 12\": \"Retrieve port statistics results after test execution.\",\n  \"Subtask 13\": \"Verify transmitted frame count equals 100 for both ports.\",\n  \"Subtask 14\": \"Save test configuration to file in xcfg subdirectory with matching script name.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test purpose: Use intelligent script to control command loop\n\nStep: Step 1: Create port;\n      Step 2: Create traffic;\n      Step 3: Check statistics;\n\nCriteria: Expected result 1: Step 3: Determine the number of packets sent by the port;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.192/1/1', '//10.0.11.192/1/2'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'BigTao' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2 = reserve_port(Locations=locations[:2])\n\n    # 创建raw stream\n    stream_1 = add_stream(Ports=port_1)\n    stream_2 = add_stream(Ports=port_2)\n    edit_port_load_profile(Ports=[port_1, port_2],\n                           TransmitMode='BURST',\n                           BurstSize=100)\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats'])\n\n    ggroup = smart_scripter_global_group()\n\n    # 使用智能脚本的loop命令\n    loopcommand = smart_scripter_command(ParentGroup=ggroup,\n                                         Command='LoopCommand',\n                                         LoopCount=2)\n    stream_handle_1 = get_object_attrs(stream_1)\n    start_stream_1 = smart_scripter_command(ParentGroup=loopcommand,\n                                            Command='StartStreamCommand',\n                                            StreamList=stream_handle_1)\n    stream_handle_2 = get_object_attrs(stream_2)\n    start_stream_2 = smart_scripter_command(ParentGroup=loopcommand,\n                                            Command='StartStreamCommand',\n                                            StreamList=stream_handle_2)\n    run_benchmark()\n    result = get_port_statistic()\n    print(result)\n    assert result['TxStreamFrames'][0] == 100\n    assert result['TxStreamFrames'][1] == 100\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Overall/smart_scripter.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 使用智能脚本创建bgp协议并通告路由\n\n Step\t\t\t:\t测试步骤1: 创建2个离线端口Port_1、Port_2;\n                   测试步骤2: 创建bgp会话及路由;\n                   测试步骤3: 启动协议通告路由;\n                   测试步骤4: 检查统计;\n\n Criteria    \t:   预期结果1: 步骤4 获取通告路由数量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Test Objective: Use an intelligent script to create BGP protocol and advertise routes\n\nStep          : Step 1: Create two offline ports, Port_1 and Port_2;\n               Step 2: Create BGP sessions and routes;\n               Step 3: Start the protocol to advertise routes;\n               Step 4: Check statistics;\n\nCriteria      : Expected Result 1: Step 4: Obtain the number of advertised routes;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2])\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='ipv4')\n    interfaces_2 = create_interface(Port=Port_2, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建BGP协议会话\n    session_1 = create_bgp(Port=Port_1)\n    session_2 = create_bgp(Port=Port_2)\n\n    edit_bgp(Session=session_1, AsNumber=100, DutAsNumber=200)\n    edit_bgp(Session=session_2, AsNumber=200, DutAsNumber=100)\n\n    # BGP协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # BGP协议会话1创建ipv4 route pool\n    ipv4_route_1 = create_bgp_ipv4_route_pool(Session=session_1, FirstRoute='100.0.0.1')\n    ipv4_route_2 = create_bgp_ipv4_route_pool(Session=session_2, FirstRoute='200.0.0.1')\n\n    # 订阅统计\n    subscribe_result(Types=['BgpSessionBlockStatistic'])\n\n    # 使用智能脚本启动协议\n    ggroup = smart_scripter_global_group()\n    group = smart_scripter_command(ggroup, 'GroupCommand', 'start')\n#    start = smart_scripter_command(group, 'StartProtocolCommand', ProtocolList=[session_1.handle, session_2.handle])\n    bgp = get_object_attrs([session_1, session_2])\n    start = smart_scripter_command(group, 'StartProtocolCommand', ProtocolList=bgp)\n    run_benchmark()\n    #StartSmartScripterCommand().execute()\n    wait_bgp_state(Sessions=[session_1, session_2])\n    # 获取统计\n    result = get_bgp_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_bgp_session_block_statistic(Session=session_2)\n    print(result)\n\n    # 使用智能脚本停止协议\n    group = smart_scripter_command(ggroup, 'GroupCommand', 'stop')\n    stop = smart_scripter_command(group, 'StopProtocolCommand', ProtocolList=[session_1.handle, session_2.handle])\n    run_benchmark()\n    #StartSmartScripterCommand().execute()\n    wait_bgp_state(Sessions=[session_1, session_2], State=['NOT_START'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "create_bgp:创建BGP协议会话对象",
      "create_bgp_ipv4_route_pool:创建BGP IPv4路由对象",
      "edit_bgp:编辑Bgp协议会话对象参数",
      "get_bgp_session_block_statistic:获取Bgp Session Block统计结果",
      "wait_bgp_state:等待BGP协议会话达到指定状态",
      "select_interface:协议绑定测试仪表接口",
      "subscribe_result:订阅测试仪表统计视图",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform for network testing.\",\n  \"Subtask 2\": \"Reserve two physical ports (Port_1 and Port_2) on the tester.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both reserved ports.\",\n  \"Subtask 4\": \"Configure IPv4 parameters for Port_1 interface: address 192.168.1.2, gateway 192.168.1.3.\",\n  \"Subtask 5\": \"Configure IPv4 parameters for Port_2 interface: address 192.168.1.3, gateway 192.168.1.2.\",\n  \"Subtask 6\": \"Create BGP session objects on both ports.\",\n  \"Subtask 7\": \"Edit BGP session parameters: AS number 100 and DUT AS 200 for Port_1 session.\",\n  \"Subtask 8\": \"Edit BGP session parameters: AS number 200 and DUT AS 100 for Port_2 session.\",\n  \"Subtask 9\": \"Bind each BGP session to its corresponding IPv4 interface.\",\n  \"Subtask 10\": \"Create IPv4 route pools for both BGP sessions with first routes 100.0.0.1 and 200.0.0.1 respectively.\",\n  \"Subtask 11\": \"Subscribe to BgpSessionBlockStatistic view for monitoring.\",\n  \"Subtask 12\": \"Start BGP sessions using smart scripter commands to advertise routes.\",\n  \"Subtask 13\": \"Execute benchmark configuration to activate protocol advertising.\",\n  \"Subtask 14\": \"Wait until both BGP sessions reach established state.\",\n  \"Subtask 15\": \"Retrieve BGP session block statistics for both sessions to obtain advertised route counts.\",\n  \"Subtask 16\": \"Stop BGP sessions using smart scripter commands.\",\n  \"Subtask 17\": \"Wait until both BGP sessions reach NOT_START state.\",\n  \"Subtask 18\": \"Save test case configuration to file for future use.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Test Objective: Use an intelligent script to create BGP protocol and advertise routes\n\nStep          : Step 1: Create two offline ports, Port_1 and Port_2;\n               Step 2: Create BGP sessions and routes;\n               Step 3: Start the protocol to advertise routes;\n               Step 4: Check statistics;\n\nCriteria      : Expected Result 1: Step 4: Obtain the number of advertised routes;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_1, Port_2 = reserve_port(Locations=locations[:2])\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=Port_1, Layers='ipv4')\n    interfaces_2 = create_interface(Port=Port_2, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建BGP协议会话\n    session_1 = create_bgp(Port=Port_1)\n    session_2 = create_bgp(Port=Port_2)\n\n    edit_bgp(Session=session_1, AsNumber=100, DutAsNumber=200)\n    edit_bgp(Session=session_2, AsNumber=200, DutAsNumber=100)\n\n    # BGP协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_1)\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # BGP协议会话1创建ipv4 route pool\n    ipv4_route_1 = create_bgp_ipv4_route_pool(Session=session_1, FirstRoute='100.0.0.1')\n    ipv4_route_2 = create_bgp_ipv4_route_pool(Session=session_2, FirstRoute='200.0.0.1')\n\n    # 订阅统计\n    subscribe_result(Types=['BgpSessionBlockStatistic'])\n\n    # 使用智能脚本启动协议\n    ggroup = smart_scripter_global_group()\n    group = smart_scripter_command(ggroup, 'GroupCommand', 'start')\n#    start = smart_scripter_command(group, 'StartProtocolCommand', ProtocolList=[session_1.handle, session_2.handle])\n    bgp = get_object_attrs([session_1, session_2])\n    start = smart_scripter_command(group, 'StartProtocolCommand', ProtocolList=bgp)\n    run_benchmark()\n    #StartSmartScripterCommand().execute()\n    wait_bgp_state(Sessions=[session_1, session_2])\n    # 获取统计\n    result = get_bgp_session_block_statistic(Session=session_1)\n    print(result)\n    result = get_bgp_session_block_statistic(Session=session_2)\n    print(result)\n\n    # 使用智能脚本停止协议\n    group = smart_scripter_command(ggroup, 'GroupCommand', 'stop')\n    stop = smart_scripter_command(group, 'StopProtocolCommand', ProtocolList=[session_1.handle, session_2.handle])\n    run_benchmark()\n    #StartSmartScripterCommand().execute()\n    wait_bgp_state(Sessions=[session_1, session_2], State=['NOT_START'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\ncreate_bgp:创建BGP协议会话对象;\ncreate_bgp_ipv4_route_pool:创建BGP IPv4路由对象;\nedit_bgp:编辑Bgp协议会话对象参数;\nget_bgp_session_block_statistic:获取Bgp Session Block统计结果;\nwait_bgp_state:等待BGP协议会话达到指定状态;\nselect_interface:协议绑定测试仪表接口;\nsubscribe_result:订阅测试仪表统计视图;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/add_stream_from_pcap.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamBlockStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamBlockStats统计;\n                   测试步骤4: 发送所有流量，查看StreamBlockStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of StreamBlockStats statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Create four traffic streams (StreamTemplate_1, 2, 3, 4) on Port_1 and Port_2 respectively;\n                   Test Step 3: Subscribe to StreamBlockStats statistics;\n                   Test Step 4: Transmit all traffic streams, monitor StreamBlockStats statistics, and wait for a period;\n                   Test Step 5: Stop all traffic streams and review StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: StreamBlockStats statistics are correctly obtained in Steps 4 and 5;\n\nCreated by   \t:   Tester-001\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 设置端口发送模式为突发包\n    BurstCount = 3\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包\n    start_capture()\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    stop_stream()\n    # 停止抓包\n    stop_capture()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    result = get_streamblock_statistic()\n    print(result)\n\n    # 下载报文\n    result = download_packages(Port=Port_Down, FileDir=f'{dirname}/xcfg', FileName=f'{filename}.pcap')\n\n    # 导入PCAP流量\n    stream_pcap = add_stream(Ports=Port_Down, Type='pcap', FilePath=result)\n\n    # 修改EthernetII头部\n    attribute_dict = edit_header_ethernet(Stream=stream_pcap[0], Level=0, DestMacAdd='00:00:00:00:00:01',\n                                          SourceMacAdd='00:00:00:00:00:02')\n    print(attribute_dict)\n\n    # EthernetII头部目的Mac地址字段添加跳变\n    edit_modifier(Stream=stream_pcap[0], Level=0, HeaderType='ethernetii', Attribute=attribute_dict['DestMacAdd'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 保存配置文件\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n\n\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform using init_tester API with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using reserve_port API with force reservation.\",\n  \"Subtask 3\": \"Create four traffic streams (StreamTemplate_1, 2 on Port_1; StreamTemplate_3, 4 on Port_2) using add_stream API.\",\n  \"Subtask 4\": \"Set port transmission mode to burst with BurstCount=3 using edit_port_load_profile API for all reserved ports.\",\n  \"Subtask 5\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 6\": \"Start packet capture on relevant ports using start_capture API.\",\n  \"Subtask 7\": \"Transmit all created traffic streams using start_stream API.\",\n  \"Subtask 8\": \"Wait 10 seconds during transmission to accumulate stable StreamBlockStats statistics.\",\n  \"Subtask 9\": \"Stop all traffic streams using stop_stream API.\",\n  \"Subtask 10\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 11\": \"Wait 3 seconds after stream stoppage to finalize StreamBlockStats statistics.\",\n  \"Subtask 12\": \"Retrieve and review StreamBlockStats results using get_streamblock_statistic API during transmission (Step 8) and after stoppage (Step 11).\",\n  \"Subtask 13\": \"Download captured packets from ports using download_packages API and save as PCAP file.\",\n  \"Subtask 14\": \"Import PCAP file as new traffic streams using add_stream API with type='pcap'.\",\n  \"Subtask 15\": \"Modify Ethernet II header fields (DestMacAdd, SourceMacAdd) for imported streams using edit_header_ethernet API.\",\n  \"Subtask 16\": \"Configure MAC address increment modifier using edit_modifier API with increment step=2 and count=10.\",\n  \"Subtask 17\": \"Save test configuration using save_case API after all modifications.\",\n  \"Subtask 18\": \"Repeat traffic transmission and statistics collection (Subtask 7-12) for modified streams.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of StreamBlockStats statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Create four traffic streams (StreamTemplate_1, 2, 3, 4) on Port_1 and Port_2 respectively;\n                   Test Step 3: Subscribe to StreamBlockStats statistics;\n                   Test Step 4: Transmit all traffic streams, monitor StreamBlockStats statistics, and wait for a period;\n                   Test Step 5: Stop all traffic streams and review StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: StreamBlockStats statistics are correctly obtained in Steps 4 and 5;\n\nCreated by   \t:   Tester-001\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 设置端口发送模式为突发包\n    BurstCount = 3\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包\n    start_capture()\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    stop_stream()\n    # 停止抓包\n    stop_capture()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    result = get_streamblock_statistic()\n    print(result)\n\n    # 下载报文\n    result = download_packages(Port=Port_Down, FileDir=f'{dirname}/xcfg', FileName=f'{filename}.pcap')\n\n    # 导入PCAP流量\n    stream_pcap = add_stream(Ports=Port_Down, Type='pcap', FilePath=result)\n\n    # 修改EthernetII头部\n    attribute_dict = edit_header_ethernet(Stream=stream_pcap[0], Level=0, DestMacAdd='00:00:00:00:00:01',\n                                          SourceMacAdd='00:00:00:00:00:02')\n    print(attribute_dict)\n\n    # EthernetII头部目的Mac地址字段添加跳变\n    edit_modifier(Stream=stream_pcap[0], Level=0, HeaderType='ethernetii', Attribute=attribute_dict['DestMacAdd'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 保存配置文件\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n\n\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/PIM/PIM.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查PIM协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 创建PIM协议及组播组;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Objective: Check normal transmission of PIM protocol bound traffic\n\nStep: \n    Step 1: Reserve two loopback ports: Port_1 and Port_2;\n    Step 2: Create PIM protocol and multicast group;\n    Step 3: Create bound traffic;\n    Step 4: Subscribe to StreamBlockStats statistics;\n    Step 5: Send all traffic and wait for a period of time;\n    Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, the sent and received packets for all traffic are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建pim协议会话\n\n    pim_1 = create_pim(Port=Port_UP)\n\n    pim_2 = create_pim(Port=Port_Down)\n\n    pim_group_1 = create_pim_group(Session=pim_1, GroupAddr='225.0.0.1')\n\n    pim_group_2 = create_pim_group(Session=pim_2, GroupAddr='225.0.0.2')\n\n\n    # DHCPv6协议会话与接口绑定\n\n    select_interface(Session=pim_1, Interface=interfaces_1)\n\n    select_interface(Session=pim_2, Interface=interfaces_2)\n\n    # 创建组播组\n\n    multicast_group_1 = create_multicast_group(Start='225.0.0.1')\n\n    multicast_group_2 = create_multicast_group(Start='225.0.0.2')\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 创建DHCP绑定流\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=multicast_group_1)\n\n    stream = add_stream(Type='binding', SrcPoints=point_2, DstPoints=multicast_group_2)\n    streams.extend(stream)\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'PimSessionStats', 'PimGroupStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待DHCP协议协议会话状态正确\n\n    wait_pim_state(Sessions=[pim_1, pim_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取PIM会话统计\n    import pandas\n    result = get_pim_session_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pim_session_stats(Session=pim_1)\n    print(result)\n\n    result = get_pim_session_stats(Session=pim_2)\n    print(result)\n\n    # 获取PIM Group统计\n    result = get_pim_group_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pim_group_stats(Session=pim_1, Group=pim_group_1)\n    print(result)\n\n    result = get_pim_group_stats(Session=pim_2, Group=pim_group_2)\n    print(result)\n\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_multicast_group:创建全局组播组对象",
      "create_pim:创建PIM协议会话对象",
      "create_pim_group:创建PIM Group对象",
      "get_pim_group_stats:获取Pim Group Stats统计结果",
      "get_pim_session_stats:获取Pim Session Stats统计结果",
      "wait_pim_state:等待PIM协议会话达到指定状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports: Port_1 and Port_2 using their physical locations.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on Port_1 and Port_2 with addresses 1.1.1.1/1.1.1.2 and 1.1.1.2/1.1.1.1 respectively.\",\n  \"Subtask 4\": \"Create PIM sessions on both reserved ports.\",\n  \"Subtask 5\": \"Create PIM groups for each session with group addresses 225.0.0.1 and 225.0.0.2.\",\n  \"Subtask 6\": \"Bind created interfaces to their respective PIM sessions.\",\n  \"Subtask 7\": \"Create global multicast groups with start addresses 225.0.0.1 and 225.0.0.2.\",\n  \"Subtask 8\": \"Retrieve encapsulation layer objects from both interfaces for traffic source points.\",\n  \"Subtask 9\": \"Create two bound traffic streams: Stream1 from Port_1 interface to multicast group 225.0.0.1, Stream2 from Port_2 interface to multicast group 225.0.0.2.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats, PimSessionStats, and PimGroupStats statistics views.\",\n  \"Subtask 11\": \"Start all PIM protocol sessions.\",\n  \"Subtask 12\": \"Wait until PIM sessions reach expected state and stabilize for 5 seconds.\",\n  \"Subtask 13\": \"Start transmission of all bound traffic streams.\",\n  \"Subtask 14\": \"Maintain traffic transmission for 10 seconds.\",\n  \"Subtask 15\": \"Stop all traffic streams.\",\n  \"Subtask 16\": \"Stop all PIM protocol sessions.\",\n  \"Subtask 17\": \"Wait 3 seconds for statistics stabilization.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats for Stream1.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats for Stream2.\",\n  \"Subtask 20\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) for Stream1.\",\n  \"Subtask 21\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) for Stream2.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Objective: Check normal transmission of PIM protocol bound traffic\n\nStep: \n    Step 1: Reserve two loopback ports: Port_1 and Port_2;\n    Step 2: Create PIM protocol and multicast group;\n    Step 3: Create bound traffic;\n    Step 4: Subscribe to StreamBlockStats statistics;\n    Step 5: Send all traffic and wait for a period of time;\n    Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, the sent and received packets for all traffic are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP)\n\n    interfaces_2 = create_interface(Port=Port_Down)\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.1',\n                   Gateway='1.1.1.2')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='1.1.1.2',\n                   Gateway='1.1.1.1')\n\n    # 创建pim协议会话\n\n    pim_1 = create_pim(Port=Port_UP)\n\n    pim_2 = create_pim(Port=Port_Down)\n\n    pim_group_1 = create_pim_group(Session=pim_1, GroupAddr='225.0.0.1')\n\n    pim_group_2 = create_pim_group(Session=pim_2, GroupAddr='225.0.0.2')\n\n\n    # DHCPv6协议会话与接口绑定\n\n    select_interface(Session=pim_1, Interface=interfaces_1)\n\n    select_interface(Session=pim_2, Interface=interfaces_2)\n\n    # 创建组播组\n\n    multicast_group_1 = create_multicast_group(Start='225.0.0.1')\n\n    multicast_group_2 = create_multicast_group(Start='225.0.0.2')\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 创建DHCP绑定流\n\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1)\n\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=multicast_group_1)\n\n    stream = add_stream(Type='binding', SrcPoints=point_2, DstPoints=multicast_group_2)\n    streams.extend(stream)\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'PimSessionStats', 'PimGroupStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待DHCP协议协议会话状态正确\n\n    wait_pim_state(Sessions=[pim_1, pim_2])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取PIM会话统计\n    import pandas\n    result = get_pim_session_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pim_session_stats(Session=pim_1)\n    print(result)\n\n    result = get_pim_session_stats(Session=pim_2)\n    print(result)\n\n    # 获取PIM Group统计\n    result = get_pim_group_stats()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_pim_group_stats(Session=pim_1, Group=pim_group_1)\n    print(result)\n\n    result = get_pim_group_stats(Session=pim_2, Group=pim_group_2)\n    print(result)\n\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_multicast_group:创建全局组播组对象;\ncreate_pim:创建PIM协议会话对象;\ncreate_pim_group:创建PIM Group对象;\nget_pim_group_stats:获取Pim Group Stats统计结果;\nget_pim_session_stats:获取Pim Session Stats统计结果;\nwait_pim_state:等待PIM协议会话达到指定状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Overall/RTSM/use_rtsm.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查RTSM服务器启动CL测试发流StreamBlockStats统计正确\n\n Step\t\t\t:\t测试步骤1: 连接RTSM服务器，启动CL，断开RTSM连接并连接刚启动的CL;\n                   测试步骤2: 预约两个自环端口Port_1、Port_2;\n                   测试步骤3: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤4: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤5: 订阅StreamBlockStats统计;\n                   测试步骤6: 发送所有流量，查看StreamBlockStats统计信息，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n                   测试步骤8: 连接RTSM服务器，关闭CL，断开RTSM连接;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Test Objective: Verify that the RTSM server correctly collects StreamBlockStats statistics when starting CL test traffic.\n\nStep          : Step 1: Connect to RTSM server, start CL, disconnect RTSM and connect to the newly started CL;\n               Step 2: Reserve two loopback ports: Port_1, Port_2;\n               Step 3: Create four traffic streams: StreamTemplate_1, 2, 3, 4 on Port_1 and Port_2 respectively;\n               Step 4: Create four traffic streams: StreamTemplate_1, 2, 3, 4 on Port_1 and Port_2 respectively;\n               Step 5: Subscribe to StreamBlockStats statistics;\n               Step 6: Transmit all traffic, view StreamBlockStats statistics, wait for a period;\n               Step 7: Stop all traffic, view StreamBlockStats statistics;\n               Step 8: Connect to RTSM server, shut down CL, disconnect RTSM;\n\nCriteria      : Expected Result 1: StreamBlockStats statistics are correctly obtained in Steps 4 and 5;\n\nCreated by    : Tester-001\n\nBugs          : None\n=================================================================================",
    "code": "import signal\n\nfrom TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DARYU' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # host = locations[0].split('/')[2]\n    host = '127.0.0.1'\n    print(f'CL host:{host}')\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Rtsm=host)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockStats所有统计结果:\n    # get_streamblock_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    release_port(Ports=[Port_UP, Port_Down])\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    # 关闭仪表测试进程\n    shutdown_tester()\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester by connecting to the RTSM server using init_tester API, specifying the product and RTSM host address.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using reserve_port API with force option enabled.\",\n  \"Subtask 3\": \"Create four traffic streams (StreamTemplate_1, StreamTemplate_2 on Port_1; StreamTemplate_3, StreamTemplate_4 on Port_2) using add_stream API.\",\n  \"Subtask 4\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 5\": \"Save the current test configuration to a file using save_case API.\",\n  \"Subtask 6\": \"Start transmitting all traffic streams using start_stream API.\",\n  \"Subtask 7\": \"Wait for 10 seconds to allow statistics stabilization.\",\n  \"Subtask 8\": \"Retrieve StreamBlockStats statistics for all streams using get_streamblock_statistic API without parameters.\",\n  \"Subtask 9\": \"Validate that StreamTemplate_1 shows non-zero TxFrameRate and RxFrameRate in the statistics.\",\n  \"Subtask 10\": \"Stop all traffic transmission using stop_stream API.\",\n  \"Subtask 11\": \"Wait for 3 seconds to collect final statistics.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats statistics again using get_streamblock_statistic API without parameters.\",\n  \"Subtask 13\": \"Release both reserved ports using release_port API.\",\n  \"Subtask 14\": \"Shut down the tester and disconnect from RTSM server using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Test Objective: Verify that the RTSM server correctly collects StreamBlockStats statistics when starting CL test traffic.\n\nStep          : Step 1: Connect to RTSM server, start CL, disconnect RTSM and connect to the newly started CL;\n               Step 2: Reserve two loopback ports: Port_1, Port_2;\n               Step 3: Create four traffic streams: StreamTemplate_1, 2, 3, 4 on Port_1 and Port_2 respectively;\n               Step 4: Create four traffic streams: StreamTemplate_1, 2, 3, 4 on Port_1 and Port_2 respectively;\n               Step 5: Subscribe to StreamBlockStats statistics;\n               Step 6: Transmit all traffic, view StreamBlockStats statistics, wait for a period;\n               Step 7: Stop all traffic, view StreamBlockStats statistics;\n               Step 8: Connect to RTSM server, shut down CL, disconnect RTSM;\n\nCriteria      : Expected Result 1: StreamBlockStats statistics are correctly obtained in Steps 4 and 5;\n\nCreated by    : Tester-001\n\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  import signal\n\nfrom TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DARYU' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # host = locations[0].split('/')[2]\n    host = '127.0.0.1'\n    print(f'CL host:{host}')\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Rtsm=host)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockStats所有统计结果:\n    # get_streamblock_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    release_port(Ports=[Port_UP, Port_Down])\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    # 关闭仪表测试进程\n    shutdown_tester()\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Overall/RTSM/not_use_rtsm.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查连接远端CL测试发流StreamBlockStats统计正确\n\n Step\t\t\t:\t测试步骤1: 连接远端CL;\n                   测试步骤2: 预约两个自环端口Port_1、Port_2;\n                   测试步骤3: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤4: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤5: 订阅StreamBlockStats统计;\n                   测试步骤6: 发送所有流量，查看StreamBlockStats统计信息，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n                   测试步骤8: 断开远端CL;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective      : Purpose: Verify that the StreamBlockStats statistics are correct when connecting to a remote CL and transmitting traffic.\n\nStep           : Step 1: Connect to the remote CL;\n                Step 2: Reserve two loopback ports Port_1 and Port_2;\n                Step 3: Create four traffic streams StreamTemplate_1, 2, 3, 4 on ports Port_1 and Port_2 respectively;\n                Step 4: Create four traffic streams StreamTemplate_1, 2, 3, 4 on ports Port_1 and Port_2 respectively;\n                Step 5: Subscribe to StreamBlockStats statistics;\n                Step 6: Transmit all traffic, monitor StreamBlockStats statistics, and wait for a period;\n                Step 7: Stop all traffic and check StreamBlockStats statistics;\n                Step 8: Disconnect from the remote CL.\n\nCriteria       : Expected Result 1: StreamBlockStats statistics are correctly retrieved in Steps 4 and 5;\n\nCreated by     : Tester-001\n\nBugs           : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DARYU' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    host = locations[0].split('/')[2]\n    print(f'CL host:{host}')\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, CL=host)\n    reset_tester()\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockStats所有统计结果:\n    # get_streamblock_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    release_port(Ports=[Port_UP, Port_Down])\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    reset_tester()\n    # 断开仪表测试进程\n    shutdown_tester()\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "reset_tester:清空测试仪表所有配置",
      "save_case:测试仪表保存配置文件",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester and connect to the remote CL using specified host and product parameters.\",\n  \"Subtask 2\": \"Reset the tester to clear any existing configurations.\",\n  \"Subtask 3\": \"Reserve two ports (Port_UP and Port_Down) from provided locations with force reservation.\",\n  \"Subtask 4\": \"Create four traffic streams: two streams on Port_UP and two streams on Port_Down.\",\n  \"Subtask 5\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 6\": \"Save current configuration to an xcfg file in the script's directory.\",\n  \"Subtask 7\": \"Start transmission of all traffic streams.\",\n  \"Subtask 8\": \"Wait 10 seconds to allow statistics stabilization during traffic transmission.\",\n  \"Subtask 9\": \"Retrieve StreamBlockStats for all streams and verify first stream's TxFrameRate and RxFrameRate are non-zero.\",\n  \"Subtask 10\": \"Stop all traffic streams.\",\n  \"Subtask 11\": \"Wait 3 seconds to collect final statistics after traffic stop.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats for the last stream (single stream) without item specification.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats for the first stream with specific items (TxStreamFrames, RxStreamFrames, TxTotalBytes, RxTotalBytes).\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats for the first two streams (multiple streams) without item specification.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats for the first three streams with specific items (TxStreamFrames, RxStreamFrames, TxTotalBytes, RxTotalBytes).\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats for all streams with specific items (TxStreamFrames, RxStreamFrames, TxTotalBytes, RxTotalBytes).\",\n  \"Subtask 17\": \"Release both reserved ports (Port_UP and Port_Down).\",\n  \"Subtask 18\": \"Reset the tester configuration.\",\n  \"Subtask 19\": \"Disconnect from the remote CL by shutting down the tester.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective      : Purpose: Verify that the StreamBlockStats statistics are correct when connecting to a remote CL and transmitting traffic.\n\nStep           : Step 1: Connect to the remote CL;\n                Step 2: Reserve two loopback ports Port_1 and Port_2;\n                Step 3: Create four traffic streams StreamTemplate_1, 2, 3, 4 on ports Port_1 and Port_2 respectively;\n                Step 4: Create four traffic streams StreamTemplate_1, 2, 3, 4 on ports Port_1 and Port_2 respectively;\n                Step 5: Subscribe to StreamBlockStats statistics;\n                Step 6: Transmit all traffic, monitor StreamBlockStats statistics, and wait for a period;\n                Step 7: Stop all traffic and check StreamBlockStats statistics;\n                Step 8: Disconnect from the remote CL.\n\nCriteria       : Expected Result 1: StreamBlockStats statistics are correctly retrieved in Steps 4 and 5;\n\nCreated by     : Tester-001\n\nBugs           : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DARYU' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    host = locations[0].split('/')[2]\n    print(f'CL host:{host}')\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, CL=host)\n    reset_tester()\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockStats所有统计结果:\n    # get_streamblock_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    release_port(Ports=[Port_UP, Port_Down])\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    reset_tester()\n    # 断开仪表测试进程\n    shutdown_tester()\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nreset_tester:清空测试仪表所有配置;\nsave_case:测试仪表保存配置文件;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStreamBlockTxStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamBlockTxStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamBlockTxStats统计;\n                   测试步骤4: 发送所有流量，查看StreamBlockTxStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamBlockTxStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockTxStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Purpose: Verify correct statistics of test instrument's StreamBlockTxStats  \nStep 1: Reserve two loopback ports: Port_1, Port_2  \nStep 2: Create four streams (StreamTemplate_1, StreamTemplate_2, StreamTemplate_3, StreamTemplate_4) on Port_1 and Port_2 respectively  \nStep 3: Subscribe to StreamBlockTxStats statistics  \nStep 4: Transmit all traffic, check StreamBlockTxStats statistics, and wait  \nStep 5: Stop all traffic and check StreamBlockTxStats statistics  \nCriteria: Expected Result 1: StreamBlockTxStats statistics obtained correctly in Steps 4 and 5  \nCreated by: Tester-001  \nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockTxStats统计视图\n    subscribe_result(Types=['StreamBlockTxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockTxStats所有统计结果:\n    # get_streamblock_tx_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_tx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'TxBitRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['TxBitRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or TxBitRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_tx_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_tx_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量和端口的统计:\n    # get_streamblock_tx_statistic传Stream和Port参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_tx_statistic(Stream=streams[-1], Port=Port_Down)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_tx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_tx_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print(result)\n\n    # 统计获取方式5 -- 获取指定多条流量的统计:\n    # get_streamblock_tx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_tx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_tx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_tx_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_tx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_tx_statistic(StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_tx_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (default 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_UP and Port_Down) at specified locations using reserve_port API with Force=True.\",\n  \"Subtask 3\": \"Create four streams (two on each reserved port) using add_stream API and store the stream objects.\",\n  \"Subtask 4\": \"Subscribe to StreamBlockTxStats statistics view using subscribe_result API.\",\n  \"Subtask 5\": \"Save current test configuration to specified path using save_case API.\",\n  \"Subtask 6\": \"Start all traffic streams using start_stream API.\",\n  \"Subtask 7\": \"Wait 10 seconds for statistics stabilization during traffic transmission.\",\n  \"Subtask 8\": \"Retrieve StreamBlockTxStats statistics for all streams using get_streamblock_tx_statistic API without filters.\",\n  \"Subtask 9\": \"Validate that first stream's TxFrameRate and TxBitRate are non-zero during transmission.\",\n  \"Subtask 10\": \"Stop all traffic streams using stop_stream API.\",\n  \"Subtask 11\": \"Wait 3 seconds for final statistics collection after traffic stop.\",\n  \"Subtask 12\": \"Retrieve StreamBlockTxStats statistics for last stream using get_streamblock_tx_statistic with Stream parameter.\",\n  \"Subtask 13\": \"Retrieve StreamBlockTxStats statistics for last stream on Port_Down using Stream and Port parameters.\",\n  \"Subtask 14\": \"Retrieve specific statistics items (TxStreamFrames, TxTotalBytes, TxByteRate, TxBitRate) for first stream using StaItems parameter.\",\n  \"Subtask 15\": \"Retrieve statistics for first two streams using Stream parameter with multiple values.\",\n  \"Subtask 16\": \"Retrieve specific statistics items for first three streams using Stream and StaItems parameters.\",\n  \"Subtask 17\": \"Retrieve specific statistics items for all streams using StaItems parameter.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Purpose: Verify correct statistics of test instrument's StreamBlockTxStats  \nStep 1: Reserve two loopback ports: Port_1, Port_2  \nStep 2: Create four streams (StreamTemplate_1, StreamTemplate_2, StreamTemplate_3, StreamTemplate_4) on Port_1 and Port_2 respectively  \nStep 3: Subscribe to StreamBlockTxStats statistics  \nStep 4: Transmit all traffic, check StreamBlockTxStats statistics, and wait  \nStep 5: Stop all traffic and check StreamBlockTxStats statistics  \nCriteria: Expected Result 1: StreamBlockTxStats statistics obtained correctly in Steps 4 and 5  \nCreated by: Tester-001  \nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockTxStats统计视图\n    subscribe_result(Types=['StreamBlockTxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockTxStats所有统计结果:\n    # get_streamblock_tx_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_tx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'TxBitRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['TxBitRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or TxBitRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_tx_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_tx_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量和端口的统计:\n    # get_streamblock_tx_statistic传Stream和Port参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_tx_statistic(Stream=streams[-1], Port=Port_Down)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_tx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_tx_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print(result)\n\n    # 统计获取方式5 -- 获取指定多条流量的统计:\n    # get_streamblock_tx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_tx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_tx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_tx_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_tx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_tx_statistic(StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_streamblock_tx_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStreamBlockRxStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamBlockRxStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamBlockRxStats统计;\n                   测试步骤4: 发送所有流量，查看StreamBlockRxStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamBlockRxStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockRxStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Objective: Verify the correctness of the StreamBlockRxStats statistics on the test instrument.\n\nStep:\n  Step 1: Reserve two loopback ports, Port_1 and Port_2.\n  Step 2: Create two streams (StreamTemplate_1, StreamTemplate_2) on Port_1 and two streams (StreamTemplate_3, StreamTemplate_4) on Port_2.\n  Step 3: Subscribe to StreamBlockRxStats statistics.\n  Step 4: Transmit all traffic, check StreamBlockRxStats statistics, and wait for a duration.\n  Step 5: Stop all traffic and check StreamBlockRxStats statistics.\n\nCriteria:\n  Expected Result 1: StreamBlockRxStats statistics are correctly retrieved in Steps 4 and 5.\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockRxStats统计视图\n    subscribe_result(Types=['StreamBlockRxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockRxStats所有统计结果:\n    # get_streamblock_rx_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1收端口为Port_Down的RxFrameRate和RxByteRate\n    df = result[(result['StreamBlockID'] == streams[0].Name) & (result['PortID'] == Port_Down.handle)][['RxFrameRate', 'RxByteRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['RxFrameRate'] == 0 or data['RxByteRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} RxFrameRate or RxByteRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量和端口的统计:\n    # get_streamblock_rx_statistic传Stream和Port参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_rx_statistic(Stream=streams[-1], Port=Port_UP)\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计:\n    # get_streamblock_rx_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式4 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_rx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[:1], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计:\n    # get_streamblock_rx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_rx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[:3], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_rx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_rx_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (e.g., DarYu) using the init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) on the tester using the reserve_port API.\",\n  \"Subtask 3\": \"Create four streams: two on Port_1 (StreamTemplate_1 and StreamTemplate_2) and two on Port_2 (StreamTemplate_3 and StreamTemplate_4) using the add_stream API.\",\n  \"Subtask 4\": \"Subscribe to the StreamBlockRxStats statistics view using the subscribe_result API.\",\n  \"Subtask 5\": \"Start transmitting all streams using the start_stream API.\",\n  \"Subtask 6\": \"Wait for 10 seconds to allow StreamBlockRxStats statistics to stabilize.\",\n  \"Subtask 7\": \"Retrieve StreamBlockRxStats statistics using get_streamblock_rx_statistic API and validate that RxFrameRate and RxByteRate for StreamTemplate_1 on Port_2 are non-zero.\",\n  \"Subtask 8\": \"Stop all streams using the stop_stream API.\",\n  \"Subtask 9\": \"Wait for 3 seconds to allow final StreamBlockRxStats statistics to stabilize.\",\n  \"Subtask 10\": \"Retrieve StreamBlockRxStats statistics again using get_streamblock_rx_statistic API to confirm successful retrieval after traffic stop.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Objective: Verify the correctness of the StreamBlockRxStats statistics on the test instrument.\n\nStep:\n  Step 1: Reserve two loopback ports, Port_1 and Port_2.\n  Step 2: Create two streams (StreamTemplate_1, StreamTemplate_2) on Port_1 and two streams (StreamTemplate_3, StreamTemplate_4) on Port_2.\n  Step 3: Subscribe to StreamBlockRxStats statistics.\n  Step 4: Transmit all traffic, check StreamBlockRxStats statistics, and wait for a duration.\n  Step 5: Stop all traffic and check StreamBlockRxStats statistics.\n\nCriteria:\n  Expected Result 1: StreamBlockRxStats statistics are correctly retrieved in Steps 4 and 5.\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockRxStats统计视图\n    subscribe_result(Types=['StreamBlockRxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockRxStats所有统计结果:\n    # get_streamblock_rx_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1收端口为Port_Down的RxFrameRate和RxByteRate\n    df = result[(result['StreamBlockID'] == streams[0].Name) & (result['PortID'] == Port_Down.handle)][['RxFrameRate', 'RxByteRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['RxFrameRate'] == 0 or data['RxByteRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} RxFrameRate or RxByteRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量和端口的统计:\n    # get_streamblock_rx_statistic传Stream和Port参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_rx_statistic(Stream=streams[-1], Port=Port_UP)\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计:\n    # get_streamblock_rx_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式4 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_rx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[:1], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计:\n    # get_streamblock_rx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_rx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(Stream=streams[:3], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_rx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_rx_statistic(StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_streamblock_rx_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStreamBlockStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamBlockStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamBlockStats统计;\n                   测试步骤4: 发送所有流量，查看StreamBlockStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamBlockStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Objective: Verify the accuracy of StreamBlockStats statistics on the test instrument\n\nStep         :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                 Test Step 2: Create four traffic streams StreamTemplate_1, 2, 3, 4 on Port_1 and Port_2 respectively;\n                 Test Step 3: Subscribe to StreamBlockStats statistics;\n                 Test Step 4: Transmit all streams, check StreamBlockStats statistics, and wait for a period;\n                 Test Step 5: Stop all streams and check StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: StreamBlockStats statistics are correctly obtained in Steps 4 and 5;\n\nCreated by   :   Tester-001\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockStats所有统计结果:\n    # get_streamblock_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with specified product configuration (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using provided location addresses.\",\n  \"Subtask 3\": \"Create four traffic streams (StreamTemplate_1-4) with two streams on Port_1 and two on Port_2.\",\n  \"Subtask 4\": \"Subscribe to StreamBlockStats statistics view for performance monitoring.\",\n  \"Subtask 5\": \"Save current test configuration to file for traceability.\",\n  \"Subtask 6\": \"Start transmission of all created traffic streams.\",\n  \"Subtask 7\": \"Wait 10 seconds to stabilize traffic and collect StreamBlockStats during transmission.\",\n  \"Subtask 8\": \"Retrieve StreamBlockStats for all streams and validate TxFrameRate/RxFrameRate are non-zero for StreamTemplate_1.\",\n  \"Subtask 9\": \"Stop all traffic streams.\",\n  \"Subtask 10\": \"Wait 3 seconds to collect final StreamBlockStats after stream stoppage.\",\n  \"Subtask 11\": \"Retrieve StreamBlockStats again for all streams and confirm successful data acquisition without errors.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Objective: Verify the accuracy of StreamBlockStats statistics on the test instrument\n\nStep         :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                 Test Step 2: Create four traffic streams StreamTemplate_1, 2, 3, 4 on Port_1 and Port_2 respectively;\n                 Test Step 3: Subscribe to StreamBlockStats statistics;\n                 Test Step 4: Transmit all streams, check StreamBlockStats statistics, and wait for a period;\n                 Test Step 5: Stop all streams and check StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: StreamBlockStats statistics are correctly obtained in Steps 4 and 5;\n\nCreated by   :   Tester-001\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamBlockStats所有统计结果:\n    # get_streamblock_statistic不传参数，返回值为DataFrame数据\n    result = get_streamblock_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[-1])\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_streamblock_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多条流量的统计:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_streamblock_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_streamblock_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetPortStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流PortStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 订阅PortStats统计;\n                   测试步骤4: 发送所有流量，查看PortStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看PortStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中PortStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify that the test instrument's PortStats statistics are correct during traffic transmission\nStep: \n    Step 1: Reserve two loopback ports: Port_1 and Port_2;\n    Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n    Step 3: Subscribe to PortStats statistics;\n    Step 4: Transmit all traffic, monitor PortStats statistics, and wait for a period;\n    Step 5: Stop all traffic and check PortStats statistics;\nCriteria: Expected Result 1: PortStats statistics are obtained correctly in steps 4 and 5;\nCreated by: Tester-001\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 订阅PortStats统计视图\n    subscribe_result(Types=['PortStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取PortStats所有统计结果: get_port_statistic不传参数，返回值为DataFrame数据\n    result = get_port_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出Port_UP的TxFrameRate\n    df = result[(result['PortID'] == Port_UP.Name)][['TxFrameRate']]\n    dict_1 = df.to_dict('records')[0]\n    # 根据DataFrame数据筛选出Port_Down的RxFrameRate\n    df = result[(result['PortID'] == Port_Down.Name)][['RxFrameRate']]\n    dict_2 = df.to_dict('records')[0]\n    # 判断收发包速率不为0\n    if dict_1['TxFrameRate'] == 0 or dict_2['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{Port_UP.Name} TxFrameRate or {Port_Down.Name} RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一个端口的统计: get_port_statistic传Port参数,实参只有一个元素，返回值为字典\n    result = get_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_statistic传Port参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_port_statistic(Port=Port_UP, StaItems=['TxTotalFrames', 'RxTotalFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多个端口的统计: get_port_statistic传Port参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_port_statistic(Port=[Port_UP, Port_Down])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_statistic传Port参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_statistic(Port=[Port_UP, Port_Down], StaItems=['TxTotalFrames', 'RxTotalFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有端口的统计,并且StaItems参数指定统计项目:\n    # get_port_statistic不传Port参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_statistic(StaItems=['TxTotalFrames', 'RxTotalFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform using the `init_tester` function with the specified product parameter.\",\n  \"Subtask 2\": \"Reserve two ports using the `reserve_port` function with provided locations and force reservation.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port using the `add_stream` function.\",\n  \"Subtask 4\": \"Subscribe to PortStats statistics using the `subscribe_result` function with Types=['PortStats'].\",\n  \"Subtask 5\": \"Save the current test configuration using the `save_case` function with a specified file path.\",\n  \"Subtask 6\": \"Start traffic transmission using the `start_stream` function.\",\n  \"Subtask 7\": \"Wait for 10 seconds to allow PortStats statistics to stabilize during transmission.\",\n  \"Subtask 8\": \"Retrieve all PortStats using `get_port_statistic` without parameters and verify TxFrameRate on sending port and RxFrameRate on receiving port are non-zero.\",\n  \"Subtask 9\": \"Stop traffic transmission using the `stop_stream` function.\",\n  \"Subtask 10\": \"Wait for 3 seconds to allow PortStats statistics to stabilize after traffic stops.\",\n  \"Subtask 11\": \"Retrieve PortStats for sending port using `get_port_statistic` with single port parameter and validate successful retrieval.\",\n  \"Subtask 12\": \"Retrieve specific statistics items (TxTotalFrames, RxTotalFrames, TxTotalBytes, RxTotalBytes) for sending port using `get_port_statistic` with StaItems parameter and validate successful retrieval.\",\n  \"Subtask 13\": \"Retrieve PortStats for both ports using `get_port_statistic` with multiple ports parameter and validate successful retrieval.\",\n  \"Subtask 14\": \"Retrieve specific statistics items for both ports using `get_port_statistic` with multiple ports and StaItems parameters and validate successful retrieval.\",\n  \"Subtask 15\": \"Retrieve specific statistics items for all ports using `get_port_statistic` with StaItems parameter only and validate successful retrieval.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify that the test instrument's PortStats statistics are correct during traffic transmission\nStep: \n    Step 1: Reserve two loopback ports: Port_1 and Port_2;\n    Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n    Step 3: Subscribe to PortStats statistics;\n    Step 4: Transmit all traffic, monitor PortStats statistics, and wait for a period;\n    Step 5: Stop all traffic and check PortStats statistics;\nCriteria: Expected Result 1: PortStats statistics are obtained correctly in steps 4 and 5;\nCreated by: Tester-001\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 订阅PortStats统计视图\n    subscribe_result(Types=['PortStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取PortStats所有统计结果: get_port_statistic不传参数，返回值为DataFrame数据\n    result = get_port_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出Port_UP的TxFrameRate\n    df = result[(result['PortID'] == Port_UP.Name)][['TxFrameRate']]\n    dict_1 = df.to_dict('records')[0]\n    # 根据DataFrame数据筛选出Port_Down的RxFrameRate\n    df = result[(result['PortID'] == Port_Down.Name)][['RxFrameRate']]\n    dict_2 = df.to_dict('records')[0]\n    # 判断收发包速率不为0\n    if dict_1['TxFrameRate'] == 0 or dict_2['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{Port_UP.Name} TxFrameRate or {Port_Down.Name} RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一个端口的统计: get_port_statistic传Port参数,实参只有一个元素，返回值为字典\n    result = get_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_statistic传Port参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_port_statistic(Port=Port_UP, StaItems=['TxTotalFrames', 'RxTotalFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多个端口的统计: get_port_statistic传Port参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_port_statistic(Port=[Port_UP, Port_Down])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_statistic传Port参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_statistic(Port=[Port_UP, Port_Down], StaItems=['TxTotalFrames', 'RxTotalFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有端口的统计,并且StaItems参数指定统计项目:\n    # get_port_statistic不传Port参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_statistic(StaItems=['TxTotalFrames', 'RxTotalFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetPortLatencyStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流PortAvgLatencyStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 订阅PortAvgLatencyStats统计;\n                   测试步骤4: 发送所有流量，查看PortAvgLatencyStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看PortAvgLatencyStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中PortAvgLatencyStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify the accuracy of the test instrument's PortAvgLatencyStats statistics\n\nStep: Test Step 1: Reserve two self-looping ports Port_1 and Port_2;\nTest Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\nTest Step 3: Subscribe to PortAvgLatencyStats statistics;\nTest Step 4: Transmit all traffic, observe PortAvgLatencyStats statistics, and wait for a period;\nTest Step 5: Stop all traffic and observe PortAvgLatencyStats statistics;\n\nCriteria: Expected Result 1: PortAvgLatencyStats statistics are correctly obtained in Steps 4 and 5;\n\nCreated by: Tester-001\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 订阅PortAvgLatencyStats统计视图\n    subscribe_result(Types=['PortAvgLatencyStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取PortStats所有统计结果: get_port_latency_statistic不传参数，返回值为DataFrame数据\n    result = get_port_latency_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出Port_UP的MinLatency\n    df = result[(result['PortID'] == Port_UP.Name)][['MinLatency']]\n    dict_1 = df.to_dict('records')[0]\n    # 根据DataFrame数据筛选出Port_Down的MaxLatency\n    df = result[(result['PortID'] == Port_Down.Name)][['MaxLatency']]\n    dict_2 = df.to_dict('records')[0]\n    # 判断收发包速率不为0\n    if dict_1['MinLatency'] != 0 or dict_2['MaxLatency'] != 0:\n        verdict = 'fail'\n        errInfo += f'{Port_UP.Name} MinLatency or {Port_Down.Name} MaxLatency is not equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一个端口的统计: get_port_latency_statistic传Port参数,实参只有一个元素，返回值为字典\n    result = get_port_latency_statistic(Port=Port_UP)\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_latency_statistic传Port参数, 实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_port_latency_statistic(Port=Port_UP, StaItems=['MinLatency', 'MaxLatency'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多个端口的统计:\n    # get_port_latency_statistic传Port参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_port_latency_statistic(Port=[Port_UP, Port_Down])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_latency_statistic传Port参数, 实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_latency_statistic(Port=[Port_UP, Port_Down], StaItems=['MinLatency', 'MaxLatency'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有端口的统计,并且StaItems参数指定统计项目:\n    # get_port_latency_statistic不传Port参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_latency_statistic(StaItems=['MinLatency', 'MaxLatency'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_port_latency_statistic:获取测试仪表端口时延统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform using init_tester API with specified product type.\",\n  \"Subtask 2\": \"Reserve two self-looping ports (Port_1 and Port_2) using reserve_port API with Force=True parameter.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 using add_stream API.\",\n  \"Subtask 4\": \"Subscribe to PortAvgLatencyStats statistics view using subscribe_result API.\",\n  \"Subtask 5\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 6\": \"Wait 10 seconds for statistics stabilization during traffic transmission.\",\n  \"Subtask 7\": \"Retrieve PortAvgLatencyStats statistics during traffic using get_port_latency_statistic API.\",\n  \"Subtask 8\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 9\": \"Wait 3 seconds for final statistics collection after traffic stops.\",\n  \"Subtask 10\": \"Retrieve PortAvgLatencyStats statistics after traffic stop using get_port_latency_statistic API.\",\n  \"Subtask 11\": \"Verify statistics are correctly obtained in both transmission and stopped states per expected results.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify the accuracy of the test instrument's PortAvgLatencyStats statistics\n\nStep: Test Step 1: Reserve two self-looping ports Port_1 and Port_2;\nTest Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\nTest Step 3: Subscribe to PortAvgLatencyStats statistics;\nTest Step 4: Transmit all traffic, observe PortAvgLatencyStats statistics, and wait for a period;\nTest Step 5: Stop all traffic and observe PortAvgLatencyStats statistics;\n\nCriteria: Expected Result 1: PortAvgLatencyStats statistics are correctly obtained in Steps 4 and 5;\n\nCreated by: Tester-001\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 订阅PortAvgLatencyStats统计视图\n    subscribe_result(Types=['PortAvgLatencyStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取PortStats所有统计结果: get_port_latency_statistic不传参数，返回值为DataFrame数据\n    result = get_port_latency_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出Port_UP的MinLatency\n    df = result[(result['PortID'] == Port_UP.Name)][['MinLatency']]\n    dict_1 = df.to_dict('records')[0]\n    # 根据DataFrame数据筛选出Port_Down的MaxLatency\n    df = result[(result['PortID'] == Port_Down.Name)][['MaxLatency']]\n    dict_2 = df.to_dict('records')[0]\n    # 判断收发包速率不为0\n    if dict_1['MinLatency'] != 0 or dict_2['MaxLatency'] != 0:\n        verdict = 'fail'\n        errInfo += f'{Port_UP.Name} MinLatency or {Port_Down.Name} MaxLatency is not equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一个端口的统计: get_port_latency_statistic传Port参数,实参只有一个元素，返回值为字典\n    result = get_port_latency_statistic(Port=Port_UP)\n    print(result)\n\n    # 统计获取方式3 -- 获取指定一个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_latency_statistic传Port参数, 实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_port_latency_statistic(Port=Port_UP, StaItems=['MinLatency', 'MaxLatency'])\n    print(result)\n\n    # 统计获取方式4 -- 获取指定多个端口的统计:\n    # get_port_latency_statistic传Port参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_port_latency_statistic(Port=[Port_UP, Port_Down])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定多个端口的统计,并且StaItems参数指定统计项目:\n    # get_port_latency_statistic传Port参数, 实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_latency_statistic(Port=[Port_UP, Port_Down], StaItems=['MinLatency', 'MaxLatency'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定所有端口的统计,并且StaItems参数指定统计项目:\n    # get_port_latency_statistic不传Port参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_port_latency_statistic(StaItems=['MinLatency', 'MaxLatency'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_port_latency_statistic:获取测试仪表端口时延统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/IGMP/IGMPv1.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查IGMP协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建IGMP协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Verify that the IGMP protocol bound stream is transmitted correctly\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Step 2: Create IGMP protocols on both ports respectively and establish routes;\n      Step 3: Create bound traffic;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, all traffic should show equal transmitted and received packets;\n\nCreated by: Tester-001\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IGMP协议会话\n\n    igmp = create_igmp(Port=Port_UP, Version='IGMPV1')\n\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n\n    select_interface(Session=igmp, Interface=interfaces_1)\n\n    # 创建组播组\n\n    multicast_group = create_multicast_group(Start='225.0.1.2')\n\n    # IGMP协议会话创建组成员关系\n\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # IGMP协议会话组成员关系与组播组绑定\n\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=Port_Down, Version='IGMPV1')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_2)\n\n    # 创建IGMP绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待IGMP协议会话稳定状态\n\n    wait_igmp_state(Sessions=[igmp])\n    wait_igmp_querier_state(Sessions=[igmp_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取IGMP Host统计\n    result = get_igmp_host_statistic()\n    print(result)\n\n    result = get_igmp_host_statistic(Session=igmp)\n    print(result)\n\n    # 获取IGMP Port统计\n    result = get_igmp_port_statistic()\n    print(result)\n\n    result = get_igmp_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取IGMP Querier统计\n    result = get_igmp_querier_statistic()\n    print(result)\n\n    result = get_igmp_querier_statistic(Session=igmp_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_igmp:创建IGMP协议会话对象",
      "create_igmp_querier:创建IGMP Querier协议会话对象",
      "edit_igmp:编辑IGMP协议会话对象",
      "edit_igmp_querier:编辑IGMP Querier协议会话对象",
      "get_igmp_host_statistic:获取Igmp协议会话统计结果",
      "get_igmp_port_statistic:获取Igmp Port统计结果",
      "get_igmp_querier_statistic:获取Igmp Querier协议会话统计结果",
      "wait_igmp_querier_state:等待Igmp Querier协议会话达到指定状态",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with product specification (e.g., DarYu).\",\n  \"Subtask 2\": \"Reserve two physical ports (Port_1 and Port_2) using provided locations.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both reserved ports with assigned IP addresses and gateways to establish routes.\",\n  \"Subtask 4\": \"Create IGMP host session on Port_1 with version IGMPV1 and enable initial join.\",\n  \"Subtask 5\": \"Bind the IGMP host session to the IPv4 interface on Port_1.\",\n  \"Subtask 6\": \"Create a multicast group starting at '225.0.1.2'.\",\n  \"Subtask 7\": \"Create memberships for the IGMP host session with round-robin device group mapping.\",\n  \"Subtask 8\": \"Bind the multicast group to the IGMP host session's memberships.\",\n  \"Subtask 9\": \"Create IGMP querier session on Port_2 with version IGMPV1 and set robustness variable to 3.\",\n  \"Subtask 10\": \"Bind the IGMP querier session to the IPv4 interface on Port_2.\",\n  \"Subtask 11\": \"Create bound traffic stream from Port_2's interface to the multicast group (unidirectional).\",\n  \"Subtask 12\": \"Subscribe to StreamBlockStats statistics for traffic validation.\",\n  \"Subtask 13\": \"Start both IGMP host and querier protocols.\",\n  \"Subtask 14\": \"Wait for IGMP sessions to reach stable state and stabilize for 5 seconds.\",\n  \"Subtask 15\": \"Start transmission of bound traffic stream.\",\n  \"Subtask 16\": \"Maintain traffic transmission for 60 seconds.\",\n  \"Subtask 17\": \"Stop bound traffic transmission.\",\n  \"Subtask 18\": \"Stop both IGMP protocols.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats for the bound traffic stream.\",\n  \"Subtask 20\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) for the bound stream.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Verify that the IGMP protocol bound stream is transmitted correctly\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Step 2: Create IGMP protocols on both ports respectively and establish routes;\n      Step 3: Create bound traffic;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, all traffic should show equal transmitted and received packets;\n\nCreated by: Tester-001\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers=['ipv4'])\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建IGMP协议会话\n\n    igmp = create_igmp(Port=Port_UP, Version='IGMPV1')\n\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n\n    select_interface(Session=igmp, Interface=interfaces_1)\n\n    # 创建组播组\n\n    multicast_group = create_multicast_group(Start='225.0.1.2')\n\n    # IGMP协议会话创建组成员关系\n\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # IGMP协议会话组成员关系与组播组绑定\n\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=Port_Down, Version='IGMPV1')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_2)\n\n    # 创建IGMP绑定流\n\n    point = get_layer_from_interfaces(Interfaces=interfaces_2)\n\n    streams = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅统计\n\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待IGMP协议会话稳定状态\n\n    wait_igmp_state(Sessions=[igmp])\n    wait_igmp_querier_state(Sessions=[igmp_querier])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(60)\n\n    stop_stream()\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取IGMP Host统计\n    result = get_igmp_host_statistic()\n    print(result)\n\n    result = get_igmp_host_statistic(Session=igmp)\n    print(result)\n\n    # 获取IGMP Port统计\n    result = get_igmp_port_statistic()\n    print(result)\n\n    result = get_igmp_port_statistic(Port=Port_UP)\n    print(result)\n\n    # 获取IGMP Querier统计\n    result = get_igmp_querier_statistic()\n    print(result)\n\n    result = get_igmp_querier_statistic(Session=igmp_querier)\n    print(result)\n\n    # 获取流量统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_igmp:创建IGMP协议会话对象;\ncreate_igmp_querier:创建IGMP Querier协议会话对象;\nedit_igmp:编辑IGMP协议会话对象;\nedit_igmp_querier:编辑IGMP Querier协议会话对象;\nget_igmp_host_statistic:获取Igmp协议会话统计结果;\nget_igmp_port_statistic:获取Igmp Port统计结果;\nget_igmp_querier_statistic:获取Igmp Querier协议会话统计结果;\nwait_igmp_querier_state:等待Igmp Querier协议会话达到指定状态;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStreamRxStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamRxStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 每条流量添加跳变;\n                   测试步骤4: 订阅StreamRxStats统计;\n                   测试步骤5: 发送所有流量，查看StreamRxStats统计信息，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamRxStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤5,6中StreamRxStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test objective: Verify the accuracy of StreamRxStats statistics on the test instrument\n\nStep: Test step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Test step 2: Create four traffic streams (StreamTemplate_1, 2, 3, 4) on Port_1 and Port_2 respectively;\n      Test step 3: Add a hop to each traffic stream;\n      Test step 4: Subscribe to StreamRxStats statistics;\n      Test step 5: Transmit all traffic streams, observe StreamRxStats statistics, and wait for a period;\n      Test step 6: Stop all traffic streams and observe StreamRxStats statistics;\n\nCriteria: Expected result 1: StreamRxStats statistics are correctly obtained in steps 5 and 6;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    for stream in streams:\n        edit_modifier(Stream=stream, Level=1, Attribute='source', Start='192.168.1.1', Type='Increment', Count=5,\n                      Step=1, StreamType='InterModifier')\n\n    # 订阅StreamRxStats统计视图\n    subscribe_result(Types=['StreamRxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamRxStats所有统计结果:\n    # get_stream_rx_statistic不传参数，返回值为DataFrame数据\n    result = get_stream_rx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1收端口为Port_Down的RxFrameRate和RxByteRate\n    df = result[(result['StreamBlockID'] == streams[0].Name) & (result['PortID'] == Port_Down.handle) & (result['StreamID'] == 1)][['RxFrameRate', 'RxByteRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['RxFrameRate'] == 0 or data['RxByteRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} RxFrameRate or RxByteRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量和端口的统计:\n    # get_stream_rx_statistic传Stream和Port参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[-1], Port=Port_UP)\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式3 -- 获取指定一条流量和端口的统计:\n    # get_stream_rx_statistic传Stream和Port参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_rx_statistic(Stream=streams[-1], Port=Port_UP, StreamID=1)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量的统计: get_stream_rx_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_rx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[:1], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定多条流量的统计: get_stream_rx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_rx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[:3], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式8 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_rx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_rx_statistic(StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_stream_rx_statistic:获取测试仪表流模板统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) by their locations using reserve_port API with Force=True.\",\n  \"Subtask 3\": \"Create four traffic streams (two on Port_1 and two on Port_2) using add_stream API.\",\n  \"Subtask 4\": \"For each stream, add an IPv4 source address modifier with increment pattern (Start='192.168.1.1', Step=1, Count=5) using edit_modifier API.\",\n  \"Subtask 5\": \"Subscribe to StreamRxStats statistics using subscribe_result API.\",\n  \"Subtask 6\": \"Start transmitting all traffic streams using start_stream API.\",\n  \"Subtask 7\": \"Wait 10 seconds to allow statistics stabilization during transmission.\",\n  \"Subtask 8\": \"Retrieve StreamRxStats for StreamTemplate_1 on Port_2 using get_stream_rx_statistic API and verify both RxFrameRate and RxByteRate are non-zero.\",\n  \"Subtask 9\": \"Stop all traffic streams using stop_stream API.\",\n  \"Subtask 10\": \"Wait 3 seconds to collect final statistics after stopping traffic.\",\n  \"Subtask 11\": \"Retrieve StreamRxStats again for StreamTemplate_1 on Port_2 using get_stream_rx_statistic API to confirm successful data acquisition.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test objective: Verify the accuracy of StreamRxStats statistics on the test instrument\n\nStep: Test step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Test step 2: Create four traffic streams (StreamTemplate_1, 2, 3, 4) on Port_1 and Port_2 respectively;\n      Test step 3: Add a hop to each traffic stream;\n      Test step 4: Subscribe to StreamRxStats statistics;\n      Test step 5: Transmit all traffic streams, observe StreamRxStats statistics, and wait for a period;\n      Test step 6: Stop all traffic streams and observe StreamRxStats statistics;\n\nCriteria: Expected result 1: StreamRxStats statistics are correctly obtained in steps 5 and 6;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    for stream in streams:\n        edit_modifier(Stream=stream, Level=1, Attribute='source', Start='192.168.1.1', Type='Increment', Count=5,\n                      Step=1, StreamType='InterModifier')\n\n    # 订阅StreamRxStats统计视图\n    subscribe_result(Types=['StreamRxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamRxStats所有统计结果:\n    # get_stream_rx_statistic不传参数，返回值为DataFrame数据\n    result = get_stream_rx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1收端口为Port_Down的RxFrameRate和RxByteRate\n    df = result[(result['StreamBlockID'] == streams[0].Name) & (result['PortID'] == Port_Down.handle) & (result['StreamID'] == 1)][['RxFrameRate', 'RxByteRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['RxFrameRate'] == 0 or data['RxByteRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} RxFrameRate or RxByteRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量和端口的统计:\n    # get_stream_rx_statistic传Stream和Port参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[-1], Port=Port_UP)\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式3 -- 获取指定一条流量和端口的统计:\n    # get_stream_rx_statistic传Stream和Port参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_rx_statistic(Stream=streams[-1], Port=Port_UP, StreamID=1)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量的统计: get_stream_rx_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_rx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[:1], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式6 -- 获取指定多条流量的统计: get_stream_rx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_rx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_rx_statistic(Stream=streams[:3], StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式8 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_rx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_rx_statistic(StaItems=['RxStreamFrames', 'RxTotalBytes', 'RxByteRate', 'RxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_stream_rx_statistic:获取测试仪表流模板统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStreamStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 每条流量添加跳变;\n                   测试步骤4: 订阅StreamStats统计;\n                   测试步骤5: 发送所有流量，查看StreamStats统计信息，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤5,6中StreamStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify that the test instrument's stream transmission StreamStats statistics are correct\n\nStep: Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n      Test Step 2: Create two streams per port on Port_1 and Port_2: StreamTemplate_1, StreamTemplate_2, StreamTemplate_3, StreamTemplate_4;\n      Test Step 3: Add hopping to each stream;\n      Test Step 4: Subscribe to StreamStats statistics;\n      Test Step 5: Transmit all streams, check StreamStats statistics, and wait for a period;\n      Test Step 6: Stop all streams and check StreamStats statistics;\n\nCriteria: Expected Result 1: StreamStats statistics are correctly retrieved in Steps 5 and 6;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Mode='DB')\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    for stream in streams:\n        edit_modifier(Stream=stream, Level=1, Attribute='source', Start='192.168.1.1', Type='Increment', Count=5,\n                      Step=1, StreamType='InterModifier')\n\n    # 订阅StreamStats统计视图\n    subscribe_result(Types=['StreamStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamStats所有统计结果:\n    # get_stream_statistic不传参数，返回值DataFrame数据\n    result = get_stream_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_stream_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式3 -- 获取指定一条流量的统计:\n    # get_stream_statistic传Stream参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_statistic(Stream=streams[-1], StreamID=1)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_stream_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic传Stream参数,实参只有一个元素并指定StreamID，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_stream_statistic(Stream=streams[:1], StreamID=1, StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式6 -- 获取指定多条流量的统计: get_stream_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_stream_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式8 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_stream_statistic:获取测试仪表流模板统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product and mode using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_UP and Port_Down) from given locations using reserve_port API.\",\n  \"Subtask 3\": \"Create four streams (two per reserved port) using add_stream API.\",\n  \"Subtask 4\": \"Configure IPv4 source address modifier with increment pattern for each stream using edit_modifier API.\",\n  \"Subtask 5\": \"Subscribe to StreamStats statistics view using subscribe_result API.\",\n  \"Subtask 6\": \"Start all streams transmission using start_stream API.\",\n  \"Subtask 7\": \"Wait 10 seconds for stable statistics collection during transmission.\",\n  \"Subtask 8\": \"Retrieve StreamStats statistics for all streams using get_stream_statistic API and verify non-zero TxFrameRate/RxFrameRate for first stream.\",\n  \"Subtask 9\": \"Stop all streams transmission using stop_stream API.\",\n  \"Subtask 10\": \"Wait 3 seconds for final statistics collection after stream stoppage.\",\n  \"Subtask 11\": \"Retrieve StreamStats statistics again using get_stream_statistic API and verify expected post-stop values.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify that the test instrument's stream transmission StreamStats statistics are correct\n\nStep: Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n      Test Step 2: Create two streams per port on Port_1 and Port_2: StreamTemplate_1, StreamTemplate_2, StreamTemplate_3, StreamTemplate_4;\n      Test Step 3: Add hopping to each stream;\n      Test Step 4: Subscribe to StreamStats statistics;\n      Test Step 5: Transmit all streams, check StreamStats statistics, and wait for a period;\n      Test Step 6: Stop all streams and check StreamStats statistics;\n\nCriteria: Expected Result 1: StreamStats statistics are correctly retrieved in Steps 5 and 6;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Mode='DB')\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    for stream in streams:\n        edit_modifier(Stream=stream, Level=1, Attribute='source', Start='192.168.1.1', Type='Increment', Count=5,\n                      Step=1, StreamType='InterModifier')\n\n    # 订阅StreamStats统计视图\n    subscribe_result(Types=['StreamStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamStats所有统计结果:\n    # get_stream_statistic不传参数，返回值DataFrame数据\n    result = get_stream_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name)][['TxFrameRate', 'RxFrameRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['RxFrameRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or RxFrameRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_stream_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式3 -- 获取指定一条流量的统计:\n    # get_stream_statistic传Stream参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_statistic(Stream=streams[-1], StreamID=1)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_stream_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic传Stream参数,实参只有一个元素并指定StreamID，StaItems参数传入获取的统计项目列表，返回值为字典\n    result = get_stream_statistic(Stream=streams[:1], StreamID=1, StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print(result)\n\n    # 统计获取方式6 -- 获取指定多条流量的统计: get_stream_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_stream_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式8 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_statistic(StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes', 'RxTotalBytes'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_stream_statistic:获取测试仪表流模板统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStatistics.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Test Purpose: Verify the test instrument's traffic transmission statistics are correct\n\nStep          : Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n               Step 3: Modify the content of traffic stream StreamTemplate_1;\n               Step 4: Subscribe to StreamBlockStats statistics;\n               Step 5: Send all traffic and wait for a period;\n               Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: In Step 6, transmitted and received packets of traffic stream StreamTemplate_1 are equal;\n\nCreated by    : Tester-001\n\nBugs          : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # NOTE: add_stream函数返回值是list\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n\n    # 修改流量报文内容\n\n    # 修改ethernet头部\n    edit_header_ethernet(Stream=stream, SourceMacAdd='00:01:01:a0:00:01')\n    # 修改ipv4头部， Option添加EndOfOption和RouterAlert\n    edit_header_ipv4(Stream=stream, Destination='10.10.0.1', HeaderOption=['EndOfOption', 'RouterAlert'])\n    # 修改ipv4头部中RouterAlert的参数\n    edit_header_ipv4_option(Stream=stream, Index=1, Option=['RouterAlert'], routerAlertValue=1)\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=1, Attribute='source',\n                  Start='192.168.1.1',\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_types = [\n        'PortStats',\n        'PortAvgLatencyStats',\n        'StreamStats',\n        'StreamTxStats',\n        'StreamRxStats',\n        'StreamBlockStats',\n        'StreamBlockTxStats',\n        'StreamBlockRxStats',\n    ]\n    subscribe_result(Types=subscribe_types)\n\n    # 发送流量\n    start_stream()\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # NOTE: 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 获取流量PortStats返回DataFrame数据\n    result = get_port_statistic(StaItems=['TxFrameRate', 'RxFrameRate'])\n    print('端口PortStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 停止流量\n    stop_stream()\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats返回Dict数据\n    result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n    print(f'StreamBlockStats流量{stream[0].Name}统计数据:\\n{result}')\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n\n    # 判断流量收发包是否相等\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'Test fail: {stream[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n    else:\n        print(f'Test pass: {stream[0].Name} TxStreamFrames({TxStreamFrames}) is equal to RxStreamFrames({RxStreamFrames})\\n')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "edit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two physical ports (Port_1 and Port_2) using force reservation mode.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 and store the stream object reference.\",\n  \"Subtask 4\": \"Create EthernetII and IPv4 headers for the traffic stream.\",\n  \"Subtask 5\": \"Modify the Ethernet header source MAC address to '00:01:01:a0:00:01'.\",\n  \"Subtask 6\": \"Modify the IPv4 header destination address to '10.10.0.1' and add EndOfOption and RouterAlert options.\",\n  \"Subtask 7\": \"Modify the IPv4 RouterAlert option value to 1 at index position 1.\",\n  \"Subtask 8\": \"Apply increment modifier to IPv4 source address starting at '192.168.1.1' with step 1 for 5 packets using InterModifier type.\",\n  \"Subtask 9\": \"Save the current test configuration to a file for reference.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats statistics view along with other relevant statistics types.\",\n  \"Subtask 11\": \"Start traffic transmission on all configured streams.\",\n  \"Subtask 12\": \"Wait for 10 seconds during traffic transmission to collect statistics.\",\n  \"Subtask 13\": \"Stop all traffic transmission.\",\n  \"Subtask 14\": \"Wait for 3 seconds after stopping traffic to finalize statistics collection.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats for the traffic stream, specifically TxStreamFrames and RxStreamFrames values.\",\n  \"Subtask 16\": \"Verify that TxStreamFrames equals RxStreamFrames for the transmitted traffic stream.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Test Purpose: Verify the test instrument's traffic transmission statistics are correct\n\nStep          : Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n               Step 3: Modify the content of traffic stream StreamTemplate_1;\n               Step 4: Subscribe to StreamBlockStats statistics;\n               Step 5: Send all traffic and wait for a period;\n               Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: In Step 6, transmitted and received packets of traffic stream StreamTemplate_1 are equal;\n\nCreated by    : Tester-001\n\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # NOTE: add_stream函数返回值是list\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n\n    # 修改流量报文内容\n\n    # 修改ethernet头部\n    edit_header_ethernet(Stream=stream, SourceMacAdd='00:01:01:a0:00:01')\n    # 修改ipv4头部， Option添加EndOfOption和RouterAlert\n    edit_header_ipv4(Stream=stream, Destination='10.10.0.1', HeaderOption=['EndOfOption', 'RouterAlert'])\n    # 修改ipv4头部中RouterAlert的参数\n    edit_header_ipv4_option(Stream=stream, Index=1, Option=['RouterAlert'], routerAlertValue=1)\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=1, Attribute='source',\n                  Start='192.168.1.1',\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_types = [\n        'PortStats',\n        'PortAvgLatencyStats',\n        'StreamStats',\n        'StreamTxStats',\n        'StreamRxStats',\n        'StreamBlockStats',\n        'StreamBlockTxStats',\n        'StreamBlockRxStats',\n    ]\n    subscribe_result(Types=subscribe_types)\n\n    # 发送流量\n    start_stream()\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # NOTE: 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 获取流量PortStats返回DataFrame数据\n    result = get_port_statistic(StaItems=['TxFrameRate', 'RxFrameRate'])\n    print('端口PortStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 停止流量\n    stop_stream()\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats返回Dict数据\n    result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n    print(f'StreamBlockStats流量{stream[0].Name}统计数据:\\n{result}')\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n\n    # 判断流量收发包是否相等\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += f'Test fail: {stream[0].Name} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n    else:\n        print(f'Test pass: {stream[0].Name} TxStreamFrames({TxStreamFrames}) is equal to RxStreamFrames({RxStreamFrames})\\n')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nedit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Protocol/OSPF/OSPFv2.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查OSPFv2协议绑定流发送正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建OSPFv2协议，并且创建路由;\n                   测试步骤3: 创建绑定流量;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中所有流量收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify normal transmission of OSPFv2 protocol bound streams  \n\nStep:  \nTest Step 1: Reserve two loopback ports: Port_1 and Port_2.  \nTest Step 2: Configure OSPFv2 protocols on both ports and establish routes.  \nTest Step 3: Create bound traffic streams.  \nTest Step 4: Subscribe to StreamBlockStats counters.  \nTest Step 5: Transmit all traffic and wait for a period.  \nTest Step 6: Stop all traffic and check StreamBlockStats information.  \n\nCriteria:  \nExpected Result 1: In Step 6, all transmitted and received packets must match.  \n\nCreated by: Tester-001  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建OSPFv2协议会话\n\n    session_1 = create_ospf(Port=Port_UP, Priority=1)\n\n    session_2 = create_ospf(Port=Port_Down, Priority=2)\n\n    # OSPFv2协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # OSPFv2协议会话1创建Summary Lsa\n\n    summary_lsa = create_ospf_summary_lsa(Session=session_1)\n\n    # OSPFv2协议会话2创建External Lsa\n\n    external_lsa = create_ospf_external_lsa(Session=session_2)\n\n    # 获取OSPFv2协议绑定流端点对象\n\n    point_1 = get_ospf_router_from_lsa(Lsa=summary_lsa)\n\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa)\n\n    # 创建OSPFv2绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待OSPFv2协议会话达到Full状态\n\n    wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n\n    advertise_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    withdraw_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取OSPFv2会话1统计\n    import pandas\n    result = get_ospf_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ospf_statistic(Session=session_1)\n    print(result)\n    TxSummaryLsa = result['TxSummaryLsa']\n    RxAsExternalLsa = result['RxAsExternalLsa']\n    print('TxSummaryLsa: {}'.format(TxSummaryLsa))\n    print('RxAsExternalLsa: {}'.format(RxAsExternalLsa))\n\n    # 获取OSPFv2会话2统计\n\n    result = get_ospf_statistic(Session=session_2)\n    print(result)\n    RxSummaryLsa = result['RxSummaryLsa']\n    TxAsExternalLsa = result['TxAsExternalLsa']\n    print('RxSummaryLsa: {}'.format(RxSummaryLsa))\n    print('TxAsExternalLsa: {}'.format(TxAsExternalLsa))\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_ospf_lsa:通告 OSPFv2 协议会话 lsa",
      "create_ospf:创建OSPFv2协议会话对象",
      "create_ospf_external_lsa:创建OSPFv2 External LSA对象",
      "create_ospf_summary_lsa:创建OSPFv2 Summary LSA对象",
      "get_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象",
      "get_ospf_statistic:获取OSPFv2协议会话统计结果",
      "wait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态",
      "withdraw_ospf_lsa:撤销OSPFv2协议会话lsa",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports using provided locations.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both reserved ports and configure IP addresses/gateways (Port_UP: 192.168.1.2/192.168.1.3, Port_Down: 192.168.1.3/192.168.1.2).\",\n  \"Subtask 4\": \"Create OSPFv2 sessions on both ports with specified priorities (Port_UP priority=1, Port_Down priority=2).\",\n  \"Subtask 5\": \"Bind each OSPF session to its corresponding IPv4 interface.\",\n  \"Subtask 6\": \"Create Summary LSA on first OSPF session and External LSA on second OSPF session.\",\n  \"Subtask 7\": \"Retrieve OSPF router endpoints from created LSAs for stream source/destination.\",\n  \"Subtask 8\": \"Create bidirectional bound streams between the two OSPF endpoints.\",\n  \"Subtask 9\": \"Subscribe to OSPF session statistics and StreamBlockStats counters.\",\n  \"Subtask 10\": \"Save current configuration to file.\",\n  \"Subtask 11\": \"Start OSPF protocol on both ports.\",\n  \"Subtask 12\": \"Wait until both OSPF sessions reach full adjacency state.\",\n  \"Subtask 13\": \"Advertise created LSAs and wait 5 seconds for propagation.\",\n  \"Subtask 14\": \"Start all traffic streams and run for 10 seconds.\",\n  \"Subtask 15\": \"Stop all traffic streams.\",\n  \"Subtask 16\": \"Withdraw advertised LSAs and wait 5 seconds.\",\n  \"Subtask 17\": \"Stop OSPF protocol.\",\n  \"Subtask 18\": \"Retrieve OSPF session statistics and verify results are in expected format.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats for all streams and verify transmitted frames equal received frames.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify normal transmission of OSPFv2 protocol bound streams  \n\nStep:  \nTest Step 1: Reserve two loopback ports: Port_1 and Port_2.  \nTest Step 2: Configure OSPFv2 protocols on both ports and establish routes.  \nTest Step 3: Create bound traffic streams.  \nTest Step 4: Subscribe to StreamBlockStats counters.  \nTest Step 5: Transmit all traffic and wait for a period.  \nTest Step 6: Stop all traffic and check StreamBlockStats information.  \n\nCriteria:  \nExpected Result 1: In Step 6, all transmitted and received packets must match.  \n\nCreated by: Tester-001  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建接口\n\n    interfaces_1 = create_interface(Port=Port_UP, Layers='ipv4')\n\n    interfaces_2 = create_interface(Port=Port_Down, Layers='ipv4')\n\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建OSPFv2协议会话\n\n    session_1 = create_ospf(Port=Port_UP, Priority=1)\n\n    session_2 = create_ospf(Port=Port_Down, Priority=2)\n\n    # OSPFv2协议会话与接口绑定\n\n    select_interface(Session=session_1, Interface=interfaces_1)\n\n    select_interface(Session=session_2, Interface=interfaces_2)\n\n    # OSPFv2协议会话1创建Summary Lsa\n\n    summary_lsa = create_ospf_summary_lsa(Session=session_1)\n\n    # OSPFv2协议会话2创建External Lsa\n\n    external_lsa = create_ospf_external_lsa(Session=session_2)\n\n    # 获取OSPFv2协议绑定流端点对象\n\n    point_1 = get_ospf_router_from_lsa(Lsa=summary_lsa)\n\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa)\n\n    # 创建OSPFv2绑定流\n\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动协议\n\n    start_protocol()\n\n    # 等待OSPFv2协议会话达到Full状态\n\n    wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n\n    advertise_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n\n    time.sleep(5)\n\n    # 发送流量\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    withdraw_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n\n    time.sleep(5)\n\n    stop_protocol()\n\n    time.sleep(3)\n\n    # 获取OSPFv2会话1统计\n    import pandas\n    result = get_ospf_statistic()\n    print(result)\n    if not isinstance(result, pandas.DataFrame):\n        verdict = 'fail'\n\n    result = get_ospf_statistic(Session=session_1)\n    print(result)\n    TxSummaryLsa = result['TxSummaryLsa']\n    RxAsExternalLsa = result['RxAsExternalLsa']\n    print('TxSummaryLsa: {}'.format(TxSummaryLsa))\n    print('RxAsExternalLsa: {}'.format(RxAsExternalLsa))\n\n    # 获取OSPFv2会话2统计\n\n    result = get_ospf_statistic(Session=session_2)\n    print(result)\n    RxSummaryLsa = result['RxSummaryLsa']\n    TxAsExternalLsa = result['TxAsExternalLsa']\n    print('RxSummaryLsa: {}'.format(RxSummaryLsa))\n    print('TxAsExternalLsa: {}'.format(TxAsExternalLsa))\n\n    # 获取流量1统计\n\n    result = get_streamblock_statistic(Stream=streams[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 获取流量2统计\n\n    result = get_streamblock_statistic(Stream=streams[1])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_ospf_lsa:通告 OSPFv2 协议会话 lsa;\ncreate_ospf:创建OSPFv2协议会话对象;\ncreate_ospf_external_lsa:创建OSPFv2 External LSA对象;\ncreate_ospf_summary_lsa:创建OSPFv2 Summary LSA对象;\nget_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象;\nget_ospf_statistic:获取OSPFv2协议会话统计结果;\nwait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态;\nwithdraw_ospf_lsa:撤销OSPFv2协议会话lsa;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStreamTxStatistic.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流StreamTxStats统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1, Port_2分别创建两条流量StreamTemplate_1、2、3、4;\n                   测试步骤3: 订阅StreamTxStats统计;\n                   测试步骤4: 发送所有流量，查看StreamTxStats统计信息，等待一段时间;\n                   测试步骤5: 停止所有流量，查看StreamTxStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤4,5中StreamTxStats统计信息获取正确;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify that the StreamTxStats statistics of the test instrument are correctly counted\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create four traffic streams: StreamTemplate_1 and StreamTemplate_2 on Port_1, StreamTemplate_3 and StreamTemplate_4 on Port_2;\n      Step 3: Subscribe to StreamTxStats statistics;\n      Step 4: Transmit all traffic, check StreamTxStats statistics, and wait for a period;\n      Step 5: Stop all traffic and check StreamTxStats statistics;\n\nCriteria: Expected Result 1: StreamTxStats statistics are correctly obtained in Steps 4 and 5;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    for stream in streams:\n        edit_modifier(Stream=stream, Level=1, Attribute='source', Start='192.168.1.1', Type='Increment', Count=5,\n                      Step=1, StreamType='InterModifier')\n\n    # 订阅StreamTxStats统计视图\n    subscribe_result(Types=['StreamTxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamTxStats所有统计结果:\n    # get_stream_tx_statistic不传参数，返回值为DataFrame数据\n    result = get_stream_tx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name) & (result['StreamID'] == 1)][['TxFrameRate', 'TxBitRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['TxBitRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or TxBitRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_stream_tx_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式3 -- 获取指定一条流量的统计:\n    # get_stream_tx_statistic传Stream参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_tx_statistic(Stream=streams[-1], StreamID=1)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量和端口的统计:\n    # get_stream_tx_statistic传Stream和Port参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[-1], Port=Port_Down)\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定一条流量和端口的统计:\n    # get_stream_tx_statistic传Stream和Port参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_tx_statistic(Stream=streams[-1], Port=Port_Down, StreamID=1)\n    print(result)\n\n    # 统计获取方式6 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_tx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定多条流量的统计: get_stream_tx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式8 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_tx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式9 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_tx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_tx_statistic(StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "get_stream_tx_statistic:获取测试仪表流模板统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (default: DarYu).\",\n  \"Subtask 2\": \"Reserve two ports using provided locations with force reservation enabled.\",\n  \"Subtask 3\": \"Create four traffic streams: two streams on first reserved port and two streams on second reserved port.\",\n  \"Subtask 4\": \"Configure IPv4 source address modifier for all streams: start value '192.168.1.1', increment type with step 1, count 5.\",\n  \"Subtask 5\": \"Subscribe to StreamTxStats statistics view.\",\n  \"Subtask 6\": \"Save test configuration to specified file path.\",\n  \"Subtask 7\": \"Start transmission of all traffic streams.\",\n  \"Subtask 8\": \"Wait 10 seconds for statistics stabilization during transmission.\",\n  \"Subtask 9\": \"Retrieve and log all StreamTxStats statistics in tabular format during transmission.\",\n  \"Subtask 10\": \"Verify non-zero TxFrameRate and TxBitRate for first stream (StreamTemplate_1) during transmission.\",\n  \"Subtask 11\": \"Stop all traffic streams.\",\n  \"Subtask 12\": \"Wait 3 seconds for final statistics collection after stopping traffic.\",\n  \"Subtask 13\": \"Retrieve and log StreamTxStats statistics in multiple formats: single stream, specific stream ID, port-specific, and custom statistic items.\",\n  \"Subtask 14\": \"Handle exceptions and finalize test verdict with error information if any.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify that the StreamTxStats statistics of the test instrument are correctly counted\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create four traffic streams: StreamTemplate_1 and StreamTemplate_2 on Port_1, StreamTemplate_3 and StreamTemplate_4 on Port_2;\n      Step 3: Subscribe to StreamTxStats statistics;\n      Step 4: Transmit all traffic, check StreamTxStats statistics, and wait for a period;\n      Step 5: Stop all traffic and check StreamTxStats statistics;\n\nCriteria: Expected Result 1: StreamTxStats statistics are correctly obtained in Steps 4 and 5;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    streams = add_stream(Ports=[Port_UP, Port_UP, Port_Down, Port_Down])\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    for stream in streams:\n        edit_modifier(Stream=stream, Level=1, Attribute='source', Start='192.168.1.1', Type='Increment', Count=5,\n                      Step=1, StreamType='InterModifier')\n\n    # 订阅StreamTxStats统计视图\n    subscribe_result(Types=['StreamTxStats'])\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n    # 发送流获取统计建议等待10sec获取到稳定统计数据\n    time.sleep(10)\n\n    # NOTE: 统计获取数据返回基本原则，当获取到单行数据时返回dict类型数据，\n    # 当获取到多行数据时返回Pandas的DataFrame数据，Pandas详细请参考: https://www.pypandas.cn/\n    # 统计获取方式1 -- 获取StreamTxStats所有统计结果:\n    # get_stream_tx_statistic不传参数，返回值为DataFrame数据\n    result = get_stream_tx_statistic()\n    # 使用tabulate库表格化输出DataFrame二维数据\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    # 将DataFrame数据转成list[dict]形式\n    data = result.to_dict('records')\n    print(data)\n\n    # 根据DataFrame数据筛选出StreamTemplate_1的TxFrameRate和RxStreamFrames\n    df = result[(result['StreamBlockID'] == streams[0].Name) & (result['StreamID'] == 1)][['TxFrameRate', 'TxBitRate']]\n    data = df.to_dict('records')[0]\n    # 判断StreamTemplate_1收发包速率不为0\n    if data['TxFrameRate'] == 0 or data['TxBitRate'] == 0:\n        verdict = 'fail'\n        errInfo += f'{streams[0].Name} TxFrameRate or TxBitRate is equal to 0\\n'\n\n    stop_stream()\n    # 停流获取统计必须等待3sec才能获取到稳定统计数据\n    time.sleep(3)\n\n    # 统计获取方式2 -- 获取指定一条流量的统计:\n    # get_stream_tx_statistic传Stream参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[-1])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式3 -- 获取指定一条流量的统计:\n    # get_stream_tx_statistic传Stream参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_tx_statistic(Stream=streams[-1], StreamID=1)\n    print(result)\n\n    # 统计获取方式4 -- 获取指定一条流量和端口的统计:\n    # get_stream_tx_statistic传Stream和Port参数,实参只有一个元素，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[-1], Port=Port_Down)\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式5 -- 获取指定一条流量和端口的统计:\n    # get_stream_tx_statistic传Stream和Port参数,实参只有一个元素并指定StreamID，返回值为字典\n    result = get_stream_tx_statistic(Stream=streams[-1], Port=Port_Down, StreamID=1)\n    print(result)\n\n    # 统计获取方式6 -- 获取指定一条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_tx_statistic传Stream参数,实参只有一个元素，StaItems参数传入获取的统计项目列表，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[:1], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式7 -- 获取指定多条流量的统计: get_stream_tx_statistic传Stream参数,实参是一个多个元素的列表，返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[:2])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式8 -- 获取指定多条流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_tx_statistic传Stream参数,实参是一个多个元素的列表，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_tx_statistic(Stream=streams[:3], StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 统计获取方式9 -- 获取指定所有流量的统计,并且StaItems参数指定统计项目:\n    # get_stream_tx_statistic不传Stream参数，StaItems参数传入获取的统计项目列表， 返回值为DataFrame数据\n    result = get_stream_tx_statistic(StaItems=['TxStreamFrames', 'TxTotalBytes', 'TxByteRate', 'TxBitRate'])\n    print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nget_stream_tx_statistic:获取测试仪表流模板统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Imix/StreamImix.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Imix模板;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tCSR-10199\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify the accuracy of flow statistics transmission by the test instrument\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream, StreamTemplate_1, on port Port_1;\n      Step 3: Modify the Imix template of traffic stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-001\n\nBugs: CSR-10199\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=78, Max=178, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=206, Max=306, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=462, Max=562, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=974, Max=1074, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1230, Max=1330, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1468, Max=1568, Weight=50)\n    bind_stream_imix(Stream=stream, IMix=imix)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "add_stream:测试仪表创建流量",
      "add_imix_distribution_frame:在Imix模板添加自定义帧长",
      "bind_stream_imix:将Imix模板和流量模板绑定",
      "create_imix:创建流量Imix模板"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports named Port_1 and Port_2 using the reserve_port API function.\",\n  \"Subtask 2\": \"Create a traffic stream named StreamTemplate_1 on Port_1 using the add_stream API function.\",\n  \"Subtask 3\": \"Create an Imix template using the create_imix API function.\",\n  \"Subtask 4\": \"Modify the Imix template by adding multiple frame length distributions with specified min/max lengths and weights using the add_imix_distribution_frame API function.\",\n  \"Subtask 5\": \"Bind the modified Imix template to StreamTemplate_1 using the bind_stream_imix API function.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats statistics for StreamTemplate_1 to monitor traffic metrics.\",\n  \"Subtask 7\": \"Start traffic transmission on all configured streams and maintain transmission for a specified duration.\",\n  \"Subtask 8\": \"Stop all traffic transmission after the waiting period.\",\n  \"Subtask 9\": \"Retrieve StreamBlockStats statistics for StreamTemplate_1 after traffic stops.\",\n  \"Subtask 10\": \"Verify that the transmitted packet count equals the received packet count for StreamTemplate_1 in the statistics.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify the accuracy of flow statistics transmission by the test instrument\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream, StreamTemplate_1, on port Port_1;\n      Step 3: Modify the Imix template of traffic stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-001\n\nBugs: CSR-10199\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=78, Max=178, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=206, Max=306, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=462, Max=562, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=974, Max=1074, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1230, Max=1330, Weight=50)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1468, Max=1568, Weight=50)\n    bind_stream_imix(Stream=stream, IMix=imix)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nadd_stream:测试仪表创建流量;\nadd_imix_distribution_frame:在Imix模板添加自定义帧长;\nbind_stream_imix:将Imix模板和流量模板绑定;\ncreate_imix:创建流量Imix模板\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6MLDv2Report.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv2 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv2 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    : Verify the test instrument correctly counts sent ICMPv6 MLDv2 report packets\nStep         : Step 1: Reserve two loopback ports Port_1, Port_2;\n              Step 2: Modify ICMPv6 MLDv2 report header content in traffic StreamTemplate_1;;\n              Step 3: Configure filtered packet capture;\n              Step 4: Subscribe to StreamBlockStats statistics;;\n              Step 5: Set port transmission mode to burst;\n              Step 6: Transmit all traffic and wait for a period;\n              Step 7: Stop all traffic and view StreamBlockStats statistics;;\nCriteria     : Expected Result 1: Sent/received packets for StreamTemplate_1 are equal in Step 6;\nCreated by   : Tester-004\nBugs         : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv2report']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_mldv2_report(Stream=stream, Level=0,\n                          Type='143',Reserved='20',NumberOfGroupRecords='2')\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2report', Attribute=header['Reserved'],\n                  Type='Increment', Count=10)\n\n    group = edit_header_icmpv6_group_records(Stream=stream, Index=1,\n                                             SourceAddressList=['2001::1', '2002::2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2report', Attribute=group['SourceAddressList: 2002::2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Report_1.type',\n                                               Value='143', MaxValue='143')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Report_1.reserved2',\n                                               Value='20',\n                                               MaxValue='20')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Report_1.numberOfGroupRecords',\n                                               Value='2',\n                                               MaxValue='2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_group_records:修改测试仪表流量模板中ICMPv6 Mldv2 Report报文头部Group Records内容",
      "edit_header_icmpv6_mldv2_report:修改测试仪表流量模板中Icmpv6 Mldv2 Report报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with the specified product platform.\",\n  \"Subtask 2\": \"Reserve two ports using the provided location addresses.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Build the stream header with EthernetII, IPv6, and MLDv2 Report protocol layers.\",\n  \"Subtask 5\": \"Modify the ICMPv6 MLDv2 Report header fields: set Type to 143, Reserved to 20, and NumberOfGroupRecords to 2.\",\n  \"Subtask 6\": \"Apply increment modifier to the Reserved field of the MLDv2 Report header with count=10.\",\n  \"Subtask 7\": \"Configure group records in the MLDv2 Report header with SourceAddressList ['2001::1', '2002::2'].\",\n  \"Subtask 8\": \"Apply increment modifier to the second source address in group records with count=10.\",\n  \"Subtask 9\": \"Create three PDU patterns on the second port for capture filtering: match Type=143, Reserved=20, and NumberOfGroupRecords=2.\",\n  \"Subtask 10\": \"Set capture filter on the second port using logical AND combination of the three PDU patterns.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 12\": \"Configure the first port's transmission mode to BURST with burst count=100.\",\n  \"Subtask 13\": \"Save the test configuration to a file.\",\n  \"Subtask 14\": \"Start packet capture on the second port.\",\n  \"Subtask 15\": \"Transmit the configured traffic stream from the first port.\",\n  \"Subtask 16\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 17\": \"Stop traffic transmission.\",\n  \"Subtask 18\": \"Stop packet capture.\",\n  \"Subtask 19\": \"Wait 3 seconds for capture stabilization.\",\n  \"Subtask 20\": \"Download captured packets from the second port to local storage.\",\n  \"Subtask 21\": \"Retrieve StreamBlockStats for the traffic stream.\",\n  \"Subtask 22\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames).\",\n  \"Subtask 23\": \"Release both reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    : Verify the test instrument correctly counts sent ICMPv6 MLDv2 report packets\nStep         : Step 1: Reserve two loopback ports Port_1, Port_2;\n              Step 2: Modify ICMPv6 MLDv2 report header content in traffic StreamTemplate_1;;\n              Step 3: Configure filtered packet capture;\n              Step 4: Subscribe to StreamBlockStats statistics;;\n              Step 5: Set port transmission mode to burst;\n              Step 6: Transmit all traffic and wait for a period;\n              Step 7: Stop all traffic and view StreamBlockStats statistics;;\nCriteria     : Expected Result 1: Sent/received packets for StreamTemplate_1 are equal in Step 6;\nCreated by   : Tester-004\nBugs         : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv2report']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_mldv2_report(Stream=stream, Level=0,\n                          Type='143',Reserved='20',NumberOfGroupRecords='2')\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2report', Attribute=header['Reserved'],\n                  Type='Increment', Count=10)\n\n    group = edit_header_icmpv6_group_records(Stream=stream, Index=1,\n                                             SourceAddressList=['2001::1', '2002::2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2report', Attribute=group['SourceAddressList: 2002::2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Report_1.type',\n                                               Value='143', MaxValue='143')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Report_1.reserved2',\n                                               Value='20',\n                                               MaxValue='20')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Report_1.numberOfGroupRecords',\n                                               Value='2',\n                                               MaxValue='2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_group_records:修改测试仪表流量模板中ICMPv6 Mldv2 Report报文头部Group Records内容;\nedit_header_icmpv6_mldv2_report:修改测试仪表流量模板中Icmpv6 Mldv2 Report报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Statistics/GetStatisticsPre.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   : Check that the test instrument's traffic statistics are accurate\n\nStep        : Step 1: Reserve two loopback ports Port_1 and Port_2;\n             Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n             Step 3: Modify the content of traffic stream StreamTemplate_1;\n             Step 4: Subscribe to StreamBlockStats;\n             Step 5: Send all traffic and wait for a period;\n             Step 6: Stop all traffic and view StreamBlockStats information;\n\nCriteria    : Expected Result 1: In step 6, traffic stream StreamTemplate_1 shows equal packets sent and received;\n\nCreated by  : Tester-001\n\nBugs        : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Mode='db')\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # NOTE: add_stream函数返回值是list\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n\n    # 修改流量报文内容\n\n    # 修改ethernet头部\n    edit_header_ethernet(Stream=stream, SourceMacAdd='00:01:01:a0:00:01')\n    # 修改ipv4头部， Option添加EndOfOption和RouterAlert\n    edit_header_ipv4(Stream=stream, Destination='10.10.0.1', HeaderOption=['EndOfOption', 'RouterAlert'])\n    # 修改ipv4头部中RouterAlert的参数\n    edit_header_ipv4_option(Stream=stream, Index=1, Option=['RouterAlert'], routerAlertValue=1)\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=1, Attribute='source',\n                  Start='192.168.1.1',\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_types = [\n        'PortStats',\n        'PortAvgLatencyStats',\n        'StreamStats',\n        'StreamTxStats',\n        'StreamRxStats',\n        'StreamBlockStats',\n        'StreamBlockTxStats',\n        'StreamBlockRxStats',\n    ]\n    subscribe_result(Types=subscribe_types)\n\n    # 发送流量\n    start_stream()\n    time.sleep(5)\n    # 停止流量\n    stop_stream()\n    time.sleep(3)\n\n    # 清空统计\n    clear_result()\n\n    # 发送流量\n    start_stream()\n    time.sleep(5)\n    # 停止流量\n    stop_stream()\n    time.sleep(3)\n\n    # 获取流量PortStats返回DataFrame数据\n    result = get_port_statistic(Mode=True)\n    print('端口PortStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    result = get_port_latency_statistic()\n    print('端口PortLatencyStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 获取流量PortStats返回DataFrame数据\n    result = get_port_statistic(Mode=True)\n    print('端口PortStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    result = get_port_latency_statistic()\n    print('端口PortLatencyStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "clear_result:清除测试仪表统计",
      "get_port_latency_statistic:获取测试仪表端口时延统计结果",
      "get_port_statistic:获取测试仪表端口统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "edit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for DarYu platform in database mode.\",\n  \"Subtask 2\": \"Reserve two loopback ports Port_1 and Port_2 using specified locations.\",\n  \"Subtask 3\": \"Create a traffic stream StreamTemplate_1 on Port_1.\",\n  \"Subtask 4\": \"Create EthernetII and IPv4 headers for StreamTemplate_1.\",\n  \"Subtask 5\": \"Modify StreamTemplate_1's Ethernet header to set source MAC address to '00:01:01:a0:00:01'.\",\n  \"Subtask 6\": \"Modify StreamTemplate_1's IPv4 header to set destination address to '10.10.0.1' and add EndOfOption and RouterAlert options.\",\n  \"Subtask 7\": \"Edit StreamTemplate_1's IPv4 RouterAlert option value to 1.\",\n  \"Subtask 8\": \"Add increment modifier to StreamTemplate_1's IPv4 source address starting from '192.168.1.1' with step 1 for 5 packets.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view along with other required statistics.\",\n  \"Subtask 10\": \"Start traffic transmission on all streams and wait for 5 seconds.\",\n  \"Subtask 11\": \"Stop all traffic transmission and wait for 3 seconds.\",\n  \"Subtask 12\": \"Clear all existing statistics results.\",\n  \"Subtask 13\": \"Restart traffic transmission and wait for 5 seconds.\",\n  \"Subtask 14\": \"Stop all traffic transmission and wait for 3 seconds.\",\n  \"Subtask 15\": \"Retrieve and display port statistics (PortStats) results.\",\n  \"Subtask 16\": \"Retrieve and display port latency statistics (PortAvgLatencyStats) results.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats information for StreamTemplate_1.\",\n  \"Subtask 18\": \"Verify that sent packet count equals received packet count for StreamTemplate_1 in StreamBlockStats.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   : Check that the test instrument's traffic statistics are accurate\n\nStep        : Step 1: Reserve two loopback ports Port_1 and Port_2;\n             Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n             Step 3: Modify the content of traffic stream StreamTemplate_1;\n             Step 4: Subscribe to StreamBlockStats;\n             Step 5: Send all traffic and wait for a period;\n             Step 6: Stop all traffic and view StreamBlockStats information;\n\nCriteria    : Expected Result 1: In step 6, traffic stream StreamTemplate_1 shows equal packets sent and received;\n\nCreated by  : Tester-001\n\nBugs        : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Mode='db')\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # NOTE: add_stream函数返回值是list\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n\n    # 修改流量报文内容\n\n    # 修改ethernet头部\n    edit_header_ethernet(Stream=stream, SourceMacAdd='00:01:01:a0:00:01')\n    # 修改ipv4头部， Option添加EndOfOption和RouterAlert\n    edit_header_ipv4(Stream=stream, Destination='10.10.0.1', HeaderOption=['EndOfOption', 'RouterAlert'])\n    # 修改ipv4头部中RouterAlert的参数\n    edit_header_ipv4_option(Stream=stream, Index=1, Option=['RouterAlert'], routerAlertValue=1)\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=1, Attribute='source',\n                  Start='192.168.1.1',\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_types = [\n        'PortStats',\n        'PortAvgLatencyStats',\n        'StreamStats',\n        'StreamTxStats',\n        'StreamRxStats',\n        'StreamBlockStats',\n        'StreamBlockTxStats',\n        'StreamBlockRxStats',\n    ]\n    subscribe_result(Types=subscribe_types)\n\n    # 发送流量\n    start_stream()\n    time.sleep(5)\n    # 停止流量\n    stop_stream()\n    time.sleep(3)\n\n    # 清空统计\n    clear_result()\n\n    # 发送流量\n    start_stream()\n    time.sleep(5)\n    # 停止流量\n    stop_stream()\n    time.sleep(3)\n\n    # 获取流量PortStats返回DataFrame数据\n    result = get_port_statistic(Mode=True)\n    print('端口PortStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    result = get_port_latency_statistic()\n    print('端口PortLatencyStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n    # 获取流量PortStats返回DataFrame数据\n    result = get_port_statistic(Mode=True)\n    print('端口PortStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n    result = get_port_latency_statistic()\n    print('端口PortLatencyStats统计数据:\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n')\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\nclear_result:清除测试仪表统计;\nget_port_latency_statistic:获取测试仪表端口时延统计结果;\nget_port_statistic:获取测试仪表端口统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nedit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2UnknownInstance.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发OSPFv2 Unknown报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量Stream的OSPFv2 Unknown头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: To verify that the test instrument correctly counts transmitted OSPFv2 Unknown packets\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Modify the OSPFv2 Unknown header content of the traffic stream;;\n                   Test Step 3: Configure filtered packet capture;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set port transmission mode to burst;\n                   Test Step 6: Transmit all traffic and wait for a period of time;\n                   Test Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria    \t:   Expected Result 1: In step 6, traffic StreamTemplate_1 shows equal transmitted and received packets;\n\nCreated by   \t:   Tester-004\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2unknown']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改ospfv2 database description头部\n    edit_header_ospfv2_unknown(Stream=stream, Level=0,\n                          RouterID='2.2.2.2', AuthType='MD5',\n                          AuthValue1=111)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Unknown_1.ospfHeader.authSelect.hdrAuthSelectNone.authValue1',\n                                               Value='111', MaxValue='111')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_unknown:修改测试仪表流量模板中OSPFv2 Unknown报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers as EthernetII, IPv4, and OSPFv2 Unknown using create_stream_header API.\",\n  \"Subtask 5\": \"Modify OSPFv2 Unknown header to set RouterID='2.2.2.2', AuthType='MD5', and AuthValue1=111 using edit_header_ospfv2_unknown API.\",\n  \"Subtask 6\": \"Create PDU pattern for capture on the second port filtering on OSPFv2 AuthValue1 field with value 111 using create_capture_pdu_pattern API.\",\n  \"Subtask 7\": \"Apply capture filter to the second port using the created PDU pattern via edit_capture_filter API.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 9\": \"Configure first port's transmission mode as burst with count=100 using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Start packet capture on the second port using start_capture API.\",\n  \"Subtask 11\": \"Initiate traffic transmission on the first port using start_stream API.\",\n  \"Subtask 12\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 13\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 14\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 16\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 17\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: To verify that the test instrument correctly counts transmitted OSPFv2 Unknown packets\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Modify the OSPFv2 Unknown header content of the traffic stream;;\n                   Test Step 3: Configure filtered packet capture;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set port transmission mode to burst;\n                   Test Step 6: Transmit all traffic and wait for a period of time;\n                   Test Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria    \t:   Expected Result 1: In step 6, traffic StreamTemplate_1 shows equal transmitted and received packets;\n\nCreated by   \t:   Tester-004\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2unknown']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改ospfv2 database description头部\n    edit_header_ospfv2_unknown(Stream=stream, Level=0,\n                          RouterID='2.2.2.2', AuthType='MD5',\n                          AuthValue1=111)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Unknown_1.ospfHeader.authSelect.hdrAuthSelectNone.authValue1',\n                                               Value='111', MaxValue='111')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_unknown:修改测试仪表流量模板中OSPFv2 Unknown报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4_EchoReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 echo reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 echo reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify that the test instrument accurately counts transmitted ICMPv4 echo reply packets.\n\nStep:\nStep 1: Reserve two loopback ports, Port_1 and Port_2.\nStep 2: Modify the ICMPv4 echo reply header in traffic stream StreamTemplate_1.\nStep 3: Configure filtered packet capture.\nStep 4: Subscribe to StreamBlockStats.\nStep 5: Set port transmission mode to burst.\nStep 6: Transmit all traffic and wait for a period.\nStep 7: Stop all traffic and check StreamBlockStats statistics.\n\nCriteria:\nExpected Result 1: In Step 6, transmitted and received packet counts for StreamTemplate_1 are equal.\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4EchoReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改Icmpv4EchoReply头部\n    header = edit_header_icmp_echo_reply(Stream=stream, Level=0, Type='2',\n                                Code='4', Identifier='100', SequenceNumber='200')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4EchoReply', Attribute=header['Code'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoReply_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoReply_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_echo_reply:修改测试仪表流量模板中Icmp Echo Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with the specified product configuration.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using their physical locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: Ethernet II, IPv4, and ICMPv4 Echo Reply.\",\n  \"Subtask 5\": \"Modify ICMPv4 Echo Reply header fields: Type=2, Code=4, Identifier=100, SequenceNumber=200.\",\n  \"Subtask 6\": \"Apply increment modifier to ICMPv4 Code field with step 1 and count 10.\",\n  \"Subtask 7\": \"Create capture PDU patterns on Port_2 filtering for ICMPv4 Identifier=100 and SequenceNumber=200.\",\n  \"Subtask 8\": \"Configure capture filter on Port_2 using logical AND of both PDU patterns.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Set Port_1 transmission mode to BURST with burst count 100.\",\n  \"Subtask 11\": \"Start packet capture on Port_2.\",\n  \"Subtask 12\": \"Transmit traffic stream from Port_1.\",\n  \"Subtask 13\": \"Wait for 10 seconds during transmission and capture.\",\n  \"Subtask 14\": \"Stop traffic transmission.\",\n  \"Subtask 15\": \"Stop packet capture.\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 17\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames).\",\n  \"Subtask 18\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify that the test instrument accurately counts transmitted ICMPv4 echo reply packets.\n\nStep:\nStep 1: Reserve two loopback ports, Port_1 and Port_2.\nStep 2: Modify the ICMPv4 echo reply header in traffic stream StreamTemplate_1.\nStep 3: Configure filtered packet capture.\nStep 4: Subscribe to StreamBlockStats.\nStep 5: Set port transmission mode to burst.\nStep 6: Transmit all traffic and wait for a period.\nStep 7: Stop all traffic and check StreamBlockStats statistics.\n\nCriteria:\nExpected Result 1: In Step 6, transmitted and received packet counts for StreamTemplate_1 are equal.\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4EchoReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改Icmpv4EchoReply头部\n    header = edit_header_icmp_echo_reply(Stream=stream, Level=0, Type='2',\n                                Code='4', Identifier='100', SequenceNumber='200')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4EchoReply', Attribute=header['Code'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoReply_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoReply_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_echo_reply:修改测试仪表流量模板中Icmp Echo Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv2DataOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发L2TPv2 Data Over UDP报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的L2TPv2 Data Over UDP头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Purpose: Verify the test instrument correctly counts L2TPv2 Data Over UDP packet statistics\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test Step 2: Modify L2TPv2 Data Over UDP header content in traffic stream StreamTemplate_1;\n      Test Step 3: Configure filter-based packet capture;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Set port transmission mode to burst packet;\n      Test Step 6: Transmit all traffic and wait for a period;\n      Test Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: During Step 6, traffic stream StreamTemplate_1 shows equal TX/RX packet counts;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=272)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv2Data']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv2Data头部\n    header = edit_header_l2tpv2_data(Stream=stream, LengthOption=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Data', Attribute=header['LengthOption'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv2Data头部Sequence Number和Offset Padding节点\n    header_option = edit_header_l2tpv2_data_option(Stream=stream, Ns=1, Nr=2, Value='102030')\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Data', Attribute=header_option['Ns'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Data', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv2Data_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_l2tpv2_data:修改测试仪表流量模板中L2tpv2 Data报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length 272 bytes using add_stream API.\",\n  \"Subtask 4\": \"Build stream headers with EthernetII, IPv4, UDP, and l2tpv2Data layers using create_stream_header API.\",\n  \"Subtask 5\": \"Modify l2tpv2Data header LengthOption to value 2 using edit_header_l2tpv2_data API.\",\n  \"Subtask 6\": \"Configure increment modifier for l2tpv2Data LengthOption field with count 10 using edit_modifier API.\",\n  \"Subtask 7\": \"Modify l2tpv2Data header options: set Ns=1, Nr=2, Value='102030' using edit_header_l2tpv2_data_option API.\",\n  \"Subtask 8\": \"Configure increment modifiers for l2tpv2Data Ns field and Value field with count 10 each using edit_modifier API.\",\n  \"Subtask 9\": \"Create PDU capture pattern on second port filtering l2tpv2Data_1.type=1 using create_capture_pdu_pattern API.\",\n  \"Subtask 10\": \"Apply capture filter expression using created PDU pattern on second port via edit_capture_filter API.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 12\": \"Configure first port transmission mode as burst with count 100 using edit_port_load_profile API.\",\n  \"Subtask 13\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 14\": \"Start packet capture on second port using start_capture API.\",\n  \"Subtask 15\": \"Begin traffic transmission using start_stream API.\",\n  \"Subtask 16\": \"Wait 10 seconds for traffic transmission and statistics collection.\",\n  \"Subtask 17\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 18\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 19\": \"Download captured packets from second port to specified directory using download_packages API.\",\n  \"Subtask 20\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 21\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames).\",\n  \"Subtask 22\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Purpose: Verify the test instrument correctly counts L2TPv2 Data Over UDP packet statistics\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test Step 2: Modify L2TPv2 Data Over UDP header content in traffic stream StreamTemplate_1;\n      Test Step 3: Configure filter-based packet capture;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Set port transmission mode to burst packet;\n      Test Step 6: Transmit all traffic and wait for a period;\n      Test Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: During Step 6, traffic stream StreamTemplate_1 shows equal TX/RX packet counts;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=272)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv2Data']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv2Data头部\n    header = edit_header_l2tpv2_data(Stream=stream, LengthOption=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Data', Attribute=header['LengthOption'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv2Data头部Sequence Number和Offset Padding节点\n    header_option = edit_header_l2tpv2_data_option(Stream=stream, Ns=1, Nr=2, Value='102030')\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Data', Attribute=header_option['Ns'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Data', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv2Data_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_l2tpv2_data:修改测试仪表流量模板中L2tpv2 Data报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahEncapsulatedCustomerEthernet.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     :   Test Objective: Verify the accuracy of traffic transmission statistics on the test instrument\n\nStep          :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Create a traffic stream (StreamTemplate_1) on port Port_1;\n                 Step 3: Modify the 802.1ah header content of stream StreamTemplate_1;\n                 Step 4: Subscribe to StreamBlockStats statistics;\n                 Step 5: Transmit all traffic and wait for a specified duration;\n                 Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In Step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by    :   Tester-002\n\nBugs          :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['mac-in-mac', 'itag', 'encapCustomerEth'])\n\n    # 修改Encapsulated Customer Ethernet头部\n    attr = edit_header_8021ah_EncapsulatedCustomerEthernet(Stream=stream, Level=0,\n                                                           EtherType='ffff')\n    edit_modifier(Stream=stream, Attribute=attr['EtherType'],\n                  Type='Increment', Count=10, HeaderType='encapCustomerEth')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (e.g., 'DarYu') using init_tester.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_UP and Port_Down) using reserve_port with provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream (StreamTemplate_1) on Port_UP using add_stream.\",\n  \"Subtask 4\": \"Create the stream header for StreamTemplate_1 with header types ['mac-in-mac', 'itag', 'encapCustomerEth'] using create_stream_header.\",\n  \"Subtask 5\": \"Modify the EtherType field in the 802.1ah Encapsulated Customer Ethernet header of StreamTemplate_1 to a specific value (e.g., 'ffff') using edit_header_8021ah_EncapsulatedCustomerEthernet.\",\n  \"Subtask 6\": \"Set an increment modifier for the modified EtherType field with count=10 using edit_modifier.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics using subscribe_result.\",\n  \"Subtask 8\": \"Configure Port_UP transmit mode to BURST with specific BurstCount (e.g., 100) using edit_port_load_profile.\",\n  \"Subtask 9\": \"Save the current configuration to a file using save_case.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete using wait_stream_state, then wait an additional 3 seconds for statistics collection.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic and extract TxStreamFrames and RxStreamFrames values.\",\n  \"Subtask 13\": \"Verify that TxStreamFrames equals RxStreamFrames for StreamTemplate_1.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     :   Test Objective: Verify the accuracy of traffic transmission statistics on the test instrument\n\nStep          :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Create a traffic stream (StreamTemplate_1) on port Port_1;\n                 Step 3: Modify the 802.1ah header content of stream StreamTemplate_1;\n                 Step 4: Subscribe to StreamBlockStats statistics;\n                 Step 5: Transmit all traffic and wait for a specified duration;\n                 Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In Step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by    :   Tester-002\n\nBugs          :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['mac-in-mac', 'itag', 'encapCustomerEth'])\n\n    # 修改Encapsulated Customer Ethernet头部\n    attr = edit_header_8021ah_EncapsulatedCustomerEthernet(Stream=stream, Level=0,\n                                                           EtherType='ffff')\n    edit_modifier(Stream=stream, Attribute=attr['EtherType'],\n                  Type='Increment', Count=10, HeaderType='encapCustomerEth')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2LinkStateRequestInstance.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发OSPFv2 Link State Request Instance报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的OSPFv2 Link State Request Instance头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: To verify that the test instrument accurately counts transmitted OSPFv2 Link State Request Instance packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Modify OSPFv2 Link State Request Instance header content in traffic StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Transmit all traffic and wait for a duration;\nTest Step 7: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstaterequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 database description头部\n    header = edit_header_ospfv2_request(Stream=stream, Level=0,\n                                        RouterID='2.2.2.2', AuthType='MD5')\n    lsa = edit_header_ospfv2_lsa(Stream=stream, HeaderType='Ospfv2LinkStateRequest',\n                                 LsTypeWide=10,\n                                 LinkStateId='3.3.3.3',\n                                 AdvertisingRouter='4.4.4.4')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstaterequest',\n                  Attribute=lsa['LinkStateId'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2LinkStateRequest_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_lsa:修改测试仪表流量模板中OSPFv2报文中Lsa头部内容",
      "edit_header_ospfv2_request:修改测试仪表流量模板中OSPFv2 Link State Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester with the specified product platform.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) at given locations for testing.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure the stream headers: EthernetII, IPv4, and ospfv2linkstaterequest.\",\n  \"Subtask 5\": \"Edit the OSPFv2 Link State Request header fields: set Router ID to '2.2.2.2' and Authentication Type to 'MD5'.\",\n  \"Subtask 6\": \"Edit the OSPFv2 LSA header within the request: set LsTypeWide=10, LinkStateId='3.3.3.3', AdvertisingRouter='4.4.4.4'.\",\n  \"Subtask 7\": \"Configure an increment modifier for LinkStateId field: step=2 for 10 packets.\",\n  \"Subtask 8\": \"Create a PDU pattern on Port_2 to capture OSPFv2 packets with RouterID='2.2.2.2'.\",\n  \"Subtask 9\": \"Apply the created PDU pattern as a capture filter on Port_2.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 11\": \"Configure Port_1 transmission mode as burst with burst count=100.\",\n  \"Subtask 12\": \"Start packet capture on Port_2.\",\n  \"Subtask 13\": \"Start traffic transmission on Port_1.\",\n  \"Subtask 14\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission on Port_1.\",\n  \"Subtask 16\": \"Stop packet capture on Port_2.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats results for the created stream.\",\n  \"Subtask 18\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 19\": \"Release all reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: To verify that the test instrument accurately counts transmitted OSPFv2 Link State Request Instance packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Modify OSPFv2 Link State Request Instance header content in traffic StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Transmit all traffic and wait for a duration;\nTest Step 7: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstaterequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 database description头部\n    header = edit_header_ospfv2_request(Stream=stream, Level=0,\n                                        RouterID='2.2.2.2', AuthType='MD5')\n    lsa = edit_header_ospfv2_lsa(Stream=stream, HeaderType='Ospfv2LinkStateRequest',\n                                 LsTypeWide=10,\n                                 LinkStateId='3.3.3.3',\n                                 AdvertisingRouter='4.4.4.4')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstaterequest',\n                  Attribute=lsa['LinkStateId'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2LinkStateRequest_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_lsa:修改测试仪表流量模板中OSPFv2报文中Lsa头部内容;\nedit_header_ospfv2_request:修改测试仪表流量模板中OSPFv2 Link State Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4DestUnreach.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 dest unreach报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 dest unreach头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Verify the test instrument correctly counts transmitted ICMPv4 Destination Unreachable packets.\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Modify the ICMPv4 Destination Unreachable header content in traffic StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats collection;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Transmit all traffic and wait for a period;\nTest Step 7: Stop all traffic and examine StreamBlockStats information;\n\nCriteria: Expected Result 1: During Step 6, received packets for traffic StreamTemplate_1 equal sent packets;\n\nCreated by: Tester-004\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'DestUnreach']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 dest unreach头部\n    header = edit_header_icmp_dest_unreach(Stream=stream, Level=0, Unused='0',\n                                  Ipv4HeaderTosPrecedence='000', Ipv4HeaderTosDelay='0',\n                                  Ipv4HeaderTosThroughput='1', Ipv4HeaderTosReliability='0',\n                                  Ipv4HeaderTosMonetaryCost='0', Ipv4HeaderTosReserved='0',\n                                  Ipv4HeaderFlags='001', Ipv4HeaderOffset='0', Ipv4HeaderTTL='200',\n                                  Ipv4HeaderSource='10.1.1.2', Ipv4HeaderDestination='20.1.1.2',\n                                  Ipv4HeaderGateway='10.1.1.1', Ipv4HeaderHeaderOption='LooseSourceRoute')\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=header['Unused'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=header['Ipv4HeaderSource'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=header['Ipv4HeaderTosPrecedence'],\n                  Type='Increment', Count=5)\n\n    option = edit_header_ipv4_option(Stream=stream, Index=0, Option='LooseSourceRoute', Header='destunreach',\n                            Pointer=1, Optiontype=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=option['Pointer'],\n                  Type='Increment', Count=5)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destUnreach_1.headerData.ipv4Header.tos.tos.throughput',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destUnreach_1.headerData.ipv4Header.source',\n                                               Value='10.1.1.2',\n                                               MaxValue='10.1.1.2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destUnreach_1.headerData.ipv4Header.destination',\n                                               Value='20.1.1.2 ',\n                                               MaxValue='20.1.1.2 ')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容",
      "edit_header_icmp_dest_unreach:修改测试仪表流量模板中Icmp Dest Unreach报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with product specification 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve two loopback ports at specified locations using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers for EthernetII, IPv4, and ICMPv4 Destination Unreachable using create_stream_header API.\",\n  \"Subtask 5\": \"Modify ICMPv4 Destination Unreachable header fields (Level, Unused, ToS, Flags, TTL, Source, Destination, Gateway) using edit_header_icmp_dest_unreach API.\",\n  \"Subtask 6\": \"Apply increment modifiers to Unused field, IPv4 Source field, and ToS Precedence field in Destination Unreachable header using edit_modifier API.\",\n  \"Subtask 7\": \"Configure IPv4 Loose Source Route option in Destination Unreachable header and apply increment modifier to Pointer field using edit_header_ipv4_option and edit_modifier APIs.\",\n  \"Subtask 8\": \"Create three PDU capture patterns on Port_2 filtering for: throughput=1, source=10.1.1.2, destination=20.1.1.2 using create_capture_pdu_pattern API.\",\n  \"Subtask 9\": \"Set packet capture filter on Port_2 using logical AND expression combining all three PDU patterns via edit_capture_filter API.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats collection using subscribe_result API.\",\n  \"Subtask 11\": \"Configure Port_1 transmission mode as burst with count=100 using edit_port_load_profile API.\",\n  \"Subtask 12\": \"Start packet capture on Port_2 using start_capture API.\",\n  \"Subtask 13\": \"Transmit traffic from Port_1 using start_stream API and wait 10 seconds.\",\n  \"Subtask 14\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 15\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats and extract TxStreamFrames and RxStreamFrames values using get_streamblock_statistic API.\",\n  \"Subtask 17\": \"Verify TxStreamFrames exactly equals RxStreamFrames as validation criteria.\",\n  \"Subtask 18\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Verify the test instrument correctly counts transmitted ICMPv4 Destination Unreachable packets.\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Modify the ICMPv4 Destination Unreachable header content in traffic StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats collection;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Transmit all traffic and wait for a period;\nTest Step 7: Stop all traffic and examine StreamBlockStats information;\n\nCriteria: Expected Result 1: During Step 6, received packets for traffic StreamTemplate_1 equal sent packets;\n\nCreated by: Tester-004\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'DestUnreach']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 dest unreach头部\n    header = edit_header_icmp_dest_unreach(Stream=stream, Level=0, Unused='0',\n                                  Ipv4HeaderTosPrecedence='000', Ipv4HeaderTosDelay='0',\n                                  Ipv4HeaderTosThroughput='1', Ipv4HeaderTosReliability='0',\n                                  Ipv4HeaderTosMonetaryCost='0', Ipv4HeaderTosReserved='0',\n                                  Ipv4HeaderFlags='001', Ipv4HeaderOffset='0', Ipv4HeaderTTL='200',\n                                  Ipv4HeaderSource='10.1.1.2', Ipv4HeaderDestination='20.1.1.2',\n                                  Ipv4HeaderGateway='10.1.1.1', Ipv4HeaderHeaderOption='LooseSourceRoute')\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=header['Unused'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=header['Ipv4HeaderSource'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=header['Ipv4HeaderTosPrecedence'],\n                  Type='Increment', Count=5)\n\n    option = edit_header_ipv4_option(Stream=stream, Index=0, Option='LooseSourceRoute', Header='destunreach',\n                            Pointer=1, Optiontype=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='DestUnreach', Attribute=option['Pointer'],\n                  Type='Increment', Count=5)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destUnreach_1.headerData.ipv4Header.tos.tos.throughput',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destUnreach_1.headerData.ipv4Header.source',\n                                               Value='10.1.1.2',\n                                               MaxValue='10.1.1.2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destUnreach_1.headerData.ipv4Header.destination',\n                                               Value='20.1.1.2 ',\n                                               MaxValue='20.1.1.2 ')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容;\nedit_header_icmp_dest_unreach:修改测试仪表流量模板中Icmp Dest Unreach报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv3Query.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发IGMPv3_Query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的IGMPv3_Query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective    :   Test Objective: Verify that the test instrument correctly counts sent IGMPv3_Query packets\n\nStep         :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                 Test Step 2: Modify IGMPv3_Query header content in traffic StreamTemplate_1;\n                 Test Step 3: Configure filtered packet capture;\n                 Test Step 4: Subscribe to StreamBlockStats statistics;\n                 Test Step 5: Set port transmission mode to burst mode;\n                 Test Step 6: Send all traffic and wait for a period;\n                 Test Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In Step 6, sent and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv3query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    header = edit_header_igmpv3_query(Stream=stream, Level=0,\n                                      Type=99,MaxResponseTime=255,\n                                      Checksum='ffff',GroupAddress='10.1.1.1',\n                                      SuppressFlag=1,Qrv='111',Qqic=255,NumberOfSources=65535,\n                                      SourceAddressList=['1.1.1.1', '2.2.2.2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3query', Attribute=header['SourceAddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Query_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Query_1.MaxResponseTime',\n                                               Value='255',\n                                               MaxValue='255')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Query_1.groupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv3_query:修改测试仪表流量模板中IGMPv3 Query报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (e.g., DarYu) using the init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) at given locations using the reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with a fixed frame length of 256 bytes using the add_stream API.\",\n  \"Subtask 4\": \"Configure the stream headers to include EthernetII, IPv4, and IGMPv3 Query layers using the create_stream_header API.\",\n  \"Subtask 5\": \"Modify the IGMPv3 Query header fields (Type, MaxResponseTime, Checksum, GroupAddress, SuppressFlag, Qrv, Qqic, NumberOfSources, SourceAddressList) using the edit_header_igmpv3_query API.\",\n  \"Subtask 6\": \"Configure an increment modifier for the 'SourceAddressList: 2.2.2.2' field in the IGMPv3 Query header with count=10 using the edit_modifier API.\",\n  \"Subtask 7\": \"Create three PDU patterns on Port_2 to filter IGMPv3 Query packets by specific fields (type=99, MaxResponseTime=255, groupAddress='10.1.1.1') using the create_capture_pdu_pattern API.\",\n  \"Subtask 8\": \"Apply a packet capture filter on Port_2 combining all three PDU patterns with logical AND using the edit_capture_filter API.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view using the subscribe_result API.\",\n  \"Subtask 10\": \"Configure Port_1 transmission mode to burst mode with burst count=100 using the edit_port_load_profile API.\",\n  \"Subtask 11\": \"Start packet capture on Port_2 using the start_capture API.\",\n  \"Subtask 12\": \"Start traffic transmission on Port_1 using the start_stream API.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission and capture.\",\n  \"Subtask 14\": \"Stop traffic transmission on Port_1 using the stop_stream API.\",\n  \"Subtask 15\": \"Stop packet capture on Port_2 using the stop_capture API.\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats for the stream and extract TxStreamFrames and RxStreamFrames values using the get_streamblock_statistic API.\",\n  \"Subtask 17\": \"Verify that TxStreamFrames equals RxStreamFrames as per test criteria.\",\n  \"Subtask 18\": \"Release all reserved ports using the release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective    :   Test Objective: Verify that the test instrument correctly counts sent IGMPv3_Query packets\n\nStep         :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                 Test Step 2: Modify IGMPv3_Query header content in traffic StreamTemplate_1;\n                 Test Step 3: Configure filtered packet capture;\n                 Test Step 4: Subscribe to StreamBlockStats statistics;\n                 Test Step 5: Set port transmission mode to burst mode;\n                 Test Step 6: Send all traffic and wait for a period;\n                 Test Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In Step 6, sent and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv3query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    header = edit_header_igmpv3_query(Stream=stream, Level=0,\n                                      Type=99,MaxResponseTime=255,\n                                      Checksum='ffff',GroupAddress='10.1.1.1',\n                                      SuppressFlag=1,Qrv='111',Qqic=255,NumberOfSources=65535,\n                                      SourceAddressList=['1.1.1.1', '2.2.2.2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3query', Attribute=header['SourceAddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Query_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Query_1.MaxResponseTime',\n                                               Value='255',\n                                               MaxValue='255')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Query_1.groupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv3_query:修改测试仪表流量模板中IGMPv3 Query报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2TPv3DataOverIp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Data Over Ip头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify the accuracy of the test instrument's traffic transmission statistics\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream, StreamTemplate_1, on port Port_1;\n      Step 3: Modify the L2TPv3 Data Over IP header content of StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a duration;\n      Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-003\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3DataOverIp'])\n\n    # 修改icmpv4 echo reply头部\n    edit_header_l2tpv3_data_over_ip(Stream=stream, Level=0,\n                                    SessionId=1,\n                                    Cookie4Byte='00000001',\n                                    L2specificsublayer={'xbit': 1, 'sbit': 1, 'xbits': '000001', 'sequence': 1},)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3DataOverIp'],\n                                             FieldName='l2tpv3DataOverIp_1.sessionId',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports using provided locations and assign as Port_UP (transmit port) and Port_Down (receive port).\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP with fixed frame length of 512 bytes.\",\n  \"Subtask 4\": \"Configure stream headers with EthernetII, IPv4, and L2TPv3 Data Over IP protocol stack.\",\n  \"Subtask 5\": \"Modify L2TPv3 header parameters: set SessionId=1, Cookie4Byte='00000001', and specific L2 sublayer settings (xbit=1, sbit=1, xbits='000001', sequence=1).\",\n  \"Subtask 6\": \"Create PDU capture pattern on Port_Down to filter L2TPv3 packets with sessionId=1.\",\n  \"Subtask 7\": \"Apply capture filter expression to Port_Down using the created PDU pattern.\",\n  \"Subtask 8\": \"Subscribe to PortStats and StreamBlockStats statistics views.\",\n  \"Subtask 9\": \"Configure Port_UP transmit mode as burst with burst count set to 100 packets.\",\n  \"Subtask 10\": \"Save test configuration to specified file path.\",\n  \"Subtask 11\": \"Start packet capture on Port_Down.\",\n  \"Subtask 12\": \"Initiate traffic transmission from Port_UP.\",\n  \"Subtask 13\": \"Wait for traffic transmission to complete automatically after sending burst count packets.\",\n  \"Subtask 14\": \"Stop packet capture on Port_Down.\",\n  \"Subtask 15\": \"Wait 3 seconds to ensure statistics stabilization before collection.\",\n  \"Subtask 16\": \"Download captured packets from Port_Down to local storage.\",\n  \"Subtask 17\": \"Retrieve and validate capture information: verify captured/downloaded packet counts equal burst count (100).\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats for the stream and validate TxStreamFrames equals RxStreamFrames equals burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify the accuracy of the test instrument's traffic transmission statistics\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream, StreamTemplate_1, on port Port_1;\n      Step 3: Modify the L2TPv3 Data Over IP header content of StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a duration;\n      Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-003\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3DataOverIp'])\n\n    # 修改icmpv4 echo reply头部\n    edit_header_l2tpv3_data_over_ip(Stream=stream, Level=0,\n                                    SessionId=1,\n                                    Cookie4Byte='00000001',\n                                    L2specificsublayer={'xbit': 1, 'sbit': 1, 'xbits': '000001', 'sequence': 1},)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3DataOverIp'],\n                                             FieldName='l2tpv3DataOverIp_1.sessionId',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv1Query.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发IGMPv1_Query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的IGMPv1_Query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify the test instrument correctly counts IGMPv1_Query packets  \n\nStep:  \nTest Step 1: Reserve two loopback ports: Port_1, Port_2  \nTest Step 2: Modify the IGMPv1_Query header content in traffic stream StreamTemplate_1  \nTest Step 3: Configure packet capture filtering  \nTest Step 4: Subscribe to StreamBlockStats counters  \nTest Step 5: Set port transmission mode to burst  \nTest Step 6: Transmit all traffic and wait  \nTest Step 7: Stop all traffic and check StreamBlockStats counters  \n\nCriteria:  \nExpected Result 1: In Step 6, StreamTemplate_1 transmitted/received packet counts match  \n\nCreated by: Tester-004  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IGMPv1Query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    header = edit_header_igmpv1_query(Stream=stream, Level=0, Type=99, Unused=255, Checksum='ffff',\n                             GroupAddress='10.1.1.1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IGMPv1Query', Attribute=header['GroupAddress'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1Query_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1Query_1.unused',\n                                               Value='255',\n                                               MaxValue='255')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv1_query:修改测试仪表流量模板中IGMPv1 Query报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (e.g., 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at given locations (e.g., '//10.0.11.191/1/5' and '//10.0.11.191/1/6') using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Define stream headers for EthernetII, IPv4, and IGMPv1Query layers using create_stream_header API.\",\n  \"Subtask 5\": \"Modify IGMPv1 Query header fields: Type=99, Unused=255, Checksum='ffff', GroupAddress='10.1.1.1' using edit_header_igmpv1_query API.\",\n  \"Subtask 6\": \"Configure modifier for GroupAddress field with increment type and count=10 using edit_modifier API.\",\n  \"Subtask 7\": \"Create two PDU patterns on the second port: 1) IGMPv1 Query type=99, 2) IGMPv1 Query unused=255 using create_capture_pdu_pattern API.\",\n  \"Subtask 8\": \"Apply capture filter with logical AND expression combining both PDU patterns using edit_capture_filter API.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats counter view using subscribe_result API.\",\n  \"Subtask 10\": \"Configure first port's transmission mode to BURST with burst count=100 using edit_port_load_profile API.\",\n  \"Subtask 11\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 12\": \"Start packet capture on second port using start_capture API.\",\n  \"Subtask 13\": \"Initiate traffic transmission using start_stream API.\",\n  \"Subtask 14\": \"Wait 10 seconds for traffic transmission and capture.\",\n  \"Subtask 15\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 16\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats counters using get_streamblock_statistic API.\",\n  \"Subtask 18\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 19\": \"Download captured packets from second port for analysis using download_packages API.\",\n  \"Subtask 20\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify the test instrument correctly counts IGMPv1_Query packets  \n\nStep:  \nTest Step 1: Reserve two loopback ports: Port_1, Port_2  \nTest Step 2: Modify the IGMPv1_Query header content in traffic stream StreamTemplate_1  \nTest Step 3: Configure packet capture filtering  \nTest Step 4: Subscribe to StreamBlockStats counters  \nTest Step 5: Set port transmission mode to burst  \nTest Step 6: Transmit all traffic and wait  \nTest Step 7: Stop all traffic and check StreamBlockStats counters  \n\nCriteria:  \nExpected Result 1: In Step 6, StreamTemplate_1 transmitted/received packet counts match  \n\nCreated by: Tester-004  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IGMPv1Query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    header = edit_header_igmpv1_query(Stream=stream, Level=0, Type=99, Unused=255, Checksum='ffff',\n                             GroupAddress='10.1.1.1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IGMPv1Query', Attribute=header['GroupAddress'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1Query_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1Query_1.unused',\n                                               Value='255',\n                                               MaxValue='255')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv1_query:修改测试仪表流量模板中IGMPv1 Query报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/LldpChassisId.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的lldp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify the accuracy of the test instrument's flow transmission statistics\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a flow StreamTemplate_1 on port Port_1;\n      Step 3: Modify the LLDP header content of flow StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and check StreamBlockStats information;\n\nCriteria: Expected Result 1: In Step 6, the number of packets sent and received for StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'chassisidtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_chassis_id_tlv(Stream=stream, Level=0, ChassisId='1.1.1.1')\n    edit_modifier(Stream=stream, Attribute=attr['ChassisId'],\n                  Type='Increment', Count=10, HeaderType='chassisidtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for the specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) on the test instrument using their physical locations.\",\n  \"Subtask 3\": \"Create a traffic stream (StreamTemplate_1) on Port_1 and configure its frame length parameters.\",\n  \"Subtask 4\": \"Add Ethernet II and LLDP Chassis ID TLV headers to StreamTemplate_1.\",\n  \"Subtask 5\": \"Modify the LLDP header content of StreamTemplate_1 by setting the Chassis ID field and configuring an increment modifier for this field.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats statistics collection for performance monitoring.\",\n  \"Subtask 7\": \"Configure Port_1's transmission parameters to burst mode with a specific packet count.\",\n  \"Subtask 8\": \"Start traffic transmission for all configured streams.\",\n  \"Subtask 9\": \"Wait until traffic transmission completes and the streams enter idle state.\",\n  \"Subtask 10\": \"Pause for 3 seconds after traffic stops to ensure complete statistics collection.\",\n  \"Subtask 11\": \"Retrieve StreamBlockStats results for StreamTemplate_1.\",\n  \"Subtask 12\": \"Verify that transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames) for StreamTemplate_1.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify the accuracy of the test instrument's flow transmission statistics\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a flow StreamTemplate_1 on port Port_1;\n      Step 3: Modify the LLDP header content of flow StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and check StreamBlockStats information;\n\nCriteria: Expected Result 1: In Step 6, the number of packets sent and received for StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'chassisidtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_chassis_id_tlv(Stream=stream, Level=0, ChassisId='1.1.1.1')\n    edit_modifier(Stream=stream, Attribute=attr['ChassisId'],\n                  Type='Increment', Count=10, HeaderType='chassisidtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4ParameterProblem.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 parameter problem报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 parameter problem头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Verify the test instrument accurately counts received ICMPv4 Parameter Problem packets  \n\nStep:  \nTest Step 1: Reserve two loopback ports: Port_1, Port_2  \nTest Step 2: Modify the ICMPv4 Parameter Problem header content in traffic StreamTemplate_1  \nTest Step 3: Configure packet capture filtering  \nTest Step 4: Subscribe to StreamBlockStats statistics  \nTest Step 5: Set port transmission mode to burst packets  \nTest Step 6: Transmit all traffic and wait  \nTest Step 7: Stop all traffic and check StreamBlockStats information  \n\nCriteria:  \nExpected Result 1: Sent and received packets for StreamTemplate_1 are equal during Step 6  \n\nCreated by: Tester-004  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4ParameterProblem']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 parameter problem头部\n    header = edit_header_icmp_parameter_problem(Stream=stream, Level=0, Pointer='1',\n                                       Ipv4HeaderFlags='111',\n                                       Ipv4HeaderSource='10.1.1.2',\n                                       Ipv4HeaderDestination='11.1.1.2',\n                                       Data='0000000000000001',\n                                       Ipv4HeaderDiffserveCodePointPrecedence='101010')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4ParameterProblem', Attribute=header['Data'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4ParameterProblem', Attribute=header['Ipv4HeaderDiffserveCodePointPrecedence'],\n                  Type='Increment', Count=5)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4ParameterProblem_1.pointer',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4ParameterProblem_1.headerData.ipv4Header.flags',\n                                               Value='111',\n                                               MaxValue='111')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4ParameterProblem_1.headerData.ipv4Header.destination',\n                                               Value='11.1.1.2',\n                                               MaxValue='11.1.1.2')\n    # pdu_pattern_4 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='Icmpv4ParameterProblem_1.headerData.data',\n    #                                            Value='0000000000000001',\n    #                                            MaxValue='0000000000000001')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_parameter_problem:修改测试仪表流量模板中Icmp Parameter Problem报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (DarYu).\",\n  \"Subtask 2\": \"Reserve two ports using the provided locations and assign them as Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with automatic frame length detection.\",\n  \"Subtask 4\": \"Configure the stream header to include EthernetII, IPv4, and ICMPv4 Parameter Problem headers.\",\n  \"Subtask 5\": \"Modify the ICMPv4 Parameter Problem header with specific attributes: Pointer=1, Flags=111, Source=10.1.1.2, Destination=11.1.1.2, Data=0000000000000001, Diffserv=101010.\",\n  \"Subtask 6\": \"Apply increment modifiers to the Data field (count=10) and Diffserv field (count=5) in the ICMPv4 header.\",\n  \"Subtask 7\": \"Create three PDU patterns on Port_2 to filter packets based on ICMP pointer=1, IPv4 flags=111, and IPv4 destination=11.1.1.2.\",\n  \"Subtask 8\": \"Set capture filter on Port_2 using a logical AND combination of the three PDU patterns.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Configure Port_1 transmission mode as burst with burst count=100.\",\n  \"Subtask 11\": \"Save the test configuration to a file.\",\n  \"Subtask 12\": \"Start packet capture on Port_2.\",\n  \"Subtask 13\": \"Start traffic transmission on Port_1.\",\n  \"Subtask 14\": \"Wait 10 seconds during traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission on Port_1.\",\n  \"Subtask 16\": \"Stop packet capture on Port_2.\",\n  \"Subtask 17\": \"Download captured packets from Port_2 to a local directory.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats results for the transmitted stream.\",\n  \"Subtask 19\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 20\": \"Release both reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Verify the test instrument accurately counts received ICMPv4 Parameter Problem packets  \n\nStep:  \nTest Step 1: Reserve two loopback ports: Port_1, Port_2  \nTest Step 2: Modify the ICMPv4 Parameter Problem header content in traffic StreamTemplate_1  \nTest Step 3: Configure packet capture filtering  \nTest Step 4: Subscribe to StreamBlockStats statistics  \nTest Step 5: Set port transmission mode to burst packets  \nTest Step 6: Transmit all traffic and wait  \nTest Step 7: Stop all traffic and check StreamBlockStats information  \n\nCriteria:  \nExpected Result 1: Sent and received packets for StreamTemplate_1 are equal during Step 6  \n\nCreated by: Tester-004  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4ParameterProblem']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 parameter problem头部\n    header = edit_header_icmp_parameter_problem(Stream=stream, Level=0, Pointer='1',\n                                       Ipv4HeaderFlags='111',\n                                       Ipv4HeaderSource='10.1.1.2',\n                                       Ipv4HeaderDestination='11.1.1.2',\n                                       Data='0000000000000001',\n                                       Ipv4HeaderDiffserveCodePointPrecedence='101010')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4ParameterProblem', Attribute=header['Data'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4ParameterProblem', Attribute=header['Ipv4HeaderDiffserveCodePointPrecedence'],\n                  Type='Increment', Count=5)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4ParameterProblem_1.pointer',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4ParameterProblem_1.headerData.ipv4Header.flags',\n                                               Value='111',\n                                               MaxValue='111')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4ParameterProblem_1.headerData.ipv4Header.destination',\n                                               Value='11.1.1.2',\n                                               MaxValue='11.1.1.2')\n    # pdu_pattern_4 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='Icmpv4ParameterProblem_1.headerData.data',\n    #                                            Value='0000000000000001',\n    #                                            MaxValue='0000000000000001')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_parameter_problem:修改测试仪表流量模板中Icmp Parameter Problem报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ripng.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发Ripng报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的Ripng头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective        : Verify the test instrument accurately counts transmitted and received Ripng packets\n\nStep             : Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Modify the Ripng header of traffic StreamTemplate_1;;\n                   Test Step 3: Configure packet capture filtering;\n                   Test Step 4: Subscribe to StreamBlockStats;;\n                   Test Step 5: Set port transmission mode to burst;\n                   Test Step 6: Transmit all traffic and wait for a duration;\n                   Test Step 7: Stop all traffic and inspect StreamBlockStats statistics;;\n\nCriteria         : Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by       : Tester-001\n\nBugs             : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripng']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripng(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripng', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripng_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripng_entry(Stream=stream, Level=0, Index=0, Ipaddr='2001::1:f1:22', RouteTag=1, PrefixLen=1, Metric=1)\n    edit_header_ripng_entry(Stream=stream, Level=0, Index=1, Ipaddr='2001::1:f1:33', RouteTag=2, PrefixLen=2, Metric=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform and reserve two ports at the specified locations.\",\n  \"Subtask 2\": \"Create a traffic stream on the first reserved port with a fixed frame length of 256 bytes.\",\n  \"Subtask 3\": \"Configure the stream headers to include EthernetII, IPv4, and Ripng protocol layers.\",\n  \"Subtask 4\": \"Modify the Ripng header at level 0: set Command=2, Version=1, Reserved=2.\",\n  \"Subtask 5\": \"Apply increment modifier to the Reserved field in Ripng header with count=3.\",\n  \"Subtask 6\": \"Insert two Ripng entries into the stream header at level 0.\",\n  \"Subtask 7\": \"Edit first Ripng entry (index=0): set Ipaddr='2001::1:f1:22', RouteTag=1, PrefixLen=1, Metric=1.\",\n  \"Subtask 8\": \"Edit second Ripng entry (index=1): set Ipaddr='2001::1:f1:33', RouteTag=2, PrefixLen=2, Metric=2.\",\n  \"Subtask 9\": \"Create two PDU patterns on the second port for Ripng header fields: Reserved (value=1-2) and Version (value=1).\",\n  \"Subtask 10\": \"Configure packet capture filter on the second port using logical AND combination of both PDU patterns.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats view for statistics monitoring.\",\n  \"Subtask 12\": \"Configure the first port's transmission mode as burst with burst count=100.\",\n  \"Subtask 13\": \"Save the current test configuration to a specified file path.\",\n  \"Subtask 14\": \"Start packet capture on the second port.\",\n  \"Subtask 15\": \"Initiate traffic transmission from the first port.\",\n  \"Subtask 16\": \"Maintain traffic transmission for 10 seconds duration.\",\n  \"Subtask 17\": \"Terminate traffic transmission from the first port.\",\n  \"Subtask 18\": \"Stop packet capture on the second port.\",\n  \"Subtask 19\": \"Download captured packets from the second port to local storage.\",\n  \"Subtask 20\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 21\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 22\": \"Release all reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective        : Verify the test instrument accurately counts transmitted and received Ripng packets\n\nStep             : Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Modify the Ripng header of traffic StreamTemplate_1;;\n                   Test Step 3: Configure packet capture filtering;\n                   Test Step 4: Subscribe to StreamBlockStats;;\n                   Test Step 5: Set port transmission mode to burst;\n                   Test Step 6: Transmit all traffic and wait for a duration;\n                   Test Step 7: Stop all traffic and inspect StreamBlockStats statistics;;\n\nCriteria         : Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by       : Tester-001\n\nBugs             : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripng']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripng(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripng', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripng_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripng_entry(Stream=stream, Level=0, Index=0, Ipaddr='2001::1:f1:22', RouteTag=1, PrefixLen=1, Metric=1)\n    edit_header_ripng_entry(Stream=stream, Level=0, Index=1, Ipaddr='2001::1:f1:33', RouteTag=2, PrefixLen=2, Metric=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/FibreChannel.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的fc头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: To verify the accuracy of flow statistics transmission from the test instrument  \nSteps:  \n1. Reserve two loopback ports: Port_1 and Port_2  \n2. Create a traffic stream StreamTemplate_1 on Port_1  \n3. Modify the FC header content of stream StreamTemplate_1  \n4. Subscribe to StreamBlockStats statistics  \n5. Transmit all traffic and wait for a duration  \n6. Stop all traffic and examine StreamBlockStats statistics  \nExpected Results:  \n1. In step 6, sent and received packets for StreamTemplate_1 are equal  \nCreated by: Tester-002  \nDefects: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['fc', 'elsflogi'])\n\n    # 修改fc头部\n    attr = edit_header_fibre_channel(Stream=stream, Level=0,\n                                     DestAddr='102030')\n    edit_modifier(Stream=stream, Attribute=attr['DestAddr'],\n                  Type='Increment', Count=10, HeaderType='fc')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester function with specified product parameter.\",\n  \"Subtask 2\": \"Reserve two ports using reserve_port function with provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port using add_stream function.\",\n  \"Subtask 4\": \"Edit stream parameters to set frame length type to AUTO using edit_stream function.\",\n  \"Subtask 5\": \"Create FC and ELSFLOGI headers for the stream using create_stream_header function.\",\n  \"Subtask 6\": \"Modify FC header destination address using edit_header_fibre_channel function.\",\n  \"Subtask 7\": \"Apply increment modifier to destination address field using edit_modifier function with count=10.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics using subscribe_result function.\",\n  \"Subtask 9\": \"Configure port load profile to burst mode with burst count=100 using edit_port_load_profile function.\",\n  \"Subtask 10\": \"Save test configuration to file using save_case function.\",\n  \"Subtask 11\": \"Start traffic transmission using start_stream function.\",\n  \"Subtask 12\": \"Wait for traffic transmission to complete using wait_stream_state function.\",\n  \"Subtask 13\": \"Wait 3 seconds to ensure proper statistics collection.\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats using get_streamblock_statistic function for the stream.\",\n  \"Subtask 15\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: To verify the accuracy of flow statistics transmission from the test instrument  \nSteps:  \n1. Reserve two loopback ports: Port_1 and Port_2  \n2. Create a traffic stream StreamTemplate_1 on Port_1  \n3. Modify the FC header content of stream StreamTemplate_1  \n4. Subscribe to StreamBlockStats statistics  \n5. Transmit all traffic and wait for a duration  \n6. Stop all traffic and examine StreamBlockStats statistics  \nExpected Results:  \n1. In step 6, sent and received packets for StreamTemplate_1 are equal  \nCreated by: Tester-002  \nDefects: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['fc', 'elsflogi'])\n\n    # 修改fc头部\n    attr = edit_header_fibre_channel(Stream=stream, Level=0,\n                                     DestAddr='102030')\n    edit_modifier(Stream=stream, Attribute=attr['DestAddr'],\n                  Type='Increment', Count=10, HeaderType='fc')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ppp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ppp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ppp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify that the test instrument accurately counts transmitted PPP packets\n\nStep: Test step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test step 2: Modify the PPP header content of traffic stream StreamTemplate_1;\n      Test step 3: Configure filter and packet capture;\n      Test step 4: Subscribe to StreamBlockStats;\n      Test step 5: Set port transmission mode to burst;\n      Test step 6: Transmit all traffic and wait for a period;\n      Test step 7: Stop all traffic and check StreamBlockStats information;\n\nCriteria: Expected result 1: For traffic stream StreamTemplate_1 in step 6, transmitted and received packet counts match;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ppp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ppp头部\n    header_dict = edit_header_ppp(Stream=stream, Level=0, Protocol='0001', Controls='11', Addresses='22')\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='ppp', Attribute=header_dict['Protocol'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=1,\n                                               Attribute=header_dict['Protocol'],\n                                               Value='0001', MaxValue='000A')\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ppp_1.protocol',\n    #                                            Value='0001', MaxValue='0001')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ppp:修改测试仪表流量模板中PPP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester function with specified product parameter.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) at given locations using reserve_port function.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 using add_stream function with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Create stream headers for EthernetII and PPP using create_stream_header function.\",\n  \"Subtask 5\": \"Modify PPP header attributes (Protocol='0001', Controls='11', Addresses='22') using edit_header_ppp function.\",\n  \"Subtask 6\": \"Configure modifier for PPP Protocol field to increment from '0001' to '000A' using edit_modifier function.\",\n  \"Subtask 7\": \"Create PDU pattern on Port_2 to capture PPP packets with Protocol range '0001'-'000A' using create_capture_pdu_pattern function.\",\n  \"Subtask 8\": \"Apply capture filter expression on Port_2 using edit_capture_filter function.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats view using subscribe_result function.\",\n  \"Subtask 10\": \"Configure Port_1 transmission mode to BURST with count=100 using edit_port_load_profile function.\",\n  \"Subtask 11\": \"Save test configuration using save_case function.\",\n  \"Subtask 12\": \"Start packet capture on Port_2 using start_capture function.\",\n  \"Subtask 13\": \"Start traffic transmission using start_stream function.\",\n  \"Subtask 14\": \"Wait for 10 seconds to allow traffic transmission and capture.\",\n  \"Subtask 15\": \"Stop traffic transmission using stop_stream function.\",\n  \"Subtask 16\": \"Stop packet capture using stop_capture function.\",\n  \"Subtask 17\": \"Download captured packets from Port_2 using download_packages function.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats using get_streamblock_statistic function and extract TxStreamFrames/RxStreamFrames values.\",\n  \"Subtask 19\": \"Verify TxStreamFrames equals RxStreamFrames for the transmitted stream.\",\n  \"Subtask 20\": \"Release reserved ports using release_port function.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify that the test instrument accurately counts transmitted PPP packets\n\nStep: Test step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test step 2: Modify the PPP header content of traffic stream StreamTemplate_1;\n      Test step 3: Configure filter and packet capture;\n      Test step 4: Subscribe to StreamBlockStats;\n      Test step 5: Set port transmission mode to burst;\n      Test step 6: Transmit all traffic and wait for a period;\n      Test step 7: Stop all traffic and check StreamBlockStats information;\n\nCriteria: Expected result 1: For traffic stream StreamTemplate_1 in step 6, transmitted and received packet counts match;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ppp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ppp头部\n    header_dict = edit_header_ppp(Stream=stream, Level=0, Protocol='0001', Controls='11', Addresses='22')\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='ppp', Attribute=header_dict['Protocol'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=1,\n                                               Attribute=header_dict['Protocol'],\n                                               Value='0001', MaxValue='000A')\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ppp_1.protocol',\n    #                                            Value='0001', MaxValue='0001')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ppp:修改测试仪表流量模板中PPP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Gre.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的GRE头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Verify correct traffic statistics on the test instrument  \n\nStep:  \nTest Step 1: Reserve two loopback ports Port_1 and Port_2;  \nTest Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;  \nTest Step 3: Modify the GRE header content of stream StreamTemplate_1;  \nTest Step 4: Subscribe to StreamBlockStats;  \nTest Step 5: Transmit all traffic and wait for a period;  \nTest Step 6: Stop all traffic and check StreamBlockStats information;  \n\nCriteria:  \nExpected Result 1: In Step 6, received and transmitted packets for stream StreamTemplate_1 are equal;  \n\nCreated by: Tester-003  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'gre'])\n\n    # 修改gre头部\n    edit_header_gre(Stream=stream, Level=0,\n                    ChecksumPresent=1,\n                    Routing=1,\n                    Protocol=6558,\n                    Checksum=123,\n                    ChecksumReserved=123,\n                    SequenceNumber=2,\n                    Key=1)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'gre'],\n                                             FieldName='gre_1.routing',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_gre:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (e.g., 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports using provided locations through reserve_port API, assigning them as Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers to include EthernetII, IPv4, and GRE layers using create_stream_header API.\",\n  \"Subtask 5\": \"Modify GRE header parameters (ChecksumPresent, Routing, Protocol, etc.) for the stream using edit_header_gre API.\",\n  \"Subtask 6\": \"Create PDU pattern for capture on Port_Down filtering GRE routing field value=1 using create_capture_pdu_pattern API.\",\n  \"Subtask 7\": \"Apply capture filter to Port_Down using the created PDU pattern via edit_capture_filter API.\",\n  \"Subtask 8\": \"Subscribe to PortStats and StreamBlockStats statistical views using subscribe_result API.\",\n  \"Subtask 9\": \"Configure Port_UP load profile to burst mode with specific burst count (e.g., 100) using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Save current configuration to file using save_case API.\",\n  \"Subtask 11\": \"Start packet capture on Port_Down using start_capture API.\",\n  \"Subtask 12\": \"Begin traffic transmission using start_stream API.\",\n  \"Subtask 13\": \"Wait for stream transmission to complete using wait_stream_state API.\",\n  \"Subtask 14\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 15\": \"Wait 3 seconds to ensure statistics stabilization.\",\n  \"Subtask 16\": \"Download captured packets from Port_Down using download_packages API.\",\n  \"Subtask 17\": \"Retrieve capture info from Port_Down using get_capture_info API and verify captured/downloaded packets match burst count.\",\n  \"Subtask 18\": \"Obtain StreamBlockStats for the stream using get_streamblock_statistic API and verify TxStreamFrames equals RxStreamFrames equals burst count.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Verify correct traffic statistics on the test instrument  \n\nStep:  \nTest Step 1: Reserve two loopback ports Port_1 and Port_2;  \nTest Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;  \nTest Step 3: Modify the GRE header content of stream StreamTemplate_1;  \nTest Step 4: Subscribe to StreamBlockStats;  \nTest Step 5: Transmit all traffic and wait for a period;  \nTest Step 6: Stop all traffic and check StreamBlockStats information;  \n\nCriteria:  \nExpected Result 1: In Step 6, received and transmitted packets for stream StreamTemplate_1 are equal;  \n\nCreated by: Tester-003  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'gre'])\n\n    # 修改gre头部\n    edit_header_gre(Stream=stream, Level=0,\n                    ChecksumPresent=1,\n                    Routing=1,\n                    Protocol=6558,\n                    Checksum=123,\n                    ChecksumReserved=123,\n                    SequenceNumber=2,\n                    Key=1)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'gre'],\n                                             FieldName='gre_1.routing',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_gre:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Fragment.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Fragment头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Verify the test instrument's correct IPv6 packet statistics\n\nStep          : Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Test Step 2: Modify the IPv6 Fragment header content of traffic StreamTemplate_1;\n               Test Step 3: Configure filtered packet capture;\n               Test Step 4: Subscribe to StreamBlockStats statistics;\n               Test Step 5: Set port transmission mode to burst;\n               Test Step 6: Transmit all traffic and wait for a period;\n               Test Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: In Step 6, transmitted and received packet counts for StreamTemplate_1 are equal;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6fragmentheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_fragment(Stream=stream, Ident=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6fragmentheader', Attribute=attr['Ident'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for product 'DarYu' or as specified.\",\n  \"Subtask 2\": \"Reserve two loopback ports at specified locations (e.g., //10.0.11.191/1/5 and //10.0.11.191/1/6).\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv6, and ipv6fragmentheader.\",\n  \"Subtask 5\": \"Modify IPv6 fragment header by setting Ident field to 10 and configure increment modifier (step=2, count=10) for the Ident field.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 7\": \"Configure port transmission mode to BURST with burst count of 100 on the traffic-sending port.\",\n  \"Subtask 8\": \"Save current test configuration to file.\",\n  \"Subtask 9\": \"Start traffic transmission.\",\n  \"Subtask 10\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 11\": \"Stop all traffic transmission.\",\n  \"Subtask 12\": \"Wait for 3 seconds post-transmission for statistics stabilization.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats results for the configured stream.\",\n  \"Subtask 14\": \"Extract and compare transmitted (TxStreamFrames) and received (RxStreamFrames) packet counts.\",\n  \"Subtask 15\": \"Verify TxStreamFrames exactly equals RxStreamFrames.\",\n  \"Subtask 16\": \"Release all reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Verify the test instrument's correct IPv6 packet statistics\n\nStep          : Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Test Step 2: Modify the IPv6 Fragment header content of traffic StreamTemplate_1;\n               Test Step 3: Configure filtered packet capture;\n               Test Step 4: Subscribe to StreamBlockStats statistics;\n               Test Step 5: Set port transmission mode to burst;\n               Test Step 6: Transmit all traffic and wait for a period;\n               Test Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: In Step 6, transmitted and received packet counts for StreamTemplate_1 are equal;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6fragmentheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_fragment(Stream=stream, Ident=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6fragmentheader', Attribute=attr['Ident'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4EchoRequest.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 echo requset报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 echo requset头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify the test instrument accurately counts ICMPv4 echo request packets\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Modify the ICMPv4 echo request header content in traffic stream StreamTemplate_1;\nTest Step 3: Configure filter-based packet capture;\nTest Step 4: Subscribe to StreamBlockStats;\nTest Step 5: Set port transmission mode to burst mode;\nTest Step 6: Transmit all traffic and wait for a period;\nTest Step 7: Stop all traffic and examine StreamBlockStats;\n\nCriteria: Expected Result 1: In Step 6, the sent and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4EchoRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改Icmpv4EchoRequest头部\n    header = edit_header_icmp_echo_request(Stream=stream, Level=0, Type='2',\n                                  Code='4', Identifier='65535', SequenceNumber='65535')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4EchoRequest', Attribute=header['Type'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoRequest_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoRequest_1.sequenceNumber',\n                                               Value='65535',\n                                               MaxValue='65535')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_echo_request:修改测试仪表流量模板中Icmp Echo Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (default: DarYu) using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at given locations (default: //10.0.11.191/1/3 and //10.0.11.191/1/4) using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers as EthernetII, IPv4, and ICMPv4EchoRequest using create_stream_header API.\",\n  \"Subtask 5\": \"Modify ICMPv4EchoRequest header fields: Type=2, Code=4, Identifier=65535, SequenceNumber=65535 using edit_header_icmp_echo_request API.\",\n  \"Subtask 6\": \"Apply increment modifier to ICMPv4 Type field with count=10 using edit_modifier API.\",\n  \"Subtask 7\": \"Create two PDU patterns for capture filtering on the second port: one matching ICMPv4 identifier=65535 and another matching sequenceNumber=65535 using create_capture_pdu_pattern API.\",\n  \"Subtask 8\": \"Configure packet capture filter on the second port using logical AND of the two PDU patterns via edit_capture_filter API.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats view using subscribe_result API.\",\n  \"Subtask 10\": \"Set transmission mode of the first port to BURST mode with burst count=100 using edit_port_load_profile API.\",\n  \"Subtask 11\": \"Start packet capture on the second port using start_capture API.\",\n  \"Subtask 12\": \"Transmit traffic from the first port using start_stream API.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 14\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 15\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 16\": \"Wait 3 seconds for statistics stabilization.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 18\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) for the stream.\",\n  \"Subtask 19\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify the test instrument accurately counts ICMPv4 echo request packets\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Modify the ICMPv4 echo request header content in traffic stream StreamTemplate_1;\nTest Step 3: Configure filter-based packet capture;\nTest Step 4: Subscribe to StreamBlockStats;\nTest Step 5: Set port transmission mode to burst mode;\nTest Step 6: Transmit all traffic and wait for a period;\nTest Step 7: Stop all traffic and examine StreamBlockStats;\n\nCriteria: Expected Result 1: In Step 6, the sent and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4EchoRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改Icmpv4EchoRequest头部\n    header = edit_header_icmp_echo_request(Stream=stream, Level=0, Type='2',\n                                  Code='4', Identifier='65535', SequenceNumber='65535')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv4EchoRequest', Attribute=header['Type'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoRequest_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4EchoRequest_1.sequenceNumber',\n                                               Value='65535',\n                                               MaxValue='65535')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_echo_request:修改测试仪表流量模板中Icmp Echo Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2LinkStateAcknowledgeInstance.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 link state acknowledge报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ospfv2 link state acknowledge头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Test Objective: Verify the test instrument correctly counts OSPFv2 Link State Acknowledgment packets.\n\nStep          : Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\n               Test Step 2: Modify the OSPFv2 Link State Acknowledgment header content in traffic StreamTemplate_1;\n               Test Step 3: Configure packet capture filtering;\n               Test Step 4: Subscribe to StreamBlockStats statistics;\n               Test Step 5: Set port transmission mode to burst;\n               Test Step 6: Transmit all traffic and wait for a period;\n               Test Step 7: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: During Step 6, received and sent packets for StreamTemplate_1 are equal.\n\nCreated by    : Tester-004\n\nBugs          : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstateacknowledge']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改ospfv2 database description头部\n    edit_header_ospfv2_ack(Stream=stream, Level=0,\n                          RouterID='2.2.2.2', AuthType='MD5')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2LinkStateAcknowledge_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_ack:修改测试仪表流量模板中OSPFv2 Link State Acknowledge报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type.\",\n  \"Subtask 2\": \"Reserve two ports using their locations.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length.\",\n  \"Subtask 4\": \"Define and apply EthernetII, IPv4, and OSPFv2 Link State Acknowledgment headers to the stream.\",\n  \"Subtask 5\": \"Modify OSPFv2 Link State Acknowledgment header fields including RouterID and AuthType.\",\n  \"Subtask 6\": \"Create a PDU capture pattern on the second port filtering by OSPFv2 RouterID value.\",\n  \"Subtask 7\": \"Apply the created PDU pattern as a capture filter on the second port.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 9\": \"Configure port transmission mode as burst with specified burst count.\",\n  \"Subtask 10\": \"Save current test configuration to a file.\",\n  \"Subtask 11\": \"Start packet capture on the second port.\",\n  \"Subtask 12\": \"Initiate traffic transmission from the first port.\",\n  \"Subtask 13\": \"Wait for specified duration during traffic transmission.\",\n  \"Subtask 14\": \"Stop traffic transmission.\",\n  \"Subtask 15\": \"Stop packet capture.\",\n  \"Subtask 16\": \"Download captured packets from the second port to local storage.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats results for the created stream.\",\n  \"Subtask 18\": \"Verify transmitted frames equal received frames in StreamBlockStats.\",\n  \"Subtask 19\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Test Objective: Verify the test instrument correctly counts OSPFv2 Link State Acknowledgment packets.\n\nStep          : Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\n               Test Step 2: Modify the OSPFv2 Link State Acknowledgment header content in traffic StreamTemplate_1;\n               Test Step 3: Configure packet capture filtering;\n               Test Step 4: Subscribe to StreamBlockStats statistics;\n               Test Step 5: Set port transmission mode to burst;\n               Test Step 6: Transmit all traffic and wait for a period;\n               Test Step 7: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: During Step 6, received and sent packets for StreamTemplate_1 are equal.\n\nCreated by    : Tester-004\n\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstateacknowledge']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改ospfv2 database description头部\n    edit_header_ospfv2_ack(Stream=stream, Level=0,\n                          RouterID='2.2.2.2', AuthType='MD5')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2LinkStateAcknowledge_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_ack:修改测试仪表流量模板中OSPFv2 Link State Acknowledge报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl2lspHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify correct traffic statistics reporting by the test instrument\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\nTest Step 3: Modify IS-IS header content of stream StreamTemplate_1;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Transmit all traffic and wait for duration;\nTest Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, )\n    edit_stream(Stream=stream, FrameLengthType='Auto')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2lspheader'])\n\n    header = edit_header_isis_lsp(Stream=stream,\n                                  LengthIndicator=10,\n                                  LspisIsTlvOptionSet=['IsIsAreaAddress', 'IsIsReachability', 'ExtendedReachability',\n                                    'IsIsIpInterReachability', 'IsIsProtocolsSupported', 'IsIsIPExternalReachability',\n                                    'IpInterfaceAddress', 'Ipv6InterfaceAddress', 'IsIsIpv6Reachability'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2lspheader', Attribute=header['LengthIndicator'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsAreaAddress', AreaAddressEntries=2)\n    edit_header_isis_area_address_entry(Stream=stream, TlvLength=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsReachability', Index=1, MetricEntries=1)\n    edit_header_isis_metric_entry(Stream=stream, TlvIndex=1, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='extendedReachability', Index=2,\n                                IisNeighborSubTlv=['AdGroupSubtlv', 'Ipv4InterfaceAddressSubtlv', 'Ipv4NeighborAddressSubtlv',\n                                      'MaxLinkBandwidthSubtlv', 'ReservableLinkBandwidthSubtlv', 'UnReservedBandwidthSubtlv',\n                                      'InterfaceIpv6Subtlv', 'NeigbhorIpv6Subtlv'])\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='AdGroupSubtlv', TlvIndex=2, SubTlvIndex=0, TlvCode=20)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4InterfaceAddressSubtlv', TlvIndex=2, SubTlvIndex=1, Ipv4InterfaceAddressValue='1.1.1.1')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4NeighborAddressSubtlv', TlvIndex=2, SubTlvIndex=2, Ipv4NeighborAddressValue='2.2.2.2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='MaxLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=3, MaxBandwidthValue=30)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='ReservableLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=4, ReservableLinkBandwidthValue=40)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='UnReservedBandwidthSubtlv', TlvIndex=2, SubTlvIndex=5, ResBandwidth0Value=50)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='InterfaceIpv6Subtlv', TlvIndex=2, SubTlvIndex=6, InterfaceIpv6Value='2022::2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='NeigbhorIpv6Subtlv', TlvIndex=2, SubTlvIndex=7, Neighboripv6Value='2033::3')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsIpInterReachability', Index=3, InternalmetricEntries=1)\n    edit_header_isis_internal_metric_entry(Stream=stream, TlvIndex=3, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IpInterfaceAddress', Index=6, Ipv4InterfaceAddress=['1.1.1.1', '2.2.2.2'])\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Ipv6InterfaceAddress', Index=7, Ipv6InterfaceAddress=['2022::2', '2033::3'])\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    # start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容",
      "edit_header_isis_internal_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容",
      "edit_header_isis_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容",
      "edit_header_isis_sub_tlv:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Sub Tlv内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform for network testing.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) for traffic testing.\",\n  \"Subtask 3\": \"Create a traffic stream (StreamTemplate_1) on Port_1 with EthernetII and IS-IS LSP headers.\",\n  \"Subtask 4\": \"Modify the IS-IS header of StreamTemplate_1 by configuring TLVs and sub-TLVs including Area Address, Reachability, Extended Reachability, and related parameters.\",\n  \"Subtask 5\": \"Set the transmission mode to burst with a count of 100 packets on Port_1.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats statistics for performance monitoring.\",\n  \"Subtask 7\": \"Start traffic transmission of StreamTemplate_1.\",\n  \"Subtask 8\": \"Wait for traffic transmission to complete and allow 3 seconds for statistics stabilization.\",\n  \"Subtask 9\": \"Retrieve StreamBlockStats results for StreamTemplate_1.\",\n  \"Subtask 10\": \"Verify transmitted packet count (TxStreamFrames) equals received packet count (RxStreamFrames) for StreamTemplate_1.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify correct traffic statistics reporting by the test instrument\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\nTest Step 3: Modify IS-IS header content of stream StreamTemplate_1;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Transmit all traffic and wait for duration;\nTest Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, )\n    edit_stream(Stream=stream, FrameLengthType='Auto')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2lspheader'])\n\n    header = edit_header_isis_lsp(Stream=stream,\n                                  LengthIndicator=10,\n                                  LspisIsTlvOptionSet=['IsIsAreaAddress', 'IsIsReachability', 'ExtendedReachability',\n                                    'IsIsIpInterReachability', 'IsIsProtocolsSupported', 'IsIsIPExternalReachability',\n                                    'IpInterfaceAddress', 'Ipv6InterfaceAddress', 'IsIsIpv6Reachability'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2lspheader', Attribute=header['LengthIndicator'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsAreaAddress', AreaAddressEntries=2)\n    edit_header_isis_area_address_entry(Stream=stream, TlvLength=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsReachability', Index=1, MetricEntries=1)\n    edit_header_isis_metric_entry(Stream=stream, TlvIndex=1, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='extendedReachability', Index=2,\n                                IisNeighborSubTlv=['AdGroupSubtlv', 'Ipv4InterfaceAddressSubtlv', 'Ipv4NeighborAddressSubtlv',\n                                      'MaxLinkBandwidthSubtlv', 'ReservableLinkBandwidthSubtlv', 'UnReservedBandwidthSubtlv',\n                                      'InterfaceIpv6Subtlv', 'NeigbhorIpv6Subtlv'])\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='AdGroupSubtlv', TlvIndex=2, SubTlvIndex=0, TlvCode=20)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4InterfaceAddressSubtlv', TlvIndex=2, SubTlvIndex=1, Ipv4InterfaceAddressValue='1.1.1.1')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4NeighborAddressSubtlv', TlvIndex=2, SubTlvIndex=2, Ipv4NeighborAddressValue='2.2.2.2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='MaxLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=3, MaxBandwidthValue=30)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='ReservableLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=4, ReservableLinkBandwidthValue=40)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='UnReservedBandwidthSubtlv', TlvIndex=2, SubTlvIndex=5, ResBandwidth0Value=50)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='InterfaceIpv6Subtlv', TlvIndex=2, SubTlvIndex=6, InterfaceIpv6Value='2022::2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='NeigbhorIpv6Subtlv', TlvIndex=2, SubTlvIndex=7, Neighboripv6Value='2033::3')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsIpInterReachability', Index=3, InternalmetricEntries=1)\n    edit_header_isis_internal_metric_entry(Stream=stream, TlvIndex=3, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IpInterfaceAddress', Index=6, Ipv4InterfaceAddress=['1.1.1.1', '2.2.2.2'])\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Ipv6InterfaceAddress', Index=7, Ipv6InterfaceAddress=['2022::2', '2033::3'])\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    # start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容;\nedit_header_isis_internal_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容;\nedit_header_isis_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容;\nedit_header_isis_sub_tlv:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Sub Tlv内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6EchoRequest.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 echo request报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 echo request头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Purpose: Verify that the test instrument correctly counts transmitted icmpv6 echo request packets\n\nStep        :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Step 2: Modify the icmpv6 echo request header content in traffic StreamTemplate_1;\n                Step 3: Configure filtered packet capture;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Set port transmission mode to burst mode;\n                Step 6: Send all traffic and wait for a period;\n                Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    :   Expected Result 1: In Step 6, transmitted and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by  :   Tester-004\n\nBugs        :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'icmpv6echorequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv6echorequest头部\n    edit_header_icmpv6_echo_request(Stream=stream, Level=0,\n                          Identifier='65535',SequenceNumber='65535')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoRequest_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoRequest_1.sequenceNumber',\n                                               Value='65535',\n                                               MaxValue='65535')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_echo_request:修改测试仪表流量模板中Icmpv6 Echo Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform for test execution.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) at specified locations.\",\n  \"Subtask 3\": \"Create a traffic stream with fixed length of 256 bytes on Port_1.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv6, and ICMPv6 Echo Request.\",\n  \"Subtask 5\": \"Modify ICMPv6 Echo Request header fields: set Identifier and SequenceNumber to 65535.\",\n  \"Subtask 6\": \"Create PDU pattern on Port_2 for ICMPv6 Echo Request identifier field with value 65535.\",\n  \"Subtask 7\": \"Create PDU pattern on Port_2 for ICMPv6 Echo Request sequenceNumber field with value 65535.\",\n  \"Subtask 8\": \"Configure packet capture filter on Port_2 using logical AND of both PDU patterns.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Set Port_1 transmission mode to BURST with burst count 100.\",\n  \"Subtask 11\": \"Start packet capture on Port_2.\",\n  \"Subtask 12\": \"Start traffic transmission on Port_1 and wait 10 seconds.\",\n  \"Subtask 13\": \"Stop traffic transmission on Port_1.\",\n  \"Subtask 14\": \"Stop packet capture on Port_2.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 16\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 17\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Purpose: Verify that the test instrument correctly counts transmitted icmpv6 echo request packets\n\nStep        :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Step 2: Modify the icmpv6 echo request header content in traffic StreamTemplate_1;\n                Step 3: Configure filtered packet capture;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Set port transmission mode to burst mode;\n                Step 6: Send all traffic and wait for a period;\n                Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    :   Expected Result 1: In Step 6, transmitted and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by  :   Tester-004\n\nBugs        :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'icmpv6echorequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv6echorequest头部\n    edit_header_icmpv6_echo_request(Stream=stream, Level=0,\n                          Identifier='65535',SequenceNumber='65535')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoRequest_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoRequest_1.sequenceNumber',\n                                               Value='65535',\n                                               MaxValue='65535')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_echo_request:修改测试仪表流量模板中Icmpv6 Echo Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4TimeExceeded.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 time exceeded报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 time exceeded头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: To verify the test instrument accurately counts sent ICMPv4 Time Exceeded messages  \nStep 1: Reserve two loopback ports: Port_1 and Port_2;  \nStep 2: Modify the ICMPv4 Time Exceeded header content in traffic stream StreamTemplate_1;;  \nStep 3: Configure filtered packet capture;  \nStep 4: Subscribe to StreamBlockStats statistics;;  \nStep 5: Set port transmission mode to burst;  \nStep 6: Send all traffic and wait for a period;  \nStep 7: Stop all traffic and check StreamBlockStats statistics;;  \nCriteria 1: During Step 6, the sent and received packet counts for StreamTemplate_1 traffic are equal;  \nCreated by: Tester-004  \nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimeExceeded']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 time exceeded头部\n    edit_header_icmp_time_exceeded(Stream=stream, Level=0,\n                                   Ipv4HeaderTosPrecedence='001', Ipv4HeaderID='100',\n                                   Ipv4HeaderProtocol='1', Ipv4HeaderPadding='11')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceeded_1.headerData.ipv4Header.tos.tos.precedence',\n                                               Value='001', MaxValue='001')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceeded_1.headerData.ipv4Header.id',\n                                               Value='100',\n                                               MaxValue='100')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceeded_1.headerData.ipv4Header.protocol',\n                                               Value='1',\n                                               MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_time_exceeded:修改测试仪表流量模板中Icmp Time Exceeded报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (e.g., 'DarYu')\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) at specified locations\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed length of 256 bytes\",\n  \"Subtask 4\": \"Create stream headers: EthernetII → IPv4 → ICMPv4 Time Exceeded\",\n  \"Subtask 5\": \"Modify ICMPv4 Time Exceeded header: set Level=0, IPv4 TOS precedence='001', IPv4 ID='100', IPv4 protocol='1', IPv4 padding='11'\",\n  \"Subtask 6\": \"Configure packet capture filter on Port_2: create three PDU patterns matching IPv4 TOS precedence='001', IPv4 ID='100', and IPv4 protocol='1'\",\n  \"Subtask 7\": \"Set capture filter expression on Port_2 as logical AND of the three PDU patterns\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode as burst with burst count=100\",\n  \"Subtask 10\": \"Start packet capture on Port_2\",\n  \"Subtask 11\": \"Start traffic transmission on Port_1\",\n  \"Subtask 12\": \"Wait for 10 seconds during traffic transmission\",\n  \"Subtask 13\": \"Stop traffic transmission on Port_1\",\n  \"Subtask 14\": \"Stop packet capture on Port_2\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats results for the traffic stream\",\n  \"Subtask 16\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames)\",\n  \"Subtask 17\": \"Release both reserved ports (Port_1 and Port_2)\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: To verify the test instrument accurately counts sent ICMPv4 Time Exceeded messages  \nStep 1: Reserve two loopback ports: Port_1 and Port_2;  \nStep 2: Modify the ICMPv4 Time Exceeded header content in traffic stream StreamTemplate_1;;  \nStep 3: Configure filtered packet capture;  \nStep 4: Subscribe to StreamBlockStats statistics;;  \nStep 5: Set port transmission mode to burst;  \nStep 6: Send all traffic and wait for a period;  \nStep 7: Stop all traffic and check StreamBlockStats statistics;;  \nCriteria 1: During Step 6, the sent and received packet counts for StreamTemplate_1 traffic are equal;  \nCreated by: Tester-004  \nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimeExceeded']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 time exceeded头部\n    edit_header_icmp_time_exceeded(Stream=stream, Level=0,\n                                   Ipv4HeaderTosPrecedence='001', Ipv4HeaderID='100',\n                                   Ipv4HeaderProtocol='1', Ipv4HeaderPadding='11')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceeded_1.headerData.ipv4Header.tos.tos.precedence',\n                                               Value='001', MaxValue='001')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceeded_1.headerData.ipv4Header.id',\n                                               Value='100',\n                                               MaxValue='100')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceeded_1.headerData.ipv4Header.protocol',\n                                               Value='1',\n                                               MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_time_exceeded:修改测试仪表流量模板中Icmp Time Exceeded报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Sctp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的sctp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Verify the test instrument's traffic statistics accuracy\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Test Step 3: Modify the SCTP header content of stream StreamTemplate_1;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Transmit all traffic and wait for a period;\n      Test Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'sctp'])\n\n    # 修改sctp头部\n    attr = edit_header_sctp(Stream=stream, Level=0,\n                            SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Attribute=attr['SourcePort'],\n                  Type='Increment', Count=10, HeaderType='sctp')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using the init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) as loopback ports using reserve_port API with force reservation.\",\n  \"Subtask 3\": \"Create a traffic stream (StreamTemplate_1) on Port_1 using add_stream API.\",\n  \"Subtask 4\": \"Create stream headers for Ethernet II, IPv4, and SCTP protocols on StreamTemplate_1 using create_stream_header API.\",\n  \"Subtask 5\": \"Modify SCTP header of StreamTemplate_1: set source port to 1000 and destination port to 2000 using edit_header_sctp API.\",\n  \"Subtask 6\": \"Configure source port modifier for StreamTemplate_1: increment by 10 per packet using edit_modifier API.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 8\": \"Configure Port_1 transmission mode: set to burst mode with burst count of 100 packets using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Save current test configuration to file using save_case API.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete using wait_stream_state API, then wait 3 seconds for statistics collection.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API.\",\n  \"Subtask 13\": \"Verify transmitted packet count (TxStreamFrames) equals received packet count (RxStreamFrames) and both equal configured burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Verify the test instrument's traffic statistics accuracy\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Test Step 3: Modify the SCTP header content of stream StreamTemplate_1;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Transmit all traffic and wait for a period;\n      Test Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'sctp'])\n\n    # 修改sctp头部\n    attr = edit_header_sctp(Stream=stream, Level=0,\n                            SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Attribute=attr['SourcePort'],\n                  Type='Increment', Count=10, HeaderType='sctp')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6MLDv1Report.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv1 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv1 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Verify that the test instrument accurately counts sent ICMPv6 MLDv1 report packets\n\nStep         :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                 Step 2: Modify the ICMPv6 MLDv1 report header content in traffic stream StreamTemplate_1;;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats statistics;;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Transmit all traffic and wait for a duration;;\n                 Step 7: Stop all traffic and inspect StreamBlockStats statistics;;\n\nCriteria     :   Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'mldv1report']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改mldv1report头部\n    edit_header_icmpv6_mldv1_report(Stream=stream, Level=0,\n                          Code='2',Reserved='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Report_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Report_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Report_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_mldv1_report:修改测试仪表流量模板中Icmpv6 Mldv1 Report报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for the specified product (default: 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports using provided locations and assign to Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv4, and MLDv1 report.\",\n  \"Subtask 5\": \"Modify MLDv1 report header parameters: set Code to '2', Reserved to '10', Multicast Address to 'FF1E::1'.\",\n  \"Subtask 6\": \"Create three PDU patterns on Port_2 to match MLDv1 report header fields: code=2, reserved=10, multicastAddress=FF1E::1.\",\n  \"Subtask 7\": \"Apply capture filter on Port_2 using logical AND combination of the three PDU patterns.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode as burst with burst count set to 100.\",\n  \"Subtask 10\": \"Save current test configuration to file.\",\n  \"Subtask 11\": \"Start packet capture on Port_2.\",\n  \"Subtask 12\": \"Initiate traffic transmission from Port_1.\",\n  \"Subtask 13\": \"Maintain traffic transmission for 10 seconds duration.\",\n  \"Subtask 14\": \"Terminate traffic transmission from Port_1.\",\n  \"Subtask 15\": \"Stop packet capture on Port_2.\",\n  \"Subtask 16\": \"Wait 3 seconds for capture finalization.\",\n  \"Subtask 17\": \"Download captured packets from Port_2 to local storage.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats for the traffic stream.\",\n  \"Subtask 19\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 20\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Verify that the test instrument accurately counts sent ICMPv6 MLDv1 report packets\n\nStep         :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                 Step 2: Modify the ICMPv6 MLDv1 report header content in traffic stream StreamTemplate_1;;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats statistics;;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Transmit all traffic and wait for a duration;;\n                 Step 7: Stop all traffic and inspect StreamBlockStats statistics;;\n\nCriteria     :   Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'mldv1report']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改mldv1report头部\n    edit_header_icmpv6_mldv1_report(Stream=stream, Level=0,\n                          Code='2',Reserved='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Report_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Report_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Report_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_mldv1_report:修改测试仪表流量模板中Icmpv6 Mldv1 Report报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Custom.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发custom报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的custom头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Test Objective: Verify the test instrument accurately counts custom packets\n\nStep          : Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Test Step 2: Modify the custom header content of traffic StreamTemplate_1;\n               Test Step 3: Configure filtered packet capture;\n               Test Step 4: Subscribe to StreamBlockStats statistics;\n               Test Step 5: Set port transmission mode to burst;\n               Test Step 6: Transmit all traffic and wait for a period;\n               Test Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: During Step 6, transmitted and received packet counts for StreamTemplate_1 are equal;\n\nCreated by    : Tester-004\n\nBugs          : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'custom']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改custom头部\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='1212121212', Checksum='Auto')\n    print(attribute_dict)\n    result = edit_header_custom(Stream=stream, Level=0, Pattern='0343434343', Checksum='Auto')\n    print(attribute_dict)\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='2323232323', Checksum='Auto')\n    print(attribute_dict)\n\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='0565656565', Index=0)\n    print(attribute_dict)\n    edit_modifier(Stream=stream, Level=0, HeaderType='custom', Attribute=attribute_dict['Pattern'], Type='Increment', Count=10, Step=2)\n\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='0787878787', Index=2)\n    print(attribute_dict)\n    edit_modifier(Stream=stream, Level=0, HeaderType='custom', Attribute=attribute_dict['Pattern'], Type='Random', Range='1787878787')\n\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='5656565656', Index=4)\n    print(attribute_dict)\n    edit_modifier(Stream=stream, Level=0, HeaderType='custom', Attribute=attribute_dict['Pattern'], Type='List', List=['5656565657', '5656565658', '5656565659'])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_custom:修改测试仪表流量模板中Custom报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (default 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations using reserve_port API, storing references as Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Define stream headers with EthernetII, IPv4, and custom layers using create_stream_header API.\",\n  \"Subtask 5\": \"Modify custom header attributes at level 0 with specific patterns (0343434343, 2323232323, etc.) using edit_header_custom API.\",\n  \"Subtask 6\": \"Apply modifiers to custom header fields: increment pattern with step 2, random pattern in range 1787878787, and list-based pattern using edit_modifier API.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 8\": \"Configure Port_1 transmission mode to BURST with burst count 100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Save current test configuration to .xcfg file using save_case API.\",\n  \"Subtask 10\": \"Start packet capture on all ports using start_capture API.\",\n  \"Subtask 11\": \"Initiate traffic transmission using start_stream API.\",\n  \"Subtask 12\": \"Wait 10 seconds during traffic transmission for statistics accumulation.\",\n  \"Subtask 13\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 14\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 15\": \"Download captured packets from Port_2 to specified directory using download_packages API.\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats for the stream using get_streamblock_statistic API and verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 17\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Test Objective: Verify the test instrument accurately counts custom packets\n\nStep          : Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Test Step 2: Modify the custom header content of traffic StreamTemplate_1;\n               Test Step 3: Configure filtered packet capture;\n               Test Step 4: Subscribe to StreamBlockStats statistics;\n               Test Step 5: Set port transmission mode to burst;\n               Test Step 6: Transmit all traffic and wait for a period;\n               Test Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: During Step 6, transmitted and received packet counts for StreamTemplate_1 are equal;\n\nCreated by    : Tester-004\n\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'custom']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改custom头部\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='1212121212', Checksum='Auto')\n    print(attribute_dict)\n    result = edit_header_custom(Stream=stream, Level=0, Pattern='0343434343', Checksum='Auto')\n    print(attribute_dict)\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='2323232323', Checksum='Auto')\n    print(attribute_dict)\n\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='0565656565', Index=0)\n    print(attribute_dict)\n    edit_modifier(Stream=stream, Level=0, HeaderType='custom', Attribute=attribute_dict['Pattern'], Type='Increment', Count=10, Step=2)\n\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='0787878787', Index=2)\n    print(attribute_dict)\n    edit_modifier(Stream=stream, Level=0, HeaderType='custom', Attribute=attribute_dict['Pattern'], Type='Random', Range='1787878787')\n\n    attribute_dict = edit_header_custom(Stream=stream, Level=0, Pattern='5656565656', Index=4)\n    print(attribute_dict)\n    edit_modifier(Stream=stream, Level=0, HeaderType='custom', Attribute=attribute_dict['Pattern'], Type='List', List=['5656565657', '5656565658', '5656565659'])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_custom:修改测试仪表流量模板中Custom报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv2Query.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发IGMPv2_Query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的IGMPv2_Query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective\t:\tTest Objective: Verify that the test instrument correctly counts transmitted IGMPv2_Query packets.\n\nStep\t\t:\tTest Step 1: Reserve two loopback ports: Port_1 and Port_2;\n\t\t\tTest Step 2: Modify IGMPv2_Query header content of traffic StreamTemplate_1;;\n\t\t\tTest Step 3: Configure filter capture;\n\t\t\tTest Step 4: Subscribe to StreamBlockStats statistics;;\n\t\t\tTest Step 5: Set port transmission mode to burst;\n\t\t\tTest Step 6: Transmit all traffic and wait for a period;\n\t\t\tTest Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria\t:\tExpected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by\t:\tTester-004\n\nBugs\t\t:\tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IGMPv2Query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv2_query(Stream=stream, Level=0, Type=99, MaxResponseTime=255, Checksum='ffff',\n                             GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.maxResponseTime',\n                                               Value='255',\n                                               MaxValue='255')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.groupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv2_query:修改测试仪表流量模板中IGMPv2 Query报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for the specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports designated as Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure the stream headers to include EthernetII, IPv4, and IGMPv2Query layers.\",\n  \"Subtask 5\": \"Modify the IGMPv2Query header with specific parameters: Type=99, MaxResponseTime=255, Checksum='ffff', GroupAddress='10.1.1.1'.\",\n  \"Subtask 6\": \"Create three PDU capture patterns on Port_2 matching the modified IGMPv2Query header fields: type=99, maxResponseTime=255, groupAddress='10.1.1.1'.\",\n  \"Subtask 7\": \"Configure the capture filter on Port_2 using a logical AND expression combining all three PDU patterns.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view for monitoring.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode to burst with burst count set to 100 packets.\",\n  \"Subtask 10\": \"Save the current test configuration to a file.\",\n  \"Subtask 11\": \"Start packet capture on Port_2.\",\n  \"Subtask 12\": \"Initiate traffic transmission from Port_1.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission and capture.\",\n  \"Subtask 14\": \"Stop traffic transmission from Port_1.\",\n  \"Subtask 15\": \"Stop packet capture on Port_2.\",\n  \"Subtask 16\": \"Wait 3 seconds for statistics stabilization.\",\n  \"Subtask 17\": \"Download captured packets from Port_2 to local storage.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats results and extract TxStreamFrames and RxStreamFrames values.\",\n  \"Subtask 19\": \"Verify TxStreamFrames equals RxStreamFrames to confirm transmitted and received packet counts match.\",\n  \"Subtask 20\": \"Release reserved ports Port_1 and Port_2.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective\t:\tTest Objective: Verify that the test instrument correctly counts transmitted IGMPv2_Query packets.\n\nStep\t\t:\tTest Step 1: Reserve two loopback ports: Port_1 and Port_2;\n\t\t\tTest Step 2: Modify IGMPv2_Query header content of traffic StreamTemplate_1;;\n\t\t\tTest Step 3: Configure filter capture;\n\t\t\tTest Step 4: Subscribe to StreamBlockStats statistics;;\n\t\t\tTest Step 5: Set port transmission mode to burst;\n\t\t\tTest Step 6: Transmit all traffic and wait for a period;\n\t\t\tTest Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria\t:\tExpected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by\t:\tTester-004\n\nBugs\t\t:\tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IGMPv2Query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv2_query(Stream=stream, Level=0, Type=99, MaxResponseTime=255, Checksum='ffff',\n                             GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.maxResponseTime',\n                                               Value='255',\n                                               MaxValue='255')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.groupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv2_query:修改测试仪表流量模板中IGMPv2 Query报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Pppoe.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发pppoe报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的pppoe头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify accurate PPPoE packet statistics reporting by the test instrument\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Test Step 2: Modify the PPPoE header content of traffic StreamTemplate_1;;\n      Test Step 3: Configure filtered packet capture;\n      Test Step 4: Subscribe to StreamBlockStats statistics;;\n      Test Step 5: Set port transmission mode to burst packets;\n      Test Step 6: Transmit all traffic and wait for a period;\n      Test Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: During Step 6, sent and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'pppoe']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改pppoe头部\n    header_dict = edit_header_pppoe(Stream=stream, Level=0, Code=11, SessionId=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='pppoe', Attribute=header_dict['SessionId'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='pppoe_1.code',\n                                               Value='11', MaxValue='11')\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='pppoe_1.sessionId',\n    #                                            Value='2',\n    #                                            MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=1,\n                                               Attribute=header_dict['SessionId'],\n                                               Value='2', MaxValue='11')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_pppoe:修改测试仪表流量模板中PPPoE报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform for the specified product (e.g., DarYu) using init_tester API.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) at given locations using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers with EthernetII and PPPoE layers using create_stream_header API.\",\n  \"Subtask 5\": \"Modify PPPoE header parameters: set code=11 and sessionId=2 at level 0 using edit_header_pppoe API.\",\n  \"Subtask 6\": \"Configure sessionId modifier with increment type (2 to 11) for 10 packets using edit_modifier API.\",\n  \"Subtask 7\": \"Create two PDU capture patterns on Port_2: one for pppoe.code=11 and another for pppoe.sessionId range 2-11 using create_capture_pdu_pattern API.\",\n  \"Subtask 8\": \"Apply packet capture filter combining both PDU patterns with logical AND using edit_capture_filter API.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 10\": \"Configure Port_1 transmission mode as burst with count=100 using edit_port_load_profile API.\",\n  \"Subtask 11\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 12\": \"Start packet capture on Port_2 using start_capture API.\",\n  \"Subtask 13\": \"Initiate traffic transmission using start_stream API and wait 10 seconds.\",\n  \"Subtask 14\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 15\": \"Stop packet capture using stop_capture API and wait 3 seconds.\",\n  \"Subtask 16\": \"Download captured packets from Port_2 to local storage using download_packages API.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 18\": \"Verify TxStreamFrames equals RxStreamFrames for packet count validation.\",\n  \"Subtask 19\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify accurate PPPoE packet statistics reporting by the test instrument\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Test Step 2: Modify the PPPoE header content of traffic StreamTemplate_1;;\n      Test Step 3: Configure filtered packet capture;\n      Test Step 4: Subscribe to StreamBlockStats statistics;;\n      Test Step 5: Set port transmission mode to burst packets;\n      Test Step 6: Transmit all traffic and wait for a period;\n      Test Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: During Step 6, sent and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'pppoe']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改pppoe头部\n    header_dict = edit_header_pppoe(Stream=stream, Level=0, Code=11, SessionId=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='pppoe', Attribute=header_dict['SessionId'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='pppoe_1.code',\n                                               Value='11', MaxValue='11')\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='pppoe_1.sessionId',\n    #                                            Value='2',\n    #                                            MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=1,\n                                               Attribute=header_dict['SessionId'],\n                                               Value='2', MaxValue='11')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_pppoe:修改测试仪表流量模板中PPPoE报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/LldpPortId.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的lldp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Test Objective: Verify the accuracy of test instrument traffic statistics\n\nStep          : Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n               Test Step 3: Modify the LLDP header content of stream StreamTemplate_1;\n               Test Step 4: Subscribe to StreamBlockStats statistics;\n               Test Step 5: Transmit all traffic and wait for a period;\n               Test Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: In Step 6, received and transmitted packets for stream StreamTemplate_1 are equal;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_port_id_tlv(Stream=stream, Level=0, PortId='22:22:22:22:22:22')\n    edit_modifier(Stream=stream, Attribute=attr['PortId'],\n                  Type='Increment', Count=10, HeaderType='portidtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for the specified product (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports using provided locations and assign them to Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP.\",\n  \"Subtask 4\": \"Configure the stream's frame length type to 'AUTO'.\",\n  \"Subtask 5\": \"Create Ethernet II and LLDP Port ID TLV headers for the stream.\",\n  \"Subtask 6\": \"Modify the LLDP Port ID TLV field 'PortId' to initial value '22:22:22:22:22:22'.\",\n  \"Subtask 7\": \"Apply increment modifier to the 'PortId' field with count=10 in the LLDP header.\",\n  \"Subtask 8\": \"Subscribe to PortStats and StreamBlockStats statistics views.\",\n  \"Subtask 9\": \"Configure the transmitting port's load profile to burst mode with burst count=100.\",\n  \"Subtask 10\": \"Save the test configuration to an .xcfg file.\",\n  \"Subtask 11\": \"Start traffic transmission on all streams.\",\n  \"Subtask 12\": \"Wait until all traffic transmission completes.\",\n  \"Subtask 13\": \"Wait 3 seconds after traffic stops for statistics stabilization.\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats results for the created stream.\",\n  \"Subtask 15\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both match the burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Test Objective: Verify the accuracy of test instrument traffic statistics\n\nStep          : Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n               Test Step 3: Modify the LLDP header content of stream StreamTemplate_1;\n               Test Step 4: Subscribe to StreamBlockStats statistics;\n               Test Step 5: Transmit all traffic and wait for a period;\n               Test Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: In Step 6, received and transmitted packets for stream StreamTemplate_1 are equal;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_port_id_tlv(Stream=stream, Level=0, PortId='22:22:22:22:22:22')\n    edit_modifier(Stream=stream, Attribute=attr['PortId'],\n                  Type='Increment', Count=10, HeaderType='portidtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/vxlan.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的vxlan头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Verify the accuracy of traffic statistics generated by the test instrument  \n\nStep:  \nTest Step 1: Reserve two loopback ports: Port_1 and Port_2;  \nTest Step 2: Create a traffic stream StreamTemplate_1 on Port_1;  \nTest Step 3: Modify the VXLAN header content of StreamTemplate_1;  \nTest Step 4: Subscribe to StreamBlockStats collection;  \nTest Step 5: Transmit all traffic and wait for a period;  \nTest Step 6: Stop all traffic and inspect StreamBlockStats information;  \n\nCriteria:  \nExpected Result 1: In Step 6, received and transmitted packets for StreamTemplate_1 should be equal;  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4', 'udp', 'vxlan'])\n\n    # 修改vxlan头部\n    attr = edit_header_vxlan(Stream=stream, Vni=1000)\n    edit_modifier(Stream=stream, Attribute=attr['Vni'],\n                  Type='Increment', Count=10, HeaderType='vxlan')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with specified product type (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two loopback ports using provided location information for Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP with default parameters.\",\n  \"Subtask 4\": \"Edit the stream to set frame length type to 'AUTO'.\",\n  \"Subtask 5\": \"Create stream headers: ethernetii, vlan, ipv4, udp, and vxlan.\",\n  \"Subtask 6\": \"Edit VXLAN header to set VNI to 1000.\",\n  \"Subtask 7\": \"Configure modifier for VNI field to increment by 1 for 10 packets.\",\n  \"Subtask 8\": \"Subscribe to PortStats and StreamBlockStats collection.\",\n  \"Subtask 9\": \"Configure port load profile with burst transmit mode and burst count of 100 packets.\",\n  \"Subtask 10\": \"Save current configuration to file for reference.\",\n  \"Subtask 11\": \"Start traffic transmission.\",\n  \"Subtask 12\": \"Wait until traffic transmission completes.\",\n  \"Subtask 13\": \"Wait 3 seconds after traffic stops to ensure statistics collection.\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats results for the created stream.\",\n  \"Subtask 15\": \"Verify transmitted frames (TxStreamFrames) equal 100 and match received frames (RxStreamFrames).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Verify the accuracy of traffic statistics generated by the test instrument  \n\nStep:  \nTest Step 1: Reserve two loopback ports: Port_1 and Port_2;  \nTest Step 2: Create a traffic stream StreamTemplate_1 on Port_1;  \nTest Step 3: Modify the VXLAN header content of StreamTemplate_1;  \nTest Step 4: Subscribe to StreamBlockStats collection;  \nTest Step 5: Transmit all traffic and wait for a period;  \nTest Step 6: Stop all traffic and inspect StreamBlockStats information;  \n\nCriteria:  \nExpected Result 1: In Step 6, received and transmitted packets for StreamTemplate_1 should be equal;  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4', 'udp', 'vxlan'])\n\n    # 修改vxlan头部\n    attr = edit_header_vxlan(Stream=stream, Vni=1000)\n    edit_modifier(Stream=stream, Attribute=attr['Vni'],\n                  Type='Increment', Count=10, HeaderType='vxlan')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/EthernetII.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ethernetii报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ethernetii头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Verify that the test instrument accurately counts Ethernet II packets sent.  \n\nStep:  \nStep 1: Reserve two loopback ports Port_1 and Port_2.  \nStep 2: Modify the Ethernet II header content of traffic StreamTemplate_1.  \nStep 3: Configure packet capture filtering.  \nStep 4: Subscribe to StreamBlockStats counters.  \nStep 5: Set port transmission mode to burst packets.  \nStep 6: Transmit all traffic and wait for a period.  \nStep 7: Stop all traffic and inspect StreamBlockStats counters.  \n\nCriteria:  \nCriterion 1: During Step 6, sent and received packets for traffic StreamTemplate_1 must be equal.  \n\nCreated by: Tester-004  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Force=True)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改EthernetII头部\n    attribute_dict = edit_header_ethernet(Stream=stream, Level=0, DestMacAdd='00:00:00:00:00:01',\n                                          SourceMacAdd='00:00:00:00:00:02')\n    print(attribute_dict)\n    # EthernetII头部目的Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='ethernetii', Attribute=attribute_dict['DestMacAdd'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # EthernetII头部源Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='ethernetii', Attribute=attribute_dict['SourceMacAdd'],\n                  Type='List',\n                  List=['00:00:00:00:00:02', '00:00:00:00:00:03', '00:00:00:00:00:04', '00:00:00:00:00:05'])\n    # 配置过滤抓包\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ethernetII_1.sourceMacAdd',\n    #                                            Value='00:00:00:00:00:02', MaxValue='00:00:00:00:00:02')\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ethernetII_1.destMacAdd',\n    #                                            Value='00:00:00:00:00:01',\n    #                                            MaxValue='00:00:00:00:00:01')\n    # edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (DarYu or from arguments) using init_tester API.\",\n  \"Subtask 2\": \"Reserve two loopback ports at given locations using reserve_port API with Force=True.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Create EthernetII header for the stream using create_stream_header API.\",\n  \"Subtask 5\": \"Modify EthernetII header destination MAC to '00:00:00:00:00:01' and source MAC to '00:00:00:00:00:02' using edit_header_ethernet API.\",\n  \"Subtask 6\": \"Add increment modifier to destination MAC field (count=10, step=2) using edit_modifier API.\",\n  \"Subtask 7\": \"Add list modifier to source MAC field with values ['00:00:00:00:00:02','00:00:00:00:00:03','00:00:00:00:00:04','00:00:00:00:00:05'] using edit_modifier API.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats counters using subscribe_result API.\",\n  \"Subtask 9\": \"Configure first port's transmission mode to burst with count=100 using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Save current configuration to file using save_case API.\",\n  \"Subtask 11\": \"Start packet capture on the second port using start_capture API.\",\n  \"Subtask 12\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 14\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 15\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 16\": \"Download captured packets from second port to local directory using download_packages API.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats counters for the stream using get_streamblock_statistic API.\",\n  \"Subtask 18\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) for the stream.\",\n  \"Subtask 19\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Verify that the test instrument accurately counts Ethernet II packets sent.  \n\nStep:  \nStep 1: Reserve two loopback ports Port_1 and Port_2.  \nStep 2: Modify the Ethernet II header content of traffic StreamTemplate_1.  \nStep 3: Configure packet capture filtering.  \nStep 4: Subscribe to StreamBlockStats counters.  \nStep 5: Set port transmission mode to burst packets.  \nStep 6: Transmit all traffic and wait for a period.  \nStep 7: Stop all traffic and inspect StreamBlockStats counters.  \n\nCriteria:  \nCriterion 1: During Step 6, sent and received packets for traffic StreamTemplate_1 must be equal.  \n\nCreated by: Tester-004  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Force=True)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改EthernetII头部\n    attribute_dict = edit_header_ethernet(Stream=stream, Level=0, DestMacAdd='00:00:00:00:00:01',\n                                          SourceMacAdd='00:00:00:00:00:02')\n    print(attribute_dict)\n    # EthernetII头部目的Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='ethernetii', Attribute=attribute_dict['DestMacAdd'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # EthernetII头部源Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='ethernetii', Attribute=attribute_dict['SourceMacAdd'],\n                  Type='List',\n                  List=['00:00:00:00:00:02', '00:00:00:00:00:03', '00:00:00:00:00:04', '00:00:00:00:00:05'])\n    # 配置过滤抓包\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ethernetII_1.sourceMacAdd',\n    #                                            Value='00:00:00:00:00:02', MaxValue='00:00:00:00:00:02')\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ethernetII_1.destMacAdd',\n    #                                            Value='00:00:00:00:00:01',\n    #                                            MaxValue='00:00:00:00:00:01')\n    # edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/LldpTtl.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的lldp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Objective: Verify that the test instrument's traffic transmission statistics are accurate\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\nTest Step 3: Modify the LLDP header content of traffic stream StreamTemplate_1;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Transmit all traffic and wait for a period;\nTest Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv', 'ttltlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_ttl_tlv(Stream=stream, Level=0, Ttl=10)\n    edit_modifier(Stream=stream, Attribute=attr['Ttl'],\n                  Type='Increment', Count=10, HeaderType='ttltlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two loopback ports using provided locations and assign them to Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API.\",\n  \"Subtask 4\": \"Configure the stream to use automatic frame length via edit_stream API.\",\n  \"Subtask 5\": \"Create LLDP headers (Ethernet II, Port ID TLV, TTL TLV) for the stream using create_stream_header API.\",\n  \"Subtask 6\": \"Modify the LLDP TTL TLV header to set initial TTL value to 10 using edit_header_lldp_ttl_tlv API.\",\n  \"Subtask 7\": \"Configure a modifier for the TTL field to increment by 1 per packet with 10-step cycle using edit_modifier API.\",\n  \"Subtask 8\": \"Subscribe to PortStats and StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 9\": \"Configure Port_UP to transmit in burst mode with burst count set to 100 using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Save the test configuration to a specified file path using save_case API.\",\n  \"Subtask 11\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 12\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 13\": \"Wait 3 seconds after traffic stops to ensure accurate statistics collection.\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats for the created stream using get_streamblock_statistic API.\",\n  \"Subtask 15\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both match the burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Objective: Verify that the test instrument's traffic transmission statistics are accurate\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\nTest Step 3: Modify the LLDP header content of traffic stream StreamTemplate_1;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Transmit all traffic and wait for a period;\nTest Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv', 'ttltlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_ttl_tlv(Stream=stream, Level=0, Ttl=10)\n    edit_modifier(Stream=stream, Attribute=attr['Ttl'],\n                  Type='Increment', Count=10, HeaderType='ttltlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Rtag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的r tag头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective\t:\tTest Objective: Verify the accuracy of traffic transmission statistics on the test instrument\n\nStep\t\t:\tTest Step 1: Reserve two loopback ports: Port_1 and Port_2;\n\t\tTest Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n\t\tTest Step 3: Modify the r tag header content of stream StreamTemplate_1;\n\t\tTest Step 4: Subscribe to StreamBlockStats statistics;\n\t\tTest Step 5: Transmit all traffic and wait for a duration;\n\t\tTest Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria\t:\tExpected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by\t:\tTester-002\n\nBugs\t\t:\tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['rtag', 'ipv4'])\n\n    # 修改rtag头部\n    attr = edit_header_r_tag(Stream=stream, Level=0,\n                             Reserved=4095)\n    edit_modifier(Stream=stream, Attribute=attr['Reserved'],\n                  Type='Increment', Count=10, HeaderType='rtag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with specified product configuration using init_tester API.\",\n  \"Subtask 2\": \"Reserve two loopback ports at given locations using reserve_port API and assign them to Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers to include rtag and ipv4 using create_stream_header API.\",\n  \"Subtask 5\": \"Modify rtag header at level 0 by setting Reserved field to 4095 using edit_header_r_tag API.\",\n  \"Subtask 6\": \"Apply increment modifier to Reserved attribute with count=10 for rtag header using edit_modifier API.\",\n  \"Subtask 7\": \"Subscribe to PortStats and StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 8\": \"Configure Port_UP transmit mode to BURST with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Save current test configuration to file using save_case API.\",\n  \"Subtask 10\": \"Initiate traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 12\": \"Wait 3 seconds for statistics stabilization after traffic stops.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats for the stream using get_streamblock_statistic API.\",\n  \"Subtask 14\": \"Verify TxStreamFrames equals RxStreamFrames and both equal configured BurstCount (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective\t:\tTest Objective: Verify the accuracy of traffic transmission statistics on the test instrument\n\nStep\t\t:\tTest Step 1: Reserve two loopback ports: Port_1 and Port_2;\n\t\tTest Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n\t\tTest Step 3: Modify the r tag header content of stream StreamTemplate_1;\n\t\tTest Step 4: Subscribe to StreamBlockStats statistics;\n\t\tTest Step 5: Transmit all traffic and wait for a duration;\n\t\tTest Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria\t:\tExpected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by\t:\tTester-002\n\nBugs\t\t:\tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['rtag', 'ipv4'])\n\n    # 修改rtag头部\n    attr = edit_header_r_tag(Stream=stream, Level=0,\n                             Reserved=4095)\n    edit_modifier(Stream=stream, Attribute=attr['Reserved'],\n                  Type='Increment', Count=10, HeaderType='rtag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Routing.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Routing头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify that the test instrument accurately counts transmitted IPv6 packets\n\nStep:\nStep 1: Reserve two loopback ports, Port_1 and Port_2;\nStep 2: Modify the IPv6 Routing header content in traffic stream StreamTemplate_1;\nStep 3: Configure packet capture with filters;\nStep 4: Subscribe to StreamBlockStats;\nStep 5: Set port transmission mode to burst;\nStep 6: Transmit all traffic streams and wait for a duration;\nStep 7: Stop all traffic and examine StreamBlockStats;\n\nCriteria: \nExpected result 1: For StreamTemplate_1 in Step 6, transmitted packet count equals received packet count;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6routingheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_routing(Stream=stream, Nodes=['2022::2', '2033::3'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6routingheader', Attribute=attr['Nodes_2022::2'],\n                  Type='Increment', Count=10, Step=2)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (default 'DarYu' or command-line input).\",\n  \"Subtask 2\": \"Reserve two ports using provided locations (default or command-line input).\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Define stream headers: EthernetII, IPv6, and IPv6 Routing header.\",\n  \"Subtask 5\": \"Edit IPv6 Routing header content with nodes ['2022::2', '2033::3'].\",\n  \"Subtask 6\": \"Configure modifier for IPv6 Routing header: Level 0, attribute 'Nodes_2022::2', increment type with count 10 and step 2.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistic view.\",\n  \"Subtask 8\": \"Configure port transmission mode: burst type with burst count 100.\",\n  \"Subtask 9\": \"Save test configuration to file in specified path.\",\n  \"Subtask 10\": \"Start traffic stream transmission.\",\n  \"Subtask 11\": \"Wait 10 seconds during traffic transmission.\",\n  \"Subtask 12\": \"Stop all traffic streams.\",\n  \"Subtask 13\": \"Wait 3 seconds for statistics stabilization.\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats results for the created stream.\",\n  \"Subtask 15\": \"Verify transmitted packet count (TxStreamFrames) equals received packet count (RxStreamFrames).\",\n  \"Subtask 16\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify that the test instrument accurately counts transmitted IPv6 packets\n\nStep:\nStep 1: Reserve two loopback ports, Port_1 and Port_2;\nStep 2: Modify the IPv6 Routing header content in traffic stream StreamTemplate_1;\nStep 3: Configure packet capture with filters;\nStep 4: Subscribe to StreamBlockStats;\nStep 5: Set port transmission mode to burst;\nStep 6: Transmit all traffic streams and wait for a duration;\nStep 7: Stop all traffic and examine StreamBlockStats;\n\nCriteria: \nExpected result 1: For StreamTemplate_1 in Step 6, transmitted packet count equals received packet count;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6routingheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_routing(Stream=stream, Nodes=['2022::2', '2033::3'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6routingheader', Attribute=attr['Nodes_2022::2'],\n                  Type='Increment', Count=10, Step=2)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2TPv3ControlOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Control Over Udp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify the correctness of the test instrument's flow transmission statistics\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the L2TPv3 Control Over Udp header content of traffic stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Transmit all traffic and wait for a period;\n                   Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-003\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp'])\n\n    # 修改l2tpv3 control over udp头部\n    edit_header_l2tpv3_control_over_udp(Stream=stream, Level=0,\n                                        Type=1,\n                                        UseLength=1,\n                                        Length=1,\n                                        )\n\n    # 修改l2tpv3 control over udp头部，添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='circuitError',\n                                      AlignmentOverruns=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='routeId',\n                                      RouteId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='assignedConnection',\n                                      ConnectionId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='localSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='remoteSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='assignedCookie',\n                                      Cookie4Byte='00000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='pwType',\n                                      PwType=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='l2SpecificSub',\n                                      L2SpecificSublayer=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='dataSequencing',\n                                      DataSequencing=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='txConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='rxConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='circuitStatus',\n                                      Nbit=1,\n                                      Abit=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp'],\n                                             FieldName='l2tpv3ControlOverUdp_1.type',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product (DarYu) using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using reserve_port API with provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed length of 512 bytes using add_stream API.\",\n  \"Subtask 4\": \"Create stream headers for EthernetII, IPv4, UDP, and L2TPv3 Control over UDP layers using create_stream_header API.\",\n  \"Subtask 5\": \"Edit main L2TPv3 Control over UDP header fields: Type=1, UseLength=1, Length=1 using edit_header_l2tpv3_control_over_udp API.\",\n  \"Subtask 6\": \"Add 19 L2TPv3 Control options to the header with specific parameters (generalTLV, messageType, resultCode, etc.) using edit_header_l2tpv3_control_option API.\",\n  \"Subtask 7\": \"Configure packet capture filter on Port_2 to match L2TPv3 Control packets with Type=1 using create_capture_pdu_pattern and edit_capture_filter APIs.\",\n  \"Subtask 8\": \"Subscribe to PortStats and StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 9\": \"Configure Port_1 transmit mode as BURST with count=100 using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 11\": \"Start packet capture on Port_2 using start_capture API.\",\n  \"Subtask 12\": \"Transmit traffic from Port_1 using start_stream API.\",\n  \"Subtask 13\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 14\": \"Stop packet capture on Port_2 using stop_capture API.\",\n  \"Subtask 15\": \"Wait 3 seconds for statistics stabilization before collecting results.\",\n  \"Subtask 16\": \"Download captured packets from Port_2 using download_packages API.\",\n  \"Subtask 17\": \"Retrieve and validate capture info from Port_2: verify CapturedPacketCount = DownloadedPacketCount = 100 using get_capture_info API.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 19\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both equal 100.\",\n  \"Subtask 20\": \"Retrieve port statistics for filter counts on Port_2 using get_port_statistic API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify the correctness of the test instrument's flow transmission statistics\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the L2TPv3 Control Over Udp header content of traffic stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Transmit all traffic and wait for a period;\n                   Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-003\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp'])\n\n    # 修改l2tpv3 control over udp头部\n    edit_header_l2tpv3_control_over_udp(Stream=stream, Level=0,\n                                        Type=1,\n                                        UseLength=1,\n                                        Length=1,\n                                        )\n\n    # 修改l2tpv3 control over udp头部，添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='circuitError',\n                                      AlignmentOverruns=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='routeId',\n                                      RouteId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='assignedConnection',\n                                      ConnectionId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='localSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='remoteSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='assignedCookie',\n                                      Cookie4Byte='00000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='pwType',\n                                      PwType=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='l2SpecificSub',\n                                      L2SpecificSublayer=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='dataSequencing',\n                                      DataSequencing=1,\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='txConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='rxConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over udp头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='circuitStatus',\n                                      Nbit=1,\n                                      Abit=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp'],\n                                             FieldName='l2tpv3ControlOverUdp_1.type',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4Redirect.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 redirect报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 redirect头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Objective: Verify that the test instrument accurately counts transmitted ICMPv4 Redirect packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Modify the ICMPv4 Redirect header content of traffic stream StreamTemplate_1;;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Transmit all traffic and wait for a duration;\nTest Step 7: Stop all traffic and inspect StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4Redirect']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 redirect头部\n    edit_header_icmp_redirect(Stream=stream, Level=0,\n                              GatewayAddress='10.1.1.1', Ipv4HeaderTosDelay='1',\n                              Ipv4HeaderTTL='200', Ipv4HeaderDestination='20.1.1.2', Data='0000000000000002')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.gatewayAddress',\n                                               Value='10.1.1.1', MaxValue='10.1.1.1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.headerData.ipv4Header.tos.tos.delay',\n                                               Value='1',\n                                               MaxValue='1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.headerData.ipv4Header.ttl',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_4 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.headerData.ipv4Header.destination',\n                                               Value='20.1.1.2',\n                                               MaxValue='20.1.1.2')\n    edit_capture_filter(Port=Ports[1],Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3} && {pdu_pattern_4}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_redirect:修改测试仪表流量模板中Icmp Redirect报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports based on provided locations (e.g., '//10.0.11.191/1/3' and '//10.0.11.191/1/4').\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Build stream headers: EthernetII, IPv4, and ICMPv4Redirect.\",\n  \"Subtask 5\": \"Modify ICMPv4 Redirect header parameters: GatewayAddress='10.1.1.1', Ipv4HeaderTosDelay='1', Ipv4HeaderTTL='200', Ipv4HeaderDestination='20.1.1.2', Data='0000000000000002'.\",\n  \"Subtask 6\": \"Create four PDU patterns on the second port to filter packets based on: gatewayAddress=10.1.1.1, tos.delay=1, TTL=200, destination=20.1.1.2.\",\n  \"Subtask 7\": \"Configure packet capture filter on second port using logical AND combination of all PDU patterns.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 9\": \"Set first port's transmission mode to BURST with burst count=100.\",\n  \"Subtask 10\": \"Save current configuration to .xcfg file in designated directory.\",\n  \"Subtask 11\": \"Start packet capture on second port.\",\n  \"Subtask 12\": \"Transmit traffic from first port.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 14\": \"Stop traffic transmission.\",\n  \"Subtask 15\": \"Stop packet capture.\",\n  \"Subtask 16\": \"Download captured packets from second port to local directory with maximum 100 packets.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats for the traffic stream.\",\n  \"Subtask 18\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 19\": \"Release both reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Objective: Verify that the test instrument accurately counts transmitted ICMPv4 Redirect packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Modify the ICMPv4 Redirect header content of traffic stream StreamTemplate_1;;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Transmit all traffic and wait for a duration;\nTest Step 7: Stop all traffic and inspect StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Icmpv4Redirect']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 redirect头部\n    edit_header_icmp_redirect(Stream=stream, Level=0,\n                              GatewayAddress='10.1.1.1', Ipv4HeaderTosDelay='1',\n                              Ipv4HeaderTTL='200', Ipv4HeaderDestination='20.1.1.2', Data='0000000000000002')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.gatewayAddress',\n                                               Value='10.1.1.1', MaxValue='10.1.1.1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.headerData.ipv4Header.tos.tos.delay',\n                                               Value='1',\n                                               MaxValue='1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.headerData.ipv4Header.ttl',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_4 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv4Redirect_1.headerData.ipv4Header.destination',\n                                               Value='20.1.1.2',\n                                               MaxValue='20.1.1.2')\n    edit_capture_filter(Port=Ports[1],Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3} && {pdu_pattern_4}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_redirect:修改测试仪表流量模板中Icmp Redirect报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/pfc.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的pfc头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Objective: Check the correctness of the test instrument's traffic transmission statistics\n\nStep        :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                Step 3: Modify the PFC header content of traffic stream StreamTemplate_1;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Transmit all traffic and wait for a period;\n                Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'pfc'])\n\n    # 修改pause头部\n    attr = edit_header_pfc(Stream=stream, Level=0,\n                             OpCode='FFFF')\n    edit_modifier(Stream=stream, Attribute=attr['OpCode'],\n                  Type='Increment', Count=10, HeaderType='pfc')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for the specified product (default 'DarYu')\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) at specified locations\",\n  \"Subtask 3\": \"Create a traffic stream (StreamTemplate_1) on Port_1 with auto frame length\",\n  \"Subtask 4\": \"Add Ethernet II and PFC headers to StreamTemplate_1\",\n  \"Subtask 5\": \"Configure PFC header with Level=0 and initial OpCode='FFFF'\",\n  \"Subtask 6\": \"Apply increment modifier to PFC OpCode field with step 1 for 10 packets\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics collection\",\n  \"Subtask 8\": \"Configure Port_1 transmit mode as BURST with burst count 100\",\n  \"Subtask 9\": \"Save test configuration to file path\",\n  \"Subtask 10\": \"Start traffic transmission on all streams\",\n  \"Subtask 11\": \"Wait until all traffic transmission completes\",\n  \"Subtask 12\": \"Wait 3 seconds for statistics stabilization\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats results for StreamTemplate_1\",\n  \"Subtask 14\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames)\",\n  \"Subtask 15\": \"Verify both TxStreamFrames and RxStreamFrames equal configured burst count (100)\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Objective: Check the correctness of the test instrument's traffic transmission statistics\n\nStep        :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                Step 3: Modify the PFC header content of traffic stream StreamTemplate_1;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Transmit all traffic and wait for a period;\n                Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'pfc'])\n\n    # 修改pause头部\n    attr = edit_header_pfc(Stream=stream, Level=0,\n                             OpCode='FFFF')\n    edit_modifier(Stream=stream, Attribute=attr['OpCode'],\n                  Type='Increment', Count=10, HeaderType='pfc')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ethernet8023Raw.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ethernetii报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ethernet raw 802.3头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Purpose: Verify the test instrument accurately counts Ethernet II packet statistics\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Modify the Ethernet raw 802.3 header content of traffic stream StreamTemplate_1;\n                 Step 3: Configure filter capture;\n                 Step 4: Subscribe to StreamBlockStats statistics;\n                 Step 5: Set port transmission mode to burst packet;\n                 Step 6: Transmit all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In step 6, traffic stream StreamTemplate_1 shows equal transmitted and received packets;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Force=True)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['Raw']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ethernet raw 802.3头部\n    attribute_dict = edit_header_raw_8023(Stream=stream, Level=0, DestMacAdd='00:00:00:00:00:01',\n                                          SourceMacAdd='00:00:00:00:00:02')\n    print(attribute_dict)\n    # ethernet raw 802.3头部目的Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='raw', Attribute=attribute_dict['DestMacAdd'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # ethernet raw 802.3头部源Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='raw', Attribute=attribute_dict['SourceMacAdd'],\n                  Type='List',\n                  List=['00:00:00:00:00:02', '00:00:00:00:00:03', '00:00:00:00:00:04', '00:00:00:00:00:05'])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for the specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) at specified locations with force option.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Create a Raw header for the traffic stream to enable Ethernet II packet configuration.\",\n  \"Subtask 5\": \"Set base attributes for Raw 802.3 header: destination MAC to '00:00:00:00:00:01' and source MAC to '00:00:00:00:00:02'.\",\n  \"Subtask 6\": \"Apply increment modifier to destination MAC field (step=2, count=10) for packet variation.\",\n  \"Subtask 7\": \"Apply list modifier to source MAC field using specified MAC address list for packet variation.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view for traffic measurement.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode to burst packets with burst count set to 100.\",\n  \"Subtask 10\": \"Save test configuration to specified file path for persistence.\",\n  \"Subtask 11\": \"Start packet capture on Port_2 to monitor received traffic.\",\n  \"Subtask 12\": \"Initiate traffic transmission from Port_1.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission for statistics accumulation.\",\n  \"Subtask 14\": \"Terminate traffic transmission from Port_1.\",\n  \"Subtask 15\": \"Stop packet capture on Port_2.\",\n  \"Subtask 16\": \"Download captured packets from Port_2 to local storage for analysis.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats results for the transmitted traffic stream.\",\n  \"Subtask 18\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 19\": \"Release reserved ports to free instrument resources.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Purpose: Verify the test instrument accurately counts Ethernet II packet statistics\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Modify the Ethernet raw 802.3 header content of traffic stream StreamTemplate_1;\n                 Step 3: Configure filter capture;\n                 Step 4: Subscribe to StreamBlockStats statistics;\n                 Step 5: Set port transmission mode to burst packet;\n                 Step 6: Transmit all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In step 6, traffic stream StreamTemplate_1 shows equal transmitted and received packets;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Force=True)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['Raw']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ethernet raw 802.3头部\n    attribute_dict = edit_header_raw_8023(Stream=stream, Level=0, DestMacAdd='00:00:00:00:00:01',\n                                          SourceMacAdd='00:00:00:00:00:02')\n    print(attribute_dict)\n    # ethernet raw 802.3头部目的Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='raw', Attribute=attribute_dict['DestMacAdd'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # ethernet raw 802.3头部源Mac地址字段添加跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='raw', Attribute=attribute_dict['SourceMacAdd'],\n                  Type='List',\n                  List=['00:00:00:00:00:02', '00:00:00:00:00:03', '00:00:00:00:00:04', '00:00:00:00:00:05'])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/vntag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的vntag头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify the accuracy of traffic statistics generated by the test instrument\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the vntag header of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a duration;\n      Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packet counts for StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vntag', 'ipv4'])\n\n    # 修改vntag头部\n    attr = edit_header_vntag(Stream=stream, Level=0,\n                             Ver='11')\n    edit_modifier(Stream=stream, Attribute=attr['Ver'],\n                  Type='Increment', Count=10, HeaderType='vntag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_UP and Port_Down) using provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP and set frame length type to 'AUTO'.\",\n  \"Subtask 4\": \"Create stream headers including ethernetii, vntag, and ipv4 layers.\",\n  \"Subtask 5\": \"Modify vntag header by setting version field to 11 and configure increment modifier with count=10.\",\n  \"Subtask 6\": \"Subscribe to PortStats and StreamBlockStats statistics views.\",\n  \"Subtask 7\": \"Configure port load profile for Port_UP with burst transmit mode and burst count=100.\",\n  \"Subtask 8\": \"Save current test configuration to specified file path.\",\n  \"Subtask 9\": \"Start traffic transmission for all streams.\",\n  \"Subtask 10\": \"Wait until traffic transmission completes and streams stop.\",\n  \"Subtask 11\": \"Wait 3 seconds to ensure accurate statistics collection.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats results for the created stream.\",\n  \"Subtask 13\": \"Verify transmitted frame count equals received frame count and both match configured burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify the accuracy of traffic statistics generated by the test instrument\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the vntag header of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a duration;\n      Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packet counts for StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vntag', 'ipv4'])\n\n    # 修改vntag头部\n    attr = edit_header_vntag(Stream=stream, Level=0,\n                             Ver='11')\n    edit_modifier(Stream=stream, Attribute=attr['Ver'],\n                  Type='Increment', Count=10, HeaderType='vntag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl2helloHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify the accuracy of flow statistics from the test instrument\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream, StreamTemplate_1, on port Port_1;\n      Step 3: Modify the ISIS header content of traffic stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a duration;\n      Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'isisl2helloheader'])\n\n    header = edit_header_isis_l1l2_hello(Stream=stream,\n                                         VersionIdExtend=10,\n                                         IsIsTlv=['AreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                  'IpInterfaceAddress', 'Neighbor', 'RestartSignal', 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl2helloheader', Attribute=header['VersionIdExtend'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AreaAddress', AreaAddressEntries=2)\n\n    edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, NlPIDEntriesField=2)\n\n    edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容",
      "edit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports named Port_1 and Port_2 using reserve_port API with specified locations.\",\n  \"Subtask 2\": \"Create a traffic stream named StreamTemplate_1 on Port_1 using add_stream API.\",\n  \"Subtask 3\": \"Configure StreamTemplate_1 headers to include EthernetII and ISIS L2 Hello using create_stream_header API.\",\n  \"Subtask 4\": \"Modify ISIS header of StreamTemplate_1 by setting VersionIdExtend=10 and configuring increment modifier using edit_header_isis_l1l2_hello and edit_modifier APIs.\",\n  \"Subtask 5\": \"Edit TLV headers of StreamTemplate_1: configure AreaAddress with 2 entries, set second entry to 'ff', set Padding length=10, set AuthenticationInfo length=20, configure ProtocolSupport with 2 NLPID entries using edit_header_isis_tlv_header and related APIs.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 7\": \"Configure Port_1 transmit mode as BURST with burst count=100 using edit_port_load_profile API.\",\n  \"Subtask 8\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 9\": \"Wait for traffic transmission to complete using wait_stream_state API, then wait 3 seconds for statistics stabilization.\",\n  \"Subtask 10\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API.\",\n  \"Subtask 11\": \"Verify TxStreamFrames equals RxStreamFrames equals 100 for StreamTemplate_1.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify the accuracy of flow statistics from the test instrument\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream, StreamTemplate_1, on port Port_1;\n      Step 3: Modify the ISIS header content of traffic stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a duration;\n      Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'isisl2helloheader'])\n\n    header = edit_header_isis_l1l2_hello(Stream=stream,\n                                         VersionIdExtend=10,\n                                         IsIsTlv=['AreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                  'IpInterfaceAddress', 'Neighbor', 'RestartSignal', 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl2helloheader', Attribute=header['VersionIdExtend'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AreaAddress', AreaAddressEntries=2)\n\n    edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, NlPIDEntriesField=2)\n\n    edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容;\nedit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv3_ControlOverIp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 control over ip报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 control over ip头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Objective: Verify that the test instrument accurately counts L2TPv3 control over IP packets.\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Modify the L2TPv3 control over IP header content of traffic StreamTemplate_1;;\n      Step 3: Configure filter capture;\n      Step 4: Subscribe to StreamBlockStats statistics;;\n      Step 5: Set port transmission mode to burst mode;\n      Step 6: Send all traffic and wait for a period;\n      Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets of StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'l2tpv3ControlOverIp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3 control over ip头部\n    header = edit_header_l2tpv3_control_over_ip(Stream=stream, Level=0, SessionId='1', Type='1',\n                                                UseLength='1', ExcludeSessionLength='1', SequenceNumberNs=1, SequenceNumberNr=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header['ExcludeSessionLength'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header['SequenceNumberNs'],\n                  Type='Increment', Count=10)\n\n    # 增加l2tpv3 control over ip选项并修改\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=0, Types='generalTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=1, Types='messageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=2, Types='resultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['ErrorMessage'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=3, Types='tieBreaker', TieBreakerValue='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['TieBreakerValue'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=4, Types='receiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=5, Types='callSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=6, Types='physicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=7, Types='circuitError', AlignmentOverruns='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['AlignmentOverruns'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=8, Types='routeId', RouteId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['RouteId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=9, Types='assignedConnection', ConnectionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['ConnectionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=10, Types='localSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=11, Types='remoteSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=12, Types='assignedCookie', Cookie4Byte='00000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['Cookie4Byte'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=13, Types='pwType', PwType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['PwType'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=14, Types='l2SpecificSub', L2SpecificSublayer='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['L2SpecificSublayer'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=15, Types='dataSequencing', DataSequencing='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['DataSequencing'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=16, Types='txConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=17, Types='rxConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=18, Types='circuitStatus', Nbit='1', Abit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['Nbit'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3ControlOverIp_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with product specification (default: 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports at specified locations (default: '//10.0.11.191/1/5' and '//10.0.11.191/1/6').\",\n  \"Subtask 3\": \"Create a new traffic stream on the first reserved port with frame length type set to 'AUTO'.\",\n  \"Subtask 4\": \"Build the stream header structure with layers: EthernetII → IPv4 → L2TPv3 Control over IP.\",\n  \"Subtask 5\": \"Modify the L2TPv3 control header attributes: set Session ID, Type, Length flags, and sequence numbers.\",\n  \"Subtask 6\": \"Apply increment modifiers to specific L2TPv3 header fields (ExcludeSessionLength, SequenceNumberNs) with count=10.\",\n  \"Subtask 7\": \"Add and configure L2TPv3 control options (generalTLV, messageType, resultCode) with respective attributes.\",\n  \"Subtask 8\": \"Apply increment modifiers to L2TPv3 option fields (AttributeValue, MessageType, ErrorCode, ErrorMessage) with count=10.\",\n  \"Subtask 9\": \"Create a PDU capture pattern on the second port filtering for L2TPv3 type=1 packets.\",\n  \"Subtask 10\": \"Apply the PDU pattern as a capture filter expression on the second port.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 12\": \"Configure the first port's transmission mode to burst mode with burst count=100.\",\n  \"Subtask 13\": \"Save the current test configuration to an .xcfg file.\",\n  \"Subtask 14\": \"Start packet capture on the second port.\",\n  \"Subtask 15\": \"Transmit the configured traffic stream from the first port.\",\n  \"Subtask 16\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 17\": \"Stop traffic transmission.\",\n  \"Subtask 18\": \"Stop packet capture and wait 3 seconds for processing.\",\n  \"Subtask 19\": \"Download captured packets from the second port to local storage.\",\n  \"Subtask 20\": \"Retrieve StreamBlockStats results for the transmitted stream.\",\n  \"Subtask 21\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 22\": \"Release all reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Objective: Verify that the test instrument accurately counts L2TPv3 control over IP packets.\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Modify the L2TPv3 control over IP header content of traffic StreamTemplate_1;;\n      Step 3: Configure filter capture;\n      Step 4: Subscribe to StreamBlockStats statistics;;\n      Step 5: Set port transmission mode to burst mode;\n      Step 6: Send all traffic and wait for a period;\n      Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets of StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'l2tpv3ControlOverIp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3 control over ip头部\n    header = edit_header_l2tpv3_control_over_ip(Stream=stream, Level=0, SessionId='1', Type='1',\n                                                UseLength='1', ExcludeSessionLength='1', SequenceNumberNs=1, SequenceNumberNr=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header['ExcludeSessionLength'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header['SequenceNumberNs'],\n                  Type='Increment', Count=10)\n\n    # 增加l2tpv3 control over ip选项并修改\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=0, Types='generalTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=1, Types='messageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=2, Types='resultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['ErrorMessage'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=3, Types='tieBreaker', TieBreakerValue='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['TieBreakerValue'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=4, Types='receiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=5, Types='callSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=6, Types='physicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=7, Types='circuitError', AlignmentOverruns='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['AlignmentOverruns'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=8, Types='routeId', RouteId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['RouteId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=9, Types='assignedConnection', ConnectionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['ConnectionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=10, Types='localSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=11, Types='remoteSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=12, Types='assignedCookie', Cookie4Byte='00000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['Cookie4Byte'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=13, Types='pwType', PwType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['PwType'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=14, Types='l2SpecificSub', L2SpecificSublayer='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['L2SpecificSublayer'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=15, Types='dataSequencing', DataSequencing='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['DataSequencing'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=16, Types='txConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=17, Types='rxConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=18, Types='circuitStatus', Nbit='1', Abit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverIp', Attribute=header_option['Nbit'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3ControlOverIp_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv3Report.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发igmpv3 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的igmpv3 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective\t:\tTest Objective: Verify that the test instrument correctly counts transmitted igmpv3 report packets\n\nStep\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n\t\tStep 2: Modify the igmpv3 report header content in traffic StreamTemplate_1;;\n\t\tStep 3: Configure filtered packet capture;\n\t\tStep 4: Subscribe to StreamBlockStats;;\n\t\tStep 5: Set port transmission mode to burst;\n\t\tStep 6: Send all traffic and wait for a period;\n\t\tStep 7: Stop all traffic and check StreamBlockStats statistics;;\n\nCriteria\t:\tExpected Result 1: In Step 6, traffic StreamTemplate_1 shows equal transmit/receive packets;\n\nCreated by\t:\tTester-004\n\nBugs\t\t:\tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv3report']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    header = edit_header_igmpv3_report(Stream=stream, Level=0,\n                                       Type=99, Reserved1='ff', Checksum='ffff',\n                                       NumGroupRecords=2)\n    group = edit_header_igmpv3_group_records(Stream=stream, Level=0, Index=1,\n                                             SourceAddressList=['1.1.1.1', '2.2.2.2'],\n                                             ExceedauxDataList=['10203040', '50607080'],\n                                             MulticastAddress='224.0.0.1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3report',\n                  Attribute=group['SourceAddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3report',\n                  Attribute=group['ExceedauxDataList: 50607080'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3report',\n                  Attribute=group['MulticastAddress'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Report_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Report_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Report_1.Reserved1',\n                                               Value='ff',\n                                               MaxValue='ff')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv3_group_records:修改测试仪表流量模板中IGMPv3 Report报文头部Group Records内容",
      "edit_header_igmpv3_report:修改测试仪表流量模板中IGMPv2 Report报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform for network testing.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using specified locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Build stream headers: EthernetII → IPv4 → IGMPv3 Report.\",\n  \"Subtask 5\": \"Modify IGMPv3 Report header: Type=99, Reserved1=ff, Checksum=ffff, NumGroupRecords=2.\",\n  \"Subtask 6\": \"Edit IGMPv3 Group Records: SourceAddressList=[1.1.1.1,2.2.2.2], ExceedauxDataList=[10203040,50607080], MulticastAddress=224.0.0.1.\",\n  \"Subtask 7\": \"Apply increment modifier to SourceAddressList field (2.2.2.2) with count=10.\",\n  \"Subtask 8\": \"Apply increment modifier to ExceedauxDataList field (50607080) with count=10.\",\n  \"Subtask 9\": \"Apply increment modifier to MulticastAddress field with count=10.\",\n  \"Subtask 10\": \"Create capture PDU pattern on Port_2 for IGMPv3 Report type=99.\",\n  \"Subtask 11\": \"Create capture PDU pattern on Port_2 for IGMPv3 Report Checksum=ffff.\",\n  \"Subtask 12\": \"Create capture PDU pattern on Port_2 for IGMPv3 Report Reserved1=ff.\",\n  \"Subtask 13\": \"Configure capture filter on Port_2 using logical AND of all three PDU patterns.\",\n  \"Subtask 14\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 15\": \"Set Port_1 transmission mode to BURST with burst count=100.\",\n  \"Subtask 16\": \"Save test configuration to file.\",\n  \"Subtask 17\": \"Start packet capture on Port_2.\",\n  \"Subtask 18\": \"Start traffic transmission on Port_1.\",\n  \"Subtask 19\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 20\": \"Stop traffic transmission on Port_1.\",\n  \"Subtask 21\": \"Stop packet capture on Port_2.\",\n  \"Subtask 22\": \"Download captured packets from Port_2 to local storage.\",\n  \"Subtask 23\": \"Retrieve StreamBlockStats for the created traffic stream.\",\n  \"Subtask 24\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 25\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective\t:\tTest Objective: Verify that the test instrument correctly counts transmitted igmpv3 report packets\n\nStep\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n\t\tStep 2: Modify the igmpv3 report header content in traffic StreamTemplate_1;;\n\t\tStep 3: Configure filtered packet capture;\n\t\tStep 4: Subscribe to StreamBlockStats;;\n\t\tStep 5: Set port transmission mode to burst;\n\t\tStep 6: Send all traffic and wait for a period;\n\t\tStep 7: Stop all traffic and check StreamBlockStats statistics;;\n\nCriteria\t:\tExpected Result 1: In Step 6, traffic StreamTemplate_1 shows equal transmit/receive packets;\n\nCreated by\t:\tTester-004\n\nBugs\t\t:\tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv3report']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    header = edit_header_igmpv3_report(Stream=stream, Level=0,\n                                       Type=99, Reserved1='ff', Checksum='ffff',\n                                       NumGroupRecords=2)\n    group = edit_header_igmpv3_group_records(Stream=stream, Level=0, Index=1,\n                                             SourceAddressList=['1.1.1.1', '2.2.2.2'],\n                                             ExceedauxDataList=['10203040', '50607080'],\n                                             MulticastAddress='224.0.0.1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3report',\n                  Attribute=group['SourceAddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3report',\n                  Attribute=group['ExceedauxDataList: 50607080'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='igmpv3report',\n                  Attribute=group['MulticastAddress'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Report_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Report_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv3Report_1.Reserved1',\n                                               Value='ff',\n                                               MaxValue='ff')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv3_group_records:修改测试仪表流量模板中IGMPv3 Report报文头部Group Records内容;\nedit_header_igmpv3_report:修改测试仪表流量模板中IGMPv2 Report报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/PppoeDiscovery.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Pppoe头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Purpose: Verify the test instrument's flow transmission statistics are correct\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the PPPoE header content of traffic stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Send all traffic and wait for a period;\n                   Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-002\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['pppoediscovery'])\n\n    # 修改Pppoe头部\n    attr = edit_header_pppoe_discovery(Stream=stream, Level=0,\n                                       SessionId=10,\n                                       EndOfListTag=1,\n                                       RelaySessionIdTag=1)\n    edit_modifier(Stream=stream, Attribute=attr['SessionId'],\n                  Type='Increment', Count=10, HeaderType='pppoediscovery')\n\n    end_of_list_attr = edit_header_pppoe_discovery_end_of_list_tag(Stream=stream,\n                                                                   Length=10)\n    edit_modifier(Stream=stream, Attribute=end_of_list_attr['Length'],\n                  Type='Increment', Count=10, HeaderType='pppoediscovery')\n\n    relay_session_id_attr = edit_header_pppoe_discovery_relay_session_id_tag(Stream=stream,\n                                                                             TagIndex=1,\n                                                                             Value='102030')\n    edit_modifier(Stream=stream, Attribute=relay_session_id_attr['Value'],\n                  Type='Increment', Count=10, HeaderType='pppoediscovery')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with product type 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) from specified locations using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 using add_stream API.\",\n  \"Subtask 4\": \"Create a PPPoE header for the traffic stream using create_stream_header API with header type 'pppoediscovery'.\",\n  \"Subtask 5\": \"Modify PPPoE SessionID attribute with increment modifier (start:10, step:10, count:10) using edit_modifier API.\",\n  \"Subtask 6\": \"Modify PPPoE EndOfListTag Length attribute with increment modifier (start:10, step:10, count:10) using edit_modifier API.\",\n  \"Subtask 7\": \"Modify PPPoE RelaySessionIdTag Value attribute with increment modifier (start:'102030', step:10, count:10) using edit_modifier API.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 9\": \"Configure port load profile for Port_1 with burst transmit mode and burst count 100 using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 11\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 12\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 13\": \"Wait 3 seconds after traffic stops to ensure statistics accuracy.\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats results for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 15\": \"Verify transmitted packet count (TxStreamFrames) equals received packet count (RxStreamFrames) and both equal 100.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Purpose: Verify the test instrument's flow transmission statistics are correct\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the PPPoE header content of traffic stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Send all traffic and wait for a period;\n                   Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-002\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['pppoediscovery'])\n\n    # 修改Pppoe头部\n    attr = edit_header_pppoe_discovery(Stream=stream, Level=0,\n                                       SessionId=10,\n                                       EndOfListTag=1,\n                                       RelaySessionIdTag=1)\n    edit_modifier(Stream=stream, Attribute=attr['SessionId'],\n                  Type='Increment', Count=10, HeaderType='pppoediscovery')\n\n    end_of_list_attr = edit_header_pppoe_discovery_end_of_list_tag(Stream=stream,\n                                                                   Length=10)\n    edit_modifier(Stream=stream, Attribute=end_of_list_attr['Length'],\n                  Type='Increment', Count=10, HeaderType='pppoediscovery')\n\n    relay_session_id_attr = edit_header_pppoe_discovery_relay_session_id_tag(Stream=stream,\n                                                                             TagIndex=1,\n                                                                             Value='102030')\n    edit_modifier(Stream=stream, Attribute=relay_session_id_attr['Value'],\n                  Type='Increment', Count=10, HeaderType='pppoediscovery')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Arp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发arp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的arp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Purpose: Verify the accuracy of ARP packet statistics transmitted by the test instrument\n\nStep         :   Step 1: Reserve two loopback ports Port_1, Port_2;\n                 Step 2: Modify the ARP header of traffic StreamTemplate_1;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Send all traffic and wait;\n                 Step 7: Stop all traffic and check StreamBlockStats;\n\nCriteria     :   Expected Result 1: In Step 6, traffic StreamTemplate_1 shows equal packets sent/received;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ARP']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改arp头部\n    attribute_dict = edit_header_arp(Stream=stream, Level=0, SendMac='00:00:00:00:00:01',\n                                     SendIpv4='192.168.0.2', TargetIpv4='192.168.0.1')\n    # arp头部SendMac字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='arp', Attribute=attribute_dict['SendMac'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # arp头部目SendIpv4字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='arp', Attribute=attribute_dict['SendIpv4'],\n                  Type='List',\n                  List=['192.168.0.2', '192.168.0.5', '192.168.0.3'])\n    # arp头部目TargetIpv4字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='arp', Attribute=attribute_dict['TargetIpv4'],\n                  Type='Random',\n                  Range='200.168.0.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='arp_1.sendIpv4',\n                                               Value='192.168.0.2', MaxValue='192.168.0.2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='arp_1.sendMac',\n                                               Value='00:00:00:00:00:01',\n                                               MaxValue='00:00:00:00:00:01')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_arp:修改测试仪表流量模板中ARP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports at given locations (e.g., '//10.0.11.191/1/5' and '//10.0.11.191/1/6') for loopback testing.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers with EthernetII and ARP protocol layers.\",\n  \"Subtask 5\": \"Modify ARP header fields: set SendMac to '00:00:00:00:00:01', SendIpv4 to '192.168.0.2', and TargetIpv4 to '192.168.0.1'.\",\n  \"Subtask 6\": \"Apply increment modifier to ARP SendMac field (count=10, step=2).\",\n  \"Subtask 7\": \"Apply list modifier to ARP SendIpv4 field with values ['192.168.0.2','192.168.0.5','192.168.0.3'].\",\n  \"Subtask 8\": \"Apply random modifier to ARP TargetIpv4 field within range '200.168.0.1'.\",\n  \"Subtask 9\": \"Create capture PDU patterns on the second port: first pattern matching ARP sendIpv4='192.168.0.2', second pattern matching ARP sendMac='00:00:00:00:00:01'.\",\n  \"Subtask 10\": \"Configure packet capture filter on second port using logical AND expression combining both PDU patterns.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 12\": \"Configure first port's transmission mode as burst with burst count=100.\",\n  \"Subtask 13\": \"Save test configuration to specified file path.\",\n  \"Subtask 14\": \"Start packet capture on second port.\",\n  \"Subtask 15\": \"Initiate traffic transmission from first port.\",\n  \"Subtask 16\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 17\": \"Stop traffic transmission and packet capture.\",\n  \"Subtask 18\": \"Download captured packets from second port to local storage.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats results for the transmitted stream.\",\n  \"Subtask 20\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 21\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Purpose: Verify the accuracy of ARP packet statistics transmitted by the test instrument\n\nStep         :   Step 1: Reserve two loopback ports Port_1, Port_2;\n                 Step 2: Modify the ARP header of traffic StreamTemplate_1;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Send all traffic and wait;\n                 Step 7: Stop all traffic and check StreamBlockStats;\n\nCriteria     :   Expected Result 1: In Step 6, traffic StreamTemplate_1 shows equal packets sent/received;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ARP']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改arp头部\n    attribute_dict = edit_header_arp(Stream=stream, Level=0, SendMac='00:00:00:00:00:01',\n                                     SendIpv4='192.168.0.2', TargetIpv4='192.168.0.1')\n    # arp头部SendMac字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='arp', Attribute=attribute_dict['SendMac'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # arp头部目SendIpv4字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='arp', Attribute=attribute_dict['SendIpv4'],\n                  Type='List',\n                  List=['192.168.0.2', '192.168.0.5', '192.168.0.3'])\n    # arp头部目TargetIpv4字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='arp', Attribute=attribute_dict['TargetIpv4'],\n                  Type='Random',\n                  Range='200.168.0.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='arp_1.sendIpv4',\n                                               Value='192.168.0.2', MaxValue='192.168.0.2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='arp_1.sendMac',\n                                               Value='00:00:00:00:00:01',\n                                               MaxValue='00:00:00:00:00:01')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_arp:修改测试仪表流量模板中ARP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahCustomerStagEthernet.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify the accuracy of traffic transmission statistics on the test instrument\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream StreamTemplate_1 on Port_1;\n      Step 3: Modify the 802.1ah header content of StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and check StreamBlockStats;\n\nCriteria: Expected Result 1: In Step 6, received and transmitted packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['sTag', 'ipv4'])\n\n    # 修改Customer Stag Ethernet头部\n    attr = edit_header_8021ah_CustomerStagEthernet(Stream=stream, Level=0,\n                                                   Vid='101010101010')\n    edit_modifier(Stream=stream, Attribute=attr['Vid'],\n                  Type='Increment', Count=10, HeaderType='sTag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using reserve_port API with provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 using add_stream API.\",\n  \"Subtask 4\": \"Create stream headers for the traffic stream with sTag and ipv4 types using create_stream_header API.\",\n  \"Subtask 5\": \"Modify the 802.1ah header by editing the VLAN ID (Vid) field in Customer Stag Ethernet header and configure increment modifier using edit_modifier API.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats and PortStats using subscribe_result API.\",\n  \"Subtask 7\": \"Configure port load profile for Port_1 to burst mode with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 8\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 9\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 10\": \"Wait for traffic to complete transmission using wait_stream_state API, then wait 3 seconds for statistics stabilization.\",\n  \"Subtask 11\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API and verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify the accuracy of traffic transmission statistics on the test instrument\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream StreamTemplate_1 on Port_1;\n      Step 3: Modify the 802.1ah header content of StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and check StreamBlockStats;\n\nCriteria: Expected Result 1: In Step 6, received and transmitted packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['sTag', 'ipv4'])\n\n    # 修改Customer Stag Ethernet头部\n    attr = edit_header_8021ah_CustomerStagEthernet(Stream=stream, Level=0,\n                                                   Vid='101010101010')\n    edit_modifier(Stream=stream, Attribute=attr['Vid'],\n                  Type='Increment', Count=10, HeaderType='sTag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Authentication.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Authentication头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Objective: Verify the test instrument's IPv6 packet statistics accuracy\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n     Test Step 2: Modify the IPv6 Authentication header content in traffic StreamTemplate_1;\n     Test Step 3: Configure packet capture filtering;\n     Test Step 4: Subscribe to StreamBlockStats statistics;\n     Test Step 5: Set port transmission mode to burst mode;\n     Test Step 6: Transmit all traffic and wait for a period;\n     Test Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6authenticationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_authentication(Stream=stream, AuthData='abcd')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6authenticationheader', Attribute=attr['AuthData'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with product specification (default 'DarYu').\",\n  \"Subtask 2\": \"Reserve two loopback ports at specified locations (default '//10.0.11.191/1/5' and '//10.0.11.191/1/6').\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Build stream headers: EthernetII → IPv6 → IPv6 Authentication Header.\",\n  \"Subtask 5\": \"Modify IPv6 Authentication Header's AuthData field to base value 'abcd'.\",\n  \"Subtask 6\": \"Configure increment modifier for AuthData field: step=2, count=10 packets.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 8\": \"Configure port transmission mode as burst mode with burst count=100 packets.\",\n  \"Subtask 9\": \"Save test configuration to specified file path.\",\n  \"Subtask 10\": \"Start traffic transmission and capture.\",\n  \"Subtask 11\": \"Wait 10 seconds for traffic transmission and statistics collection.\",\n  \"Subtask 12\": \"Stop traffic transmission and statistics capture.\",\n  \"Subtask 13\": \"Wait 3 seconds for final statistics processing.\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats results for the created stream.\",\n  \"Subtask 15\": \"Extract transmitted (TxStreamFrames) and received (RxStreamFrames) packet counts.\",\n  \"Subtask 16\": \"Verify TxStreamFrames equals RxStreamFrames for packet count accuracy.\",\n  \"Subtask 17\": \"Release all reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Objective: Verify the test instrument's IPv6 packet statistics accuracy\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n     Test Step 2: Modify the IPv6 Authentication header content in traffic StreamTemplate_1;\n     Test Step 3: Configure packet capture filtering;\n     Test Step 4: Subscribe to StreamBlockStats statistics;\n     Test Step 5: Set port transmission mode to burst mode;\n     Test Step 6: Transmit all traffic and wait for a period;\n     Test Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6authenticationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_authentication(Stream=stream, AuthData='abcd')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6authenticationheader', Attribute=attr['AuthData'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6Neighboradvertise.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 neighbor advertise报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 neighbor advertise头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify that the test instrument correctly counts transmitted ICMPv6 Neighbor Advertisement packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n     Test Step 2: Modify the ICMPv6 Neighbor Advertisement header content of traffic stream StreamTemplate_1;;\n     Test Step 3: Configure filtered packet capture;\n     Test Step 4: Subscribe to StreamBlockStats statistics;;\n     Test Step 5: Set port transmission mode to burst;\n     Test Step 6: Transmit all traffic and wait for a period;;\n     Test Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'NeighborAdvertise']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_neighbor_advertise(Stream=stream, Level=0,\n                                                   Type='143',Checksum='0000',\n                                                   HeaderOption=['OptionSourceLinkLayerAddress', 'OptionMTU'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='NeighborAdvertise', Attribute=header['Checksum'],\n                  Type='Increment', Count=10)\n\n    option = edit_header_icmpv6_header_option(Stream=stream, Header='neighboradvertise',\n                                              Option='OptionSourceLinkLayerAddress',\n                                              Address='22:22:22:22:22:22')\n    edit_modifier(Stream=stream, Level=0, HeaderType='NeighborAdvertise', Attribute=option['Address'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='neighborAdvertise_1.type',\n                                               Value='143', MaxValue='143')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='neighborAdvertise_1.checksum',\n                                               Value='0000', MaxValue='0000')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_header_option:修改测试仪表流量模板中ICMPv6报文头部Header Option内容",
      "edit_header_icmpv6_neighbor_advertise:修改测试仪表流量模板中Icmpv6 Neighbor Advertise报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports at given locations for loopback testing.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv6, and ICMPv6 Neighbor Advertisement.\",\n  \"Subtask 5\": \"Modify ICMPv6 Neighbor Advertisement header fields: set Type to '143', Checksum to '0000', and include HeaderOption 'OptionSourceLinkLayerAddress' and 'OptionMTU'.\",\n  \"Subtask 6\": \"Apply increment modifiers to Checksum field (step count: 10) in Neighbor Advertisement header.\",\n  \"Subtask 7\": \"Apply increment modifiers to Source Link-Layer Address field (step count: 10) in ICMPv6 Header Option.\",\n  \"Subtask 8\": \"Create PDU patterns on the second port for capture filtering: one matching Neighbor Advertisement Type=143, another matching Checksum=0000.\",\n  \"Subtask 9\": \"Configure packet capture filter on second port using logical AND of both PDU patterns.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 11\": \"Set transmission mode on first port to BURST with burst count of 100 packets.\",\n  \"Subtask 12\": \"Save test configuration to specified file path.\",\n  \"Subtask 13\": \"Start packet capture on second port.\",\n  \"Subtask 14\": \"Initiate traffic transmission from first port.\",\n  \"Subtask 15\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 16\": \"Stop traffic transmission.\",\n  \"Subtask 17\": \"Stop packet capture.\",\n  \"Subtask 18\": \"Download captured packets from second port to local storage.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats for the traffic stream and verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 20\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify that the test instrument correctly counts transmitted ICMPv6 Neighbor Advertisement packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n     Test Step 2: Modify the ICMPv6 Neighbor Advertisement header content of traffic stream StreamTemplate_1;;\n     Test Step 3: Configure filtered packet capture;\n     Test Step 4: Subscribe to StreamBlockStats statistics;;\n     Test Step 5: Set port transmission mode to burst;\n     Test Step 6: Transmit all traffic and wait for a period;;\n     Test Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'NeighborAdvertise']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_neighbor_advertise(Stream=stream, Level=0,\n                                                   Type='143',Checksum='0000',\n                                                   HeaderOption=['OptionSourceLinkLayerAddress', 'OptionMTU'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='NeighborAdvertise', Attribute=header['Checksum'],\n                  Type='Increment', Count=10)\n\n    option = edit_header_icmpv6_header_option(Stream=stream, Header='neighboradvertise',\n                                              Option='OptionSourceLinkLayerAddress',\n                                              Address='22:22:22:22:22:22')\n    edit_modifier(Stream=stream, Level=0, HeaderType='NeighborAdvertise', Attribute=option['Address'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='neighborAdvertise_1.type',\n                                               Value='143', MaxValue='143')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='neighborAdvertise_1.checksum',\n                                               Value='0000', MaxValue='0000')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_header_option:修改测试仪表流量模板中ICMPv6报文头部Header Option内容;\nedit_header_icmpv6_neighbor_advertise:修改测试仪表流量模板中Icmpv6 Neighbor Advertise报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6MLDv1Query.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv1 query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv1 query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Check that the test instrument accurately counts sent and received packets for icmpv6 mldv1 query messages\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Modify the icmpv6 mldv1 query header content in traffic stream StreamTemplate_1;;\n      Step 3: Configure filtered packet capture;;\n      Step 4: Subscribe to StreamBlockStats;;\n      Step 5: Set port transmission mode to burst;;\n      Step 6: Transmit all traffic streams and wait for a period;;\n      Step 7: Stop all traffic streams and check StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In Step 6, the sent and received packet counts for traffic stream StreamTemplate_1 should be equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv1query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv6 mldv1query头部\n    edit_header_icmpv6_mldv1_query(Stream=stream, Level=0,\n                          Code='2',Reserved='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Query_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Query_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Query_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_mldv1_query:修改测试仪表流量模板中Icmpv6 Mldv1 Query报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with specified product configuration (default: DarYu).\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) at specified locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Configure the traffic stream headers: EthernetII, IPv6, and MLDv1 Query.\",\n  \"Subtask 5\": \"Modify the MLDv1 Query header fields: set Code to '2', Reserved to '10', and Multicast Address to 'FF1E::1'.\",\n  \"Subtask 6\": \"Create three PDU patterns on Port_2 for capture filtering: matching MLDv1 Query Code=2, Reserved=10, and Multicast Address='FF1E::1'.\",\n  \"Subtask 7\": \"Configure packet capture filter on Port_2 using logical AND combination of the three PDU patterns.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view for monitoring.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode as burst with burst count set to 100 packets.\",\n  \"Subtask 10\": \"Start packet capture on Port_2.\",\n  \"Subtask 11\": \"Start traffic stream transmission on Port_1.\",\n  \"Subtask 12\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 13\": \"Stop traffic stream transmission on Port_1.\",\n  \"Subtask 14\": \"Stop packet capture on Port_2.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats results for the transmitted traffic stream.\",\n  \"Subtask 16\": \"Extract transmitted frame count (TxStreamFrames) and received frame count (RxStreamFrames) from statistics.\",\n  \"Subtask 17\": \"Verify that transmitted frame count equals received frame count.\",\n  \"Subtask 18\": \"Release both reserved ports (Port_1 and Port_2).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Check that the test instrument accurately counts sent and received packets for icmpv6 mldv1 query messages\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Modify the icmpv6 mldv1 query header content in traffic stream StreamTemplate_1;;\n      Step 3: Configure filtered packet capture;;\n      Step 4: Subscribe to StreamBlockStats;;\n      Step 5: Set port transmission mode to burst;;\n      Step 6: Transmit all traffic streams and wait for a period;;\n      Step 7: Stop all traffic streams and check StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In Step 6, the sent and received packet counts for traffic stream StreamTemplate_1 should be equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv1query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv6 mldv1query头部\n    edit_header_icmpv6_mldv1_query(Stream=stream, Level=0,\n                          Code='2',Reserved='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Query_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Query_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Query_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_mldv1_query:修改测试仪表流量模板中Icmpv6 Mldv1 Query报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Hdlc.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Hdlc头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of the test instrument's traffic generation statistics\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports Port_1 and Port_2;\n                   Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the Hdlc header content of stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Transmit all traffic and wait for a duration;\n                   Step 6: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-002\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['chdlc', 'ipv4'])\n\n    # 修改Hdlc头部\n    attr = edit_header_hdlc(Stream=stream, Level=0,\n                            Address='FF')\n    edit_modifier(Stream=stream, Attribute=attr['Address'],\n                  Type='Increment', Count=10, HeaderType='chdlc')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for the specified product (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two loopback ports using provided locations and assign as Port_1 (source) and Port_2 (destination).\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1.\",\n  \"Subtask 4\": \"Configure the stream headers to include HDLC and IPv4 protocols.\",\n  \"Subtask 5\": \"Modify the HDLC header by setting the Address field to 'FF' at level 0.\",\n  \"Subtask 6\": \"Apply an increment modifier to the HDLC Address field with count=10.\",\n  \"Subtask 7\": \"Subscribe to PortStats and StreamBlockStats statistics views.\",\n  \"Subtask 8\": \"Configure Port_1's load profile with burst transmit mode and burst count=100.\",\n  \"Subtask 9\": \"Save the current test configuration to a file.\",\n  \"Subtask 10\": \"Start traffic transmission on all streams.\",\n  \"Subtask 11\": \"Wait until traffic transmission completes and streams stop.\",\n  \"Subtask 12\": \"Wait 3 seconds for statistics stabilization.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats results for the created stream.\",\n  \"Subtask 14\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames) and both equal the configured burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of the test instrument's traffic generation statistics\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports Port_1 and Port_2;\n                   Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the Hdlc header content of stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Transmit all traffic and wait for a duration;\n                   Step 6: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-002\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['chdlc', 'ipv4'])\n\n    # 修改Hdlc头部\n    attr = edit_header_hdlc(Stream=stream, Level=0,\n                            Address='FF')\n    edit_modifier(Stream=stream, Attribute=attr['Address'],\n                  Type='Increment', Count=10, HeaderType='chdlc')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Trill.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的trill头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Purpose: Verify the correctness of flow statistics from the test instrument\n\nStep        :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                Step 2: Create a traffic stream, StreamTemplate_1, on port Port_1;\n                Step 3: Modify the trill header content of stream StreamTemplate_1;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Send all traffic and wait for a period of time;\n                Step 6: Stop all traffic and check the StreamBlockStats statistics;\n\nCriteria    :   Expected Result 1: In step 6, the transmitted and received packets of stream StreamTemplate_1 are equal;\n\nCreated by  :   Tester-002\n\nBugs        :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'trill'])\n\n    # 修改trill头部\n    attr = edit_header_trill(Stream=stream, Level=0,\n                             EgressRBridge=1000, IngressBridge=2000)\n    edit_modifier(Stream=stream, Attribute=attr['IngressBridge'],\n                  Type='Increment', Count=10, HeaderType='trill')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (default 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at provided locations using reserve_port API, assigning them as Port_UP and Port_Down with Force=True.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API.\",\n  \"Subtask 4\": \"Create stream headers including Ethernet II and TRILL using create_stream_header API.\",\n  \"Subtask 5\": \"Modify TRILL header's IngressBridge field with increment modifier (start=2000, step=1, count=10) using edit_modifier API.\",\n  \"Subtask 6\": \"Subscribe to PortStats and StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 7\": \"Configure port load profile for Port_UP: set TransmitMode='BURST' and BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 8\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 9\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 10\": \"Wait for traffic to complete transmission using wait_stream_state API.\",\n  \"Subtask 11\": \"Wait 3 seconds after traffic stops to ensure statistics collection.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats for the stream using get_streamblock_statistic API.\",\n  \"Subtask 13\": \"Verify TxStreamFrames equals RxStreamFrames and both equal the configured BurstCount (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Purpose: Verify the correctness of flow statistics from the test instrument\n\nStep        :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                Step 2: Create a traffic stream, StreamTemplate_1, on port Port_1;\n                Step 3: Modify the trill header content of stream StreamTemplate_1;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Send all traffic and wait for a period of time;\n                Step 6: Stop all traffic and check the StreamBlockStats statistics;\n\nCriteria    :   Expected Result 1: In step 6, the transmitted and received packets of stream StreamTemplate_1 are equal;\n\nCreated by  :   Tester-002\n\nBugs        :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'trill'])\n\n    # 修改trill头部\n    attr = edit_header_trill(Stream=stream, Level=0,\n                             EgressRBridge=1000, IngressBridge=2000)\n    edit_modifier(Stream=stream, Attribute=attr['IngressBridge'],\n                  Type='Increment', Count=10, HeaderType='trill')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahEncapsulatedBackboneEthernet.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     :   Test Objective: Verify the accuracy of the test instrument's traffic transmission statistics\n\nStep          :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                  Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                  Step 3: Modify the 802.1ah header content of stream StreamTemplate_1;\n                  Step 4: Subscribe to StreamBlockStats statistics;\n                  Step 5: Transmit all traffic and wait for a period;\n                  Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In step 6, packets sent and received for stream StreamTemplate_1 are equal;\n\nCreated by    :   Tester-002\n\nBugs          :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['encapbackboneeth', 'ipv4'])\n\n    # 修改Encapsulated Mac-in-Mac头部\n    attr = edit_header_8021ah_EncapsulatedBackboneEthernet(Stream=stream, Level=0,\n                                                           Vid=200)\n    edit_modifier(Stream=stream, Attribute=attr['Vid'],\n                  Type='Increment', Count=10, HeaderType='encapbackboneeth')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream (StreamTemplate_1) on Port_1.\",\n  \"Subtask 4\": \"Configure the stream header for StreamTemplate_1 with 'encapbackboneeth' and 'ipv4' header types.\",\n  \"Subtask 5\": \"Modify the 802.1ah header (EncapsulatedBackboneEthernet) of StreamTemplate_1 by setting initial VLAN ID (Vid=200).\",\n  \"Subtask 6\": \"Apply increment modifier to the VLAN ID field (Vid) with step=1 and count=10.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics collection.\",\n  \"Subtask 8\": \"Configure port load profile for Port_1 with burst transmit mode and specified burst count (e.g., 100 packets).\",\n  \"Subtask 9\": \"Start traffic transmission for all streams.\",\n  \"Subtask 10\": \"Wait until traffic transmission completes and stream state stops.\",\n  \"Subtask 11\": \"Pause for 3 seconds to ensure statistics stabilization.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats results for StreamTemplate_1.\",\n  \"Subtask 13\": \"Verify that transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) for StreamTemplate_1.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     :   Test Objective: Verify the accuracy of the test instrument's traffic transmission statistics\n\nStep          :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                  Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                  Step 3: Modify the 802.1ah header content of stream StreamTemplate_1;\n                  Step 4: Subscribe to StreamBlockStats statistics;\n                  Step 5: Transmit all traffic and wait for a period;\n                  Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In step 6, packets sent and received for stream StreamTemplate_1 are equal;\n\nCreated by    :   Tester-002\n\nBugs          :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['encapbackboneeth', 'ipv4'])\n\n    # 修改Encapsulated Mac-in-Mac头部\n    attr = edit_header_8021ah_EncapsulatedBackboneEthernet(Stream=stream, Level=0,\n                                                           Vid=200)\n    edit_modifier(Stream=stream, Attribute=attr['Vid'],\n                  Type='Increment', Count=10, HeaderType='encapbackboneeth')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Fcoe.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的ELS FLOGI头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective      : Verify the accuracy of traffic transmission statistics from the test instrument\n\nStep           : Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                Step 3: Modify the ELS FLOGI header content of StreamTemplate_1;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Transmit all traffic and wait for a period;\n                Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria       : Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by     : Tester-002\n\nBugs           : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['elsflogi'])\n\n    # 修改ELS FLOGI头部\n    attr = edit_header_els_flogi(Stream=stream, Level=0,\n                                 Bbscn=255)\n    edit_modifier(Stream=stream, Attribute=attr['Bbscn'],\n                  Type='Increment', Count=10, HeaderType='elsflogi')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product type (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two loopback ports using provided locations and assign them as Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP and configure its frame length type to 'AUTO'.\",\n  \"Subtask 4\": \"Add an ELS FLOGI header to the traffic stream.\",\n  \"Subtask 5\": \"Modify the Bbscn field in the ELS FLOGI header to start at 255 with increment modifier (step 1, count 10).\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats statistics for result collection.\",\n  \"Subtask 7\": \"Configure Port_UP's load profile to burst mode with specified burst count (e.g., 100 packets).\",\n  \"Subtask 8\": \"Save the current test configuration to a file.\",\n  \"Subtask 9\": \"Start traffic transmission for the configured stream.\",\n  \"Subtask 10\": \"Wait until traffic transmission completes and streams stop.\",\n  \"Subtask 11\": \"Pause for 3 seconds to ensure accurate statistics collection.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 13\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both match the configured burst count.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective      : Verify the accuracy of traffic transmission statistics from the test instrument\n\nStep           : Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                Step 3: Modify the ELS FLOGI header content of StreamTemplate_1;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Transmit all traffic and wait for a period;\n                Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria       : Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by     : Tester-002\n\nBugs           : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['elsflogi'])\n\n    # 修改ELS FLOGI头部\n    attr = edit_header_els_flogi(Stream=stream, Level=0,\n                                 Bbscn=255)\n    edit_modifier(Stream=stream, Attribute=attr['Bbscn'],\n                  Type='Increment', Count=10, HeaderType='elsflogi')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Header_GRE.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发gre报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的gre头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Objective: Verify the test instrument correctly counts GRE packet statistics\n\nStep: Step 1: Reserve two loopback ports Port_1, Port_2;\n              Step 2: Modify GRE header content of traffic stream StreamTemplate_1;;\n              Step 3: Configure packet capture filtering;\n              Step 4: Subscribe to StreamBlockStats statistics;;\n              Step 5: Set port transmission mode to burst mode;\n              Step 6: Send all traffic, wait for specified duration;\n              Step 7: Stop all traffic, check StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets of traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'gre']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改gre头部\n    header = edit_header_gre(Stream=stream, Level=0, ChecksumPresent=1, Routing=1, Protocol='IPv4',\n                             Checksum=123, ChecksumReserved=123, SequenceNumber=2, Key=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gre', Attribute=header['Checksum'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gre', Attribute=header['Key'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gre', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='gre_1.routing ',\n                                               Value='1', MaxValue='1')\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='gre_1.checksum.GreChecksum_0.checksum',\n    #                                            Value='123',\n    #                                            MaxValue='123')\n    # pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='gre_1.sequenceNumber.GreSequenceNumber_0.sequenceNumber',\n    #                                            Value='2',\n    #                                            MaxValue='2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_gre:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with product set to 'DarYu' or provided product parameter.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations for Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv4, and GRE protocol layers.\",\n  \"Subtask 5\": \"Modify GRE header fields: set ChecksumPresent=1, Routing=1, Protocol='IPv4', Checksum=123, ChecksumReserved=123, SequenceNumber=2, Key=1.\",\n  \"Subtask 6\": \"Apply increment modifiers to GRE Checksum, Key, and SequenceNumber fields with step=2 and count=10.\",\n  \"Subtask 7\": \"Create PDU pattern filter on Port_2 for GRE routing field equal to 1.\",\n  \"Subtask 8\": \"Apply capture filter expression using the created PDU pattern on Port_2.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Configure Port_1 transmission mode as burst with burst count=100.\",\n  \"Subtask 11\": \"Start packet capture on Port_2.\",\n  \"Subtask 12\": \"Start traffic transmission on Port_1.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 14\": \"Stop traffic transmission on Port_1.\",\n  \"Subtask 15\": \"Stop packet capture on Port_2.\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 17\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 18\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Objective: Verify the test instrument correctly counts GRE packet statistics\n\nStep: Step 1: Reserve two loopback ports Port_1, Port_2;\n              Step 2: Modify GRE header content of traffic stream StreamTemplate_1;;\n              Step 3: Configure packet capture filtering;\n              Step 4: Subscribe to StreamBlockStats statistics;;\n              Step 5: Set port transmission mode to burst mode;\n              Step 6: Send all traffic, wait for specified duration;\n              Step 7: Stop all traffic, check StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets of traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'gre']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改gre头部\n    header = edit_header_gre(Stream=stream, Level=0, ChecksumPresent=1, Routing=1, Protocol='IPv4',\n                             Checksum=123, ChecksumReserved=123, SequenceNumber=2, Key=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gre', Attribute=header['Checksum'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gre', Attribute=header['Key'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gre', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='gre_1.routing ',\n                                               Value='1', MaxValue='1')\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='gre_1.checksum.GreChecksum_0.checksum',\n    #                                            Value='123',\n    #                                            MaxValue='123')\n    # pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='gre_1.sequenceNumber.GreSequenceNumber_0.sequenceNumber',\n    #                                            Value='2',\n    #                                            MaxValue='2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_gre:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4InformationRequest.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 information request报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 information request头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Verify the test instrument correctly counts ICMPv4 Information Request packets  \n\nStep:  \nTest Step 1: Reserve two loopback ports: Port_1, Port_2;  \nTest Step 2: Modify the ICMPv4 Information Request header in traffic StreamTemplate_1;  \nTest Step 3: Configure filtered packet capture;  \nTest Step 4: Subscribe to StreamBlockStats;  \nTest Step 5: Set port transmission mode to burst;  \nTest Step 6: Transmit all traffic and wait;  \nTest Step 7: Stop all traffic and check StreamBlockStats;  \n\nCriteria:  \nExpected Result 1: In Step 6, StreamTemplate_1's transmitted/received packets are equal;  \n\nCreated by: Tester-004  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'InformationRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 InformationRequest头部\n    edit_header_icmp_information_request(Stream=stream, Level=0, Code='4',\n                                         Identifier='100', SequenceNumber='200')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationRequest_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationRequest_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_information_request:修改测试仪表流量模板中Icmp Information Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (default 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports at given locations (default locations '//10.0.11.191/1/3' and '//10.0.11.191/1/4').\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII → IPv4 → ICMPv4 InformationRequest.\",\n  \"Subtask 5\": \"Modify ICMPv4 InformationRequest header parameters: set Code=4, Identifier=100, SequenceNumber=200.\",\n  \"Subtask 6\": \"On the second port, create PDU pattern filters: one matching ICMP Identifier=100 and another matching SequenceNumber=200.\",\n  \"Subtask 7\": \"Apply capture filter on second port using logical AND combination of both PDU patterns.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 9\": \"Configure first port's transmission mode to BURST with burst count=100.\",\n  \"Subtask 10\": \"Save test configuration to file in specified path.\",\n  \"Subtask 11\": \"Start packet capture on second port.\",\n  \"Subtask 12\": \"Initiate traffic transmission from first port.\",\n  \"Subtask 13\": \"Wait 10 seconds during traffic transmission and capture.\",\n  \"Subtask 14\": \"Stop traffic transmission.\",\n  \"Subtask 15\": \"Stop packet capture.\",\n  \"Subtask 16\": \"Download captured packets from second port to local storage.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats results for transmitted stream.\",\n  \"Subtask 18\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 19\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Verify the test instrument correctly counts ICMPv4 Information Request packets  \n\nStep:  \nTest Step 1: Reserve two loopback ports: Port_1, Port_2;  \nTest Step 2: Modify the ICMPv4 Information Request header in traffic StreamTemplate_1;  \nTest Step 3: Configure filtered packet capture;  \nTest Step 4: Subscribe to StreamBlockStats;  \nTest Step 5: Set port transmission mode to burst;  \nTest Step 6: Transmit all traffic and wait;  \nTest Step 7: Stop all traffic and check StreamBlockStats;  \n\nCriteria:  \nExpected Result 1: In Step 6, StreamTemplate_1's transmitted/received packets are equal;  \n\nCreated by: Tester-004  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'InformationRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 InformationRequest头部\n    edit_header_icmp_information_request(Stream=stream, Level=0, Code='4',\n                                         Identifier='100', SequenceNumber='200')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationRequest_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationRequest_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_information_request:修改测试仪表流量模板中Icmp Information Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl1helloHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Verify the accuracy of flow statistics from the test instrument  \nStep: Step 1: Reserve two loopback ports Port_1, Port_2;  \nStep 2: Create a flow StreamTemplate_1 on port Port_1;  \nStep 3: Modify the ISIS header content of flow StreamTemplate_1;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Send all flows and wait for a period of time;  \nStep 6: Stop all flows and view StreamBlockStats statistical information;  \nCriteria: Expected Result 1: In step 6, the transmit and receive packets of flow StreamTemplate_1 are equal;  \nCreated by: Tester-002  \nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'isisl1helloheader'])\n\n    header = edit_header_isis_l1l2_hello(Stream=stream,\n                                         Version=1,\n                                         FixedReserve1=10,\n                                         IsIsTlv=['IsIsAreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                'IpInterfaceAddress', 'Neighbor', 'RestartSignal', 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=header['FixedReserve1'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsAreaAddress',\n                                      TlvCode=10,\n                                      AreaAddressEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n\n    addr = edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=addr['AreaAddress'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['TlvLength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['AuthenticationLength'],\n    #               Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, TlvCode=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['TlvCode'],\n    #               Type='Increment', Count=10)\n\n    entry = edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=entry['TlvLength'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容",
      "edit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports (Port_1 and Port_2) using the reserve_port API with specified locations.\",\n  \"Subtask 2\": \"Create a flow named StreamTemplate_1 on Port_1 using add_stream API and configure its headers (EthernetII and ISIS L1 Hello) via create_stream_header.\",\n  \"Subtask 3\": \"Modify the ISIS header of StreamTemplate_1 by editing Version, FixedReserve1, and TLV fields (AreaAddress, Padding, etc.) using edit_header_isis_l1l2_hello and edit_header_isis_tlv_header APIs.\",\n  \"Subtask 4\": \"Configure increment modifiers for edited ISIS header fields (Version, FixedReserve1, TlvCode, AreaAddress, TlvLength) using edit_modifier API.\",\n  \"Subtask 5\": \"Subscribe to StreamBlockStats statistics using subscribe_result API with type 'StreamBlockStats'.\",\n  \"Subtask 6\": \"Configure Port_1 transmission mode to BURST with specific burst count using edit_port_load_profile API.\",\n  \"Subtask 7\": \"Start traffic transmission for StreamTemplate_1 using start_stream API.\",\n  \"Subtask 8\": \"Wait for stream transmission to complete using wait_stream_state API, then pause for 3 seconds to ensure statistics collection.\",\n  \"Subtask 9\": \"Retrieve StreamBlockStats statistics for StreamTemplate_1 using get_streamblock_statistic API.\",\n  \"Subtask 10\": \"Verify that TxStreamFrames equals RxStreamFrames for StreamTemplate_1.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Verify the accuracy of flow statistics from the test instrument  \nStep: Step 1: Reserve two loopback ports Port_1, Port_2;  \nStep 2: Create a flow StreamTemplate_1 on port Port_1;  \nStep 3: Modify the ISIS header content of flow StreamTemplate_1;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Send all flows and wait for a period of time;  \nStep 6: Stop all flows and view StreamBlockStats statistical information;  \nCriteria: Expected Result 1: In step 6, the transmit and receive packets of flow StreamTemplate_1 are equal;  \nCreated by: Tester-002  \nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'isisl1helloheader'])\n\n    header = edit_header_isis_l1l2_hello(Stream=stream,\n                                         Version=1,\n                                         FixedReserve1=10,\n                                         IsIsTlv=['IsIsAreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                'IpInterfaceAddress', 'Neighbor', 'RestartSignal', 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=header['FixedReserve1'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsAreaAddress',\n                                      TlvCode=10,\n                                      AreaAddressEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n\n    addr = edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=addr['AreaAddress'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['TlvLength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['AuthenticationLength'],\n    #               Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, TlvCode=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=tlv['TlvCode'],\n    #               Type='Increment', Count=10)\n\n    entry = edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n    edit_modifier(Stream=stream, Level=0, HeaderType='isisl1helloheader', Attribute=entry['TlvLength'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容;\nedit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6ParameterProblem.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 parameter problem报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 parameter problem头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Verify that the test instrument correctly counts sent ICMPv6 Parameter Problem packets.\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Modify the ICMPv6 Parameter Problem header content in traffic stream StreamTemplate_1;;\n      Step 3: Configure filtered packet capture;\n      Step 4: Subscribe to StreamBlockStats statistics;;\n      Step 5: Set port transmission mode to burst packets;\n      Step 6: Send all traffic and wait for a period;\n      Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'icmpv6parameterproblem']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    #  修改icmpv6 parameter problem头部\n    edit_header_icmpv6_parameter_problem(Stream=stream, Level=0,\n                                         Pointer='00000011', FlowLabel='1111', HopLimit='255', Source='2020::2',\n                                         Gateway='2020::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6ParameterProblem_1.headerData.ipv6Header.hopLimit',\n                                               Value='255', MaxValue='255')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6ParameterProblem_1.headerData.ipv6Header.source',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6ParameterProblem_1.pointer',\n                                               Value='00000011',\n                                               MaxValue='00000011')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_parameter_problem:修改测试仪表流量模板中Icmpv6 Parameter Problem报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (DarYu) using init_tester API.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) at given locations using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Create stream headers for EthernetII, IPv4, and ICMPv6 Parameter Problem using create_stream_header API.\",\n  \"Subtask 5\": \"Modify ICMPv6 Parameter Problem header with specific parameters: Pointer=00000011, FlowLabel=1111, HopLimit=255, Source=2020::2, Gateway=2020::1 using edit_header_icmpv6_parameter_problem API.\",\n  \"Subtask 6\": \"Create PDU pattern on Port_2 for ICMPv6 hopLimit=255 using create_capture_pdu_pattern API.\",\n  \"Subtask 7\": \"Create PDU pattern on Port_2 for ICMPv6 source=2020::2 using create_capture_pdu_pattern API.\",\n  \"Subtask 8\": \"Create PDU pattern on Port_2 for ICMPv6 pointer=00000011 using create_capture_pdu_pattern API.\",\n  \"Subtask 9\": \"Configure packet capture filter on Port_2 with logical AND of all three PDU patterns using edit_capture_filter API.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 11\": \"Set Port_1 transmission mode to burst with count=100 using edit_port_load_profile API.\",\n  \"Subtask 12\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 13\": \"Start packet capture on Port_2 using start_capture API.\",\n  \"Subtask 14\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 15\": \"Wait 10 seconds for traffic transmission and capture.\",\n  \"Subtask 16\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 17\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 18\": \"Wait 3 seconds for capture processing.\",\n  \"Subtask 19\": \"Download captured packets from Port_2 using download_packages API.\",\n  \"Subtask 20\": \"Retrieve StreamBlockStats for the stream using get_streamblock_statistic API.\",\n  \"Subtask 21\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 22\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Verify that the test instrument correctly counts sent ICMPv6 Parameter Problem packets.\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Modify the ICMPv6 Parameter Problem header content in traffic stream StreamTemplate_1;;\n      Step 3: Configure filtered packet capture;\n      Step 4: Subscribe to StreamBlockStats statistics;;\n      Step 5: Set port transmission mode to burst packets;\n      Step 6: Send all traffic and wait for a period;\n      Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'icmpv6parameterproblem']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    #  修改icmpv6 parameter problem头部\n    edit_header_icmpv6_parameter_problem(Stream=stream, Level=0,\n                                         Pointer='00000011', FlowLabel='1111', HopLimit='255', Source='2020::2',\n                                         Gateway='2020::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6ParameterProblem_1.headerData.ipv6Header.hopLimit',\n                                               Value='255', MaxValue='255')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6ParameterProblem_1.headerData.ipv6Header.source',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6ParameterProblem_1.pointer',\n                                               Value='00000011',\n                                               MaxValue='00000011')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_parameter_problem:修改测试仪表流量模板中Icmpv6 Parameter Problem报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4AddressMaskReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 address mask reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 address mask reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective      : Test Purpose: Verify that the test instrument accurately counts transmitted ICMPv4 Address Mask Reply packets\n\nStep           : Step 1: Reserve two loopback ports: Port_1, Port_2;\n                Step 2: Modify the ICMPv4 Address Mask Reply header content in traffic StreamTemplate_1;;\n                Step 3: Configure filtered packet capture;\n                Step 4: Subscribe to StreamBlockStats statistics;;\n                Step 5: Set port transmission mode to burst;\n                Step 6: Transmit all traffic and wait for a duration;;\n                Step 7: Stop all traffic and examine StreamBlockStats statistics;;\n\nCriteria       : Expected Result 1: Traffic StreamTemplate_1 shows equal transmitted/received packets in Step 6;\n\nCreated by     : Tester-004\n\nBugs           : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IcmpMaskReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv4 address mask reply头部\n    header = edit_header_icmp_mask_reply(Stream=stream, Level=0,\n                                Identifier=100, SequenceNumber='200', AddrMask='24')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IcmpMaskReply', Attribute=header['Identifier'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskReply_1.Identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskReply_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskReply_1.AddrMask',\n                                               Value='24',\n                                               MaxValue='24')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_mask_reply:修改测试仪表流量模板中Icmp Mask Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at given locations using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers as EthernetII, IPv4, and IcmpMaskReply using create_stream_header API.\",\n  \"Subtask 5\": \"Edit ICMPv4 Address Mask Reply header fields (Identifier=100, SequenceNumber=200, AddrMask=24) using edit_header_icmp_mask_reply API.\",\n  \"Subtask 6\": \"Configure modifier for Identifier field with increment type and count=10 using edit_modifier API.\",\n  \"Subtask 7\": \"Create three PDU patterns on the second port for ICMPv4 header fields (Identifier, SequenceNumber, AddrMask) using create_capture_pdu_pattern API.\",\n  \"Subtask 8\": \"Set capture filter expression combining all three PDU patterns using edit_capture_filter API.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 10\": \"Configure port transmission mode as burst with burst count=100 using edit_port_load_profile API.\",\n  \"Subtask 11\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 12\": \"Start packet capture on the second port using start_capture API.\",\n  \"Subtask 13\": \"Transmit traffic stream using start_stream API.\",\n  \"Subtask 14\": \"Wait for 10 seconds duration during transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 16\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 17\": \"Wait 3 seconds for capture finalization.\",\n  \"Subtask 18\": \"Download captured packets from the second port using download_packages API.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats results using get_streamblock_statistic API.\",\n  \"Subtask 20\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 21\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective      : Test Purpose: Verify that the test instrument accurately counts transmitted ICMPv4 Address Mask Reply packets\n\nStep           : Step 1: Reserve two loopback ports: Port_1, Port_2;\n                Step 2: Modify the ICMPv4 Address Mask Reply header content in traffic StreamTemplate_1;;\n                Step 3: Configure filtered packet capture;\n                Step 4: Subscribe to StreamBlockStats statistics;;\n                Step 5: Set port transmission mode to burst;\n                Step 6: Transmit all traffic and wait for a duration;;\n                Step 7: Stop all traffic and examine StreamBlockStats statistics;;\n\nCriteria       : Expected Result 1: Traffic StreamTemplate_1 shows equal transmitted/received packets in Step 6;\n\nCreated by     : Tester-004\n\nBugs           : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IcmpMaskReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv4 address mask reply头部\n    header = edit_header_icmp_mask_reply(Stream=stream, Level=0,\n                                Identifier=100, SequenceNumber='200', AddrMask='24')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IcmpMaskReply', Attribute=header['Identifier'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskReply_1.Identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskReply_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskReply_1.AddrMask',\n                                               Value='24',\n                                               MaxValue='24')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_mask_reply:修改测试仪表流量模板中Icmp Mask Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/PrpTag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的prp tag头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test objective: Verify the accuracy of the test instrument's flow transmission statistics\n\nStep: Test step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Test step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                 Test step 3: Modify the PRP tag header content of stream StreamTemplate_1;\n                 Test step 4: Subscribe to StreamBlockStats statistics;\n                 Test step 5: Transmit all traffic and wait for a period;\n                 Test step 6: Stop all traffic and examine StreamBlockStats information;\n\nCriteria: Expected result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['prptag', 'ipv4'])\n\n    # 修改hsr头部\n    attr = edit_header_prp_tag(Stream=stream, Level=0,\n                               SequenceNumber=4095)\n    edit_modifier(Stream=stream, Attribute=attr['SequenceNumber'],\n                  Type='Increment', Count=10, HeaderType='prptag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using the specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports designated as Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream named StreamTemplate_1 on Port_1.\",\n  \"Subtask 4\": \"Configure StreamTemplate_1's header to include PRP tag and IPv4 protocols.\",\n  \"Subtask 5\": \"Modify the sequence number field in the PRP tag header of StreamTemplate_1 to increment from 0 to 4095.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats statistics collection.\",\n  \"Subtask 7\": \"Set Port_1's transmit mode to burst with a burst count of 100 packets.\",\n  \"Subtask 8\": \"Save the current test configuration to a file.\",\n  \"Subtask 9\": \"Start traffic transmission for StreamTemplate_1.\",\n  \"Subtask 10\": \"Wait until traffic transmission completes and enters stopped state.\",\n  \"Subtask 11\": \"Wait 3 seconds after traffic stops to ensure statistics stabilization.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats results for StreamTemplate_1.\",\n  \"Subtask 13\": \"Verify transmitted frame count equals received frame count and both match the burst count of 100.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test objective: Verify the accuracy of the test instrument's flow transmission statistics\n\nStep: Test step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Test step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                 Test step 3: Modify the PRP tag header content of stream StreamTemplate_1;\n                 Test step 4: Subscribe to StreamBlockStats statistics;\n                 Test step 5: Transmit all traffic and wait for a period;\n                 Test step 6: Stop all traffic and examine StreamBlockStats information;\n\nCriteria: Expected result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Force=True)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['prptag', 'ipv4'])\n\n    # 修改hsr头部\n    attr = edit_header_prp_tag(Stream=stream, Level=0,\n                               SequenceNumber=4095)\n    edit_modifier(Stream=stream, Attribute=attr['SequenceNumber'],\n                  Type='Increment', Count=10, HeaderType='prptag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4InformationReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 information reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 information reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Verify the test instrument correctly counts received ICMPv4 Information Reply packets\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;  \nTest Step 2: Modify the ICMPv4 Information Reply header content in traffic StreamTemplate_1;;  \nTest Step 3: Configure filtered packet capture;  \nTest Step 4: Subscribe to StreamBlockStats;;  \nTest Step 5: Set port transmission mode to burst packets;  \nTest Step 6: Transmit all traffic and wait for a period;;  \nTest Step 7: Stop all traffic and check StreamBlockStats;;  \n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;  \n\nCreated by: Tester-004  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'InformationReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    #修改icmpv4 information reply头部\n    edit_header_icmp_information_reply(Stream=stream, Level=0,Code='4',\n                          Identifier='65535',SequenceNumber='65535')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationReply_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationReply_1.code',\n                                               Value='4',\n                                               MaxValue='4')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_information_reply:修改测试仪表流量模板中Icmp Information Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform for network testing operations.\",\n  \"Subtask 2\": \"Reserve two specific ports (Port_1 and Port_2) on the tester for loopback testing.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers to include Ethernet II, IPv4, and ICMPv4 Information Reply layers.\",\n  \"Subtask 5\": \"Modify ICMPv4 Information Reply header fields: set Code to 4, Identifier to 65535, and Sequence Number to 65535.\",\n  \"Subtask 6\": \"Create capture filter patterns on Port_2 for ICMPv4 Information Reply identifier (65535) and code (4) fields.\",\n  \"Subtask 7\": \"Apply packet capture filter on Port_2 using logical AND combination of identifier and code patterns.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats view for traffic performance monitoring.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode to burst mode with burst count set to 100 packets.\",\n  \"Subtask 10\": \"Save current test configuration to file for traceability.\",\n  \"Subtask 11\": \"Start packet capture on Port_2.\",\n  \"Subtask 12\": \"Initiate traffic transmission from Port_1.\",\n  \"Subtask 13\": \"Wait 10 seconds during traffic transmission and capture period.\",\n  \"Subtask 14\": \"Stop traffic transmission from Port_1.\",\n  \"Subtask 15\": \"Stop packet capture on Port_2.\",\n  \"Subtask 16\": \"Wait 3 seconds for final statistics collection.\",\n  \"Subtask 17\": \"Download captured packets from Port_2 to local storage.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats results for transmitted and received frame counts.\",\n  \"Subtask 19\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames).\",\n  \"Subtask 20\": \"Release reserved ports Port_1 and Port_2.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Verify the test instrument correctly counts received ICMPv4 Information Reply packets\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;  \nTest Step 2: Modify the ICMPv4 Information Reply header content in traffic StreamTemplate_1;;  \nTest Step 3: Configure filtered packet capture;  \nTest Step 4: Subscribe to StreamBlockStats;;  \nTest Step 5: Set port transmission mode to burst packets;  \nTest Step 6: Transmit all traffic and wait for a period;;  \nTest Step 7: Stop all traffic and check StreamBlockStats;;  \n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;  \n\nCreated by: Tester-004  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'InformationReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    #修改icmpv4 information reply头部\n    edit_header_icmp_information_reply(Stream=stream, Level=0,Code='4',\n                          Identifier='65535',SequenceNumber='65535')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationReply_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='informationReply_1.code',\n                                               Value='4',\n                                               MaxValue='4')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_information_reply:修改测试仪表流量模板中Icmp Information Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv3_DataOverIp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 data over ip报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 data over ip头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    : Check that the test instrument accurately counts L2TPv3 data over IP packets\n\nStep         : Step 1: Reserve two loopback ports: Port_1 and Port_2;\n              Step 2: Modify the L2TPv3 data over IP header content in traffic stream StreamTemplate_1;\n              Step 3: Configure filtered packet capture;\n              Step 4: Subscribe to StreamBlockStats statistics;\n              Step 5: Set port transmission mode to burst;\n              Step 6: Send all traffic and wait for a period of time;\n              Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     : Expected Result 1: In Step 6, transmitted and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by   : Tester-004\n\nBugs         : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'l2tpv3DataOverIp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3 data over ip头部\n    header = edit_header_l2tpv3_data_over_ip(Stream=stream, Level=0, SessionId='1', Cookie4Byte='10203040', Atmspecificsublayer=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverIp', Attribute=header['Cookie4Byte'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv3 data over ip头部选项\n    header_option = edit_header_l2tpv3_data_sublayer(Stream=stream, Type='Atmspecificsublayer', Xbit=1, Qbit=1, Sequence=10)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverIp', Attribute=header_option['Sequence'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3DataOverIp_1.sessionId',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product platform.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using the provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with a fixed frame length of 512 bytes.\",\n  \"Subtask 4\": \"Configure the stream headers: EthernetII, IPv4, and L2TPv3 data over IP.\",\n  \"Subtask 5\": \"Edit the L2TPv3 header to set Session ID to '1', Cookie to '10203040', and enable ATM specific sublayer.\",\n  \"Subtask 6\": \"Apply increment modifiers to the L2TPv3 Cookie field (10 values starting from '10203040').\",\n  \"Subtask 7\": \"Configure ATM sublayer parameters: set Xbit=1, Qbit=1, Sequence=10, then apply increment modifier to Sequence field (10 values).\",\n  \"Subtask 8\": \"Create a PDU pattern on Port_2 to capture packets with L2TPv3 sessionId=1.\",\n  \"Subtask 9\": \"Set capture filter on Port_2 using the created PDU pattern expression.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 11\": \"Configure Port_1 transmission mode as burst with burst count set to 100.\",\n  \"Subtask 12\": \"Save the test configuration to a file.\",\n  \"Subtask 13\": \"Start packet capture on Port_2.\",\n  \"Subtask 14\": \"Start traffic transmission on Port_1.\",\n  \"Subtask 15\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 16\": \"Stop traffic transmission on Port_1.\",\n  \"Subtask 17\": \"Stop packet capture on Port_2.\",\n  \"Subtask 18\": \"Download captured packets from Port_2 to local storage.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 20\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 21\": \"Release the reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    : Check that the test instrument accurately counts L2TPv3 data over IP packets\n\nStep         : Step 1: Reserve two loopback ports: Port_1 and Port_2;\n              Step 2: Modify the L2TPv3 data over IP header content in traffic stream StreamTemplate_1;\n              Step 3: Configure filtered packet capture;\n              Step 4: Subscribe to StreamBlockStats statistics;\n              Step 5: Set port transmission mode to burst;\n              Step 6: Send all traffic and wait for a period of time;\n              Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     : Expected Result 1: In Step 6, transmitted and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by   : Tester-004\n\nBugs         : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'l2tpv3DataOverIp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3 data over ip头部\n    header = edit_header_l2tpv3_data_over_ip(Stream=stream, Level=0, SessionId='1', Cookie4Byte='10203040', Atmspecificsublayer=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverIp', Attribute=header['Cookie4Byte'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv3 data over ip头部选项\n    header_option = edit_header_l2tpv3_data_sublayer(Stream=stream, Type='Atmspecificsublayer', Xbit=1, Qbit=1, Sequence=10)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverIp', Attribute=header_option['Sequence'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3DataOverIp_1.sessionId',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4SourceQuench.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 source quench报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 source quench头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: To verify that the test instrument accurately counts sent ICMPv4 Source Quench packets.\n\nStep:  \nStep 1: Reserve two loopback ports: Port_1 and Port_2;  \nStep 2: Modify the ICMPv4 Source Quench header content of traffic StreamTemplate_1;  \nStep 3: Configure packet capture filtering;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Set port transmission mode to burst;  \nStep 6: Send all traffic and wait for a period;  \nStep 7: Stop all traffic and check StreamBlockStats statistics;  \n\nCriteria:  \nCriteria 1: In Step 6, sent and received packets for StreamTemplate_1 are equal;  \n\nCreated by: Tester-004  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'SourceQuench']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改SourceQuench头部\n    edit_header_icmp_source_quench(Stream=stream, Level=0,\n                          Code='2', Ipv4HeaderTosReserved='1',\n                          Ipv4HeaderOffset='1', Ipv4HeaderSource='10.1.1.2')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='sourceQuench_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='sourceQuench_1.headerData.ipv4Header.offset',\n                                               Value='1',\n                                               MaxValue='1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='sourceQuench_1.headerData.ipv4Header.source',\n                                               Value='10.1.1.2',\n                                               MaxValue='10.1.1.2')\n    edit_capture_filter(Port=Ports[1],Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_source_quench:修改测试仪表流量模板中Icmp Source Quench报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports at the provided locations and assign them as Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with a fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure the stream header to include EthernetII, IPv4, and ICMPv4 Source Quench layers.\",\n  \"Subtask 5\": \"Modify the ICMPv4 Source Quench header with specific parameters: Level=0, Code='2', Ipv4HeaderTosReserved='1', Ipv4HeaderOffset='1', Ipv4HeaderSource='10.1.1.2'.\",\n  \"Subtask 6\": \"Create three PDU patterns on Port_2 for capture filtering: Source Quench code=2, IPv4 offset=1, and IPv4 source='10.1.1.2'.\",\n  \"Subtask 7\": \"Set the capture filter on Port_2 to require all three PDU patterns simultaneously (logical AND).\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode to burst with a burst count of 100 packets.\",\n  \"Subtask 10\": \"Save the current test configuration to a file.\",\n  \"Subtask 11\": \"Start packet capture on Port_2.\",\n  \"Subtask 12\": \"Initiate traffic transmission from Port_1.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission and capture.\",\n  \"Subtask 14\": \"Stop traffic transmission from Port_1.\",\n  \"Subtask 15\": \"Stop packet capture on Port_2.\",\n  \"Subtask 16\": \"Download captured packets from Port_2 to a specified directory.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats for the stream and verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 18\": \"Release all reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: To verify that the test instrument accurately counts sent ICMPv4 Source Quench packets.\n\nStep:  \nStep 1: Reserve two loopback ports: Port_1 and Port_2;  \nStep 2: Modify the ICMPv4 Source Quench header content of traffic StreamTemplate_1;  \nStep 3: Configure packet capture filtering;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Set port transmission mode to burst;  \nStep 6: Send all traffic and wait for a period;  \nStep 7: Stop all traffic and check StreamBlockStats statistics;  \n\nCriteria:  \nCriteria 1: In Step 6, sent and received packets for StreamTemplate_1 are equal;  \n\nCreated by: Tester-004  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'SourceQuench']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改SourceQuench头部\n    edit_header_icmp_source_quench(Stream=stream, Level=0,\n                          Code='2', Ipv4HeaderTosReserved='1',\n                          Ipv4HeaderOffset='1', Ipv4HeaderSource='10.1.1.2')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='sourceQuench_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='sourceQuench_1.headerData.ipv4Header.offset',\n                                               Value='1',\n                                               MaxValue='1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='sourceQuench_1.headerData.ipv4Header.source',\n                                               Value='10.1.1.2',\n                                               MaxValue='10.1.1.2')\n    edit_capture_filter(Port=Ports[1],Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_source_quench:修改测试仪表流量模板中Icmp Source Quench报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/pause.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的pause头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify the accuracy of flow statistics transmission by the test instrument\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the pause header content of traffic stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'pause'])\n\n    # 修改pause头部\n    attr = edit_header_pause(Stream=stream, Level=0,\n                             PauseCode='FFFF')\n    edit_modifier(Stream=stream, Attribute=attr['PauseCode'],\n                  Type='Increment', Count=10, HeaderType='pause')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_UP and Port_Down) using provided location addresses.\",\n  \"Subtask 3\": \"Create a traffic stream on the sending port (Port_UP).\",\n  \"Subtask 4\": \"Configure the stream's frame length type to 'AUTO' mode.\",\n  \"Subtask 5\": \"Add Ethernet II and Pause headers to the traffic stream.\",\n  \"Subtask 6\": \"Modify the Pause header by setting level=0 and PauseCode='FFFF'.\",\n  \"Subtask 7\": \"Apply increment modifier to PauseCode field with count=10.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics type.\",\n  \"Subtask 9\": \"Configure port load profile with burst transmit mode and burst count=100.\",\n  \"Subtask 10\": \"Start traffic transmission on all streams.\",\n  \"Subtask 11\": \"Wait until all traffic transmission completes.\",\n  \"Subtask 12\": \"Wait 3 seconds post-transmission for statistics stabilization.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 14\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify the accuracy of flow statistics transmission by the test instrument\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the pause header content of traffic stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'pause'])\n\n    # 修改pause头部\n    attr = edit_header_pause(Stream=stream, Level=0,\n                             PauseCode='FFFF')\n    edit_modifier(Stream=stream, Attribute=attr['PauseCode'],\n                  Type='Increment', Count=10, HeaderType='pause')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6TimeExceed.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 timeexceed报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 timeexceed头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Objective: Verify the test instrument correctly counts sent ICMPv6 Time Exceeded packets\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports Port_1, Port_2;\n                   Step 2: Modify ICMPv6 Time Exceeded header content in traffic stream StreamTemplate_1;;\n                   Step 3: Configure filtered packet capture;;\n                   Step 4: Subscribe to StreamBlockStats;;\n                   Step 5: Set port transmission mode to burst;;\n                   Step 6: Send all traffic and wait for duration;;\n                   Step 7: Stop all traffic and check StreamBlockStats;;\n\nCriteria    \t:   Expected Result 1: In Step 6, sent and received packets for StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-004\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'timeexceed']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 timeexceed头部\n    edit_header_icmpv6_time_exceed(Stream=stream, Level=0, Code='1', Reserve='11')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceed_1.reserve',\n                                               Value='11', MaxValue='11')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceed_1.code',\n                                               Value='1',\n                                               MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_time_exceed:修改测试仪表流量模板中Icmpv6 Time Exceed报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) at given locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv4, and ICMPv6 Time Exceeded.\",\n  \"Subtask 5\": \"Modify ICMPv6 Time Exceeded header parameters: set Level=0, Code=1, Reserve=11.\",\n  \"Subtask 6\": \"Create PDU patterns for capture filtering on Port_2: match ICMPv6 Reserve=11 and Code=1 fields.\",\n  \"Subtask 7\": \"Apply packet capture filter expression on Port_2 using logical AND of both PDU patterns.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats view for result monitoring.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode to BURST with BurstCount=100.\",\n  \"Subtask 10\": \"Save test case configuration to file.\",\n  \"Subtask 11\": \"Start packet capture on Port_2.\",\n  \"Subtask 12\": \"Start traffic transmission on Port_1.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 14\": \"Stop traffic transmission on Port_1.\",\n  \"Subtask 15\": \"Stop packet capture on Port_2.\",\n  \"Subtask 16\": \"Download captured packets from Port_2 to local storage.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats results for the transmitted stream.\",\n  \"Subtask 18\": \"Verify TxStreamFrames equals RxStreamFrames in StreamBlockStats.\",\n  \"Subtask 19\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Objective: Verify the test instrument correctly counts sent ICMPv6 Time Exceeded packets\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports Port_1, Port_2;\n                   Step 2: Modify ICMPv6 Time Exceeded header content in traffic stream StreamTemplate_1;;\n                   Step 3: Configure filtered packet capture;;\n                   Step 4: Subscribe to StreamBlockStats;;\n                   Step 5: Set port transmission mode to burst;;\n                   Step 6: Send all traffic and wait for duration;;\n                   Step 7: Stop all traffic and check StreamBlockStats;;\n\nCriteria    \t:   Expected Result 1: In Step 6, sent and received packets for StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-004\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'timeexceed']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 timeexceed头部\n    edit_header_icmpv6_time_exceed(Stream=stream, Level=0, Code='1', Reserve='11')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceed_1.reserve',\n                                               Value='11', MaxValue='11')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timeExceed_1.code',\n                                               Value='1',\n                                               MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_time_exceed:修改测试仪表流量模板中Icmpv6 Time Exceed报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6PacketTooBig.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 packet too big报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 packet too big头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify that the test instrument correctly counts sent ICMPv6 Packet Too Big messages\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports Port_1 and Port_2;\n                   Step 2: Modify the ICMPv6 Packet Too Big header content in traffic stream StreamTemplate_1;\n                   Step 3: Configure filtered packet capture;\n                   Step 4: Subscribe to StreamBlockStats;\n                   Step 5: Set port transmission mode to burst;\n                   Step 6: Send all traffic and wait for a period;\n                   Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-004\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'packettoobig']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv6 packet too big头部\n    edit_header_icmpv6_packet_too_big(Stream=stream, Level=0,\n                                      Mtu='500', FlowLabel='1111', HopLimit='255',\n                                      Source='2020::2', Gateway='2020::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='packetTooBig_1.headerData.ipv6Header.hopLimit',\n                                               Value='255', MaxValue='255')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='packetTooBig_1.headerData.ipv6Header.source',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='packetTooBig_1.mtu',\n                                               Value='500',\n                                               MaxValue='500')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_packet_too_big:修改测试仪表流量模板中Icmpv6 Packet Too Big报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (DarYu or provided argument).\",\n  \"Subtask 2\": \"Reserve two ports at specified locations for loopback testing.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Define stream headers: EthernetII, IPv6, and ICMPv6 Packet Too Big.\",\n  \"Subtask 5\": \"Modify ICMPv6 Packet Too Big header with MTU=500, FlowLabel=1111, HopLimit=255, Source=2020::2, Gateway=2020::1.\",\n  \"Subtask 6\": \"Create three PDU patterns on the second port for capture filtering: HopLimit=255, Source=2020::2, and MTU=500.\",\n  \"Subtask 7\": \"Configure packet capture filter on the second port using logical AND combination of the three PDU patterns.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 9\": \"Set first port's transmission mode to burst with burst count of 100 packets.\",\n  \"Subtask 10\": \"Save test configuration to specified file path.\",\n  \"Subtask 11\": \"Start packet capture on the second port.\",\n  \"Subtask 12\": \"Initiate traffic transmission from the first port.\",\n  \"Subtask 13\": \"Wait 10 seconds for traffic transmission and capture.\",\n  \"Subtask 14\": \"Stop traffic transmission.\",\n  \"Subtask 15\": \"Stop packet capture.\",\n  \"Subtask 16\": \"Download captured packets from the second port to local storage with maximum 100 packets.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 18\": \"Extract transmitted (TxStreamFrames) and received (RxStreamFrames) packet counts from statistics.\",\n  \"Subtask 19\": \"Verify TxStreamFrames equals RxStreamFrames as validation criteria.\",\n  \"Subtask 20\": \"Release both reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify that the test instrument correctly counts sent ICMPv6 Packet Too Big messages\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports Port_1 and Port_2;\n                   Step 2: Modify the ICMPv6 Packet Too Big header content in traffic stream StreamTemplate_1;\n                   Step 3: Configure filtered packet capture;\n                   Step 4: Subscribe to StreamBlockStats;\n                   Step 5: Set port transmission mode to burst;\n                   Step 6: Send all traffic and wait for a period;\n                   Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-004\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'packettoobig']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv6 packet too big头部\n    edit_header_icmpv6_packet_too_big(Stream=stream, Level=0,\n                                      Mtu='500', FlowLabel='1111', HopLimit='255',\n                                      Source='2020::2', Gateway='2020::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='packetTooBig_1.headerData.ipv6Header.hopLimit',\n                                               Value='255', MaxValue='255')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='packetTooBig_1.headerData.ipv6Header.source',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='packetTooBig_1.mtu',\n                                               Value='500',\n                                               MaxValue='500')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_packet_too_big:修改测试仪表流量模板中Icmpv6 Packet Too Big报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6EchoReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 echo reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 echo reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify that the test instrument correctly counts the transmitted ICMPv6 echo reply packets\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Modify the header content of the ICMPv6 echo reply in traffic StreamTemplate_1;;\n                   Test Step 3: Configure filtered packet capture;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set the port transmission mode to burst packet;\n                   Test Step 6: Send all traffic, wait for a period of time;\n                   Test Step 7: Stop all traffic, view StreamBlockStats statistics;;\n\nCriteria    \t:   Expected Result 1: In step 6, the sent and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by   \t:  \tTester-004\n\nBugs   \t    :  \tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'icmpv6echoreply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6echoreply头部\n    header = edit_header_icmpv6_echo_reply(Stream=stream, Level=0,\n                          Identifier='65535',SequenceNumber='65535')\n    edit_modifier(Stream=stream, Level=0, HeaderType='icmpv6echoreply', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoReply_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoReply_1.sequenceNumber',\n                                               Value='65535',\n                                               MaxValue='65535')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_echo_reply:修改测试仪表流量模板中Icmpv6 Echo Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports (Port_1 and Port_2) using the reserve_port API with specified locations.\",\n  \"Subtask 2\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes using the add_stream API.\",\n  \"Subtask 3\": \"Configure stream headers with EthernetII, IPv6, and ICMPv6EchoReply protocols using create_stream_header API.\",\n  \"Subtask 4\": \"Modify ICMPv6EchoReply header fields (Identifier and SequenceNumber) to 65535 using edit_header_icmpv6_echo_reply API.\",\n  \"Subtask 5\": \"Apply increment modifier to SequenceNumber field with count=10 using edit_modifier API.\",\n  \"Subtask 6\": \"Create two PDU patterns on Port_2 for capture filtering: one for ICMPv6 Identifier=65535 and another for SequenceNumber=65535 using create_capture_pdu_pattern API.\",\n  \"Subtask 7\": \"Configure packet capture filter on Port_2 using logical AND expression combining both PDU patterns via edit_capture_filter API.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 9\": \"Set Port_1 transmission mode to BURST with burst count=100 using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Start packet capture on Port_2 using start_capture API.\",\n  \"Subtask 11\": \"Initiate traffic transmission from Port_1 using start_stream API.\",\n  \"Subtask 12\": \"Wait 10 seconds for traffic transmission and capture completion.\",\n  \"Subtask 13\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 14\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 16\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) for the stream.\",\n  \"Subtask 17\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify that the test instrument correctly counts the transmitted ICMPv6 echo reply packets\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Modify the header content of the ICMPv6 echo reply in traffic StreamTemplate_1;;\n                   Test Step 3: Configure filtered packet capture;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set the port transmission mode to burst packet;\n                   Test Step 6: Send all traffic, wait for a period of time;\n                   Test Step 7: Stop all traffic, view StreamBlockStats statistics;;\n\nCriteria    \t:   Expected Result 1: In step 6, the sent and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by   \t:  \tTester-004\n\nBugs   \t    :  \tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'icmpv6echoreply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6echoreply头部\n    header = edit_header_icmpv6_echo_reply(Stream=stream, Level=0,\n                          Identifier='65535',SequenceNumber='65535')\n    edit_modifier(Stream=stream, Level=0, HeaderType='icmpv6echoreply', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoReply_1.identifier',\n                                               Value='65535', MaxValue='65535')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Icmpv6EchoReply_1.sequenceNumber',\n                                               Value='65535',\n                                               MaxValue='65535')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_echo_reply:修改测试仪表流量模板中Icmpv6 Echo Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv2ControlOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发L2TPv2 Control Over UDP报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的L2TPv2 Control Over UDP头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Verify that the test instrument accurately counts L2TPv2 Control Over UDP packets sent\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Modify the L2TPv2 Control Over UDP header content of traffic StreamTemplate_1;;\n                   Test Step 3: Configure packet capture filtering;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set port transmission mode to burst;\n                   Test Step 6: Transmit all traffic and wait for a period;\n                   Test Step 7: Stop all traffic and examine StreamBlockStats statistics;;\n\nCriteria    \t:   Expected Result 1: In step 6, traffic StreamTemplate_1 shows equal transmitted and received packets;\n\nCreated by   \t:  \tTester-004\n\nBugs   \t    :  \tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv2Control头部\n    header = edit_header_l2tpv2_control(Stream=stream, Level=0, Reserved1=11, Ns=5, Nr=6)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header['Nr'],\n                  Type='Increment', Count=10)\n    # 修改l2tp control option\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=0, Types='GeneralTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=1, Types='MessageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=2, Types='ResultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ErrorMessage'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=3, Types='ProtocolVersion', Ver='1', Rev='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Ver'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=4, Types='FramingCapabilities', Abit='1', Sbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Abit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=5, Types='BearerCapabilities', Abit='1', Dbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Dbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=6, Types='TieBreaker', TieBreakerValue='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['TieBreakerValue'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=7, Types='FirmwareRevision', FirmwareRevision='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['FirmwareRevision'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=8, Types='AssignedTunnelId', TunnelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['TunnelId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=9, Types='ReceiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=10, Types='AssignedSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=11, Types='Response', ResponseValue='00000000000000000000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ResponseValue'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=12, Types='CallSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=13, Types='MinimumBps', MinimumBps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MinimumBps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=14, Types='MaximumBps', MaximumBps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MaximumBps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=15, Types='BearerType', Abit='1', Dbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Dbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=16, Types='FramingType', Abit='1', Sbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Sbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=17, Types='TxConnectSpeed', Bps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Bps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=18, Types='RxConnectSpeed', HighBPS='1', LowBPS='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['HighBPS'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=19, Types='PhysicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=20, Types='ProxyAuthenType', AuthenType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AuthenType'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=21, Types='ProxyAuthenId', AuthenId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AuthenId'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv2Control_1.ns',\n                                               Value='5', MaxValue='5')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using the specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) for testing.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with auto frame length.\",\n  \"Subtask 4\": \"Configure the stream header with EthernetII, IPv4, UDP, and L2TPv2 Control protocols.\",\n  \"Subtask 5\": \"Modify the L2TPv2 Control header fields including Reserved1, Ns, Nr, and various option attributes.\",\n  \"Subtask 6\": \"Apply increment modifiers to specific L2TPv2 Control header fields with count=10.\",\n  \"Subtask 7\": \"Create a PDU capture pattern on Port_2 filtering for L2TPv2 Control packets with ns=5.\",\n  \"Subtask 8\": \"Configure packet capture filter on Port_2 using the created PDU pattern.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Set Port_1 transmission mode to burst with burst count=100.\",\n  \"Subtask 11\": \"Save the test configuration to a file.\",\n  \"Subtask 12\": \"Start packet capture on Port_2.\",\n  \"Subtask 13\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 14\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission.\",\n  \"Subtask 16\": \"Stop packet capture.\",\n  \"Subtask 17\": \"Wait 3 seconds for statistics stabilization.\",\n  \"Subtask 18\": \"Download captured packets from Port_2 for analysis.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats for the transmitted stream.\",\n  \"Subtask 20\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 21\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Verify that the test instrument accurately counts L2TPv2 Control Over UDP packets sent\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Modify the L2TPv2 Control Over UDP header content of traffic StreamTemplate_1;;\n                   Test Step 3: Configure packet capture filtering;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set port transmission mode to burst;\n                   Test Step 6: Transmit all traffic and wait for a period;\n                   Test Step 7: Stop all traffic and examine StreamBlockStats statistics;;\n\nCriteria    \t:   Expected Result 1: In step 6, traffic StreamTemplate_1 shows equal transmitted and received packets;\n\nCreated by   \t:  \tTester-004\n\nBugs   \t    :  \tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv2Control头部\n    header = edit_header_l2tpv2_control(Stream=stream, Level=0, Reserved1=11, Ns=5, Nr=6)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header['Nr'],\n                  Type='Increment', Count=10)\n    # 修改l2tp control option\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=0, Types='GeneralTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=1, Types='MessageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=2, Types='ResultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ErrorMessage'],\n                  Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=3, Types='ProtocolVersion', Ver='1', Rev='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Ver'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=4, Types='FramingCapabilities', Abit='1', Sbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Abit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=5, Types='BearerCapabilities', Abit='1', Dbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Dbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=6, Types='TieBreaker', TieBreakerValue='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['TieBreakerValue'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=7, Types='FirmwareRevision', FirmwareRevision='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['FirmwareRevision'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=8, Types='AssignedTunnelId', TunnelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['TunnelId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=9, Types='ReceiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=10, Types='AssignedSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=11, Types='Response', ResponseValue='00000000000000000000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['ResponseValue'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=12, Types='CallSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=13, Types='MinimumBps', MinimumBps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MinimumBps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=14, Types='MaximumBps', MaximumBps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['MaximumBps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=15, Types='BearerType', Abit='1', Dbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Dbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=16, Types='FramingType', Abit='1', Sbit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Sbit'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=17, Types='TxConnectSpeed', Bps='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['Bps'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=18, Types='RxConnectSpeed', HighBPS='1', LowBPS='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['HighBPS'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=19, Types='PhysicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=20, Types='ProxyAuthenType', AuthenType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AuthenType'],\n    #               Type='Increment', Count=10)\n    header_option = edit_header_l2tpv2_control_option(Stream=stream, Level=0, Index=21, Types='ProxyAuthenId', AuthenId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv2Control', Attribute=header_option['AuthenId'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv2Control_1.ns',\n                                               Value='5', MaxValue='5')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream[0])\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv1Report.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发igmpv1 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的igmpv1 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Purpose: Verify the test instrument correctly counts IGMPv1 report packets.\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n     Test Step 2: Modify the IGMPv1 report header content of traffic StreamTemplate_1;\n     Test Step 3: Configure packet capture filtering;\n     Test Step 4: Subscribe to StreamBlockStats counters;\n     Test Step 5: Set port transmission mode to burst;\n     Test Step 6: Transmit all traffic and wait for a period;\n     Test Step 7: Stop all traffic and check StreamBlockStats counters;\n\nCriteria: Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv1']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv1_report(Stream=stream, Level=0, Type=99, Unused='255', Checksum='ffff',\n                              GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.GroupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv1_report:修改测试仪表流量模板中IGMPv1 Report报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (DarYu or provided argument).\",\n  \"Subtask 2\": \"Reserve two ports at given locations (default: '//10.0.11.191/1/3' and '//10.0.11.191/1/4').\",\n  \"Subtask 3\": \"Create a stream on the first reserved port with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv4, and IGMPv1.\",\n  \"Subtask 5\": \"Modify IGMPv1 report header fields: Type=99, Unused=255, Checksum='ffff', GroupAddress='10.1.1.1'.\",\n  \"Subtask 6\": \"On second reserved port, create PDU pattern for IGMPv1 type field matching value 99.\",\n  \"Subtask 7\": \"On second reserved port, create PDU pattern for IGMPv1 Checksum field matching value 'ffff'.\",\n  \"Subtask 8\": \"On second reserved port, create PDU pattern for IGMPv1 GroupAddress field matching value '10.1.1.1'.\",\n  \"Subtask 9\": \"Set capture filter on second port using logical AND of the three PDU patterns.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 11\": \"Configure first port's transmit mode as burst with burst count=100.\",\n  \"Subtask 12\": \"Save test configuration to file in xcfg subdirectory using script's base name.\",\n  \"Subtask 13\": \"Start packet capture on second port.\",\n  \"Subtask 14\": \"Begin stream transmission on first port.\",\n  \"Subtask 15\": \"Wait for 10 seconds during traffic transmission and capture.\",\n  \"Subtask 16\": \"Stop stream transmission.\",\n  \"Subtask 17\": \"Stop packet capture.\",\n  \"Subtask 18\": \"Download captured packets from second port to pcap directory.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats for the stream to get TxStreamFrames and RxStreamFrames.\",\n  \"Subtask 20\": \"Verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 21\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Purpose: Verify the test instrument correctly counts IGMPv1 report packets.\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n     Test Step 2: Modify the IGMPv1 report header content of traffic StreamTemplate_1;\n     Test Step 3: Configure packet capture filtering;\n     Test Step 4: Subscribe to StreamBlockStats counters;\n     Test Step 5: Set port transmission mode to burst;\n     Test Step 6: Transmit all traffic and wait for a period;\n     Test Step 7: Stop all traffic and check StreamBlockStats counters;\n\nCriteria: Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv1']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv1_report(Stream=stream, Level=0, Type=99, Unused='255', Checksum='ffff',\n                              GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv1_1.GroupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv1_report:修改测试仪表流量模板中IGMPv1 Report报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2TPv3ControlOverIp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Control Over Ip头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify the accuracy of traffic statistics generated by the test instrument  \n\nStep:  \nStep 1: Reserve two loopback ports: Port_1 and Port_2  \nStep 2: Create a traffic stream StreamTemplate_1 on port Port_1  \nStep 3: Modify the L2TPv3 Control Over IP header content in StreamTemplate_1  \nStep 4: Subscribe to StreamBlockStats  \nStep 5: Transmit all traffic and wait for a period  \nStep 6: Stop all traffic and check StreamBlockStats information  \n\nCriteria:  \nExpected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal  \n\nCreated by: Tester-003  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3ControlOverIp'])\n\n    # 修改l2tpv3 control over ip头部\n    edit_header_l2tpv3_control_over_ip(Stream=stream, Level=0,\n                                       SessionId=1,\n                                       Type=1,\n                                       UseLength=1,\n                                       ExcludeSessionLength=1,\n                                       )\n\n    # 修改l2tpv3 control over ip头部，添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='circuitError',\n                                      AlignmentOverruns=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='routeId',\n                                      RouteId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='assignedConnection',\n                                      ConnectionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='localSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='remoteSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='assignedCookie',\n                                      Cookie4Byte='00000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='pwType',\n                                      PwType=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='l2SpecificSub',\n                                      L2SpecificSublayer=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='dataSequencing',\n                                      DataSequencing=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='txConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='rxConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='circuitStatus',\n                                      Nbit=1,\n                                      Abit=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3ControlOverIp'],\n                                             FieldName='l2tpv3ControlOverIp_1.type',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with the specified product type (e.g., DarYu).\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using their network locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with a fixed frame length of 512 bytes.\",\n  \"Subtask 4\": \"Configure the traffic stream to include Ethernet II, IPv4, and L2TPv3 Control over IP headers.\",\n  \"Subtask 5\": \"Modify the base L2TPv3 Control over IP header parameters: SessionId=1, Type=1, UseLength=1, ExcludeSessionLength=1.\",\n  \"Subtask 6\": \"Add 18 distinct L2TPv3 Control over IP header options to the stream with specified parameters (e.g., Types, AttributeValue, SessionId).\",\n  \"Subtask 7\": \"Configure packet capture on Port_2 to filter L2TPv3 Control over IP packets with type=1.\",\n  \"Subtask 8\": \"Subscribe to PortStats and StreamBlockStats statistical views.\",\n  \"Subtask 9\": \"Configure Port_1 to transmit traffic in burst mode with a burst count of 100 packets.\",\n  \"Subtask 10\": \"Save the current test configuration to a file.\",\n  \"Subtask 11\": \"Start packet capture on Port_2.\",\n  \"Subtask 12\": \"Initiate traffic transmission from Port_1.\",\n  \"Subtask 13\": \"Wait for traffic transmission to complete.\",\n  \"Subtask 14\": \"Stop packet capture on Port_2.\",\n  \"Subtask 15\": \"Wait 3 seconds to ensure statistics stabilization.\",\n  \"Subtask 16\": \"Download captured packets from Port_2 and verify captured count equals transmitted burst count (100).\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats for the traffic stream.\",\n  \"Subtask 18\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both equal the burst count (100).\",\n  \"Subtask 19\": \"Retrieve port statistics for Port_2 to check Rx filter counts.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify the accuracy of traffic statistics generated by the test instrument  \n\nStep:  \nStep 1: Reserve two loopback ports: Port_1 and Port_2  \nStep 2: Create a traffic stream StreamTemplate_1 on port Port_1  \nStep 3: Modify the L2TPv3 Control Over IP header content in StreamTemplate_1  \nStep 4: Subscribe to StreamBlockStats  \nStep 5: Transmit all traffic and wait for a period  \nStep 6: Stop all traffic and check StreamBlockStats information  \n\nCriteria:  \nExpected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal  \n\nCreated by: Tester-003  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3ControlOverIp'])\n\n    # 修改l2tpv3 control over ip头部\n    edit_header_l2tpv3_control_over_ip(Stream=stream, Level=0,\n                                       SessionId=1,\n                                       Type=1,\n                                       UseLength=1,\n                                       ExcludeSessionLength=1,\n                                       )\n\n    # 修改l2tpv3 control over ip头部，添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='circuitError',\n                                      AlignmentOverruns=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='routeId',\n                                      RouteId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='assignedConnection',\n                                      ConnectionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='localSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='remoteSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='assignedCookie',\n                                      Cookie4Byte='00000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='pwType',\n                                      PwType=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='l2SpecificSub',\n                                      L2SpecificSublayer=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='dataSequencing',\n                                      DataSequencing=1,\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='txConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='rxConnectSpeed',\n                                      SpeedBps='0000000000000001',\n                                      )\n\n    # 修改l2tpv3 control over ip头部，再添加一个Option头部\n    edit_header_l2tpv3_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='circuitStatus',\n                                      Nbit=1,\n                                      Abit=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'l2tpv3ControlOverIp'],\n                                             FieldName='l2tpv3ControlOverIp_1.type',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/IPv4.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv4报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv4头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify the test instrument correctly counts transmitted IPv4 packets\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Step 2: Modify the IPv4 header content of traffic StreamTemplate_1;\n      Step 3: Configure filtered packet capture;\n      Step 4: Subscribe to StreamBlockStats;\n      Step 5: Set port transmission mode to burst;\n      Step 6: Transmit all traffic and wait for a period;\n      Step 7: Stop all traffic and check StreamBlockStats information;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packet counts for StreamTemplate_1 are equal\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port1, port2 = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=port1, FixedLength=256)\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n    # 修改ipv4头部\n    HeaderOption = ['Security', 'RouterAlert']\n    attribute_dict = edit_header_ipv4(Stream=stream, Level=0, TTL=200, Source='10.1.1.2', Destination='20.1.1.2',\n                                      Flags=111, HeaderOption=HeaderOption)\n    # ipv4头部Source字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=10, Step=2)\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 修改ipv4头部，添加一个Security\n    attribute_dict_security = edit_header_ipv4_option(Stream=stream, Index=0, Option='Security', Security=1)\n    # ipv4头部Security的Security字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_security['Security'],\n                  Type='List', List=[1, 11, 111])\n    # ipv4头部RouterAlert的Length字段添加Random跳变\n    attribute_dict_RouterAlert = edit_header_ipv4_option(Stream=stream, Index=1, Option='RouterAlert', Length=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_RouterAlert['Length'],\n                  Type='Random', Range=15)\n    # 修改ipv4头部，添加一个LooseSourceRoute节点\n    attribute_dict_loose = edit_header_ipv4_option(Stream=stream, Index=2, Option='LooseSourceRoute',\n                                                   AddressList=['1.1.1.1', '2.2.2.2'])\n    # 修改其中一个地址的跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_loose['AddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n    # 修改ipv4头部，添加一个TimeStamp节点\n    timestamp = edit_header_ipv4_option(Stream=stream, Index=3, Option='TimeStamp',\n                                        TimeStampSet=['10203040', '50607080'])\n    # 修改其中一个地址的跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=timestamp['TimeStampSet: 50607080'],\n                  Type='Increment', Count=10)\n    # 使用Level和Attribute参数添加pdu_pattern\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=port2, HeaderTypes=['EthernetII', 'IPv4'],\n                                               Level=1,\n                                               Attribute=attribute_dict_security['Security'],\n                                               Value=1, MaxValue=1)\n    # 使用FieldName参数添加pdu_pattern\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=port2, HeaderTypes=['EthernetII', 'IPv4'],\n                                               FieldName='ipv4_1.ipv4HeaderOption.ipv4HeaderOptionList_1.optionRouterAlert.length',\n                                               Value=10, MaxValue=10)\n\n    edit_capture_filter(Port=port2, Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=port1, TransmitMode='BURST', BurstCount=100)\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    PackagesPath = download_packages(Port=port2, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    Result = get_streamblock_statistic(Stream=stream)\n    TxStreamFrames = Result['TxStreamFrames']\n    RxStreamFrames = Result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    release_port(locations)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "edit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration (default: 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports at given locations as Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers to include EthernetII and IPv4 protocol layers.\",\n  \"Subtask 5\": \"Edit IPv4 header (level 0) to set TTL=200, Source='10.1.1.2', Destination='20.1.1.2', Flags=111, and HeaderOptions=['Security','RouterAlert'].\",\n  \"Subtask 6\": \"Add increment modifier to IPv4 Source field (count=10, step=2).\",\n  \"Subtask 7\": \"Edit IPv4 Security option (index 0) to set Security=1.\",\n  \"Subtask 8\": \"Add list modifier to Security option field with values [1,11,111].\",\n  \"Subtask 9\": \"Edit IPv4 RouterAlert option (index 1) to set Length=10.\",\n  \"Subtask 10\": \"Add random modifier to RouterAlert Length field with range=15.\",\n  \"Subtask 11\": \"Edit IPv4 to add LooseSourceRoute option (index 2) with AddressList=['1.1.1.1','2.2.2.2'].\",\n  \"Subtask 12\": \"Add increment modifier to '2.2.2.2' address in LooseSourceRoute option.\",\n  \"Subtask 13\": \"Edit IPv4 to add TimeStamp option (index 3) with TimeStampSet=['10203040','50607080'].\",\n  \"Subtask 14\": \"Add increment modifier to '50607080' timestamp in TimeStamp option.\",\n  \"Subtask 15\": \"Create first PDU pattern on Port_2 matching IPv4 Security option value=1.\",\n  \"Subtask 16\": \"Create second PDU pattern on Port_2 matching IPv4 RouterAlert Length=10 using field name.\",\n  \"Subtask 17\": \"Set capture filter on Port_2 to logical AND of both PDU patterns.\",\n  \"Subtask 18\": \"Subscribe to StreamBlockStats view.\",\n  \"Subtask 19\": \"Configure Port_1 transmission mode as burst with burst count=100.\",\n  \"Subtask 20\": \"Start packet capture on Port_2.\",\n  \"Subtask 21\": \"Transmit traffic stream from Port_1.\",\n  \"Subtask 22\": \"Wait 10 seconds during transmission.\",\n  \"Subtask 23\": \"Stop traffic transmission.\",\n  \"Subtask 24\": \"Stop packet capture.\",\n  \"Subtask 25\": \"Download captured packets from Port_2 to local directory.\",\n  \"Subtask 26\": \"Retrieve StreamBlockStats for the traffic stream.\",\n  \"Subtask 27\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 28\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify the test instrument correctly counts transmitted IPv4 packets\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Step 2: Modify the IPv4 header content of traffic StreamTemplate_1;\n      Step 3: Configure filtered packet capture;\n      Step 4: Subscribe to StreamBlockStats;\n      Step 5: Set port transmission mode to burst;\n      Step 6: Transmit all traffic and wait for a period;\n      Step 7: Stop all traffic and check StreamBlockStats information;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packet counts for StreamTemplate_1 are equal\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port1, port2 = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=port1, FixedLength=256)\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n    # 修改ipv4头部\n    HeaderOption = ['Security', 'RouterAlert']\n    attribute_dict = edit_header_ipv4(Stream=stream, Level=0, TTL=200, Source='10.1.1.2', Destination='20.1.1.2',\n                                      Flags=111, HeaderOption=HeaderOption)\n    # ipv4头部Source字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=10, Step=2)\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 修改ipv4头部，添加一个Security\n    attribute_dict_security = edit_header_ipv4_option(Stream=stream, Index=0, Option='Security', Security=1)\n    # ipv4头部Security的Security字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_security['Security'],\n                  Type='List', List=[1, 11, 111])\n    # ipv4头部RouterAlert的Length字段添加Random跳变\n    attribute_dict_RouterAlert = edit_header_ipv4_option(Stream=stream, Index=1, Option='RouterAlert', Length=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_RouterAlert['Length'],\n                  Type='Random', Range=15)\n    # 修改ipv4头部，添加一个LooseSourceRoute节点\n    attribute_dict_loose = edit_header_ipv4_option(Stream=stream, Index=2, Option='LooseSourceRoute',\n                                                   AddressList=['1.1.1.1', '2.2.2.2'])\n    # 修改其中一个地址的跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict_loose['AddressList: 2.2.2.2'],\n                  Type='Increment', Count=10)\n    # 修改ipv4头部，添加一个TimeStamp节点\n    timestamp = edit_header_ipv4_option(Stream=stream, Index=3, Option='TimeStamp',\n                                        TimeStampSet=['10203040', '50607080'])\n    # 修改其中一个地址的跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=timestamp['TimeStampSet: 50607080'],\n                  Type='Increment', Count=10)\n    # 使用Level和Attribute参数添加pdu_pattern\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=port2, HeaderTypes=['EthernetII', 'IPv4'],\n                                               Level=1,\n                                               Attribute=attribute_dict_security['Security'],\n                                               Value=1, MaxValue=1)\n    # 使用FieldName参数添加pdu_pattern\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=port2, HeaderTypes=['EthernetII', 'IPv4'],\n                                               FieldName='ipv4_1.ipv4HeaderOption.ipv4HeaderOptionList_1.optionRouterAlert.length',\n                                               Value=10, MaxValue=10)\n\n    edit_capture_filter(Port=port2, Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=port1, TransmitMode='BURST', BurstCount=100)\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    PackagesPath = download_packages(Port=port2, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    Result = get_streamblock_statistic(Stream=stream)\n    TxStreamFrames = Result['TxStreamFrames']\n    RxStreamFrames = Result['RxStreamFrames']\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    release_port(locations)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nedit_header_ipv4_option:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Sr.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Sr头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify the accuracy of IPv6 packet statistics transmitted by the test instrument  \n\nStep:  \nTest Step 1: Reserve two loopback ports, Port_1 and Port_2.  \nTest Step 2: Modify the IPv6 SR header content in traffic StreamTemplate_1.  \nTest Step 3: Configure packet filtering and capture.  \nTest Step 4: Subscribe to StreamBlockStats statistics.  \nTest Step 5: Set port transmission mode to burst packets.  \nTest Step 6: Transmit all traffic and wait for a period.  \nTest Step 7: Stop all traffic and inspect StreamBlockStats statistics.  \n\nCriteria:  \nExpected Result 1: Packets sent and received for StreamTemplate_1 in Step 6 are equal.  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0])\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6srheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_sr(Stream=stream, SRHeaderFlag='10101010',\n                               SRHOption=['sRSegment', 'sRSegment'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6srheader', Attribute=attr['SRHeaderFlag'],\n                  Type='Increment', Count=10, Step=2)\n    attr_segment = edit_header_ipv6_sr_option(Stream=stream, Option='sRSegment', Index=1,\n                                              Segment='2033::3')\n    edit_modifier(Stream=stream, Attribute=attr_segment['Segment'],\n                  Type='Increment', Count=10, HeaderType='ipv6srheader')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using the init_tester API to prepare for testing.\",\n  \"Subtask 2\": \"Reserve two loopback ports using reserve_port API with specified locations.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port using add_stream API.\",\n  \"Subtask 4\": \"Edit the stream parameters to set frame length type to 'AUTO' using edit_stream API.\",\n  \"Subtask 5\": \"Create stream headers (EthernetII, IPv6, ipv6srheader) using create_stream_header API.\",\n  \"Subtask 6\": \"Modify IPv6 SR header content by setting SRHeaderFlag and SRHOption using edit_header_ipv6_sr API.\",\n  \"Subtask 7\": \"Apply increment modifier to SRHeaderFlag attribute with count=10 and step=2 using edit_modifier API.\",\n  \"Subtask 8\": \"Edit IPv6 SR header option for sRSegment at index 1 using edit_header_ipv6_sr_option API.\",\n  \"Subtask 9\": \"Apply increment modifier to Segment attribute with count=10 and step=2 using edit_modifier API.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 11\": \"Configure port transmission mode to burst with burst count=100 using edit_port_load_profile API.\",\n  \"Subtask 12\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 13\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 14\": \"Wait for 10 seconds to allow traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats using get_streamblock_statistic API.\",\n  \"Subtask 17\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 18\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify the accuracy of IPv6 packet statistics transmitted by the test instrument  \n\nStep:  \nTest Step 1: Reserve two loopback ports, Port_1 and Port_2.  \nTest Step 2: Modify the IPv6 SR header content in traffic StreamTemplate_1.  \nTest Step 3: Configure packet filtering and capture.  \nTest Step 4: Subscribe to StreamBlockStats statistics.  \nTest Step 5: Set port transmission mode to burst packets.  \nTest Step 6: Transmit all traffic and wait for a period.  \nTest Step 7: Stop all traffic and inspect StreamBlockStats statistics.  \n\nCriteria:  \nExpected Result 1: Packets sent and received for StreamTemplate_1 in Step 6 are equal.  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0])\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6srheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_sr(Stream=stream, SRHeaderFlag='10101010',\n                               SRHOption=['sRSegment', 'sRSegment'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6srheader', Attribute=attr['SRHeaderFlag'],\n                  Type='Increment', Count=10, Step=2)\n    attr_segment = edit_header_ipv6_sr_option(Stream=stream, Option='sRSegment', Index=1,\n                                              Segment='2033::3')\n    edit_modifier(Stream=stream, Attribute=attr_segment['Segment'],\n                  Type='Increment', Count=10, HeaderType='ipv6srheader')\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4EchoReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的icmpv4 echo reply头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify correct flow transmission statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n                   Test Step 3: Modify icmpv4 echo reply header content in stream StreamTemplate_1;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Transmit all traffic and wait for a duration;\n                   Test Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, traffic stream StreamTemplate_1 shows equal sent/received packets;\n\nCreated by   \t:   Tester-001\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'Icmpv4EchoReply'])\n\n    # 修改icmpv4 echo reply头部\n    attr = edit_header_icmp_echo_reply(Stream=stream, Level=0,\n                                       Type=2,\n                                       Code=4,\n                                       Identifier=65535,\n                                       SequenceNumber=65535)\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=2, Attribute=attr['SequenceNumber'],\n                  Start=100,\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'Icmpv4EchoReply'],\n                                             FieldName='Icmpv4EchoReply_1.code',\n                                             Value=4,\n                                             MaxValue=4,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_echo_reply:修改测试仪表流量模板中Icmp Echo Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1.\",\n  \"Subtask 4\": \"Build stream headers for the traffic stream with EthernetII, IPv4, and Icmpv4EchoReply layers.\",\n  \"Subtask 5\": \"Modify the ICMPv4 Echo Reply header in the stream to set Type=2, Code=4, Identifier=65535, and SequenceNumber=65535.\",\n  \"Subtask 6\": \"Apply an increment modifier to the SequenceNumber field starting at 100 with step 1 for 5 packets.\",\n  \"Subtask 7\": \"Create a PDU pattern on Port_2 to capture ICMPv4 Echo Reply packets with code=4.\",\n  \"Subtask 8\": \"Set capture filter on Port_2 using the created PDU pattern.\",\n  \"Subtask 9\": \"Subscribe to PortStats and StreamBlockStats statistics views.\",\n  \"Subtask 10\": \"Configure Port_1's load profile for burst transmission mode with burst count=100.\",\n  \"Subtask 11\": \"Save the current test configuration to a file.\",\n  \"Subtask 12\": \"Start packet capture on Port_2.\",\n  \"Subtask 13\": \"Begin traffic transmission from Port_1.\",\n  \"Subtask 14\": \"Wait until traffic transmission completes.\",\n  \"Subtask 15\": \"Stop packet capture on Port_2.\",\n  \"Subtask 16\": \"Wait 3 seconds to ensure statistics stabilization.\",\n  \"Subtask 17\": \"Download captured packets from Port_2 and retrieve capture information.\",\n  \"Subtask 18\": \"Verify captured packet count equals downloaded packet count and matches burst count (100).\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats for the traffic stream.\",\n  \"Subtask 20\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and match burst count (100).\",\n  \"Subtask 21\": \"Retrieve port statistics for filter counts on Port_2.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify correct flow transmission statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n                   Test Step 3: Modify icmpv4 echo reply header content in stream StreamTemplate_1;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Transmit all traffic and wait for a duration;\n                   Test Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, traffic stream StreamTemplate_1 shows equal sent/received packets;\n\nCreated by   \t:   Tester-001\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'Icmpv4EchoReply'])\n\n    # 修改icmpv4 echo reply头部\n    attr = edit_header_icmp_echo_reply(Stream=stream, Level=0,\n                                       Type=2,\n                                       Code=4,\n                                       Identifier=65535,\n                                       SequenceNumber=65535)\n\n    # 流量报文IPv4头部源IP地址添加Modifier跳变\n    edit_modifier(Stream=stream, Level=2, Attribute=attr['SequenceNumber'],\n                  Start=100,\n                  Type='Increment',\n                  Count=5,\n                  Step=1,\n                  StreamType='InterModifier',\n                  )\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'Icmpv4EchoReply'],\n                                             FieldName='Icmpv4EchoReply_1.code',\n                                             Value=4,\n                                             MaxValue=4,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_echo_reply:修改测试仪表流量模板中Icmp Echo Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4TimeStampReply.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 time stamp reply报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 time stamp reply头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Verify the test instrument accurately counts ICMPv4 Timestamp Reply packets  \n\nStep:  \n1. Reserve two loopback ports: Port_1 and Port_2  \n2. Modify the ICMPv4 Timestamp Reply header content in traffic stream StreamTemplate_1  \n3. Configure packet capture filtering  \n4. Subscribe to StreamBlockStats counters  \n5. Set port transmission mode to burst  \n6. Transmit all traffic and wait  \n7. Stop all traffic and check StreamBlockStats counters  \n\nCriteria:  \n1. During Step 6, StreamTemplate_1's transmitted/received packet counts must match  \n\nCreated by: Tester-004  \nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimestampReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 TimestampReply头部\n    edit_header_icmp_time_stamp_reply(Stream=stream, Level=0,\n                                      Identifier='100', SequenceNumber='200', OriginateTimestamp='111',\n                                      ReceiveTimestamp='222', TransmitTimestamp='333')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampReply_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampReply_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_time_stamp_reply:修改测试仪表流量模板中Icmp Time Stamp Reply报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations (e.g., '//10.0.11.191/1/3' and '//10.0.11.191/1/4') using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers to include EthernetII, IPv4, and TimestampReply layers using create_stream_header API.\",\n  \"Subtask 5\": \"Modify ICMPv4 Timestamp Reply header fields: set Identifier=100, SequenceNumber=200, OriginateTimestamp=111, ReceiveTimestamp=222, TransmitTimestamp=333 using edit_header_icmp_time_stamp_reply API.\",\n  \"Subtask 6\": \"Create two PDU patterns on the second port for capture filtering: one matching Identifier=100 and another matching SequenceNumber=200 using create_capture_pdu_pattern API.\",\n  \"Subtask 7\": \"Configure capture filter on the second port using logical AND expression combining both PDU patterns via edit_capture_filter API.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats counter view using subscribe_result API.\",\n  \"Subtask 9\": \"Set transmission mode of first port to BURST with burst count=100 using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 11\": \"Start packet capture on the second port using start_capture API.\",\n  \"Subtask 12\": \"Transmit traffic stream from the first port using start_stream API.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 14\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 15\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 16\": \"Download captured packets from the second port to specified directory using download_packages API.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 18\": \"Verify transmitted packet count (TxStreamFrames) equals received packet count (RxStreamFrames).\",\n  \"Subtask 19\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Verify the test instrument accurately counts ICMPv4 Timestamp Reply packets  \n\nStep:  \n1. Reserve two loopback ports: Port_1 and Port_2  \n2. Modify the ICMPv4 Timestamp Reply header content in traffic stream StreamTemplate_1  \n3. Configure packet capture filtering  \n4. Subscribe to StreamBlockStats counters  \n5. Set port transmission mode to burst  \n6. Transmit all traffic and wait  \n7. Stop all traffic and check StreamBlockStats counters  \n\nCriteria:  \n1. During Step 6, StreamTemplate_1's transmitted/received packet counts must match  \n\nCreated by: Tester-004  \nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimestampReply']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改icmpv4 TimestampReply头部\n    edit_header_icmp_time_stamp_reply(Stream=stream, Level=0,\n                                      Identifier='100', SequenceNumber='200', OriginateTimestamp='111',\n                                      ReceiveTimestamp='222', TransmitTimestamp='333')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampReply_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampReply_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_time_stamp_reply:修改测试仪表流量模板中Icmp Time Stamp Reply报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahItag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify correct traffic statistics from the test instrument\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\nTest Step 3: Modify the 802.1ah header contents of stream StreamTemplate_1;\nTest Step 4: Subscribe to StreamBlockStats;\nTest Step 5: Transmit all traffic and wait for a period;\nTest Step 6: Stop all traffic and check StreamBlockStats information;\n\nCriteria: Expected Result 1: In Step 6, received packets equal sent packets for stream StreamTemplate_1;\n\nCreated by: Tester-002\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['itag', 'ipv4'])\n\n    # 修改itag头部\n    attr = edit_header_8021ah_iTag(Stream=stream, Level=0,\n                                   EncapCusDstAddr='22:00:00:00:00:00',\n                                   SourceMacAdd='22:11:11:11:11:11')\n    edit_modifier(Stream=stream, Attribute=attr['EncapCusDstAddr'],\n                  Type='Increment', Count=10, HeaderType='itag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (default 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two loopback ports at provided locations (default '//10.0.11.191/1/5' and '//10.0.11.191/1/6') using reserve_port API, assigning them as Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers to include 'itag' and 'ipv4' using create_stream_header API.\",\n  \"Subtask 5\": \"Modify the 802.1ah (iTag) header at level 0 by setting EncapCusDstAddr to '22:00:00:00:00:00' and SourceMacAdd to '22:11:11:11:11:11' using edit_header_8021ah_iTag API.\",\n  \"Subtask 6\": \"Apply increment modifier to EncapCusDstAddr field with count=10 using edit_modifier API.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats and PortStats using subscribe_result API.\",\n  \"Subtask 8\": \"Configure port load profile on Port_UP with transmit_mode='BURST' and burst_count=100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Save current configuration to file using save_case API.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete using wait_stream_state API, then delay 3 seconds for statistics stabilization.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats using get_streamblock_statistic API and verify TxStreamFrames equals RxStreamFrames equals 100.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify correct traffic statistics from the test instrument\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\nTest Step 3: Modify the 802.1ah header contents of stream StreamTemplate_1;\nTest Step 4: Subscribe to StreamBlockStats;\nTest Step 5: Transmit all traffic and wait for a period;\nTest Step 6: Stop all traffic and check StreamBlockStats information;\n\nCriteria: Expected Result 1: In Step 6, received packets equal sent packets for stream StreamTemplate_1;\n\nCreated by: Tester-002\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['itag', 'ipv4'])\n\n    # 修改itag头部\n    attr = edit_header_8021ah_iTag(Stream=stream, Level=0,\n                                   EncapCusDstAddr='22:00:00:00:00:00',\n                                   SourceMacAdd='22:11:11:11:11:11')\n    edit_modifier(Stream=stream, Attribute=attr['EncapCusDstAddr'],\n                  Type='Increment', Count=10, HeaderType='itag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahEncapsulatedCustomerEthernetII.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Purpose: Verify the test instrument's traffic statistics accuracy\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the 802.1ah header content of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a duration;\n      Step 6: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['encapEthernetII', 'ipv4'])\n\n    # 修改Encapsulated Customer EthernetII头部\n    attr = edit_header_8021ah_EncapsulatedCustomerEthernetII(Stream=stream, Level=0,\n                                                           ServiceTag=True,\n                                                           CustomerTag=True\n                                                           )\n    attr_service = edit_header_8021ah_EncapsulatedCustomerEthernetII_serviceTag(Stream=stream,\n                                                                              Vid='101010101010')\n    attr_customer = edit_header_8021ah_EncapsulatedCustomerEthernetII_customerTag(Stream=stream,\n                                                                                Id='110011001100')\n    edit_modifier(Stream=stream, Attribute=attr_service['Vid'],\n                  Type='Increment', Count=10, HeaderType='encapEthernetII')\n    edit_modifier(Stream=stream, Attribute=attr_customer['Id'],\n                  Type='Increment', Count=10, HeaderType='encapEthernetII')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) for traffic testing.\",\n  \"Subtask 3\": \"Create a traffic stream (StreamTemplate_1) on port Port_1.\",\n  \"Subtask 4\": \"Configure EthernetII and IPv4 headers for StreamTemplate_1.\",\n  \"Subtask 5\": \"Modify 802.1ah Encapsulated Customer EthernetII header in StreamTemplate_1 by enabling Service Tag and Customer Tag.\",\n  \"Subtask 6\": \"Set specific values for Service Tag VID (101010101010) and Customer Tag ID (110011001100) in StreamTemplate_1.\",\n  \"Subtask 7\": \"Apply increment modifiers to Service Tag VID and Customer Tag ID fields with count=10.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics collection.\",\n  \"Subtask 9\": \"Configure port Port_1 transmit mode as BURST with burst count=100.\",\n  \"Subtask 10\": \"Save current test configuration to file.\",\n  \"Subtask 11\": \"Start traffic transmission for all streams.\",\n  \"Subtask 12\": \"Wait until traffic transmission completes and streams stop.\",\n  \"Subtask 13\": \"Wait 3 seconds to ensure accurate statistics collection.\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats results for StreamTemplate_1 and record TxStreamFrames/RxStreamFrames values.\",\n  \"Subtask 15\": \"Verify TxStreamFrames equals RxStreamFrames and both equal configured burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Purpose: Verify the test instrument's traffic statistics accuracy\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the 802.1ah header content of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a duration;\n      Step 6: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['encapEthernetII', 'ipv4'])\n\n    # 修改Encapsulated Customer EthernetII头部\n    attr = edit_header_8021ah_EncapsulatedCustomerEthernetII(Stream=stream, Level=0,\n                                                           ServiceTag=True,\n                                                           CustomerTag=True\n                                                           )\n    attr_service = edit_header_8021ah_EncapsulatedCustomerEthernetII_serviceTag(Stream=stream,\n                                                                              Vid='101010101010')\n    attr_customer = edit_header_8021ah_EncapsulatedCustomerEthernetII_customerTag(Stream=stream,\n                                                                                Id='110011001100')\n    edit_modifier(Stream=stream, Attribute=attr_service['Vid'],\n                  Type='Increment', Count=10, HeaderType='encapEthernetII')\n    edit_modifier(Stream=stream, Attribute=attr_customer['Id'],\n                  Type='Increment', Count=10, HeaderType='encapEthernetII')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/DHCPv4Server.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv4 Server头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of traffic transmission statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Test Step 3: Modify the DHCPv4 Server header content of traffic stream StreamTemplate_1;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Transmit all traffic and wait for a period;\n                   Test Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-003\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Server'])\n\n    # 修改dhcpv4 server头部\n    edit_header_dhcpv4_server(Stream=stream, Level=0,\n                              MessageType=1,\n                              HardwareType=1,\n                              Hops=1,\n                              Bootpflags='0001',\n                              )\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='serverId',\n                                     ReqAddr='1.1.1.1',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ReqAddr'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='message',\n                                     Value='01',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='leaseTime',\n                                     LeaseTime=1,\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['LeaseTime'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='endOfOptions',\n                                     Type='01',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Type'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='messageSize',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='clientIdHW',\n                                     IdType='01',\n                                     ClientHWA='00:00:00:00:00:01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ClientHWA'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='clientIdNoneHW',\n                                     IdType='01',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='hostName',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='paramReqList',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reqAddr',\n                                     ReqAddr='1.1.1.1',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ReqAddr'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='optionOverload',\n                                     Overload=1,\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Overload='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Server'],\n                                             FieldName='dhcpv4Server_1.hops',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports: Port_1 and Port_2.\",\n  \"Subtask 2\": \"Create a traffic stream named StreamTemplate_1 on Port_1 with fixed frame length of 512 bytes.\",\n  \"Subtask 3\": \"Create stream header for StreamTemplate_1 with layers: EthernetII, IPv4, UDP, and dhcpv4Server.\",\n  \"Subtask 4\": \"Edit main dhcpv4Server header fields for StreamTemplate_1: set MessageType=1, HardwareType=1, Hops=1, Bootpflags='0001'.\",\n  \"Subtask 5\": \"Add and configure DHCPv4 options in StreamTemplate_1 header (serverId, message, leaseTime, endOfOptions, etc.) with specific parameters.\",\n  \"Subtask 6\": \"Apply increment modifiers to selected DHCPv4 option fields in StreamTemplate_1 to generate packet variations.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 8\": \"Configure Port_1 transmission mode as burst with specified burst count (e.g., 100 packets).\",\n  \"Subtask 9\": \"Start packet capture on Port_2 with PDU filter matching dhcpv4Server.hops=1.\",\n  \"Subtask 10\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete and stream state to stop.\",\n  \"Subtask 12\": \"Stop packet capture on Port_2 after traffic stops.\",\n  \"Subtask 13\": \"Wait 3 seconds for statistics stabilization after traffic stops.\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats for StreamTemplate_1 and capture TxStreamFrames/RxStreamFrames values.\",\n  \"Subtask 15\": \"Verify TxStreamFrames equals RxStreamFrames equals configured burst count.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of traffic transmission statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Test Step 3: Modify the DHCPv4 Server header content of traffic stream StreamTemplate_1;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Transmit all traffic and wait for a period;\n                   Test Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-003\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Server'])\n\n    # 修改dhcpv4 server头部\n    edit_header_dhcpv4_server(Stream=stream, Level=0,\n                              MessageType=1,\n                              HardwareType=1,\n                              Hops=1,\n                              Bootpflags='0001',\n                              )\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='serverId',\n                                     ReqAddr='1.1.1.1',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ReqAddr'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='message',\n                                     Value='01',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='leaseTime',\n                                     LeaseTime=1,\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['LeaseTime'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='endOfOptions',\n                                     Type='01',\n                                     )\n    # 设置Option头部跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Type'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='messageSize',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='clientIdHW',\n                                     IdType='01',\n                                     ClientHWA='00:00:00:00:00:01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ClientHWA'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='clientIdNoneHW',\n                                     IdType='01',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='hostName',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='paramReqList',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reqAddr',\n                                     ReqAddr='1.1.1.1',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['ReqAddr'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='optionOverload',\n                                     Overload=1,\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Overload='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='01',\n                                     )\n    # # 设置Option头部跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Server'],\n                                             FieldName='dhcpv4Server_1.hops',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6DestinationUnreachable.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 destination unreachable报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 destination unreachable头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify the test instrument correctly counts transmitted ICMPv6 Destination Unreachable packets\n\nStep: \nStep 1: Reserve two loopback ports Port_1 and Port_2;\nStep 2: Modify ICMPv6 Destination Unreachable header content in traffic StreamTemplate_1;;\nStep 3: Configure filtered packet capture;;\nStep 4: Subscribe to StreamBlockStats statistics;;\nStep 5: Set port transmission mode to burst;;\nStep 6: Transmit all traffic and wait for a period;;\nStep 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: \nCriteria 1: During Step 6, transmitted and received packet counts for StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'destinationunreachable']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 destination unreachable头部\n    header = edit_header_icmpv6_destination_unreachable(Stream=stream, Level=0,\n                                                        Code='3', HeaderData='1020304050607080',\n                                                        FlowLabel='2',\n                                                        HopLimit='250', Source='2022::2',\n                                                        Destination='2020::2', Gateway='2022::1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='destinationunreachable', Attribute=header['HeaderData'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='destinationunreachable', Attribute=header['Source'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.code',\n                                               Value='3', MaxValue='3')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.headerData.ipv6Header.hopLimit',\n                                               Value='250',\n                                               MaxValue='250')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.headerData.ipv6Header.destination',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_destination_unreachable:修改测试仪表流量模板中Icmpv6 Destination Unreachable报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) at given locations.\",\n  \"Subtask 3\": \"Create a stream on Port_1 with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: Ethernet II, IPv6, and ICMPv6 Destination Unreachable.\",\n  \"Subtask 5\": \"Edit ICMPv6 Destination Unreachable header fields: code=3, header data='1020304050607080', flow label=2, hop limit=250, source='2022::2', destination='2020::2', gateway='2022::1'.\",\n  \"Subtask 6\": \"Apply increment modifier to ICMPv6 Destination Unreachable HeaderData field: type=Increment, count=10.\",\n  \"Subtask 7\": \"Apply increment modifier to ICMPv6 Destination Unreachable Source field: type=Increment, count=10.\",\n  \"Subtask 8\": \"Create capture PDU pattern on Port_2 for ICMPv6 code field: value=3, max value=3.\",\n  \"Subtask 9\": \"Create capture PDU pattern on Port_2 for IPv6 hop limit field: value=250, max value=250.\",\n  \"Subtask 10\": \"Create capture PDU pattern on Port_2 for IPv6 destination field: value='2020::2', max value='2020::2'.\",\n  \"Subtask 11\": \"Set capture filter on Port_2 using logical AND expression combining all PDU patterns.\",\n  \"Subtask 12\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 13\": \"Configure Port_1 transmission mode: burst mode with burst count=100.\",\n  \"Subtask 14\": \"Start packet capture on Port_2.\",\n  \"Subtask 15\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 16\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 17\": \"Stop traffic transmission from Port_1.\",\n  \"Subtask 18\": \"Stop packet capture on Port_2.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats results for the stream.\",\n  \"Subtask 20\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames).\",\n  \"Subtask 21\": \"Release both reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify the test instrument correctly counts transmitted ICMPv6 Destination Unreachable packets\n\nStep: \nStep 1: Reserve two loopback ports Port_1 and Port_2;\nStep 2: Modify ICMPv6 Destination Unreachable header content in traffic StreamTemplate_1;;\nStep 3: Configure filtered packet capture;;\nStep 4: Subscribe to StreamBlockStats statistics;;\nStep 5: Set port transmission mode to burst;;\nStep 6: Transmit all traffic and wait for a period;;\nStep 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: \nCriteria 1: During Step 6, transmitted and received packet counts for StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'destinationunreachable']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 destination unreachable头部\n    header = edit_header_icmpv6_destination_unreachable(Stream=stream, Level=0,\n                                                        Code='3', HeaderData='1020304050607080',\n                                                        FlowLabel='2',\n                                                        HopLimit='250', Source='2022::2',\n                                                        Destination='2020::2', Gateway='2022::1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='destinationunreachable', Attribute=header['HeaderData'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='destinationunreachable', Attribute=header['Source'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.code',\n                                               Value='3', MaxValue='3')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.headerData.ipv6Header.hopLimit',\n                                               Value='250',\n                                               MaxValue='250')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='destinationUnreachable_1.headerData.ipv6Header.destination',\n                                               Value='2020::2',\n                                               MaxValue='2020::2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_destination_unreachable:修改测试仪表流量模板中Icmpv6 Destination Unreachable报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/DHCPv6Client.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv6 Client头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     :   Objective: Verify the test instrument's traffic transmission statistics accuracy\n\nStep          :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                  Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                  Step 3: Modify the DHCPv6 Client header content of stream StreamTemplate_1;\n                  Step 4: Subscribe to StreamBlockStats statistics;\n                  Step 5: Transmit all traffic and wait for a period;\n                  Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by    :   Tester-003\n\nBugs          :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Client'])\n\n    # 修改dhcpv6 client头部\n    header = edit_header_dhcpv6_client(Stream=stream, Level=0,\n                              MessageType=2,\n                              TransId=2,\n                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='clientIdOption',\n                                     Duid='01',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Duid'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='serverIdOption',\n                                     DuidType=2,\n                                     HardwareType=2,\n                                     LinkAddress='00:00:00:00:00:02',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['LinkAddress'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='ianaOption',\n                                     Iaid='00000003',\n                                     T1=3,\n                                     T2=3,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['T1'],\n                  Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_address(Stream=stream, Index=2,\n                                                Type=5, Length=5, Ipv6Address='2020::1',\n                                                PreferredLifetime=1, ValidLifetime=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=ia_option['Ipv6Address'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='requestOption',\n                                     Value='04',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='elapsedTimeOption',\n                                     ElapseTime=5,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['ElapseTime'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='serverUnicastOption',\n                                     ServerAddress='2022::1',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['ServerAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='statusCodeOption',\n                                     StatusCode=7,\n                                     StatusMsg='0000000007',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['StatusMsg'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='rapidCommitOption',\n                                     Length=8,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Length'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='interfaceIdOption',\n                                     InterfaceId='0000000009',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['InterfaceId'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reconfigureAcceptOption',\n                                     Type=10,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Type'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='iapdOption',\n                                     Iaid='00000011',\n                                     T1=11,\n                                     T2=11,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Iaid'],\n    #               Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_prefix(Stream=stream, Index=10,\n                                                            Type=5, Length=5, Ipv6Address='2020::1',\n                                                            PreferredLifetime=1, ValidLifetime=1, PrefixLength=128)\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=ia_option['Ipv6Address'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Value='12',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='13',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Client'],\n                                             FieldName='dhcpv6Client_1.messageType',\n                                             Value=2,\n                                             MaxValue=2,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using provided locations, assigning Port_1 as sending port and Port_2 as receiving port.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 512 bytes.\",\n  \"Subtask 4\": \"Configure stream headers to include EthernetII, IPv6, UDP, and DHCPv6 Client protocols.\",\n  \"Subtask 5\": \"Modify DHCPv6 Client header by setting base parameters (message type, transaction ID) and adding multiple options (clientIdOption, serverIdOption, etc.), applying increment modifiers to selected fields with count=10.\",\n  \"Subtask 6\": \"Configure Port_1 transmission mode to burst with burst count=100 packets.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics for performance monitoring.\",\n  \"Subtask 8\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 9\": \"Wait until traffic transmission completes and wait 3 additional seconds for statistics stabilization.\",\n  \"Subtask 10\": \"Retrieve StreamBlockStats for the stream and verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames), both matching burst count of 100.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     :   Objective: Verify the test instrument's traffic transmission statistics accuracy\n\nStep          :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                  Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                  Step 3: Modify the DHCPv6 Client header content of stream StreamTemplate_1;\n                  Step 4: Subscribe to StreamBlockStats statistics;\n                  Step 5: Transmit all traffic and wait for a period;\n                  Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria      :   Expected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by    :   Tester-003\n\nBugs          :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Client'])\n\n    # 修改dhcpv6 client头部\n    header = edit_header_dhcpv6_client(Stream=stream, Level=0,\n                              MessageType=2,\n                              TransId=2,\n                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='clientIdOption',\n                                     Duid='01',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Duid'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='serverIdOption',\n                                     DuidType=2,\n                                     HardwareType=2,\n                                     LinkAddress='00:00:00:00:00:02',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['LinkAddress'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='ianaOption',\n                                     Iaid='00000003',\n                                     T1=3,\n                                     T2=3,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['T1'],\n                  Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_address(Stream=stream, Index=2,\n                                                Type=5, Length=5, Ipv6Address='2020::1',\n                                                PreferredLifetime=1, ValidLifetime=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=ia_option['Ipv6Address'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='requestOption',\n                                     Value='04',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='elapsedTimeOption',\n                                     ElapseTime=5,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['ElapseTime'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='serverUnicastOption',\n                                     ServerAddress='2022::1',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['ServerAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='statusCodeOption',\n                                     StatusCode=7,\n                                     StatusMsg='0000000007',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['StatusMsg'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='rapidCommitOption',\n                                     Length=8,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Length'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='interfaceIdOption',\n                                     InterfaceId='0000000009',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['InterfaceId'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reconfigureAcceptOption',\n                                     Type=10,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Type'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='iapdOption',\n                                     Iaid='00000011',\n                                     T1=11,\n                                     T2=11,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Iaid'],\n    #               Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_prefix(Stream=stream, Index=10,\n                                                            Type=5, Length=5, Ipv6Address='2020::1',\n                                                            PreferredLifetime=1, ValidLifetime=1, PrefixLength=128)\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=ia_option['Ipv6Address'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Value='12',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='13',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Client'],\n                                             FieldName='dhcpv6Client_1.messageType',\n                                             Value=2,\n                                             MaxValue=2,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Bier.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Bier头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Verify the accuracy of test instrument traffic statistics  \n\nStep:  \n1. Reserve two loopback ports: Port_1, Port_2  \n2. Create traffic stream StreamTemplate_1 on Port_1  \n3. Modify the BIER header content of StreamTemplate_1  \n4. Subscribe to StreamBlockStats  \n5. Transmit all traffic and wait  \n6. Stop all traffic and check StreamBlockStats statistics  \n\nCriteria:  \nExpected Result 1: In step 6, transmitted and received packets for StreamTemplate_1 are equal  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['bier'])\n\n    # 修改Bier头部\n    attr = edit_header_bier(Stream=stream, Level=0,\n                            BiftId=10,\n                            BierbitString=1)\n    edit_modifier(Stream=stream, Attribute=attr['BiftId'],\n                  Type='Increment', Count=10, HeaderType='bier')\n\n    bit_string = edit_header_bier_bit_string(Stream=stream,\n                                             BitString='1' * 32)\n    edit_modifier(Stream=stream, Attribute=bit_string['BitString'],\n                  Type='Increment', Count=10, HeaderType='bier')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1.\",\n  \"Subtask 4\": \"Add a BIER header to the created traffic stream.\",\n  \"Subtask 5\": \"Modify the BIER header's BiftID field with increment modifier (start=10, step=10).\",\n  \"Subtask 6\": \"Modify the BIER header's BitString field with increment modifier (start=32 ones, step=10).\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 8\": \"Configure Port_1's load profile to burst mode with burst count set to 100 packets.\",\n  \"Subtask 9\": \"Save the current test configuration to a file.\",\n  \"Subtask 10\": \"Start traffic transmission on all streams.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete and enter stopped state.\",\n  \"Subtask 12\": \"Wait 3 seconds after traffic stops to ensure accurate statistics collection.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats results for the created traffic stream.\",\n  \"Subtask 14\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Verify the accuracy of test instrument traffic statistics  \n\nStep:  \n1. Reserve two loopback ports: Port_1, Port_2  \n2. Create traffic stream StreamTemplate_1 on Port_1  \n3. Modify the BIER header content of StreamTemplate_1  \n4. Subscribe to StreamBlockStats  \n5. Transmit all traffic and wait  \n6. Stop all traffic and check StreamBlockStats statistics  \n\nCriteria:  \nExpected Result 1: In step 6, transmitted and received packets for StreamTemplate_1 are equal  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['bier'])\n\n    # 修改Bier头部\n    attr = edit_header_bier(Stream=stream, Level=0,\n                            BiftId=10,\n                            BierbitString=1)\n    edit_modifier(Stream=stream, Attribute=attr['BiftId'],\n                  Type='Increment', Count=10, HeaderType='bier')\n\n    bit_string = edit_header_bier_bit_string(Stream=stream,\n                                             BitString='1' * 32)\n    edit_modifier(Stream=stream, Attribute=bit_string['BitString'],\n                  Type='Increment', Count=10, HeaderType='bier')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Eoam.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Eoam头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify that the test instrument's traffic transmission statistics are accurate\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the Eoam header content of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['CCM'])\n\n    # 修改Eoam头部\n    attr = edit_header_eoam(Stream=stream, Level=0,\n                            MDlevel=7,\n                            Tlvs=['SenderIDTLV', 'PortStatusTLV', 'InterfaceStatusTLV',\n                                  'OrgSpecTLV', 'EndTLV'])\n    edit_modifier(Stream=stream, Attribute=attr['MDlevel'],\n                  Type='Increment', Count=10, HeaderType='CCM')\n\n    sender_attr = edit_header_eoam_sender_id_tlv(Stream=stream,\n                                                 Type='FF',\n                                                 theChassisID='ChassisComponent',\n                                                 theManagementAddressDomain='MADtDU4')\n    edit_modifier(Stream=stream, Attribute=sender_attr['Type'],\n                  Type='Increment', Count=10, HeaderType='CCM')\n\n    chassis_attr = edit_header_eoam_sender_id_tlv_chassis_id(Stream=stream,\n                                                             Type='ChassisComponent',\n                                                             ChassisID='TEST')\n    management_attr = edit_header_eoam_sender_id_tlv_management_address_domain(Stream=stream,\n                                                                               Type='MADtDU4',\n                                                                               IPv4='1.1.1.1')\n    end_attr = edit_header_eoam_end_tlv(Stream=stream, Index=4, Type='FF')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two ports (Port_1 and Port_2) on the tester using reserve_port API.\",\n  \"Subtask 2\": \"Create a traffic stream (StreamTemplate_1) on Port_1 using add_stream API.\",\n  \"Subtask 3\": \"Create CCM header for StreamTemplate_1 using create_stream_header API.\",\n  \"Subtask 4\": \"Modify Eoam header fields (MDlevel, TLVs) for StreamTemplate_1 using edit_modifier API.\",\n  \"Subtask 5\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 6\": \"Configure Port_1 transmission mode to BURST with specified burst count using edit_port_load_profile API.\",\n  \"Subtask 7\": \"Save current test configuration using save_case API.\",\n  \"Subtask 8\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 9\": \"Wait for traffic transmission completion using wait_stream_state API.\",\n  \"Subtask 10\": \"Wait 3 seconds after traffic stops to ensure statistics collection.\",\n  \"Subtask 11\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API.\",\n  \"Subtask 12\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify that the test instrument's traffic transmission statistics are accurate\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the Eoam header content of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['CCM'])\n\n    # 修改Eoam头部\n    attr = edit_header_eoam(Stream=stream, Level=0,\n                            MDlevel=7,\n                            Tlvs=['SenderIDTLV', 'PortStatusTLV', 'InterfaceStatusTLV',\n                                  'OrgSpecTLV', 'EndTLV'])\n    edit_modifier(Stream=stream, Attribute=attr['MDlevel'],\n                  Type='Increment', Count=10, HeaderType='CCM')\n\n    sender_attr = edit_header_eoam_sender_id_tlv(Stream=stream,\n                                                 Type='FF',\n                                                 theChassisID='ChassisComponent',\n                                                 theManagementAddressDomain='MADtDU4')\n    edit_modifier(Stream=stream, Attribute=sender_attr['Type'],\n                  Type='Increment', Count=10, HeaderType='CCM')\n\n    chassis_attr = edit_header_eoam_sender_id_tlv_chassis_id(Stream=stream,\n                                                             Type='ChassisComponent',\n                                                             ChassisID='TEST')\n    management_attr = edit_header_eoam_sender_id_tlv_management_address_domain(Stream=stream,\n                                                                               Type='MADtDU4',\n                                                                               IPv4='1.1.1.1')\n    end_attr = edit_header_eoam_end_tlv(Stream=stream, Index=4, Type='FF')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl2csnpHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective\t:\tTest Objective: Verify the accuracy of traffic transmission statistics on the test instrument\n\nStep\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                Test Step 3: Modify the ISIS header content of traffic stream StreamTemplate_1;\n                Test Step 4: Subscribe to StreamBlockStats statistics;\n                Test Step 5: Transmit all traffic and wait for a period;\n                Test Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria\t:\tExpected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nBugs\t\t:\tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2csnpheader'])\n\n    header = edit_header_isis_csnp(Stream=stream,\n                                   Version=10,\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2csnpheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries', LspEntries=2)\n\n    edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports Port_1 and Port_2 using the reserve_port API.\",\n  \"Subtask 2\": \"Create a traffic stream StreamTemplate_1 on Port_1 using the add_stream API.\",\n  \"Subtask 3\": \"Create EthernetII and l2csnpheader headers for StreamTemplate_1 using the create_stream_header API.\",\n  \"Subtask 4\": \"Modify the ISIS CSNP header version to 10 and set TLV options to ['IsIsLspEntries', 'AuthentionInfo'] using edit_header_isis_csnp.\",\n  \"Subtask 5\": \"Configure an increment modifier for the ISIS version field starting at 10 with count 10 using edit_modifier.\",\n  \"Subtask 6\": \"Set ISIS TLV header LSP entries to 2 using edit_header_isis_tlv_header.\",\n  \"Subtask 7\": \"Configure the first LSP entry (index 0) with remainTime=10 using edit_header_isis_lsp_entry.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode as BURST with BurstCount=100 using edit_port_load_profile.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete using wait_stream_state API, then wait 3 seconds for statistics stabilization.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API.\",\n  \"Subtask 13\": \"Verify transmitted packet count (TxStreamFrames) equals received packet count (RxStreamFrames).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective\t:\tTest Objective: Verify the accuracy of traffic transmission statistics on the test instrument\n\nStep\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                Test Step 3: Modify the ISIS header content of traffic stream StreamTemplate_1;\n                Test Step 4: Subscribe to StreamBlockStats statistics;\n                Test Step 5: Transmit all traffic and wait for a period;\n                Test Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria\t:\tExpected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nBugs\t\t:\tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2csnpheader'])\n\n    header = edit_header_isis_csnp(Stream=stream,\n                                   Version=10,\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2csnpheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries', LspEntries=2)\n\n    edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4AddressMaskRequest.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 address mask requset报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 address mask requset头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Purpose: Verify that the test instrument correctly counts sent ICMPv4 Address Mask Request packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Modify the ICMPv4 Address Mask Request header content in traffic StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst mode;\nTest Step 6: Send all traffic and wait for a period;\nTest Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IcmpMaskRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改IcmpMaskRequest头部\n    header = edit_header_icmp_mask_request(Stream=stream, Level=0,\n                          Identifier='100',SequenceNumber='200',AddrMask='24')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IcmpMaskRequest', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.Identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.AddrMask',\n                                               Value='24',\n                                               MaxValue='24')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_mask_request:修改测试仪表流量模板中Icmp Mask Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (default 'DarYu' or from argument).\",\n  \"Subtask 2\": \"Reserve two ports using provided locations (default '//10.0.11.191/1/3' and '//10.0.11.191/1/4' or from argument).\",\n  \"Subtask 3\": \"Create a traffic stream on first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv4, and IcmpMaskRequest layers.\",\n  \"Subtask 5\": \"Edit ICMPv4 Address Mask Request header fields: set Identifier=100, SequenceNumber=200, AddrMask=24.\",\n  \"Subtask 6\": \"Apply increment modifier to SequenceNumber field: increment type with count=10.\",\n  \"Subtask 7\": \"Create three PDU capture patterns on second port: filter by Identifier=100, SequenceNumber=200, AddrMask=24.\",\n  \"Subtask 8\": \"Set capture filter on second port using logical AND combination of all three PDU patterns.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Configure first port's transmission mode as burst with burst count=100.\",\n  \"Subtask 11\": \"Save current configuration to file in 'xcfg' directory using script name.\",\n  \"Subtask 12\": \"Start packet capture on second port.\",\n  \"Subtask 13\": \"Start traffic transmission from first port.\",\n  \"Subtask 14\": \"Wait 10 seconds during traffic transmission and capture.\",\n  \"Subtask 15\": \"Stop traffic transmission.\",\n  \"Subtask 16\": \"Stop packet capture.\",\n  \"Subtask 17\": \"Download captured packets from second port to 'pcap' directory with filename matching script.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats for the stream and compare TxStreamFrames with RxStreamFrames.\",\n  \"Subtask 19\": \"Assert transmitted frames equal received frames (TxStreamFrames == RxStreamFrames).\",\n  \"Subtask 20\": \"Release both reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Purpose: Verify that the test instrument correctly counts sent ICMPv4 Address Mask Request packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Modify the ICMPv4 Address Mask Request header content in traffic StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst mode;\nTest Step 6: Send all traffic and wait for a period;\nTest Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'IcmpMaskRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改IcmpMaskRequest头部\n    header = edit_header_icmp_mask_request(Stream=stream, Level=0,\n                          Identifier='100',SequenceNumber='200',AddrMask='24')\n    edit_modifier(Stream=stream, Level=0, HeaderType='IcmpMaskRequest', Attribute=header['SequenceNumber'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.Identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.SequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='IcmpMaskRequest_1.AddrMask',\n                                               Value='24',\n                                               MaxValue='24')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_mask_request:修改测试仪表流量模板中Icmp Mask Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6Redirect.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 redirect报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 redirect头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Purpose: Verify the test instrument correctly counts transmitted ICMPv6 redirect packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Modify the ICMPv6 redirect header content in traffic stream template StreamTemplate_1;\nTest Step 3: Configure packet capture filtering;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Send all traffic and wait for a period;\nTest Step 7: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for traffic stream template StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'Icmpv6Redirect']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_redirect(Stream=stream, Level=0, Code=10,\n                                         HeaderOption=['OptionPrefixInformation', 'GeneralTLV'],\n                                         RedirectedHdrOption=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv6Redirect', Attribute=header['Code'],\n                  Type='Increment', Count=10)\n\n    option = edit_header_icmpv6_header_option(Stream=stream, Header='icmpv6redirect',\n                                              Option='GeneralTLV', Index=1,\n                                              Value='1020')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv6Redirect', Attribute=option['Value'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='icmpv6Redirect_1.code',\n                                               Value='10', MaxValue='10')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_header_option:修改测试仪表流量模板中ICMPv6报文头部Header Option内容",
      "edit_header_icmpv6_redirect:修改测试仪表流量模板中Icmpv6 Redirect报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform for network testing.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) from the tester.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers for the traffic: EthernetII, IPv6, and Icmpv6Redirect.\",\n  \"Subtask 5\": \"Modify ICMPv6 Redirect header: set code to 10 and include OptionPrefixInformation and GeneralTLV options.\",\n  \"Subtask 6\": \"Apply increment modifier to ICMPv6 Redirect code field with count of 10 packets.\",\n  \"Subtask 7\": \"Modify GeneralTLV option value in ICMPv6 header to '1020'.\",\n  \"Subtask 8\": \"Apply increment modifier to GeneralTLV option value field with count of 10 packets.\",\n  \"Subtask 9\": \"Create PDU pattern on Port_2 to filter ICMPv6 Redirect packets with code=10.\",\n  \"Subtask 10\": \"Apply capture filter expression using the created PDU pattern on Port_2.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 12\": \"Configure Port_1 transmission mode to burst with burst count of 100.\",\n  \"Subtask 13\": \"Save test configuration to file.\",\n  \"Subtask 14\": \"Start packet capture on Port_2.\",\n  \"Subtask 15\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 16\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 17\": \"Stop traffic transmission from Port_1.\",\n  \"Subtask 18\": \"Stop packet capture on Port_2.\",\n  \"Subtask 19\": \"Wait 3 seconds for capture finalization.\",\n  \"Subtask 20\": \"Download captured packets from Port_2 to local storage.\",\n  \"Subtask 21\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 22\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 23\": \"Release reserved ports (Port_1 and Port_2).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: Verify the test instrument correctly counts transmitted ICMPv6 redirect packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\nTest Step 2: Modify the ICMPv6 redirect header content in traffic stream template StreamTemplate_1;\nTest Step 3: Configure packet capture filtering;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Send all traffic and wait for a period;\nTest Step 7: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, transmitted and received packets for traffic stream template StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'Icmpv6Redirect']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2report头部\n    header = edit_header_icmpv6_redirect(Stream=stream, Level=0, Code=10,\n                                         HeaderOption=['OptionPrefixInformation', 'GeneralTLV'],\n                                         RedirectedHdrOption=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv6Redirect', Attribute=header['Code'],\n                  Type='Increment', Count=10)\n\n    option = edit_header_icmpv6_header_option(Stream=stream, Header='icmpv6redirect',\n                                              Option='GeneralTLV', Index=1,\n                                              Value='1020')\n    edit_modifier(Stream=stream, Level=0, HeaderType='Icmpv6Redirect', Attribute=option['Value'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='icmpv6Redirect_1.code',\n                                               Value='10', MaxValue='10')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_header_option:修改测试仪表流量模板中ICMPv6报文头部Header Option内容;\nedit_header_icmpv6_redirect:修改测试仪表流量模板中Icmpv6 Redirect报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/DHCPv6Server.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv6 Server头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of flow statistics from the test instrument\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a traffic stream, StreamTemplate_1, on port Port_1;\n                   Step 3: Modify the DHCPv6 Server header content in traffic stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Transmit all traffic and wait for a period;\n                   Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:  \tTester-003\n\nBugs   \t    :  \tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Server'])\n\n    # 修改dhcpv6 server头部\n    header = edit_header_dhcpv6_server(Stream=stream, Level=0,\n                              MessageType=2,\n                              TransId=2,\n                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='clientIdOption',\n                                     Duid='01',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Duid'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='serverIdOption',\n                                     DuidType=2,\n                                     HardwareType=2,\n                                     LinkAddress='00:00:00:00:00:02',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['LinkAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='ianaOption',\n                                     Iaid='00000003',\n                                     T1=3,\n                                     T2=3,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Iaid'],\n                  Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_address(Stream=stream, Index=2,\n                                                Type=5, Length=5, Ipv6Address='2020::1',\n                                                PreferredLifetime=1, ValidLifetime=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=ia_option['Ipv6Address'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='requestOption',\n                                     Value='04',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='elapsedTimeOption',\n                                     ElapseTime=5,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['ElapseTime'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='serverUnicastOption',\n                                     ServerAddress='2022::1',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['ServerAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='statusCodeOption',\n                                     StatusCode=7,\n                                     StatusMsg='0000000007',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['StatusMsg'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='rapidCommitOption',\n                                     Length=8,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Length'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='interfaceIdOption',\n                                     InterfaceId='0000000009',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['InterfaceId'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reconfigureAcceptOption',\n                                     Type=10,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Type'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='iapdOption',\n                                     Iaid='00000011',\n                                     T1=11,\n                                     T2=11,\n                                     IaOption=1,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Iaid'],\n    #               Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_prefix(Stream=stream, Index=10,\n                                                            Type=5, Length=5, Ipv6Address='2020::1',\n                                                            PreferredLifetime=1, ValidLifetime=1, PrefixLength=128)\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=ia_option['Ipv6Address'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Value='12',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='13',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Server'],\n                                             FieldName='dhcpv6Server_1.messageType',\n                                             Value=2,\n                                             MaxValue=2,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports named Port_1 and Port_2 using the reserve_port API function.\",\n  \"Subtask 2\": \"Create a traffic stream named StreamTemplate_1 on Port_1 using the add_stream API function with fixed frame length configuration.\",\n  \"Subtask 3\": \"Modify DHCPv6 Server header content in StreamTemplate_1 using edit_header_dhcpv6_server and related header editing API functions.\",\n  \"Subtask 4\": \"Subscribe to StreamBlockStats statistics view using the subscribe_result API function.\",\n  \"Subtask 5\": \"Configure traffic transmission parameters for StreamTemplate_1 using edit_port_load_profile API to set burst mode with specific packet count.\",\n  \"Subtask 6\": \"Start traffic transmission using the start_stream API function.\",\n  \"Subtask 7\": \"Wait until traffic transmission completes using the wait_stream_state API function.\",\n  \"Subtask 8\": \"Wait for 3 seconds to ensure statistics collection completes.\",\n  \"Subtask 9\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API function.\",\n  \"Subtask 10\": \"Verify transmitted packet count (TxStreamFrames) equals received packet count (RxStreamFrames) for StreamTemplate_1.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of flow statistics from the test instrument\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a traffic stream, StreamTemplate_1, on port Port_1;\n                   Step 3: Modify the DHCPv6 Server header content in traffic stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Transmit all traffic and wait for a period;\n                   Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:  \tTester-003\n\nBugs   \t    :  \tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Server'])\n\n    # 修改dhcpv6 server头部\n    header = edit_header_dhcpv6_server(Stream=stream, Level=0,\n                              MessageType=2,\n                              TransId=2,\n                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=0,\n                                     Types='clientIdOption',\n                                     Duid='01',\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Duid'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=1,\n                                     Types='serverIdOption',\n                                     DuidType=2,\n                                     HardwareType=2,\n                                     LinkAddress='00:00:00:00:00:02',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['LinkAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=2,\n                                     Types='ianaOption',\n                                     Iaid='00000003',\n                                     T1=3,\n                                     T2=3,\n                                     IaOption=1\n                                     )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Iaid'],\n                  Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_address(Stream=stream, Index=2,\n                                                Type=5, Length=5, Ipv6Address='2020::1',\n                                                PreferredLifetime=1, ValidLifetime=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=ia_option['Ipv6Address'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=3,\n                                     Types='requestOption',\n                                     Value='04',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=4,\n                                     Types='elapsedTimeOption',\n                                     ElapseTime=5,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['ElapseTime'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=5,\n                                     Types='serverUnicastOption',\n                                     ServerAddress='2022::1',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['ServerAddress'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=6,\n                                     Types='statusCodeOption',\n                                     StatusCode=7,\n                                     StatusMsg='0000000007',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['StatusMsg'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=7,\n                                     Types='rapidCommitOption',\n                                     Length=8,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Length'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=8,\n                                     Types='interfaceIdOption',\n                                     InterfaceId='0000000009',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['InterfaceId'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=9,\n                                     Types='reconfigureAcceptOption',\n                                     Type=10,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Type'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=10,\n                                     Types='iapdOption',\n                                     Iaid='00000011',\n                                     T1=11,\n                                     T2=11,\n                                     IaOption=1,\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Iaid'],\n    #               Type='Increment', Count=10)\n    ia_option = edit_header_dhcpv6_option_ia_prefix(Stream=stream, Index=10,\n                                                            Type=5, Length=5, Ipv6Address='2020::1',\n                                                            PreferredLifetime=1, ValidLifetime=1, PrefixLength=128)\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=ia_option['Ipv6Address'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=11,\n                                     Types='customOption',\n                                     Value='12',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv6 server头部，添加一个Option头部\n    header_option = edit_header_dhcpv6_option(Stream=stream, Level=0,\n                                     Index=12,\n                                     Types='generalTLV',\n                                     Value='13',\n                                     )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv6Server', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv6', 'UDP', 'dhcpv6Server'],\n                                             FieldName='dhcpv6Server_1.messageType',\n                                             Value=2,\n                                             MaxValue=2,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/llc.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的llc头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Verify the accuracy of traffic statistics sent by the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports: Port_1, Port_2;\n                    Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                    Test Step 3: Modify the LLC header content of traffic stream StreamTemplate_1;\n                    Test Step 4: Subscribe to StreamBlockStats statistics;\n                    Test Step 5: Send all traffic streams and wait for a period;\n                    Test Step 6: Stop all traffic streams and check StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, received and sent packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-002\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp', 'logicLinkControl'])\n\n    # 修改802.3头部\n    attr = edit_header_llc(Stream=stream, Level=0, Dsap='FF')\n    edit_modifier(Stream=stream, Attribute=attr['Dsap'],\n                  Type='Increment', Count=10, HeaderType='logicLinkControl')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using the provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream named StreamTemplate_1 on Port_1.\",\n  \"Subtask 4\": \"Edit StreamTemplate_1 parameters to set frame length type to 'AUTO'.\",\n  \"Subtask 5\": \"Create Ethernet II, IPv4, UDP, and LLC headers for StreamTemplate_1.\",\n  \"Subtask 6\": \"Modify LLC header of StreamTemplate_1 by setting Dsap field to 'FF'.\",\n  \"Subtask 7\": \"Add increment modifier to Dsap field in LLC header with count=10.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 9\": \"Configure Port_1 to transmit in BURST mode with burst count=100.\",\n  \"Subtask 10\": \"Start transmission of all traffic streams.\",\n  \"Subtask 11\": \"Wait until all traffic streams stop transmitting.\",\n  \"Subtask 12\": \"Wait 3 seconds after stream stop to ensure accurate statistics collection.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats results for StreamTemplate_1.\",\n  \"Subtask 14\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 15\": \"Verify both TxStreamFrames and RxStreamFrames equal the configured burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Verify the accuracy of traffic statistics sent by the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports: Port_1, Port_2;\n                    Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                    Test Step 3: Modify the LLC header content of traffic stream StreamTemplate_1;\n                    Test Step 4: Subscribe to StreamBlockStats statistics;\n                    Test Step 5: Send all traffic streams and wait for a period;\n                    Test Step 6: Stop all traffic streams and check StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, received and sent packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-002\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp', 'logicLinkControl'])\n\n    # 修改802.3头部\n    attr = edit_header_llc(Stream=stream, Level=0, Dsap='FF')\n    edit_modifier(Stream=stream, Attribute=attr['Dsap'],\n                  Type='Increment', Count=10, HeaderType='logicLinkControl')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Destination.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Destination头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify that the test instrument correctly counts transmitted IPv6 packets\n\nStep: Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n      Test Step 2: Modify the IPv6 Destination header of traffic StreamTemplate_1;\n      Test Step 3: Configure filtered packet capture;\n      Test Step 4: Subscribe to StreamBlockStats;\n      Test Step 5: Set port transmission mode to Burst;\n      Test Step 6: Transmit all traffic and wait for a period;\n      Test Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: Transmitted and received packets for StreamTemplate_1 in Step 6 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6destinationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_destination(Stream=stream,\n                                        Length=10,\n                                        OptionHeaders=['bierv6'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr['Length'],\n                  Type='Increment', Count=10, Step=2)\n    attr_bier = edit_header_ipv6_destination_option(Stream=stream, Option='bierv6',\n                                                    Optiontype=20,\n                                                    BierbitString=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr_bier['Optiontype'],\n                  Type='Increment', Count=10, Step=2)\n    attr_bit_string = edit_header_ipv6_destination_bier_bit_string(Stream=stream,\n                                                                   BitString='11001100110011001100110011001100')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr_bit_string['BitString'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester for the specified product (DarYu) using init_tester API.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using reserve_port API with provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv6, and ipv6destinationheader using create_stream_header API.\",\n  \"Subtask 5\": \"Modify IPv6 Destination header length field and configure increment modifier (Step=2, Count=10) using edit_header_ipv6_destination and edit_modifier APIs.\",\n  \"Subtask 6\": \"Modify IPv6 Destination BIERv6 option type field and configure increment modifier (Step=2, Count=10) using edit_header_ipv6_destination_option and edit_modifier APIs.\",\n  \"Subtask 7\": \"Modify IPv6 Destination BIER bit string field and configure increment modifier (Step=2, Count=10) using edit_header_ipv6_destination_bier_bit_string and edit_modifier APIs.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats view using subscribe_result API.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode to Burst with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for 10 seconds to allow traffic flow.\",\n  \"Subtask 12\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats using get_streamblock_statistic API for the created stream.\",\n  \"Subtask 14\": \"Verify TxStreamFrames equal RxStreamFrames in the retrieved statistics.\",\n  \"Subtask 15\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify that the test instrument correctly counts transmitted IPv6 packets\n\nStep: Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n      Test Step 2: Modify the IPv6 Destination header of traffic StreamTemplate_1;\n      Test Step 3: Configure filtered packet capture;\n      Test Step 4: Subscribe to StreamBlockStats;\n      Test Step 5: Set port transmission mode to Burst;\n      Test Step 6: Transmit all traffic and wait for a period;\n      Test Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: Transmitted and received packets for StreamTemplate_1 in Step 6 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6destinationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_destination(Stream=stream,\n                                        Length=10,\n                                        OptionHeaders=['bierv6'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr['Length'],\n                  Type='Increment', Count=10, Step=2)\n    attr_bier = edit_header_ipv6_destination_option(Stream=stream, Option='bierv6',\n                                                    Optiontype=20,\n                                                    BierbitString=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr_bier['Optiontype'],\n                  Type='Increment', Count=10, Step=2)\n    attr_bit_string = edit_header_ipv6_destination_bier_bit_string(Stream=stream,\n                                                                   BitString='11001100110011001100110011001100')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6destinationheader', Attribute=attr_bit_string['BitString'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Dot1ahMacInMac.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.1ah头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Verify the test instrument's traffic transmission statistics accuracy\n\nStep          : Step 1: Reserve two loopback ports: Port_1 and Port_2;\n               Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n               Step 3: Modify the 802.1ah header content of traffic stream StreamTemplate_1;\n               Step 4: Subscribe to StreamBlockStats statistics;\n               Step 5: Transmit all traffic and wait for a duration;\n               Step 6: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['mac-in-mac', 'ipv4'])\n\n    # 修改Encapsulated Mac-in-Mac头部\n    attr = edit_header_8021ah_MacInMac(Stream=stream, Level=0,\n                                       DestMacAdd='22:00:00:00:00:00',\n                                       SourceMacAdd='22:11:11:11:11:11')\n    edit_modifier(Stream=stream, Attribute=attr['DestMacAdd'],\n                  Type='Increment', Count=10, HeaderType='mac-in-mac')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform.\",\n  \"Subtask 2\": \"Reserve two test ports designated as Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream named StreamTemplate_1 on Port_1.\",\n  \"Subtask 4\": \"Configure StreamTemplate_1 with mac-in-mac and ipv4 headers.\",\n  \"Subtask 5\": \"Modify the 802.1ah header of StreamTemplate_1: set destination MAC to '22:00:00:00:00:00' and source MAC to '22:11:11:11:11:11'.\",\n  \"Subtask 6\": \"Apply increment modifier to destination MAC address field with step value 10.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics collection.\",\n  \"Subtask 8\": \"Configure Port_1 transmit mode as burst with burst count set to 100.\",\n  \"Subtask 9\": \"Start traffic transmission for StreamTemplate_1.\",\n  \"Subtask 10\": \"Wait until traffic transmission completes and then wait 3 seconds for statistics stabilization.\",\n  \"Subtask 11\": \"Retrieve StreamBlockStats results for StreamTemplate_1.\",\n  \"Subtask 12\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames) for StreamTemplate_1.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Verify the test instrument's traffic transmission statistics accuracy\n\nStep          : Step 1: Reserve two loopback ports: Port_1 and Port_2;\n               Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n               Step 3: Modify the 802.1ah header content of traffic stream StreamTemplate_1;\n               Step 4: Subscribe to StreamBlockStats statistics;\n               Step 5: Transmit all traffic and wait for a duration;\n               Step 6: Stop all traffic and inspect StreamBlockStats statistics;\n\nCriteria      : Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['mac-in-mac', 'ipv4'])\n\n    # 修改Encapsulated Mac-in-Mac头部\n    attr = edit_header_8021ah_MacInMac(Stream=stream, Level=0,\n                                       DestMacAdd='22:00:00:00:00:00',\n                                       SourceMacAdd='22:11:11:11:11:11')\n    edit_modifier(Stream=stream, Attribute=attr['DestMacAdd'],\n                  Type='Increment', Count=10, HeaderType='mac-in-mac')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ripv2.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发Ripv2报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的Ripv2头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify that the test instrument correctly counts sent/received Ripv2 packets  \n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;  \n      Test Step 2: Modify Ripv2 header content in traffic StreamTemplate_1;  \n      Test Step 3: Configure filtered packet capture;  \n      Test Step 4: Subscribe to StreamBlockStats;  \n      Test Step 5: Set port transmission mode to burst;  \n      Test Step 6: Send all traffic and wait;  \n      Test Step 7: Stop all traffic and check StreamBlockStats;  \n\nCriteria: Expected Result 1: In Step 6, transmitted/received packets for StreamTemplate_1 are equal;  \n\nCreated by: Tester-001  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripv2']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripv2(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripv2', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripv2_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripv2_entry(Stream=stream, Level=0, Index=0, Ipaddr='192.168.0.11', SubnetMask='192.168.1.11', NextHop='192.168.2.11', Afi=1, RouteTag=1)\n    edit_header_ripv2_entry(Stream=stream, Level=0, Index=1, Ipaddr='192.168.0.12', SubnetMask='192.168.1.12', NextHop='192.168.2.12', Afi=2, RouteTag=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform for product 'DarYu'.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations for loopback testing.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv4, and Ripv2.\",\n  \"Subtask 5\": \"Modify Ripv2 header fields: set Command=2, Version=1, Reserved=2 at Level 0.\",\n  \"Subtask 6\": \"Apply increment modifier to Ripv2 Reserved field with count=3.\",\n  \"Subtask 7\": \"Insert two Ripv2 entries into the stream.\",\n  \"Subtask 8\": \"Edit first Ripv2 entry: set Ipaddr='192.168.0.11', SubnetMask='192.168.1.11', NextHop='192.168.2.11', Afi=1, RouteTag=1.\",\n  \"Subtask 9\": \"Edit second Ripv2 entry: set Ipaddr='192.168.0.12', SubnetMask='192.168.1.12', NextHop='192.168.2.12', Afi=2, RouteTag=2.\",\n  \"Subtask 10\": \"Create first PDU capture pattern on second port: match Ripv2 Reserved field at Level 2 with value=1 and max=2.\",\n  \"Subtask 11\": \"Create second PDU capture pattern on second port: match Ripv2 Version field at Level 2 with value=1 and max=1.\",\n  \"Subtask 12\": \"Configure packet capture filter on second port using logical AND of both PDU patterns.\",\n  \"Subtask 13\": \"Subscribe to StreamBlockStats view for statistics collection.\",\n  \"Subtask 14\": \"Set port transmission mode to BURST with burst count=100 on traffic source port.\",\n  \"Subtask 15\": \"Save test configuration to specified file path.\",\n  \"Subtask 16\": \"Start packet capture on second port.\",\n  \"Subtask 17\": \"Transmit traffic stream from first port.\",\n  \"Subtask 18\": \"Wait 10 seconds during traffic transmission.\",\n  \"Subtask 19\": \"Stop traffic transmission.\",\n  \"Subtask 20\": \"Stop packet capture.\",\n  \"Subtask 21\": \"Download captured packets from second port to local storage.\",\n  \"Subtask 22\": \"Retrieve StreamBlockStats for the traffic stream.\",\n  \"Subtask 23\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 24\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify that the test instrument correctly counts sent/received Ripv2 packets  \n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;  \n      Test Step 2: Modify Ripv2 header content in traffic StreamTemplate_1;  \n      Test Step 3: Configure filtered packet capture;  \n      Test Step 4: Subscribe to StreamBlockStats;  \n      Test Step 5: Set port transmission mode to burst;  \n      Test Step 6: Send all traffic and wait;  \n      Test Step 7: Stop all traffic and check StreamBlockStats;  \n\nCriteria: Expected Result 1: In Step 6, transmitted/received packets for StreamTemplate_1 are equal;  \n\nCreated by: Tester-001  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripv2']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripv2(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripv2', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripv2_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripv2_entry(Stream=stream, Level=0, Index=0, Ipaddr='192.168.0.11', SubnetMask='192.168.1.11', NextHop='192.168.2.11', Afi=1, RouteTag=1)\n    edit_header_ripv2_entry(Stream=stream, Level=0, Index=1, Ipaddr='192.168.0.12', SubnetMask='192.168.1.12', NextHop='192.168.2.12', Afi=2, RouteTag=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/HsrTag.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的hsr tag头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Verify the accuracy of test instrument traffic statistics  \n\nStep:  \n1. Reserve two loopback ports: Port_1, Port_2  \n2. Create traffic stream StreamTemplate_1 on Port_1  \n3. Modify HSR tag header content of StreamTemplate_1  \n4. Subscribe to StreamBlockStats  \n5. Transmit all traffic and wait for a period  \n6. Stop all traffic and check StreamBlockStats  \n\nCriteria:  \n1. Received and transmitted packets of StreamTemplate_1 must match in Step 6  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['hsrtag', 'ipv4'])\n\n    # 修改hsr头部\n    attr = edit_header_hsr_tag(Stream=stream, Level=0,\n                            LsduSize=4095)\n    edit_modifier(Stream=stream, Attribute=attr['LsduSize'],\n                  Type='Increment', Count=10, HeaderType='hsrtag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with the specified product using init_tester API.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_UP and Port_Down) using reserve_port API with provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API.\",\n  \"Subtask 4\": \"Create stream headers including HSR tag and IPv4 using create_stream_header API.\",\n  \"Subtask 5\": \"Edit HSR tag header by setting LsduSize to 4095 using edit_header_hsr_tag API.\",\n  \"Subtask 6\": \"Configure modifier for LsduSize field with increment type and count of 10 using edit_modifier API.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats and PortStats using subscribe_result API.\",\n  \"Subtask 8\": \"Configure port load profile for Port_UP with burst transmit mode and burst count of 100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 12\": \"Wait additional 3 seconds to ensure accurate statistics collection.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 14\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both equal burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Verify the accuracy of test instrument traffic statistics  \n\nStep:  \n1. Reserve two loopback ports: Port_1, Port_2  \n2. Create traffic stream StreamTemplate_1 on Port_1  \n3. Modify HSR tag header content of StreamTemplate_1  \n4. Subscribe to StreamBlockStats  \n5. Transmit all traffic and wait for a period  \n6. Stop all traffic and check StreamBlockStats  \n\nCriteria:  \n1. Received and transmitted packets of StreamTemplate_1 must match in Step 6  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['hsrtag', 'ipv4'])\n\n    # 修改hsr头部\n    attr = edit_header_hsr_tag(Stream=stream, Level=0,\n                            LsduSize=4095)\n    edit_modifier(Stream=stream, Attribute=attr['LsduSize'],\n                  Type='Increment', Count=10, HeaderType='hsrtag')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ipv6Encapsulation.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6 Encapsulation头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective\t:\tTest Objective: Verify that the test instrument correctly counts transmitted IPv6 packets\n\nStep\t\t:\tTest Step 1: Reserve two loopback ports: Port_1 and Port_2;\n\t\t\t\tTest Step 2: Modify the IPv6 Encapsulation header content of traffic stream StreamTemplate_1;\n\t\t\t\tTest Step 3: Configure filtered packet capture;\n\t\t\t\tTest Step 4: Subscribe to StreamBlockStats statistics;\n\t\t\t\tTest Step 5: Set port transmission mode to burst mode;\n\t\t\t\tTest Step 6: Transmit all traffic and wait for a period of time;\n\t\t\t\tTest Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria\t:\tExpected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by\t:\tTester-002\n\nBugs\t\t:\tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6encapsulationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_encapsulation(Stream=stream, Spi=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6encapsulationheader', Attribute=attr['Spi'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with product specification 'DarYu' using the init_tester API.\",\n  \"Subtask 2\": \"Reserve two physical ports at specified locations using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Build stream headers with EthernetII, IPv6, and IPv6 Encapsulation Header layers using create_stream_header API.\",\n  \"Subtask 5\": \"Set base value of Security Parameters Index (SPI) field in IPv6 Encapsulation Header to 10.\",\n  \"Subtask 6\": \"Configure increment modifier for SPI field with step size 2 and packet count 10 using edit_modifier API.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 8\": \"Configure port transmission mode as burst with burst count 100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Save current test configuration to specified file path using save_case API.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Maintain traffic flow for 10 seconds to allow packet transmission and reception.\",\n  \"Subtask 12\": \"Stop all traffic transmission using stop_stream API.\",\n  \"Subtask 13\": \"Wait 3 seconds for statistics stabilization after traffic stop.\",\n  \"Subtask 14\": \"Retrieve StreamBlock statistics for the created stream using get_streamblock_statistic API.\",\n  \"Subtask 15\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) in statistics.\",\n  \"Subtask 16\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective\t:\tTest Objective: Verify that the test instrument correctly counts transmitted IPv6 packets\n\nStep\t\t:\tTest Step 1: Reserve two loopback ports: Port_1 and Port_2;\n\t\t\t\tTest Step 2: Modify the IPv6 Encapsulation header content of traffic stream StreamTemplate_1;\n\t\t\t\tTest Step 3: Configure filtered packet capture;\n\t\t\t\tTest Step 4: Subscribe to StreamBlockStats statistics;\n\t\t\t\tTest Step 5: Set port transmission mode to burst mode;\n\t\t\t\tTest Step 6: Transmit all traffic and wait for a period of time;\n\t\t\t\tTest Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria\t:\tExpected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by\t:\tTester-002\n\nBugs\t\t:\tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6encapsulationheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    attr = edit_header_ipv6_encapsulation(Stream=stream, Spi=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6encapsulationheader', Attribute=attr['Spi'],\n                  Type='Increment', Count=10, Step=2)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    time.sleep(3)\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Vlan.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发vlan报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的vlan头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify that the test instrument correctly counts transmitted VLAN packets\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Modify the VLAN header content of traffic stream StreamTemplate_1;;\n                   Test Step 3: Configure filtered packet capture;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set port transmission mode to burst;\n                   Test Step 6: Transmit all traffic and wait for a period;\n                   Test Step 7: Stop all traffic and check StreamBlockStats statistics;;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-004\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'vlan']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改vlan头部\n    attribute_dict = edit_header_vlan(Stream=stream, Level=0, ID=100, Priority=5, CFI=0)\n    # vlan头部目字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['ID'],\n                  Type='Increment', StreamType='InterModifier',\n                  Count=10, Step=2)\n    # vlan头部目字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['Priority'],\n                  Type='List',\n                  List=[2, 4, 6, 3])\n    # vlan头部目字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['CFI'],\n                  Type='Random',\n                  Range=1)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.cfi',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.id',\n                                               Value='100',\n                                               MaxValue='100')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.priority',\n                                               Value='5',\n                                               MaxValue='5')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (default 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports at provided locations (default '//10.0.11.191/1/5' and '//10.0.11.191/1/6').\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Create stream headers for EthernetII and VLAN protocols.\",\n  \"Subtask 5\": \"Modify VLAN header at level 0: set ID=100, Priority=5, CFI=0.\",\n  \"Subtask 6\": \"Apply increment modifier to VLAN ID field: start=100, step=2, count=10.\",\n  \"Subtask 7\": \"Apply list modifier to VLAN Priority field: values=[2,4,6,3].\",\n  \"Subtask 8\": \"Apply random modifier to VLAN CFI field: range=0-1.\",\n  \"Subtask 9\": \"Create capture PDU patterns on second port for: VLAN CFI=1, VLAN ID=100, VLAN Priority=5.\",\n  \"Subtask 10\": \"Configure capture filter on second port using logical AND of all PDU patterns.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 12\": \"Set transmission mode to burst with burst count=100 on first port.\",\n  \"Subtask 13\": \"Save test configuration to specified file path.\",\n  \"Subtask 14\": \"Start packet capture on second port.\",\n  \"Subtask 15\": \"Start traffic transmission.\",\n  \"Subtask 16\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 17\": \"Stop traffic transmission.\",\n  \"Subtask 18\": \"Stop packet capture.\",\n  \"Subtask 19\": \"Download captured packets from second port (optional debug step).\",\n  \"Subtask 20\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 21\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 22\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify that the test instrument correctly counts transmitted VLAN packets\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Modify the VLAN header content of traffic stream StreamTemplate_1;;\n                   Test Step 3: Configure filtered packet capture;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set port transmission mode to burst;\n                   Test Step 6: Transmit all traffic and wait for a period;\n                   Test Step 7: Stop all traffic and check StreamBlockStats statistics;;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-004\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'vlan']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改vlan头部\n    attribute_dict = edit_header_vlan(Stream=stream, Level=0, ID=100, Priority=5, CFI=0)\n    # vlan头部目字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['ID'],\n                  Type='Increment', StreamType='InterModifier',\n                  Count=10, Step=2)\n    # vlan头部目字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['Priority'],\n                  Type='List',\n                  List=[2, 4, 6, 3])\n    # vlan头部目字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='vlan', Attribute=attribute_dict['CFI'],\n                  Type='Random',\n                  Range=1)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.cfi',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.id',\n                                               Value='100',\n                                               MaxValue='100')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='vlan_1.priority',\n                                               Value='5',\n                                               MaxValue='5')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/goose.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Goose头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test purpose: Verify the test instrument's traffic statistics accuracy  \n\nStep:  \n1. Reserve two loopback ports: Port_1 and Port_2.  \n2. Create a traffic stream StreamTemplate_1 on Port_1.  \n3. Modify the Goose header content of StreamTemplate_1.  \n4. Subscribe to StreamBlockStats.  \n5. Transmit all traffic and wait for a period.  \n6. Stop all traffic and check StreamBlockStats.  \n\nCriteria:  \n1. Expected result: In step 6, StreamTemplate_1's transmitted and received packets are equal.  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetII', 'goose'])\n\n    # 修改Goose头部\n    attr = edit_header_goose(Stream=stream, Level=0,\n                             Apdu='102030405060')\n    edit_modifier(Stream=stream, Attribute=attr['Apdu'],\n                  Type='Increment', Count=10, HeaderType='goose')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using 'init_tester' API with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports using 'reserve_port' API, assigning them as Port_UP (sender) and Port_Down (receiver).\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using 'add_stream' API.\",\n  \"Subtask 4\": \"Configure stream parameters with 'edit_stream' API to set frame length type to 'AUTO'.\",\n  \"Subtask 5\": \"Create Ethernet II and Goose headers for the stream using 'create_stream_header' API.\",\n  \"Subtask 6\": \"Modify Goose header's Apdu field to specific value and configure increment modifier using 'edit_modifier' API.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats and PortStats using 'subscribe_result' API.\",\n  \"Subtask 8\": \"Configure Port_UP's load profile with 'edit_port_load_profile' API for burst mode transmission (100 packets).\",\n  \"Subtask 9\": \"Save test configuration to file using 'save_case' API.\",\n  \"Subtask 10\": \"Start traffic transmission using 'start_stream' API.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete using 'wait_stream_state' API.\",\n  \"Subtask 12\": \"Wait 3 seconds for statistics stabilization after traffic stops.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats using 'get_streamblock_statistic' API for the created stream.\",\n  \"Subtask 14\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both match configured burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test purpose: Verify the test instrument's traffic statistics accuracy  \n\nStep:  \n1. Reserve two loopback ports: Port_1 and Port_2.  \n2. Create a traffic stream StreamTemplate_1 on Port_1.  \n3. Modify the Goose header content of StreamTemplate_1.  \n4. Subscribe to StreamBlockStats.  \n5. Transmit all traffic and wait for a period.  \n6. Stop all traffic and check StreamBlockStats.  \n\nCriteria:  \n1. Expected result: In step 6, StreamTemplate_1's transmitted and received packets are equal.  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetII', 'goose'])\n\n    # 修改Goose头部\n    attr = edit_header_goose(Stream=stream, Level=0,\n                             Apdu='102030405060')\n    edit_modifier(Stream=stream, Attribute=attr['Apdu'],\n                  Type='Increment', Count=10, HeaderType='goose')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Udp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发udp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的udp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Purpose: Verify the test instrument accurately counts transmitted UDP packets\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2\n      Step 2: Modify UDP header content of traffic stream StreamTemplate_1\n      Step 3: Configure filtered packet capture\n      Step 4: Subscribe to StreamBlockStats\n      Step 5: Set port transmission mode to burst\n      Step 6: Transmit all traffic streams and wait\n      Step 7: Stop all traffic and check StreamBlockStats\n\nCriteria: Expected Result 1: Packets sent/received for StreamTemplate_1 are equal during Step 6\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ipv4', 'udp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改vlan头部\n    header = edit_header_udp(Stream=stream, Level=0,\n                             SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Level=0, HeaderType='udp',\n                  Attribute=header['SourcePort'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='udp_1.destPort',\n                                               Value='2000', MaxValue='2000')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_udp:修改测试仪表流量模板中UDP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports (Port_1 and Port_2) for testing.\",\n  \"Subtask 2\": \"Create a traffic stream on Port_1 with fixed length 256 bytes.\",\n  \"Subtask 3\": \"Configure stream headers for Ethernet II, IPv4, and UDP protocols.\",\n  \"Subtask 4\": \"Edit UDP header of the stream to set source port=1000 and destination port=2000.\",\n  \"Subtask 5\": \"Apply increment modifier to UDP source port field with step=2 and count=10.\",\n  \"Subtask 6\": \"Create capture PDU pattern on Port_2 filtering UDP packets with destination port=2000.\",\n  \"Subtask 7\": \"Set capture filter on Port_2 using the created PDU pattern.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistic view.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode as burst with burst count=100 packets.\",\n  \"Subtask 10\": \"Start packet capture on Port_2.\",\n  \"Subtask 11\": \"Initiate traffic transmission from Port_1.\",\n  \"Subtask 12\": \"Wait 10 seconds during traffic transmission and capture.\",\n  \"Subtask 13\": \"Stop traffic transmission from Port_1.\",\n  \"Subtask 14\": \"Stop packet capture on Port_2.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 16\": \"Verify transmitted frame count equals received frame count for the UDP stream.\",\n  \"Subtask 17\": \"Release reserved ports Port_1 and Port_2.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Purpose: Verify the test instrument accurately counts transmitted UDP packets\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2\n      Step 2: Modify UDP header content of traffic stream StreamTemplate_1\n      Step 3: Configure filtered packet capture\n      Step 4: Subscribe to StreamBlockStats\n      Step 5: Set port transmission mode to burst\n      Step 6: Transmit all traffic streams and wait\n      Step 7: Stop all traffic and check StreamBlockStats\n\nCriteria: Expected Result 1: Packets sent/received for StreamTemplate_1 are equal during Step 6\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ipv4', 'udp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改vlan头部\n    header = edit_header_udp(Stream=stream, Level=0,\n                             SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Level=0, HeaderType='udp',\n                  Attribute=header['SourcePort'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='udp_1.destPort',\n                                               Value='2000', MaxValue='2000')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_udp:修改测试仪表流量模板中UDP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6MLDv2Query.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv2 query报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv2 query头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify that the test instrument accurately counts sent ICMPv6 MLDv2 query packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test Step 2: Modify ICMPv6 MLDv2 query header content in traffic StreamTemplate_1;\n      Test Step 3: Configure filter for packet capture;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Set port transmission mode to burst;\n      Test Step 6: Transmit all traffic and wait for a period;\n      Test Step 7: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, sent and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv2query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2 query头部\n    header = edit_header_icmpv6_mldv2_query(Stream=stream, Level=0,\n                                            Code='2', Reserved='10',\n                                            GroupAddress='FF1E::1', Qrv='111',\n                                            SourceAddressList=['2001::1', '2002::2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2query', Attribute=header['SourceAddressList: 2002::2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.Qrv',\n                                               Value='111',\n                                               MaxValue='111')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_mldv2_query:修改测试仪表流量模板中Icmpv6 Mldv2 Query报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with product specification 'DarYu'.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) at specified locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv6, and MLDv2 Query.\",\n  \"Subtask 5\": \"Modify MLDv2 Query header parameters: Code=2, Reserved=10, GroupAddress='FF1E::1', Qrv=111, SourceAddressList=['2001::1','2002::2'].\",\n  \"Subtask 6\": \"Apply increment modifier to SourceAddressList field with count=10.\",\n  \"Subtask 7\": \"Create PDU patterns on Port_2 for capture filtering: MLDv2 Query Code=2, Reserved=10, Qrv=111.\",\n  \"Subtask 8\": \"Configure capture filter on Port_2 using logical AND combination of PDU patterns.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Set Port_1 transmission mode to BURST with burst count=100.\",\n  \"Subtask 11\": \"Start packet capture on Port_2.\",\n  \"Subtask 12\": \"Initiate traffic transmission from Port_1.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission and capture.\",\n  \"Subtask 14\": \"Stop traffic transmission on Port_1.\",\n  \"Subtask 15\": \"Stop packet capture on Port_2.\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats results for transmitted and received frame counts.\",\n  \"Subtask 17\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 18\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify that the test instrument accurately counts sent ICMPv6 MLDv2 query packets\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test Step 2: Modify ICMPv6 MLDv2 query header content in traffic StreamTemplate_1;\n      Test Step 3: Configure filter for packet capture;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Set port transmission mode to burst;\n      Test Step 6: Transmit all traffic and wait for a period;\n      Test Step 7: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, sent and received packets for traffic StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv2query']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改icmpv6 mldv2 query头部\n    header = edit_header_icmpv6_mldv2_query(Stream=stream, Level=0,\n                                            Code='2', Reserved='10',\n                                            GroupAddress='FF1E::1', Qrv='111',\n                                            SourceAddressList=['2001::1', '2002::2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='mldv2query', Attribute=header['SourceAddressList: 2002::2'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.code',\n                                               Value='2', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.reserved',\n                                               Value='10',\n                                               MaxValue='10')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv2Query_1.Qrv',\n                                               Value='111',\n                                               MaxValue='111')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_mldv2_query:修改测试仪表流量模板中Icmpv6 Mldv2 Query报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2LinkStateUpdate.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发OSPFv2 Link State Update Instance报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的OSPFv2 Link State Update Instance头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Verify that the test instrument accurately counts transmitted OSPFv2 Link State Update Instance packets\n\nStep         :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Test Step 2: Modify the OSPFv2 Link State Update Instance header of traffic stream StreamTemplate_1;\n                Test Step 3: Configure filtered packet capture;\n                Test Step 4: Subscribe to StreamBlockStats;\n                Test Step 5: Set port transmission mode to burst;\n                Test Step 6: Transmit all traffic and wait for a period;\n                Test Step 7: Stop all traffic and examine StreamBlockStats;\n\nCriteria     :   Expected Result 1: In step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstateupdate']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2头部\n    header = edit_header_ospfv2_update(Stream=stream, Level=0,\n                                       RouterID='2.2.2.2', AuthType='MD5')\n\n    router_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Router',\n                                               RouterLsaReserved1=10,\n                                               LsaAge=20,\n                                               Reserved7=1,\n                                               Reserved7Router=0,\n                                               )\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['RouterLsaReserved1'],\n    #               Type='Increment',\n    #               Count=10, Step=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['LsaAge'],\n    #               Type='Increment',\n    #               Count=10, Step=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['Reserved7'],\n    #               Type='Increment',\n    #               Count=2, Step=1)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['Reserved7Router'],\n    #               Type='Increment',\n    #               Count=2, Step=1)\n\n    router_lsa_link = edit_header_ospfv2_update_route_lsa_link(Stream=stream,\n                                                               LinkId='3.3.3.3')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=router_lsa_link['LinkId'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    router_lsa_link_metric = edit_header_ospfv2_update_route_link_tos_metric(Stream=stream,\n                                                                             RouterLsaMetricReserved=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=router_lsa_link_metric['RouterLsaMetricReserved'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    network_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Network', Index=1,\n                                                LsType=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=network_lsa['LsType'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    network_attached_router = edit_header_ospfv2_update_network_attached_route(Stream=stream, LsaIndex=1,\n                                                                               RouterID='4.4.4.4')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=network_attached_router['RouterID'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    summary_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Summary', Index=2,\n                                                AdvertisingRouter='5.5.5.5')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=summary_lsa['AdvertisingRouter'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    summary_tos_metric = edit_header_ospfv2_update_tos_metric(Stream=stream, Type='Summary', LsaIndex=2,\n                                                              MetricReserved=20)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=summary_tos_metric['MetricReserved'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='ospfv2LinkStateUpdate_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_update:修改测试仪表流量模板中OSPFv2 Link State Update报文头部内容",
      "edit_header_ospfv2_update_lsa:修改测试仪表流量模板中OSPFv2 Update报文中Lsa头部内容.",
      "edit_header_ospfv2_update_route_link_tos_metric:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容",
      "edit_header_ospfv2_update_route_lsa_link:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容",
      "edit_header_ospfv2_update_tos_metric:修改测试仪表流量模板中OSPFv2 Update报文中Summary、 SummaryAsbr或AsExternal Lsa头部Tos Metric内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu'.\",\n  \"Subtask 2\": \"Reserve two ports using specified locations.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Create stream headers: EthernetII, IPv4, and OSPFv2 Link State Update.\",\n  \"Subtask 5\": \"Edit OSPFv2 Link State Update header: set router ID to '2.2.2.2' and authentication type to 'MD5'.\",\n  \"Subtask 6\": \"Edit Router LSA: set RouterLsaReserved1=10, LsaAge=20, Reserved7=1, Reserved7Router=0.\",\n  \"Subtask 7\": \"Set increment modifier on Router LSA LinkId field: start '3.3.3.3', count=10, step=2.\",\n  \"Subtask 8\": \"Set increment modifier on Router LSA MetricReserved field: start=10, count=10, step=2.\",\n  \"Subtask 9\": \"Edit Network LSA: set Type='Network', Index=1, LsType=10, then set increment modifier on LsType field with count=10, step=2.\",\n  \"Subtask 10\": \"Edit Network Attached Router: set LsaIndex=1, RouterID='4.4.4.4', then set increment modifier on RouterID field with count=10, step=2.\",\n  \"Subtask 11\": \"Edit Summary LSA: set Type='Summary', Index=2, AdvertisingRouter='5.5.5.5', then set increment modifier on AdvertisingRouter field with count=10, step=2.\",\n  \"Subtask 12\": \"Edit Summary TOS Metric: set MetricReserved=20, then set increment modifier on MetricReserved field with count=10, step=2.\",\n  \"Subtask 13\": \"Create capture PDU pattern on second port: filter by OSPFv2 routerID='2.2.2.2'.\",\n  \"Subtask 14\": \"Apply capture filter expression to second port using created PDU pattern.\",\n  \"Subtask 15\": \"Subscribe to StreamBlockStats view.\",\n  \"Subtask 16\": \"Configure first port transmission mode: set to BURST with burst count=100.\",\n  \"Subtask 17\": \"Save test configuration to file.\",\n  \"Subtask 18\": \"Start packet capture on second port.\",\n  \"Subtask 19\": \"Start traffic stream transmission on first port.\",\n  \"Subtask 20\": \"Wait for 10 seconds during transmission.\",\n  \"Subtask 21\": \"Stop traffic stream transmission.\",\n  \"Subtask 22\": \"Stop packet capture.\",\n  \"Subtask 23\": \"Download captured packets from second port.\",\n  \"Subtask 24\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 25\": \"Verify transmitted frames equal received frames (TxStreamFrames == RxStreamFrames).\",\n  \"Subtask 26\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Verify that the test instrument accurately counts transmitted OSPFv2 Link State Update Instance packets\n\nStep         :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Test Step 2: Modify the OSPFv2 Link State Update Instance header of traffic stream StreamTemplate_1;\n                Test Step 3: Configure filtered packet capture;\n                Test Step 4: Subscribe to StreamBlockStats;\n                Test Step 5: Set port transmission mode to burst;\n                Test Step 6: Transmit all traffic and wait for a period;\n                Test Step 7: Stop all traffic and examine StreamBlockStats;\n\nCriteria     :   Expected Result 1: In step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2linkstateupdate']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2头部\n    header = edit_header_ospfv2_update(Stream=stream, Level=0,\n                                       RouterID='2.2.2.2', AuthType='MD5')\n\n    router_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Router',\n                                               RouterLsaReserved1=10,\n                                               LsaAge=20,\n                                               Reserved7=1,\n                                               Reserved7Router=0,\n                                               )\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['RouterLsaReserved1'],\n    #               Type='Increment',\n    #               Count=10, Step=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['LsaAge'],\n    #               Type='Increment',\n    #               Count=10, Step=2)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['Reserved7'],\n    #               Type='Increment',\n    #               Count=2, Step=1)\n    # edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n    #               Attribute=router_lsa['Reserved7Router'],\n    #               Type='Increment',\n    #               Count=2, Step=1)\n\n    router_lsa_link = edit_header_ospfv2_update_route_lsa_link(Stream=stream,\n                                                               LinkId='3.3.3.3')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=router_lsa_link['LinkId'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    router_lsa_link_metric = edit_header_ospfv2_update_route_link_tos_metric(Stream=stream,\n                                                                             RouterLsaMetricReserved=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=router_lsa_link_metric['RouterLsaMetricReserved'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    network_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Network', Index=1,\n                                                LsType=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=network_lsa['LsType'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    network_attached_router = edit_header_ospfv2_update_network_attached_route(Stream=stream, LsaIndex=1,\n                                                                               RouterID='4.4.4.4')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=network_attached_router['RouterID'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    summary_lsa = edit_header_ospfv2_update_lsa(Stream=stream, Type='Summary', Index=2,\n                                                AdvertisingRouter='5.5.5.5')\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=summary_lsa['AdvertisingRouter'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    summary_tos_metric = edit_header_ospfv2_update_tos_metric(Stream=stream, Type='Summary', LsaIndex=2,\n                                                              MetricReserved=20)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2linkstateupdate',\n                  Attribute=summary_tos_metric['MetricReserved'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='ospfv2LinkStateUpdate_1.ospfHeader.routerID',\n                                               Value='2.2.2.2', MaxValue='2.2.2.2')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_update:修改测试仪表流量模板中OSPFv2 Link State Update报文头部内容;\nedit_header_ospfv2_update_lsa:修改测试仪表流量模板中OSPFv2 Update报文中Lsa头部内容.;\nedit_header_ospfv2_update_route_link_tos_metric:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容;\nedit_header_ospfv2_update_route_lsa_link:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容;\nedit_header_ospfv2_update_tos_metric:修改测试仪表流量模板中OSPFv2 Update报文中Summary、 SummaryAsbr或AsExternal Lsa头部Tos Metric内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/MstpConfig.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的mstp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify the test instrument accurately counts traffic statistics\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a stream, StreamTemplate_1, on port Port_1;\n      Step 3: Modify the MSTP header content of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats;\n      Step 5: Transmit all streams and wait for a period;\n      Step 6: Stop all streams and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, packets received and sent for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'logicLinkControl', 'cfg'])\n\n    # 修改mstp头部\n    attr = edit_header_mstp_config(Stream=stream, Level=0,\n                                   RootBridgeSystemID='22:11:11:11:11:11',\n                                   MstInstances=1)\n    edit_modifier(Stream=stream, Attribute=attr['RootBridgeSystemID'],\n                  Type='Increment', Count=10, HeaderType='cfg')\n    attr_ins = edit_header_mstp_config_mst_instance(Stream=stream,\n                                                    RemainingHops=255)\n    edit_modifier(Stream=stream, Attribute=attr_ins['RemainingHops'],\n                  Type='Increment', Count=10, HeaderType='cfg')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using the specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using provided locations.\",\n  \"Subtask 3\": \"Create a stream (StreamTemplate_1) on Port_1.\",\n  \"Subtask 4\": \"Edit the stream to set frame length type to 'AUTO'.\",\n  \"Subtask 5\": \"Create stream headers for ethernetii, logicLinkControl, and cfg protocols.\",\n  \"Subtask 6\": \"Modify MSTP header configuration: set Level=0, RootBridgeSystemID='22:11:11:11:11:11', and MstInstances=1.\",\n  \"Subtask 7\": \"Configure increment modifier for RootBridgeSystemID attribute (Increment by 10 for 10 counts).\",\n  \"Subtask 8\": \"Modify MSTP instance header configuration: set RemainingHops=255.\",\n  \"Subtask 9\": \"Configure increment modifier for RemainingHops attribute (Increment by 10 for 10 counts).\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 11\": \"Configure port load profile for Port_1: set TransmitMode='BURST' and BurstCount=100.\",\n  \"Subtask 12\": \"Save the test configuration to a file.\",\n  \"Subtask 13\": \"Start stream transmission.\",\n  \"Subtask 14\": \"Wait until all streams stop transmitting.\",\n  \"Subtask 15\": \"Wait 3 seconds after stream stop to ensure accurate statistics collection.\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats results for StreamTemplate_1.\",\n  \"Subtask 17\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both equal the burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify the test instrument accurately counts traffic statistics\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a stream, StreamTemplate_1, on port Port_1;\n      Step 3: Modify the MSTP header content of stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats;\n      Step 5: Transmit all streams and wait for a period;\n      Step 6: Stop all streams and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, packets received and sent for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'logicLinkControl', 'cfg'])\n\n    # 修改mstp头部\n    attr = edit_header_mstp_config(Stream=stream, Level=0,\n                                   RootBridgeSystemID='22:11:11:11:11:11',\n                                   MstInstances=1)\n    edit_modifier(Stream=stream, Attribute=attr['RootBridgeSystemID'],\n                  Type='Increment', Count=10, HeaderType='cfg')\n    attr_ins = edit_header_mstp_config_mst_instance(Stream=stream,\n                                                    RemainingHops=255)\n    edit_modifier(Stream=stream, Attribute=attr_ins['RemainingHops'],\n                  Type='Increment', Count=10, HeaderType='cfg')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl1psnpHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    : Verify the accuracy of traffic statistics from the test instrument\n\nStep        : Step 1: Reserve two loopback ports, Port_1 and Port_2;\n             Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n             Step 3: Modify the ISIS header content of StreamTemplate_1;\n             Step 4: Subscribe to StreamBlockStats statistics;\n             Step 5: Transmit all traffic and wait for a duration;\n             Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    : Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by  : Tester-002\n\nBugs        : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1psnpHeader'])\n\n    header = edit_header_isis_psnp(Stream=stream,\n                                   LengthIndicator=10,\n                                   CsnpDataTlvOptionHeader=['isIsLspEntries', 'authentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=header['LengthIndicator'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries',\n                                      Length=10,\n                                      LspEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=tlv['Length'],\n                  Type='Increment', Count=10)\n\n    entry = edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=entry['RemainTime'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1psnpHeader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports (Port_1 and Port_2) using reserve_port API with specified locations.\",\n  \"Subtask 2\": \"Create traffic stream StreamTemplate_1 on Port_1 using add_stream API.\",\n  \"Subtask 3\": \"Create stream headers for StreamTemplate_1 with EthernetII and l1psnpHeader using create_stream_header API.\",\n  \"Subtask 4\": \"Modify ISIS PSNP header in StreamTemplate_1: set LengthIndicator=10 and configure increment modifier using edit_header_isis_psnp and edit_modifier APIs.\",\n  \"Subtask 5\": \"Modify ISIS TLV header in StreamTemplate_1: set Option='IsIsLspEntries', Length=10 and configure increment modifier using edit_header_isis_tlv_header and edit_modifier APIs.\",\n  \"Subtask 6\": \"Modify ISIS LSP entry in StreamTemplate_1: set RemainTime=10 and configure increment modifier using edit_header_isis_lsp_entry and edit_modifier APIs.\",\n  \"Subtask 7\": \"Subscribe to StreamBlockStats statistics using subscribe_result API with type 'StreamBlockStats'.\",\n  \"Subtask 8\": \"Configure Port_1 transmit mode as burst with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Start traffic transmission using start_stream API and wait for completion using wait_stream_state API.\",\n  \"Subtask 10\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API and verify TxStreamFrames equals RxStreamFrames.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    : Verify the accuracy of traffic statistics from the test instrument\n\nStep        : Step 1: Reserve two loopback ports, Port_1 and Port_2;\n             Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n             Step 3: Modify the ISIS header content of StreamTemplate_1;\n             Step 4: Subscribe to StreamBlockStats statistics;\n             Step 5: Transmit all traffic and wait for a duration;\n             Step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria    : Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by  : Tester-002\n\nBugs        : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1psnpHeader'])\n\n    header = edit_header_isis_psnp(Stream=stream,\n                                   LengthIndicator=10,\n                                   CsnpDataTlvOptionHeader=['isIsLspEntries', 'authentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=header['LengthIndicator'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries',\n                                      Length=10,\n                                      LspEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=tlv['Length'],\n                  Type='Increment', Count=10)\n\n    entry = edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1psnpHeader', Attribute=entry['RemainTime'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1psnpHeader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Gtpv1.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发gtpv1报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的gtpv1头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective     : Purpose: Verify the test instrument correctly counts GTPv1 packets sent\n\nStep          : Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Step 2: Modify GTPv1 header content in traffic stream StreamTemplate_1;\n               Step 3: Configure filtered packet capture;\n               Step 4: Subscribe to StreamBlockStats counters;\n               Step 5: Set port transmission mode to burst;\n               Step 6: Transmit all traffic streams and wait;\n               Step 7: Stop all traffic and check StreamBlockStats data;\n\nCriteria      : Expected Result 1: Packets sent/received for StreamTemplate_1 match in Step 6;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TCP', 'gtpv1', 'gtpv1opt', 'gtpv1ext']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改gtp头部\n    gtp = edit_header_gtpv1(Stream=stream, Teid=10)\n    opt = edit_header_gtpv1_optional(Stream=stream, Sequence=20)\n    optext = edit_header_gtpv1_optional_extension(Stream=stream, NPDUNumber=30)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1', Attribute=gtp['Teid'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1opt', Attribute=opt['Sequence'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1ext', Attribute=optext['NPDUNumber'],\n                  Type='Increment', Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='gtpv1_1.version',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (default 'DarYu' or command-line input).\",\n  \"Subtask 2\": \"Reserve two ports based on provided locations (default or command-line input).\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length of 256 bytes.\",\n  \"Subtask 4\": \"Create stream headers: EthernetII, IPv4, TCP, GTPv1, GTPv1 optional, and GTPv1 extension.\",\n  \"Subtask 5\": \"Edit GTPv1 header fields: set initial TEID=10, Sequence=20, and NPDU Number=30.\",\n  \"Subtask 6\": \"Configure modifiers for GTPv1 fields: increment TEID by 2 for 10 counts, Sequence by 2 for 10 counts, NPDU Number by 2 for 10 counts.\",\n  \"Subtask 7\": \"Create capture filter on second port: GTPv1 packets with version=1.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats counter view.\",\n  \"Subtask 9\": \"Configure first port's transmission mode: burst mode with count=100 packets.\",\n  \"Subtask 10\": \"Save test configuration to file.\",\n  \"Subtask 11\": \"Start packet capture on second port.\",\n  \"Subtask 12\": \"Start traffic transmission on first port.\",\n  \"Subtask 13\": \"Wait 10 seconds during transmission.\",\n  \"Subtask 14\": \"Stop traffic transmission.\",\n  \"Subtask 15\": \"Stop packet capture.\",\n  \"Subtask 16\": \"Download captured packets from second port to local directory.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats counters for the traffic stream.\",\n  \"Subtask 18\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 19\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective     : Purpose: Verify the test instrument correctly counts GTPv1 packets sent\n\nStep          : Step 1: Reserve two loopback ports Port_1 and Port_2;\n               Step 2: Modify GTPv1 header content in traffic stream StreamTemplate_1;\n               Step 3: Configure filtered packet capture;\n               Step 4: Subscribe to StreamBlockStats counters;\n               Step 5: Set port transmission mode to burst;\n               Step 6: Transmit all traffic streams and wait;\n               Step 7: Stop all traffic and check StreamBlockStats data;\n\nCriteria      : Expected Result 1: Packets sent/received for StreamTemplate_1 match in Step 6;\n\nCreated by    : Tester-002\n\nBugs          : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TCP', 'gtpv1', 'gtpv1opt', 'gtpv1ext']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改gtp头部\n    gtp = edit_header_gtpv1(Stream=stream, Teid=10)\n    opt = edit_header_gtpv1_optional(Stream=stream, Sequence=20)\n    optext = edit_header_gtpv1_optional_extension(Stream=stream, NPDUNumber=30)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1', Attribute=gtp['Teid'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1opt', Attribute=opt['Sequence'],\n                  Type='Increment', Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='gtpv1ext', Attribute=optext['NPDUNumber'],\n                  Type='Increment', Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='gtpv1_1.version',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2UpdateRouteLsa.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 link state update报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的ospfv2 link state update头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify that the test instrument correctly counts OSPFv2 Link State Update packets sent\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the OSPFv2 Link State Update header content in traffic stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: For traffic stream StreamTemplate_1 in Step 6, transmitted and received packet counts are equal;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n\n    stream = add_stream(Ports=Port_UP, FixedLength=256)\n\n    # 修改流量报文头部\n\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'ospfv2linkstateupdate'])\n\n    # 修改ospfv2 link state update头部，添加一个Router LSA\n\n    LsaHeaders = ['Router']\n    edit_header_ospfv2_update(Stream=stream, Level=0,\n                              RouterID='10.1.1.2',\n                              AreaID='0.0.0.2',\n                              AuthValue2=1,\n                              LsaHeaders=LsaHeaders,\n                              )\n\n    # 修改ospfv2 link state update头部，Router LSA内容，并添加4个Lsa Link即RouterLsaLinkCount=4\n\n    edit_header_ospfv2_update_lsa(Stream=stream, Level=0,\n                                  Index=0,\n                                  Type='Router',\n                                  LinkStateId='10.1.0.1',\n                                  AdvertisingRouter='10.1.0.2',\n                                  RouterLsaLinkCount=4,\n                                  )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第一个RouterLsaLinkCount内容即Index=0\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=0,\n                                             LinkId='10.1.0.0',\n                                             LinkData='255.255.255.255',\n                                             RouterLsaLinkType=3,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第二个RouterLsaLinkCount内容即Index=1\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=1,\n                                             LinkId='10.2.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=2,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第三个RouterLsaLinkCount内容即Index=2\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=2,\n                                             LinkId='10.3.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=4,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第四个RouterLsaLinkCount内容即Index=3\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=3,\n                                             LinkId='10.4.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=1,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 订阅StreamBlockStats统计视图\n\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n\n    start_capture()\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_capture()\n\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(stream, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 释放端口资源\n\n    result = release_port(Locations=locations)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_update:修改测试仪表流量模板中OSPFv2 Link State Update报文头部内容",
      "edit_header_ospfv2_update_lsa:修改测试仪表流量模板中OSPFv2 Update报文中Lsa头部内容.",
      "edit_header_ospfv2_update_route_lsa_link:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using 'init_tester' API with specified product parameter.\",\n  \"Subtask 2\": \"Reserve two ports using 'reserve_port' API with provided locations, assigning them to Port_1 (sending port) and Port_2 (receiving port).\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 using 'add_stream' API with fixed length of 256 bytes, assigning it to stream variable.\",\n  \"Subtask 4\": \"Configure stream headers for EthernetII, IPv4, and OSPFv2 Link State Update using 'create_stream_header' API.\",\n  \"Subtask 5\": \"Modify OSPFv2 Link State Update header using 'edit_header_ospfv2_update' API with parameters: RouterID='10.1.1.2', AreaID='0.0.0.2', AuthValue2=1, and LSA type 'Router'.\",\n  \"Subtask 6\": \"Edit Router LSA header using 'edit_header_ospfv2_update_lsa' API with parameters: LinkStateId='10.1.0.1', AdvertisingRouter='10.1.0.2', RouterLsaLinkCount=4.\",\n  \"Subtask 7\": \"Configure first Router LSA link (index 0) using 'edit_header_ospfv2_update_route_lsa_link' API with parameters: LinkId='10.1.0.0', LinkData='255.255.255.255', RouterLsaLinkType=3.\",\n  \"Subtask 8\": \"Configure second Router LSA link (index 1) using 'edit_header_ospfv2_update_route_lsa_link' API with parameters: LinkId='10.2.0.0', LinkData='255.255.0.0', RouterLsaLinkType=2.\",\n  \"Subtask 9\": \"Configure third Router LSA link (index 2) using 'edit_header_ospfv2_update_route_lsa_link' API with parameters: LinkId='10.3.0.0', LinkData='255.255.0.0', RouterLsaLinkType=4.\",\n  \"Subtask 10\": \"Configure fourth Router LSA link (index 3) using 'edit_header_ospfv2_update_route_lsa_link' API with parameters: LinkId='10.4.0.0', LinkData='255.255.0.0', RouterLsaLinkType=1.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics using 'subscribe_result' API.\",\n  \"Subtask 12\": \"Start packet capture on both ports using 'start_capture' API.\",\n  \"Subtask 13\": \"Transmit traffic stream using 'start_stream' API.\",\n  \"Subtask 14\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission using 'stop_stream' API.\",\n  \"Subtask 16\": \"Stop packet capture using 'stop_capture' API.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats using 'get_streamblock_statistic' API for the created stream.\",\n  \"Subtask 18\": \"Verify transmitted packet count (TxStreamFrames) equals received packet count (RxStreamFrames); if not equal, mark test as failed.\",\n  \"Subtask 19\": \"Download captured packets from Port_2 using 'download_packages' API with specified directory and filename.\",\n  \"Subtask 20\": \"Release reserved ports using 'release_port' API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify that the test instrument correctly counts OSPFv2 Link State Update packets sent\n\nStep: Step 1: Reserve two loopback ports, Port_1 and Port_2;\n      Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Step 3: Modify the OSPFv2 Link State Update header content in traffic stream StreamTemplate_1;\n      Step 4: Subscribe to StreamBlockStats statistics;\n      Step 5: Transmit all traffic and wait for a period;\n      Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: For traffic stream StreamTemplate_1 in Step 6, transmitted and received packet counts are equal;\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n\n    stream = add_stream(Ports=Port_UP, FixedLength=256)\n\n    # 修改流量报文头部\n\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'ospfv2linkstateupdate'])\n\n    # 修改ospfv2 link state update头部，添加一个Router LSA\n\n    LsaHeaders = ['Router']\n    edit_header_ospfv2_update(Stream=stream, Level=0,\n                              RouterID='10.1.1.2',\n                              AreaID='0.0.0.2',\n                              AuthValue2=1,\n                              LsaHeaders=LsaHeaders,\n                              )\n\n    # 修改ospfv2 link state update头部，Router LSA内容，并添加4个Lsa Link即RouterLsaLinkCount=4\n\n    edit_header_ospfv2_update_lsa(Stream=stream, Level=0,\n                                  Index=0,\n                                  Type='Router',\n                                  LinkStateId='10.1.0.1',\n                                  AdvertisingRouter='10.1.0.2',\n                                  RouterLsaLinkCount=4,\n                                  )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第一个RouterLsaLinkCount内容即Index=0\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=0,\n                                             LinkId='10.1.0.0',\n                                             LinkData='255.255.255.255',\n                                             RouterLsaLinkType=3,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第二个RouterLsaLinkCount内容即Index=1\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=1,\n                                             LinkId='10.2.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=2,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第三个RouterLsaLinkCount内容即Index=2\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=2,\n                                             LinkId='10.3.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=4,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 修改ospfv2 link state update头部，Router LSA中，第四个RouterLsaLinkCount内容即Index=3\n\n    edit_header_ospfv2_update_route_lsa_link(Stream=stream, Level=0,\n                                             LsaIndex=0,\n                                             Index=3,\n                                             LinkId='10.4.0.0',\n                                             LinkData='255.255.0.0',\n                                             RouterLsaLinkType=1,\n                                             NumRouterLsaTosMetrics=10,\n                                             )\n\n    # 订阅StreamBlockStats统计视图\n\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n\n    start_capture()\n\n    start_stream()\n\n    time.sleep(10)\n\n    stop_stream()\n\n    stop_capture()\n\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames:\n        verdict = 'fail'\n        errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(stream, TxStreamFrames,\n                                                                                       RxStreamFrames)\n\n    # 释放端口资源\n\n    result = release_port(Locations=locations)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_update:修改测试仪表流量模板中OSPFv2 Link State Update报文头部内容;\nedit_header_ospfv2_update_lsa:修改测试仪表流量模板中OSPFv2 Update报文中Lsa头部内容.;\nedit_header_ospfv2_update_route_lsa_link:修改测试仪表流量模板中OSPFv2 Update报文中Route Lsa头部Link内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2TPv3DataOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv3 Data Over Udp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test objective: Verify the accuracy of the test instrument's traffic statistics\n\nStep: Test step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Test step 3: Modify the L2TPv3 Data Over UDP header content of stream StreamTemplate_1;\n      Test step 4: Subscribe to StreamBlockStats statistics;\n      Test step 5: Transmit all traffic and wait for a period;\n      Test step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-003\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp'])\n\n    # 修改icmpv4 echo reply头部\n    edit_header_l2tpv3_data_over_udp(Stream=stream, Level=0,\n                                     Type=1,\n                                     Reserved1='00000000001',\n                                     Version=1,\n                                     Reserved2=1,\n                                     SessionId=1,\n                                     Cookie4Byte='00000001',\n                                     L2specificsublayer={'xbit': 1, 'sbit': 1, 'xbits': '000001', 'sequence': 1}, )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp'],\n                                             FieldName='l2tpv3DataOverUdp_1.sessionId',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two test instrument ports: Port_1 as the transmitting port and Port_2 as the receiving port for loopback testing.\",\n  \"Subtask 2\": \"Create a traffic stream (StreamTemplate_1) on Port_1 with a fixed frame length of 512 bytes.\",\n  \"Subtask 3\": \"Construct the stream header for StreamTemplate_1 with protocol layers: Ethernet II, IPv4, UDP, and L2TPv3 Data over UDP.\",\n  \"Subtask 4\": \"Modify the L2TPv3 Data over UDP header parameters: set Type=1, Reserved1='00000000001', Version=1, Reserved2=1, SessionId=1, Cookie4Byte='00000001', and L2-specific sublayer with xbit=1, sbit=1, xbits='000001', sequence=1.\",\n  \"Subtask 5\": \"Subscribe to StreamBlockStats statistics view for performance monitoring.\",\n  \"Subtask 6\": \"Configure Port_1 transmission mode as BURST with burst count set to 100 packets.\",\n  \"Subtask 7\": \"Start traffic transmission from Port_1 and simultaneously begin packet capture on Port_2.\",\n  \"Subtask 8\": \"Wait for traffic transmission to complete and then pause for 3 seconds to stabilize statistics collection.\",\n  \"Subtask 9\": \"Stop packet capture on Port_2 after traffic transmission ends.\",\n  \"Subtask 10\": \"Retrieve StreamBlockStats statistics for StreamTemplate_1 to obtain transmitted (TxStreamFrames) and received (RxStreamFrames) packet counts.\",\n  \"Subtask 11\": \"Verify that TxStreamFrames equals RxStreamFrames and both match the configured burst count of 100 packets.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test objective: Verify the accuracy of the test instrument's traffic statistics\n\nStep: Test step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Test step 3: Modify the L2TPv3 Data Over UDP header content of stream StreamTemplate_1;\n      Test step 4: Subscribe to StreamBlockStats statistics;\n      Test step 5: Transmit all traffic and wait for a period;\n      Test step 6: Stop all traffic and examine StreamBlockStats statistics;\n\nCriteria: Expected result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by: Tester-003\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp'])\n\n    # 修改icmpv4 echo reply头部\n    edit_header_l2tpv3_data_over_udp(Stream=stream, Level=0,\n                                     Type=1,\n                                     Reserved1='00000000001',\n                                     Version=1,\n                                     Reserved2=1,\n                                     SessionId=1,\n                                     Cookie4Byte='00000001',\n                                     L2specificsublayer={'xbit': 1, 'sbit': 1, 'xbits': '000001', 'sequence': 1}, )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp'],\n                                             FieldName='l2tpv3DataOverUdp_1.sessionId',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Igmpv2Report.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发igmpv2 report报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的igmpv2 report头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   : Verify that the test instrument correctly counts transmitted IGMPv2 report packets\nStep        : Step 1: Reserve two loopback ports: Port_1 and Port_2;\n             : Step 2: Modify the IGMPv2 report header content of traffic StreamTemplate_1;\n             : Step 3: Configure filtered packet capture;\n             : Step 4: Subscribe to StreamBlockStats statistics;\n             : Step 5: Set port transmission mode to burst;\n             : Step 6: Send all traffic and wait for a period;\n             : Step 7: Stop all traffic and check StreamBlockStats statistics;\nCriteria    : Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\nCreated by  : Tester-004\nBugs        : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv2']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv2_report(Stream=stream, Level=0, Type=99, MaxResponseTime='255', Checksum='ffff',\n                              GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.GroupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_igmpv2_report:修改测试仪表流量模板中IGMPv2 Report报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu' using the init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations using reserve_port API, assigning them as Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Build stream headers with EthernetII, IPv4, and IGMPv2 layers using create_stream_header API.\",\n  \"Subtask 5\": \"Modify IGMPv2 report header parameters: Type=99, MaxResponseTime='255', Checksum='ffff', GroupAddress='10.1.1.1' using edit_header_igmpv2_report API.\",\n  \"Subtask 6\": \"Create three PDU patterns on Port_2 for capture filtering: match igmpv2_1.type=99, igmpv2_1.Checksum='ffff', and igmpv2_1.GroupAddress='10.1.1.1' using create_capture_pdu_pattern API.\",\n  \"Subtask 7\": \"Configure packet capture filter on Port_2 with logical AND expression combining the three PDU patterns using edit_capture_filter API.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 9\": \"Configure Port_1 transmission mode as burst with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Start packet capture on Port_2 using start_capture API.\",\n  \"Subtask 11\": \"Transmit traffic from Port_1 using start_stream API.\",\n  \"Subtask 12\": \"Wait 10 seconds for traffic transmission and capture.\",\n  \"Subtask 13\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 14\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats using get_streamblock_statistic API and verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 16\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   : Verify that the test instrument correctly counts transmitted IGMPv2 report packets\nStep        : Step 1: Reserve two loopback ports: Port_1 and Port_2;\n             : Step 2: Modify the IGMPv2 report header content of traffic StreamTemplate_1;\n             : Step 3: Configure filtered packet capture;\n             : Step 4: Subscribe to StreamBlockStats statistics;\n             : Step 5: Set port transmission mode to burst;\n             : Step 6: Send all traffic and wait for a period;\n             : Step 7: Stop all traffic and check StreamBlockStats statistics;\nCriteria    : Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\nCreated by  : Tester-004\nBugs        : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'igmpv2']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改igmpv3 report头部\n    edit_header_igmpv2_report(Stream=stream, Level=0, Type=99, MaxResponseTime='255', Checksum='ffff',\n                              GroupAddress='10.1.1.1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.type',\n                                               Value='99', MaxValue='99')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.Checksum',\n                                               Value='ffff',\n                                               MaxValue='ffff')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='igmpv2_1.GroupAddress',\n                                               Value='10.1.1.1',\n                                               MaxValue='10.1.1.1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_igmpv2_report:修改测试仪表流量模板中IGMPv2 Report报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/IPv6.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv6报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv6头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective      :   Test Objective: Verify the accuracy of IPv6 packet statistics transmitted by the test instrument\n\nStep           :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Modify the IPv6 header content of traffic StreamTemplate_1;\n                   Test Step 3: Configure packet capture filtering;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Set port transmission mode to burst packet;\n                   Test Step 6: Transmit all traffic and wait for a period;\n                   Test Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria       :   Expected Result 1: In Step 6, transmitted and received packets of StreamTemplate_1 are equal;\n\nCreated by     :   Tester-004\n\nBugs           :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6fragmentheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ipv6头部\n    attribute_dict = edit_header_ipv6(Stream=stream, Level=0, HopLimit=20,\n                                      Source='2022::2', Destination='2020::2', Gateway='2022::1')\n    # ipv6头部HopLimit字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['HopLimit'],\n                  Type='Increment', Count=10, Step=2)\n    # ipv6头部Source字段添加List跳变\n#    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['Source'],\n#                  Type='List', List=['2022::2', '2022::5', '2022::3'])\n    # ipv6头部Destination的Length字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['Destination'],\n                  Type='Random', Range='2020::10')\n    # ipv6 fragment\n    attr = edit_header_ipv6_fragment(Stream=stream, NextHeader=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6fragmentheader', Attribute=attr['NextHeader'],\n                  Type='Increment', Count=10, Step=2)\n\n    # 配置过滤抓包\n    # 使用Level和Attribute参数添加pdu_pattern\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            Level=1,\n    #                                            Attribute=attribute_dict['HopLimit'],\n    #                                            Value=20, MaxValue=22)\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            Level=1,\n    #                                            Attribute=attribute_dict['Source'],\n    #                                            Value='2022::2', MaxValue='2022::2')\n    # 使用FieldName参数添加pdu_pattern\n    # pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ipv6_1.destination',\n    #                                            Value='2020::2', MaxValue='2020::2')\n    # edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv6:修改测试仪表流量模板中IPv6报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two loopback ports Port_1 and Port_2 using reserve_port API with specified locations.\",\n  \"Subtask 2\": \"Create a traffic stream on Port_1 using add_stream API with fixed length of 256 bytes.\",\n  \"Subtask 3\": \"Configure stream headers for EthernetII, IPv6, and ipv6fragmentheader using create_stream_header API.\",\n  \"Subtask 4\": \"Modify IPv6 header fields (HopLimit, Source, Destination) using edit_header_ipv6 API.\",\n  \"Subtask 5\": \"Apply increment modifier to IPv6 HopLimit field using edit_modifier API with Count=10 and Step=2.\",\n  \"Subtask 6\": \"Apply random modifier to IPv6 Destination field using edit_modifier API with Range='2020::10'.\",\n  \"Subtask 7\": \"Apply increment modifier to ipv6fragmentheader NextHeader field using edit_modifier API.\",\n  \"Subtask 8\": \"Configure packet capture filtering on Port_2 by creating PDU patterns and setting filter expression (commented in code but required by intent).\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 10\": \"Set Port_1 transmission mode to burst with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 11\": \"Save test configuration using save_case API.\",\n  \"Subtask 12\": \"Start packet capture on Port_2 using start_capture API.\",\n  \"Subtask 13\": \"Transmit traffic from Port_1 using start_stream API.\",\n  \"Subtask 14\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 16\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 17\": \"Download captured packets from Port_2 using download_packages API.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats using get_streamblock_statistic API and verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 19\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective      :   Test Objective: Verify the accuracy of IPv6 packet statistics transmitted by the test instrument\n\nStep           :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Modify the IPv6 header content of traffic StreamTemplate_1;\n                   Test Step 3: Configure packet capture filtering;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Set port transmission mode to burst packet;\n                   Test Step 6: Transmit all traffic and wait for a period;\n                   Test Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria       :   Expected Result 1: In Step 6, transmitted and received packets of StreamTemplate_1 are equal;\n\nCreated by     :   Tester-004\n\nBugs           :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'ipv6fragmentheader']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ipv6头部\n    attribute_dict = edit_header_ipv6(Stream=stream, Level=0, HopLimit=20,\n                                      Source='2022::2', Destination='2020::2', Gateway='2022::1')\n    # ipv6头部HopLimit字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['HopLimit'],\n                  Type='Increment', Count=10, Step=2)\n    # ipv6头部Source字段添加List跳变\n#    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['Source'],\n#                  Type='List', List=['2022::2', '2022::5', '2022::3'])\n    # ipv6头部Destination的Length字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='IPv6', Attribute=attribute_dict['Destination'],\n                  Type='Random', Range='2020::10')\n    # ipv6 fragment\n    attr = edit_header_ipv6_fragment(Stream=stream, NextHeader=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ipv6fragmentheader', Attribute=attr['NextHeader'],\n                  Type='Increment', Count=10, Step=2)\n\n    # 配置过滤抓包\n    # 使用Level和Attribute参数添加pdu_pattern\n    # pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            Level=1,\n    #                                            Attribute=attribute_dict['HopLimit'],\n    #                                            Value=20, MaxValue=22)\n    # pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            Level=1,\n    #                                            Attribute=attribute_dict['Source'],\n    #                                            Value='2022::2', MaxValue='2022::2')\n    # 使用FieldName参数添加pdu_pattern\n    # pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n    #                                            FieldName='ipv6_1.destination',\n    #                                            Value='2020::2', MaxValue='2020::2')\n    # edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv6:修改测试仪表流量模板中IPv6报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Mpls.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发mpls报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的mpls头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Objective: Verify the test instrument's accurate MPLS packet statistics\n\nStep        :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Step 2: Modify the MPLS header content of traffic StreamTemplate_1;\n                Step 3: Configure packet capture filtering;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Set port transmission mode to burst packet;\n                Step 6: Transmit all traffic and wait for a period;\n                Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria    :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by  :   Tester-004\n\nBugs        :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Log=True)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'mpls']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改mpls头部\n    attribute_dict = edit_header_mpls(Stream=stream, Level=0, Label=32, Exp='001', TTL=200)\n    # mpls头部Label字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['Label'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # mpls头部目Exp字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['Exp'],\n                  Type='List',\n                  List=['001', '011', '110'])\n    # mpls头部目TTL字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['TTL'],\n                  Type='Random',\n                  Range=1000)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mpls_1.label',\n                                               Value='32', MaxValue='32')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mpls_1.ttl',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_mpls:修改测试仪表流量模板中MPLS报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product and enable logging using init_tester.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations using reserve_port.\",\n  \"Subtask 3\": \"Create a stream on the first reserved port with fixed length of 256 bytes using add_stream.\",\n  \"Subtask 4\": \"Create stream headers of type EthernetII and MPLS using create_stream_header.\",\n  \"Subtask 5\": \"Modify MPLS header at level 0 to set Label=32, Exp='001', TTL=200 using edit_header_mpls.\",\n  \"Subtask 6\": \"Configure increment modifier for MPLS Label field with count=10 and step=2 using edit_modifier.\",\n  \"Subtask 7\": \"Configure list modifier for MPLS Exp field with values ['001','011','110'] using edit_modifier.\",\n  \"Subtask 8\": \"Configure random modifier for MPLS TTL field within range 1000 using edit_modifier.\",\n  \"Subtask 9\": \"Create PDU pattern for MPLS label=32 on second port using create_capture_pdu_pattern.\",\n  \"Subtask 10\": \"Create PDU pattern for MPLS TTL=200 on second port using create_capture_pdu_pattern.\",\n  \"Subtask 11\": \"Set capture filter on second port using logical AND of both PDU patterns via edit_capture_filter.\",\n  \"Subtask 12\": \"Subscribe to StreamBlockStats statistics using subscribe_result.\",\n  \"Subtask 13\": \"Set first port's transmission mode to BURST with burst count=100 using edit_port_load_profile.\",\n  \"Subtask 14\": \"Save test configuration to file using save_case.\",\n  \"Subtask 15\": \"Start packet capture on second port using start_capture.\",\n  \"Subtask 16\": \"Start stream transmission using start_stream.\",\n  \"Subtask 17\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 18\": \"Stop stream transmission using stop_stream.\",\n  \"Subtask 19\": \"Stop packet capture using stop_capture.\",\n  \"Subtask 20\": \"Wait 3 seconds for capture finalization.\",\n  \"Subtask 21\": \"Download captured packets from second port to specified directory using download_packages.\",\n  \"Subtask 22\": \"Retrieve StreamBlockStats for the stream using get_streamblock_statistic.\",\n  \"Subtask 23\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 24\": \"Release reserved ports using release_port.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Objective: Verify the test instrument's accurate MPLS packet statistics\n\nStep        :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Step 2: Modify the MPLS header content of traffic StreamTemplate_1;\n                Step 3: Configure packet capture filtering;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Set port transmission mode to burst packet;\n                Step 6: Transmit all traffic and wait for a period;\n                Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria    :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by  :   Tester-004\n\nBugs        :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product, Log=True)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'mpls']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改mpls头部\n    attribute_dict = edit_header_mpls(Stream=stream, Level=0, Label=32, Exp='001', TTL=200)\n    # mpls头部Label字段添加Increment跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['Label'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # mpls头部目Exp字段添加List跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['Exp'],\n                  Type='List',\n                  List=['001', '011', '110'])\n    # mpls头部目TTL字段添加Random跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='mpls', Attribute=attribute_dict['TTL'],\n                  Type='Random',\n                  Range=1000)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mpls_1.label',\n                                               Value='32', MaxValue='32')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mpls_1.ttl',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_mpls:修改测试仪表流量模板中MPLS报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ancp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的ANCP头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test objective: Verify accurate traffic statistics generation by the test instrument  \n\nStep:  \n1. Reserve two loopback ports: Port_1 and Port_2  \n2. Create traffic stream StreamTemplate_1 on Port_1  \n3. Modify ANCP header content of StreamTemplate_1  \n4. Subscribe to StreamBlockStats  \n5. Transmit all traffic and wait  \n6. Stop all traffic and check StreamBlockStats  \n\nCriteria:  \nExpected result 1: Received and transmitted packets for StreamTemplate_1 are equal in Step 6  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['portManagement'])\n\n    # 修改ancp头部\n    attr = edit_header_ancp(Stream=stream, Level=0,\n                            Version=20,\n                            AccessLineIdentifyingTlvs=1,\n                            TestingRelatedTlvs=1,\n                            StatusInfoTlvs=1)\n    edit_modifier(Stream=stream, Attribute=attr['Version'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    access_attr = edit_header_ancp_access_line_identifying_tlv(Stream=stream,\n                                                               Value='102030')\n    edit_modifier(Stream=stream, Attribute=access_attr['Value'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    testing_attr = edit_header_ancp_testing_related_tlv(Stream=stream,\n                                                        Value1='405060')\n    edit_modifier(Stream=stream, Attribute=testing_attr['Value1'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    edit_header_ancp_status_info_tlv(Stream=stream,\n                                     OptionalSubTLV=1)\n    optinal_attr = edit_header_ancp_status_info_tlv_optional_sub_tlv(Stream=stream,\n                                                                     Data='708090')\n    edit_modifier(Stream=stream, Attribute=optinal_attr['Data'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with specified product configuration (default 'DarYu' or from command line argument).\",\n  \"Subtask 2\": \"Reserve two ports using provided locations (default '//10.0.11.191/1/5' and '//10.0.11.191/1/6' or command line arguments) and assign them as Port_UP and Port_Down.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API.\",\n  \"Subtask 4\": \"Create stream header of type 'portManagement' for the traffic stream using create_stream_header API.\",\n  \"Subtask 5\": \"Edit ANCP header version to 20 and set required TLV flags (AccessLineIdentifyingTlvs, TestingRelatedTlvs, StatusInfoTlvs) at level 0 using edit_header_ancp API.\",\n  \"Subtask 6\": \"Apply increment modifier to ANCP version field with count=10 and type='Increment' using edit_modifier API.\",\n  \"Subtask 7\": \"Edit ANCP Access Line Identifying TLV value to '102030' and apply increment modifier with count=10 using edit_header_ancp_access_line_identifying_tlv and edit_modifier APIs.\",\n  \"Subtask 8\": \"Edit ANCP Testing Related TLV value to '405060' and apply increment modifier with count=10 using edit_header_ancp_testing_related_tlv and edit_modifier APIs.\",\n  \"Subtask 9\": \"Edit ANCP Status Info TLV to enable OptionalSubTLV and set its data to '708090', then apply increment modifier with count=10 using edit_header_ancp_status_info_tlv, edit_header_ancp_status_info_tlv_optional_sub_tlv and edit_modifier APIs.\",\n  \"Subtask 10\": \"Subscribe to PortStats and StreamBlockStats statistics views using subscribe_result API.\",\n  \"Subtask 11\": \"Configure port load profile for Port_UP with TransmitMode='BURST' and BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 12\": \"Save test configuration to file path derived from current script name and location using save_case API.\",\n  \"Subtask 13\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 14\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 15\": \"Wait 3 seconds after traffic stops to ensure accurate statistics collection.\",\n  \"Subtask 16\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API and extract TxStreamFrames and RxStreamFrames values.\",\n  \"Subtask 17\": \"Verify TxStreamFrames equals RxStreamFrames and both equal the configured BurstCount (100), setting verdict to 'fail' if mismatch occurs.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test objective: Verify accurate traffic statistics generation by the test instrument  \n\nStep:  \n1. Reserve two loopback ports: Port_1 and Port_2  \n2. Create traffic stream StreamTemplate_1 on Port_1  \n3. Modify ANCP header content of StreamTemplate_1  \n4. Subscribe to StreamBlockStats  \n5. Transmit all traffic and wait  \n6. Stop all traffic and check StreamBlockStats  \n\nCriteria:  \nExpected result 1: Received and transmitted packets for StreamTemplate_1 are equal in Step 6  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['portManagement'])\n\n    # 修改ancp头部\n    attr = edit_header_ancp(Stream=stream, Level=0,\n                            Version=20,\n                            AccessLineIdentifyingTlvs=1,\n                            TestingRelatedTlvs=1,\n                            StatusInfoTlvs=1)\n    edit_modifier(Stream=stream, Attribute=attr['Version'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    access_attr = edit_header_ancp_access_line_identifying_tlv(Stream=stream,\n                                                               Value='102030')\n    edit_modifier(Stream=stream, Attribute=access_attr['Value'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    testing_attr = edit_header_ancp_testing_related_tlv(Stream=stream,\n                                                        Value1='405060')\n    edit_modifier(Stream=stream, Attribute=testing_attr['Value1'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    edit_header_ancp_status_info_tlv(Stream=stream,\n                                     OptionalSubTLV=1)\n    optinal_attr = edit_header_ancp_status_info_tlv_optional_sub_tlv(Stream=stream,\n                                                                     Data='708090')\n    edit_modifier(Stream=stream, Attribute=optinal_attr['Data'],\n                  Type='Increment', Count=10, HeaderType='portManagement')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/LldpEnd.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的lldp头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Purpose: Verify that the test instrument's traffic transmission statistics are correct\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the LLDP header content of traffic stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Transmit all traffic and wait for a period;\n                   Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-002\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv', 'ttltlv', 'endtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_end_tlv(Stream=stream, Level=0, Length=10)\n    edit_modifier(Stream=stream, Attribute=attr['Length'],\n                  Type='Increment', Count=10, HeaderType='endtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product (e.g., 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_UP and Port_Down) using reserve_port API with provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API.\",\n  \"Subtask 4\": \"Edit the stream parameters to set frame length type to 'AUTO' using edit_stream API.\",\n  \"Subtask 5\": \"Create stream headers including Ethernet II, Port ID TLV, TTL TLV, and End TLV using create_stream_header API.\",\n  \"Subtask 6\": \"Modify the End TLV header's length field by setting initial value to 10 and applying increment modifier with count 10 using edit_modifier API.\",\n  \"Subtask 7\": \"Subscribe to PortStats and StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 8\": \"Configure port load profile for Port_UP to burst mode with burst count 100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Save the current configuration to a file using save_case API.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 12\": \"Wait 3 seconds after traffic stops to ensure statistics collection.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 14\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames) and both equal the burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Purpose: Verify that the test instrument's traffic transmission statistics are correct\n\nStep\t\t\t:\tStep 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the LLDP header content of traffic stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats statistics;\n                   Step 5: Transmit all traffic and wait for a period;\n                   Step 6: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-002\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'portidtlv', 'ttltlv', 'endtlv'])\n\n    # 修改lldp头部\n    attr = edit_header_lldp_end_tlv(Stream=stream, Level=0, Length=10)\n    edit_modifier(Stream=stream, Attribute=attr['Length'],\n                  Type='Increment', Count=10, HeaderType='endtlv')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/LinkModifier.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ipv4报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ipv4头部内容;;\n                   测试步骤3: 设置link Modifer;\n\n Criteria    \t:   预期结果1: 配置无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   : Test Purpose: Verify that the test instrument correctly counts transmitted IPv4 packets\n\nStep        : Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\n             Test Step 2: Modify the IPv4 header content of traffic stream template StreamTemplate_1;\n             Test Step 3: Set the link modifier\n\nCriteria    : Expected Result 1: Configuration without abnormalities\n\nCreated by  : Tester-001\n\nBugs        : None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port1, port2 = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=port1, FixedLength=256)\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n    # 修改ipv4头部\n    HeaderOption = ['Security', 'RouterAlert']\n    attribute_dict = edit_header_ipv4(Stream=stream, Level=0, TTL=200, Source='10.1.1.2', Destination='20.1.1.2',\n                                      Flags=111, HeaderOption=HeaderOption)\n    # ipv4头部Source字段添加Increment跳变\n    modifier_1 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=10, Step=2)\n\n    modifier_2 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=20, Step=2)\n\n    modifier_3 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Destination'],\n                               Type='Increment', Count=10, Step=2)\n\n    modifier_4 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Destination'],\n                               Type='Increment', Count=20, Step=2)\n    # 设置流量link modifer\n    link_modifier = [[modifier_1, modifier_2, modifier_3], [modifier_2, modifier_3, modifier_4], [modifier_3, modifier_4]]\n    edit_modifier_link(Stream=stream, Link=link_modifier)\n\n    # 保存配置\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 释放端口资源\n    release_port(locations)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using the init_tester API with the specified product platform.\",\n  \"Subtask 2\": \"Reserve two physical ports (Port_1 and Port_2) using reserve_port API based on provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes using add_stream API.\",\n  \"Subtask 4\": \"Configure the stream headers to include EthernetII and IPv4 layers using create_stream_header API.\",\n  \"Subtask 5\": \"Modify IPv4 header parameters: set TTL=200, Source='10.1.1.2', Destination='20.1.1.2', Flags=111, and HeaderOptions=['Security','RouterAlert'] using edit_header_ipv4 API.\",\n  \"Subtask 6\": \"Create modifier_1 for IPv4 Source field: Increment type with Count=10 and Step=2 using edit_modifier API.\",\n  \"Subtask 7\": \"Create modifier_2 for IPv4 Source field: Increment type with Count=20 and Step=2 using edit_modifier API.\",\n  \"Subtask 8\": \"Create modifier_3 for IPv4 Destination field: Increment type with Count=10 and Step=2 using edit_modifier API.\",\n  \"Subtask 9\": \"Create modifier_4 for IPv4 Destination field: Increment type with Count=20 and Step=2 using edit_modifier API.\",\n  \"Subtask 10\": \"Configure link modifier relationships: [[modifier_1, modifier_2, modifier_3], [modifier_2, modifier_3, modifier_4], [modifier_3, modifier_4]] using edit_modifier_link API.\",\n  \"Subtask 11\": \"Save the complete test configuration to an .xcfg file using save_case API.\",\n  \"Subtask 12\": \"Release all reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   : Test Purpose: Verify that the test instrument correctly counts transmitted IPv4 packets\n\nStep        : Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\n             Test Step 2: Modify the IPv4 header content of traffic stream template StreamTemplate_1;\n             Test Step 3: Set the link modifier\n\nCriteria    : Expected Result 1: Configuration without abnormalities\n\nCreated by  : Tester-001\n\nBugs        : None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port1, port2 = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=port1, FixedLength=256)\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4'])\n    # 修改ipv4头部\n    HeaderOption = ['Security', 'RouterAlert']\n    attribute_dict = edit_header_ipv4(Stream=stream, Level=0, TTL=200, Source='10.1.1.2', Destination='20.1.1.2',\n                                      Flags=111, HeaderOption=HeaderOption)\n    # ipv4头部Source字段添加Increment跳变\n    modifier_1 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=10, Step=2)\n\n    modifier_2 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Source'],\n                  Type='Increment', Count=20, Step=2)\n\n    modifier_3 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Destination'],\n                               Type='Increment', Count=10, Step=2)\n\n    modifier_4 = edit_modifier(Stream=stream, Level=0, HeaderType='IPv4', Attribute=attribute_dict['Destination'],\n                               Type='Increment', Count=20, Step=2)\n    # 设置流量link modifer\n    link_modifier = [[modifier_1, modifier_2, modifier_3], [modifier_2, modifier_3, modifier_4], [modifier_3, modifier_4]]\n    edit_modifier_link(Stream=stream, Link=link_modifier)\n\n    # 保存配置\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 释放端口资源\n    release_port(locations)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Tcp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发tcp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的tcp头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Purpose: Verify the accuracy of TCP packet statistics transmitted by the test instrument.\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test Step 2: Modify the TCP header content of traffic StreamTemplate_1;\n      Test Step 3: Configure filter-based packet capture;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Set port transmission mode to burst packet;\n      Test Step 6: Transmit all traffic streams and wait for a period;\n      Test Step 7: Stop all traffic and examine StreamBlockStats information;\n\nCriteria: Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ipv4', 'tcp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改vlan头部\n    header = edit_header_tcp(Stream=stream, Level=0,\n                             SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Level=0, HeaderType='tcp',\n                  Attribute=header['SourcePort'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='tcp_1.destPort',\n                                               Value='2000', MaxValue='2000')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_tcp:修改测试仪表流量模板中TCP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports at the provided locations, assigning them to Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Create stream headers for the traffic stream with types: EthernetII, IPv4, TCP.\",\n  \"Subtask 5\": \"Edit TCP header of the traffic stream: set source port to 1000 and destination port to 2000 at level 0.\",\n  \"Subtask 6\": \"Configure modifier for TCP source port field: increment by step 2 for 10 counts.\",\n  \"Subtask 7\": \"On Port_2, create capture PDU pattern matching TCP destination port 2000 with header types EthernetII/IPv4/TCP.\",\n  \"Subtask 8\": \"Set capture filter on Port_2 using the created PDU pattern expression.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Configure Port_1 transmission mode to BURST with burst count 100.\",\n  \"Subtask 11\": \"Save current configuration to a file.\",\n  \"Subtask 12\": \"Start packet capture on Port_2.\",\n  \"Subtask 13\": \"Start traffic transmission on Port_1.\",\n  \"Subtask 14\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission on Port_1.\",\n  \"Subtask 16\": \"Stop packet capture on Port_2.\",\n  \"Subtask 17\": \"Retrieve StreamBlockStats for the traffic stream and verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 18\": \"Release all reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Purpose: Verify the accuracy of TCP packet statistics transmitted by the test instrument.\n\nStep: Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n      Test Step 2: Modify the TCP header content of traffic StreamTemplate_1;\n      Test Step 3: Configure filter-based packet capture;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Set port transmission mode to burst packet;\n      Test Step 6: Transmit all traffic streams and wait for a period;\n      Test Step 7: Stop all traffic and examine StreamBlockStats information;\n\nCriteria: Expected Result 1: During Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by: Tester-002\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'ipv4', 'tcp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改vlan头部\n    header = edit_header_tcp(Stream=stream, Level=0,\n                             SourcePort=1000, DestPort=2000)\n    edit_modifier(Stream=stream, Level=0, HeaderType='tcp',\n                  Attribute=header['SourcePort'],\n                  Type='Increment',\n                  Count=10, Step=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='tcp_1.destPort',\n                                               Value='2000', MaxValue='2000')\n    edit_capture_filter(Port=Ports[1], Expression=pdu_pattern_1)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_tcp:修改测试仪表流量模板中TCP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv3_DataOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 data over udp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 data over udp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: To verify that the test instrument correctly counts L2TPv3 data over UDP packets\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\nStep 2: Modify the L2TPv3 data over UDP header content in traffic StreamTemplate_1;;\nStep 3: Configure filtered packet capture;\nStep 4: Subscribe to StreamBlockStats statistics;;\nStep 5: Set the port transmission mode to burst packets;\nStep 6: Send all traffic and wait for a period of time;\nStep 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In step 6, the traffic StreamTemplate_1 should have equal send and receive packets;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改l2tpv3DataOverUdp头部\n    header = edit_header_l2tpv3_data_over_udp(Stream=stream, Level=0, SessionId='1', Cookie8Byte='0000000000000001',\n                                     L2specificsublayer=1)\n    # 修改l2tpv3 data over udp头部选项\n    header_option = edit_header_l2tpv3_data_sublayer(Stream=stream, Type='L2specificsublayer', Xbit=1, Sbit=1, Sequence=10)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverUdp', Attribute=header_option['Sequence'],\n                  Type='Increment', Count=10)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverUdp', Attribute=header['Cookie8Byte'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3DataOverUdp_1.sessionId',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product type (e.g., 'DarYu').\",\n  \"Subtask 2\": \"Reserve two ports using provided locations for Port_1 and Port_2.\",\n  \"Subtask 3\": \"Add a traffic stream on Port_1 with fixed frame length of 512 bytes.\",\n  \"Subtask 4\": \"Create stream headers: EthernetII, IPv4, UDP, and L2TPv3 data over UDP.\",\n  \"Subtask 5\": \"Edit L2TPv3 data over UDP header: set SessionId=1, Cookie8Byte='0000000000000001', enable L2 specific sublayer.\",\n  \"Subtask 6\": \"Edit L2TPv3 data sublayer: set Xbit=1, Sbit=1, Sequence=10.\",\n  \"Subtask 7\": \"Configure modifier for L2TPv3 Sequence field: increment by 1 for 10 packets.\",\n  \"Subtask 8\": \"Configure modifier for L2TPv3 Cookie8Byte field: increment by 1 for 10 packets.\",\n  \"Subtask 9\": \"Create PDU capture pattern on Port_2: filter L2TPv3 sessionId=1 with specified headers.\",\n  \"Subtask 10\": \"Apply capture filter expression to Port_2 using created PDU pattern.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 12\": \"Configure Port_1 transmission mode: burst mode with burst count=100.\",\n  \"Subtask 13\": \"Save test configuration to file.\",\n  \"Subtask 14\": \"Start packet capture on Port_2.\",\n  \"Subtask 15\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 16\": \"Wait 10 seconds during traffic transmission.\",\n  \"Subtask 17\": \"Stop traffic transmission.\",\n  \"Subtask 18\": \"Stop packet capture on Port_2.\",\n  \"Subtask 19\": \"Download captured packets from Port_2 to specified directory.\",\n  \"Subtask 20\": \"Retrieve StreamBlockStats results for the traffic stream.\",\n  \"Subtask 21\": \"Verify TxStreamFrames equals RxStreamFrames.\",\n  \"Subtask 22\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: To verify that the test instrument correctly counts L2TPv3 data over UDP packets\n\nStep: Step 1: Reserve two loopback ports Port_1 and Port_2;\nStep 2: Modify the L2TPv3 data over UDP header content in traffic StreamTemplate_1;;\nStep 3: Configure filtered packet capture;\nStep 4: Subscribe to StreamBlockStats statistics;;\nStep 5: Set the port transmission mode to burst packets;\nStep 6: Send all traffic and wait for a period of time;\nStep 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria: Expected Result 1: In step 6, the traffic StreamTemplate_1 should have equal send and receive packets;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv3DataOverUdp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改l2tpv3DataOverUdp头部\n    header = edit_header_l2tpv3_data_over_udp(Stream=stream, Level=0, SessionId='1', Cookie8Byte='0000000000000001',\n                                     L2specificsublayer=1)\n    # 修改l2tpv3 data over udp头部选项\n    header_option = edit_header_l2tpv3_data_sublayer(Stream=stream, Type='L2specificsublayer', Xbit=1, Sbit=1, Sequence=10)\n\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverUdp', Attribute=header_option['Sequence'],\n                  Type='Increment', Count=10)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3DataOverUdp', Attribute=header['Cookie8Byte'],\n                  Type='Increment', Count=10)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3DataOverUdp_1.sessionId',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/ControlWord.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的Control Word头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Purpose: Verify correct traffic statistics on the test instrument\n\nStep         :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                 Step 2: Create traffic stream StreamTemplate_1 on Port_1;\n                 Step 3: Modify the Control Word header of StreamTemplate_1;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Transmit all traffic and wait for a period;\n                 Step 6: Stop all traffic and check StreamBlockStats;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['cw', 'ethernetii', 'ipv4'])\n\n    # 修改Control Word头部\n    attr = edit_header_control_word(Stream=stream, Level=0,\n                                    Sn='65535')\n    edit_modifier(Stream=stream, Attribute=attr['Sn'],\n                  Type='Increment', Count=10, HeaderType='cw')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (default 'DarYu') to prepare the test environment.\",\n  \"Subtask 2\": \"Reserve two loopback ports using provided locations (e.g., '//10.0.11.191/1/5' and '//10.0.11.191/1/6') and assign them as Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 using the add_stream API function.\",\n  \"Subtask 4\": \"Create stream headers for the traffic stream including Control Word, Ethernet II, and IPv4 using create_stream_header API.\",\n  \"Subtask 5\": \"Modify the Control Word header by setting Sequence Number (Sn) to 65535 and configure an increment modifier for Sn field (increment by 1 for 10 packets).\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats using subscribe_result API to enable statistics collection.\",\n  \"Subtask 7\": \"Configure Port_1's load profile to burst mode with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 8\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 9\": \"Wait for traffic transmission to complete using wait_stream_state API, then wait 3 seconds for statistics stabilization.\",\n  \"Subtask 10\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API and record TxStreamFrames and RxStreamFrames values.\",\n  \"Subtask 11\": \"Verify TxStreamFrames equals RxStreamFrames to validate correct traffic statistics.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Purpose: Verify correct traffic statistics on the test instrument\n\nStep         :   Step 1: Reserve two loopback ports Port_1 and Port_2;\n                 Step 2: Create traffic stream StreamTemplate_1 on Port_1;\n                 Step 3: Modify the Control Word header of StreamTemplate_1;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Transmit all traffic and wait for a period;\n                 Step 6: Stop all traffic and check StreamBlockStats;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['cw', 'ethernetii', 'ipv4'])\n\n    # 修改Control Word头部\n    attr = edit_header_control_word(Stream=stream, Level=0,\n                                    Sn='65535')\n    edit_modifier(Stream=stream, Attribute=attr['Sn'],\n                  Type='Increment', Count=10, HeaderType='cw')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ethernet8023.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的802.3头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Verify the accuracy of traffic statistics from the test instrument  \n\nStep:  \nStep 1: Reserve two loopback ports, Port_1 and Port_2;  \nStep 2: Create a traffic stream StreamTemplate_1 on port Port_1;  \nStep 3: Modify the 802.3 header of stream StreamTemplate_1;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Send all traffic and wait for a period of time;  \nStep 6: Stop all traffic and check StreamBlockStats statistics;  \n\nCriteria:  \nExpected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['8023'])\n\n    # 修改802.3头部\n    attr = edit_header_8023(Stream=stream, Level=0,\n                            Oui='102030')\n    edit_modifier(Stream=stream, Attribute=attr['Oui'],\n                  Type='Increment', Count=10, HeaderType='8023')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (e.g., 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports using reserve_port API with provided locations.\",\n  \"Subtask 3\": \"Create traffic stream on upstream port using add_stream API.\",\n  \"Subtask 4\": \"Edit stream parameters to set frame length type to 'AUTO' using edit_stream API.\",\n  \"Subtask 5\": \"Create 802.3 header for the stream using create_stream_header API.\",\n  \"Subtask 6\": \"Modify 802.3 header Oui field to '102030' at level 0 using edit_header_8023 API.\",\n  \"Subtask 7\": \"Configure modifier for Oui field with increment type and count=10 using edit_modifier API.\",\n  \"Subtask 8\": \"Set port load profile to burst mode with burst count=100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats and PortStats using subscribe_result API.\",\n  \"Subtask 11\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 12\": \"Wait for traffic to stop automatically after burst transmission using wait_stream_state API.\",\n  \"Subtask 13\": \"Wait 3 seconds after traffic stops to ensure accurate statistics collection.\",\n  \"Subtask 14\": \"Retrieve StreamBlockStats using get_streamblock_statistic API for the created stream.\",\n  \"Subtask 15\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both equal burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Verify the accuracy of traffic statistics from the test instrument  \n\nStep:  \nStep 1: Reserve two loopback ports, Port_1 and Port_2;  \nStep 2: Create a traffic stream StreamTemplate_1 on port Port_1;  \nStep 3: Modify the 802.3 header of stream StreamTemplate_1;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Send all traffic and wait for a period of time;  \nStep 6: Stop all traffic and check StreamBlockStats statistics;  \n\nCriteria:  \nExpected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n    edit_stream(Stream=stream, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['8023'])\n\n    # 修改802.3头部\n    attr = edit_header_8023(Stream=stream, Level=0,\n                            Oui='102030')\n    edit_modifier(Stream=stream, Attribute=attr['Oui'],\n                  Type='Increment', Count=10, HeaderType='8023')\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 发送流量\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl1csnpHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: To verify the accuracy of traffic transmission statistics on the test instrument.  \n\nStep:  \nStep 1: Reserve two loopback ports, Port_1 and Port_2;  \nStep 2: Create a traffic stream StreamTemplate_1 on port Port_1;  \nStep 3: Modify the IS-IS header content of traffic stream StreamTemplate_1;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Transmit all traffic and wait for a duration;  \nStep 6: Stop all traffic and examine StreamBlockStats statistics;  \n\nCriteria:  \nExpected result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;  \n\nCreated by: Tester-002  \n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1csnpheader'])\n\n    header = edit_header_isis_csnp(Stream=stream,\n                                   Version=1,\n                                   LspId='10203040506070',\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=header['LspId'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries',\n                                      TlvCode=10,\n                                      LspEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n\n    lsp = edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1,\n                                     RemainTime=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=lsp['RemainTime'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using their physical locations.\",\n  \"Subtask 3\": \"Create a traffic stream (StreamTemplate_1) on Port_1 with EthernetII and IS-IS L1 CSNP headers.\",\n  \"Subtask 4\": \"Modify the IS-IS CSNP header of StreamTemplate_1 by setting version, LSP ID, and CSNP data TLV options.\",\n  \"Subtask 5\": \"Apply increment modifiers to specific IS-IS header fields (version, LSP ID, TLV code, and remain time) with defined increment counts.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats and PortStats statistics views.\",\n  \"Subtask 7\": \"Configure Port_1's transmission mode as burst with a specified packet count (e.g., 100 packets).\",\n  \"Subtask 8\": \"Start traffic transmission on all streams and simultaneously begin packet capture.\",\n  \"Subtask 9\": \"Wait until traffic transmission completes and stop packet capture.\",\n  \"Subtask 10\": \"Retrieve StreamBlockStats statistics for StreamTemplate_1 and capture information from Port_2.\",\n  \"Subtask 11\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and match the configured burst count.\",\n  \"Subtask 12\": \"Check captured packet count matches transmitted burst count and downloaded packets.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: To verify the accuracy of traffic transmission statistics on the test instrument.  \n\nStep:  \nStep 1: Reserve two loopback ports, Port_1 and Port_2;  \nStep 2: Create a traffic stream StreamTemplate_1 on port Port_1;  \nStep 3: Modify the IS-IS header content of traffic stream StreamTemplate_1;  \nStep 4: Subscribe to StreamBlockStats statistics;  \nStep 5: Transmit all traffic and wait for a duration;  \nStep 6: Stop all traffic and examine StreamBlockStats statistics;  \n\nCriteria:  \nExpected result 1: In step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;  \n\nCreated by: Tester-002  \n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1csnpheader'])\n\n    header = edit_header_isis_csnp(Stream=stream,\n                                   Version=1,\n                                   LspId='10203040506070',\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=header['Version'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=header['LspId'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsLspEntries',\n                                      TlvCode=10,\n                                      LspEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n\n    lsp = edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1,\n                                     RemainTime=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1csnpheader', Attribute=lsp['RemainTime'],\n                  Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv6MLDv1Done.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv6 mldv1 done报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv6 mldv1 done头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Purpose: Verify that the test instrument accurately counts sent ICMPv6 MLDv1 Done packets\n\nStep         :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                 Step 2: Modify the ICMPv6 MLDv1 Done header in traffic stream StreamTemplate_1;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Send all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats;\n\nCriteria     :   Expected Result 1: In Step 6, sent and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv1done']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # icmpv6 mldv1done头部\n    edit_header_icmpv6_mldv1_done(Stream=stream, Level=0,\n                          Type='132',MaxRespDelay='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.maxRespDelay',\n                                               Value='10', MaxValue='10')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.type',\n                                               Value='132',\n                                               MaxValue='132')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmpv6_mldv1_done:修改测试仪表流量模板中Icmpv6 Mldv1 Done报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform with specified product type (DarYu or provided argument).\",\n  \"Subtask 2\": \"Reserve two ports using provided locations (default or command-line arguments).\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length of 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers with EthernetII, IPv6, and MLDv1 Done protocol layers.\",\n  \"Subtask 5\": \"Modify ICMPv6 MLDv1 Done header parameters: Type=132, MaxRespDelay=10, MulticastAddress='FF1E::1'.\",\n  \"Subtask 6\": \"Create three PDU patterns on the second port for MLDv1 Done header fields: maxRespDelay=10, multicastAddress='FF1E::1', type=132.\",\n  \"Subtask 7\": \"Apply packet capture filter using logical AND combination of the three PDU patterns.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 9\": \"Configure port transmission mode as burst with burst count set to 100 packets.\",\n  \"Subtask 10\": \"Save test configuration to specified file path.\",\n  \"Subtask 11\": \"Start packet capture on the second port.\",\n  \"Subtask 12\": \"Initiate traffic transmission from the first port.\",\n  \"Subtask 13\": \"Wait for 10 seconds during traffic transmission and capture.\",\n  \"Subtask 14\": \"Stop traffic transmission.\",\n  \"Subtask 15\": \"Stop packet capture.\",\n  \"Subtask 16\": \"Wait 3 seconds for packet processing completion.\",\n  \"Subtask 17\": \"Download captured packets from second port to local directory.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats results for transmitted and received frame counts.\",\n  \"Subtask 19\": \"Verify transmitted frame count (TxStreamFrames) equals received frame count (RxStreamFrames).\",\n  \"Subtask 20\": \"Release both reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Purpose: Verify that the test instrument accurately counts sent ICMPv6 MLDv1 Done packets\n\nStep         :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                 Step 2: Modify the ICMPv6 MLDv1 Done header in traffic stream StreamTemplate_1;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Send all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats;\n\nCriteria     :   Expected Result 1: In Step 6, sent and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv6', 'mldv1done']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # icmpv6 mldv1done头部\n    edit_header_icmpv6_mldv1_done(Stream=stream, Level=0,\n                          Type='132',MaxRespDelay='10',MulticastAddress='FF1E::1')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.maxRespDelay',\n                                               Value='10', MaxValue='10')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.multicastAddress',\n                                               Value='FF1E::1',\n                                               MaxValue='FF1E::1')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='mldv1Done_1.type',\n                                               Value='132',\n                                               MaxValue='132')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmpv6_mldv1_done:修改测试仪表流量模板中Icmpv6 Mldv1 Done报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2DatabaseDescription.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 database description报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ospfv2 database description头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Objective: To verify the test instrument correctly counts transmitted and received OSPFv2 Database Description packets\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Modify the OSPFv2 Database Description header content in traffic stream StreamTemplate_1;;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats statistics;;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Transmit all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2databasedescription']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 database description头部\n    header = edit_header_ospfv2_dd(Stream=stream, Level=0,\n                                   PacketOptionsReserved7=1,\n                                   RouterID='2.2.2.2', AuthType='SimplePassword',\n                                   AuthValue1=123, AuthValue2=456,\n                                   PacketOptionsDcBit=1, DdOptionsReserved3=1,\n                                   SequenceNumber=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['RouterID'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['PacketOptionsReserved7'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['AuthValue1'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['DdOptionsReserved3'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    lsa = edit_header_ospfv2_lsa(Stream=stream, HeaderType='Ospfv2DatabaseDescription',\n                                 LsaAge=10, Reserved7=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=lsa['LsaAge'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=lsa['Reserved7'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.ddOptions.dcBit',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.ospfHeader.authSelect.hdrAuthSelectNone.authValue2',\n                                               Value='456',\n                                               MaxValue='456')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.sequenceNumber',\n                                               Value='10',\n                                               MaxValue='10')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_dd:修改测试仪表流量模板中OSPFv2 Database Description报文头部内容",
      "edit_header_ospfv2_lsa:修改测试仪表流量模板中OSPFv2报文中Lsa头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for the specified product using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports at given locations using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length using add_stream API.\",\n  \"Subtask 4\": \"Configure stream headers as EthernetII, IPv4, and OSPFv2 Database Description using create_stream_header API.\",\n  \"Subtask 5\": \"Edit OSPFv2 Database Description header fields (RouterID, AuthType, PacketOptions, etc.) using edit_header_ospfv2_dd API.\",\n  \"Subtask 6\": \"Configure increment modifiers for RouterID, PacketOptionsReserved7, AuthValue1, and DdOptionsReserved3 fields in OSPFv2 header using edit_modifier API.\",\n  \"Subtask 7\": \"Edit OSPFv2 LSA header fields (LsaAge, Reserved7) within Database Description using edit_header_ospfv2_lsa API.\",\n  \"Subtask 8\": \"Configure increment modifiers for LsaAge and Reserved7 fields in OSPFv2 LSA header using edit_modifier API.\",\n  \"Subtask 9\": \"Create three PDU patterns for capture filtering on the second port targeting dcBit=1, authValue2=456, and sequenceNumber=10 using create_capture_pdu_pattern API.\",\n  \"Subtask 10\": \"Set capture filter expression combining all three PDU patterns with logical AND on the second port using edit_capture_filter API.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats statistics view using subscribe_result API.\",\n  \"Subtask 12\": \"Configure port transmission mode as burst with count=100 using edit_port_load_profile API.\",\n  \"Subtask 13\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 14\": \"Start packet capture on the second port using start_capture API.\",\n  \"Subtask 15\": \"Begin traffic transmission using start_stream API.\",\n  \"Subtask 16\": \"Wait 10 seconds for traffic transmission and capture.\",\n  \"Subtask 17\": \"Stop traffic transmission using stop_stream API.\",\n  \"Subtask 18\": \"Stop packet capture using stop_capture API.\",\n  \"Subtask 19\": \"Wait 3 seconds for capture processing.\",\n  \"Subtask 20\": \"Download captured packets from the second port using download_packages API.\",\n  \"Subtask 21\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 22\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 23\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Objective: To verify the test instrument correctly counts transmitted and received OSPFv2 Database Description packets\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Modify the OSPFv2 Database Description header content in traffic stream StreamTemplate_1;;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats statistics;;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Transmit all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats statistics;;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2databasedescription']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 database description头部\n    header = edit_header_ospfv2_dd(Stream=stream, Level=0,\n                                   PacketOptionsReserved7=1,\n                                   RouterID='2.2.2.2', AuthType='SimplePassword',\n                                   AuthValue1=123, AuthValue2=456,\n                                   PacketOptionsDcBit=1, DdOptionsReserved3=1,\n                                   SequenceNumber=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['RouterID'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['PacketOptionsReserved7'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['AuthValue1'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=header['DdOptionsReserved3'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    lsa = edit_header_ospfv2_lsa(Stream=stream, HeaderType='Ospfv2DatabaseDescription',\n                                 LsaAge=10, Reserved7=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=lsa['LsaAge'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2databasedescription',\n                  Attribute=lsa['Reserved7'],\n                  Type='Increment',\n                  Count=2, Step=1)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.ddOptions.dcBit',\n                                               Value='1', MaxValue='1')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.ospfHeader.authSelect.hdrAuthSelectNone.authValue2',\n                                               Value='456',\n                                               MaxValue='456')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2DatabaseDescription_1.sequenceNumber',\n                                               Value='10',\n                                               MaxValue='10')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_dd:修改测试仪表流量模板中OSPFv2 Database Description报文头部内容;\nedit_header_ospfv2_lsa:修改测试仪表流量模板中OSPFv2报文中Lsa头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2TPv2Control.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的L2TPv2 Control头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Verify the correctness of flow statistics transmitted by the test instrument\n\nStep: Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n      Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Test Step 3: Modify the L2TPv2 Control header content of traffic stream StreamTemplate_1;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Transmit all traffic and wait for a period;\n      Test Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-003\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control'])\n\n    # 修改l2tpv2 control头部\n    edit_header_l2tpv2_control(Stream=stream, Level=0,\n                               Type=1,\n                               Reserved1=11,\n                               Ns=5,\n                               Nr=6,\n                               )\n\n    # 修改l2tpv2 control头部，添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='protocolVersion',\n                                      Ver=1,\n                                      Rev=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='framingCapabilities',\n                                      Abit=1,\n                                      Sbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='bearerCapabilities',\n                                      Abit=1,\n                                      Dbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='firmwareRevision',\n                                      FirmwareRevision=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='assignedTunnelId',\n                                      TunnelId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='assignedSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='response',\n                                      ResponseValue='00000000000000000000000000000001',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='minimumBps',\n                                      MinimumBps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='maximumBps',\n                                      MaximumBps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='bearerType',\n                                      Abit=1,\n                                      Dbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='framingType',\n                                      Abit=1,\n                                      Sbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='txConnectSpeed',\n                                      Bps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='rxConnectSpeed',\n                                      HighBPS=1,\n                                      LowBPS=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=19,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=20,\n                                      Types='proxyAuthenType',\n                                      AuthenType=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=21,\n                                      Types='proxyAuthenId',\n                                      AuthenId=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control'],\n                                             FieldName='l2tpv2Control_1.ns',\n                                             Value=5,\n                                             MaxValue=5,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream named StreamTemplate_1 on Port_1 using add_stream API with frame length set to AUTO.\",\n  \"Subtask 4\": \"Create stream headers for StreamTemplate_1 including EthernetII, IPv4, UDP, and L2TPv2Control using create_stream_header API.\",\n  \"Subtask 5\": \"Modify L2TPv2 Control header of StreamTemplate_1 to set Type=1, Reserved1=11, Ns=5, Nr=6 and add multiple header options with specific attributes.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 7\": \"Configure Port_1 transmit mode as BURST with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 8\": \"Start traffic transmission using start_stream API and wait for completion using wait_stream_state API.\",\n  \"Subtask 9\": \"Wait 3 seconds after traffic stops to ensure accurate statistics collection.\",\n  \"Subtask 10\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API.\",\n  \"Subtask 11\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both equal 100.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Verify the correctness of flow statistics transmitted by the test instrument\n\nStep: Test Step 1: Reserve two loopback ports: Port_1 and Port_2;\n      Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n      Test Step 3: Modify the L2TPv2 Control header content of traffic stream StreamTemplate_1;\n      Test Step 4: Subscribe to StreamBlockStats statistics;\n      Test Step 5: Transmit all traffic and wait for a period;\n      Test Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-003\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FrameLengthType='AUTO')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control'])\n\n    # 修改l2tpv2 control头部\n    edit_header_l2tpv2_control(Stream=stream, Level=0,\n                               Type=1,\n                               Reserved1=11,\n                               Ns=5,\n                               Nr=6,\n                               )\n\n    # 修改l2tpv2 control头部，添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=0,\n                                      Types='generalTLV',\n                                      AttributeValue='11',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=1,\n                                      Types='messageType',\n                                      MessageType=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=2,\n                                      Types='resultCode',\n                                      ErrorCode=1,\n                                      ErrorMessage='01',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=3,\n                                      Types='protocolVersion',\n                                      Ver=1,\n                                      Rev=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=4,\n                                      Types='framingCapabilities',\n                                      Abit=1,\n                                      Sbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=5,\n                                      Types='bearerCapabilities',\n                                      Abit=1,\n                                      Dbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=6,\n                                      Types='tieBreaker',\n                                      TieBreakerValue='0000000000000001',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=7,\n                                      Types='firmwareRevision',\n                                      FirmwareRevision=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=8,\n                                      Types='assignedTunnelId',\n                                      TunnelId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=9,\n                                      Types='receiveWindowSize',\n                                      WindowSize=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=10,\n                                      Types='assignedSessionId',\n                                      SessionId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=11,\n                                      Types='response',\n                                      ResponseValue='00000000000000000000000000000001',\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=12,\n                                      Types='callSerialNumber',\n                                      CallSerialNumber=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=13,\n                                      Types='minimumBps',\n                                      MinimumBps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=14,\n                                      Types='maximumBps',\n                                      MaximumBps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=15,\n                                      Types='bearerType',\n                                      Abit=1,\n                                      Dbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=16,\n                                      Types='framingType',\n                                      Abit=1,\n                                      Sbit=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=17,\n                                      Types='txConnectSpeed',\n                                      Bps=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=18,\n                                      Types='rxConnectSpeed',\n                                      HighBPS=1,\n                                      LowBPS=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=19,\n                                      Types='physicalChannelId',\n                                      PhysicalChannelId=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=20,\n                                      Types='proxyAuthenType',\n                                      AuthenType=1,\n                                      )\n\n    # 修改l2tpv2 control头部，再添加一个Option头部\n    edit_header_l2tpv2_control_option(Stream=stream, Level=0,\n                                      Index=21,\n                                      Types='proxyAuthenId',\n                                      AuthenId=1,\n                                      )\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'l2tpv2Control'],\n                                             FieldName='l2tpv2Control_1.ns',\n                                             Value=5,\n                                             MaxValue=5,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Icmpv4TimeStampRequest.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发icmpv4 time stamp request报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的icmpv4 time stamp request头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Purpose: Verify that the test instrument correctly counts the statistics of ICMPv4 timestamp request packets sent\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Modify the header content of the ICMPv4 timestamp request in traffic StreamTemplate_1;;\n                   Test Step 3: Configure filtered packet capture;;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set the port transmission mode to burst mode;;\n                   Test Step 6: Send all traffic, wait for a period of time;;\n                   Test Step 7: Stop all traffic, view StreamBlockStats statistical information;;\n\nCriteria    \t:   Expected Result 1: In step 6, the traffic StreamTemplate_1 has equal send and receive packets;\n\nCreated by   \t:  \tTester-004\n\nBugs   \t    :  \tNone\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimestampRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改TimestampRequest头部\n    edit_header_icmp_time_stamp_request(Stream=stream, Level=0,\n                          Identifier='100', SequenceNumber='200',\n                          OriginateTimestamp='111', ReceiveTimestamp='222', TransmitTimestamp='333')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampRequest_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampRequest_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_icmp_time_stamp_request:修改测试仪表流量模板中Icmp Time Stamp Request报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform and reserve two ports (Port_1 and Port_2) using specified locations.\",\n  \"Subtask 2\": \"Create a traffic stream on Port_1 with fixed frame length of 256 bytes and configure headers: EthernetII, IPv4, and ICMPv4 Timestamp Request.\",\n  \"Subtask 3\": \"Modify ICMPv4 Timestamp Request header fields: set Identifier=100, SequenceNumber=200, OriginateTimestamp=111, ReceiveTimestamp=222, TransmitTimestamp=333.\",\n  \"Subtask 4\": \"Configure filtered packet capture on Port_2 by creating two PDU patterns: one matching ICMPv4 Identifier=100 and another matching SequenceNumber=200, then set capture filter as logical AND of both patterns.\",\n  \"Subtask 5\": \"Subscribe to StreamBlockStats statistics view for performance monitoring.\",\n  \"Subtask 6\": \"Configure Port_1 transmission mode as burst mode with burst count set to 100.\",\n  \"Subtask 7\": \"Start packet capture on Port_2, initiate traffic transmission from Port_1, maintain active state for 10 seconds, then stop traffic transmission and packet capture.\",\n  \"Subtask 8\": \"Retrieve StreamBlockStats for the created stream and verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 9\": \"Release reserved ports and cleanup resources.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Purpose: Verify that the test instrument correctly counts the statistics of ICMPv4 timestamp request packets sent\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Test Step 2: Modify the header content of the ICMPv4 timestamp request in traffic StreamTemplate_1;;\n                   Test Step 3: Configure filtered packet capture;;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;;\n                   Test Step 5: Set the port transmission mode to burst mode;;\n                   Test Step 6: Send all traffic, wait for a period of time;;\n                   Test Step 7: Stop all traffic, view StreamBlockStats statistical information;;\n\nCriteria    \t:   Expected Result 1: In step 6, the traffic StreamTemplate_1 has equal send and receive packets;\n\nCreated by   \t:  \tTester-004\n\nBugs   \t    :  \tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'TimestampRequest']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # # 修改TimestampRequest头部\n    edit_header_icmp_time_stamp_request(Stream=stream, Level=0,\n                          Identifier='100', SequenceNumber='200',\n                          OriginateTimestamp='111', ReceiveTimestamp='222', TransmitTimestamp='333')\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampRequest_1.identifier',\n                                               Value='100', MaxValue='100')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='timestampRequest_1.sequenceNumber',\n                                               Value='200',\n                                               MaxValue='200')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_icmp_time_stamp_request:修改测试仪表流量模板中Icmp Time Stamp Request报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl2psnpHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Verify the accuracy of traffic statistics sent by the test instrument\n\nStep         :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                Step 3: Modify the IS-IS header content of traffic stream StreamTemplate_1;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Send all traffic and wait for a period;\n                Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2psnpHeader'])\n\n    header = edit_header_isis_psnp(Stream=stream,\n                                   SourceId='102030405060',\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2psnpHeader', Attribute=header['SourceId'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsLspEntries', LspEntries=2)\n\n    edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l2psnpHeader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using init_tester API with specified product configuration.\",\n  \"Subtask 2\": \"Reserve two ports (Port_1 and Port_2) using reserve_port API with provided location information.\",\n  \"Subtask 3\": \"Create traffic stream on Port_1 using add_stream API and build header structure with create_stream_header API specifying EthernetII and l2psnpHeader types.\",\n  \"Subtask 4\": \"Modify IS-IS PSNP header using edit_header_isis_psnp API to set SourceId='102030405060' and CsnpDataTlvOptionHeader=['IsIsLspEntries','AuthentionInfo'].\",\n  \"Subtask 5\": \"Configure modifier for SourceId field using edit_modifier API with increment type and count=10.\",\n  \"Subtask 6\": \"Edit TLV header using edit_header_isis_tlv_header API to set LspEntries=2.\",\n  \"Subtask 7\": \"Modify LSP entry using edit_header_isis_lsp_entry API to set RemainTime=10 for TlvIndex=0 and LspIndex=1.\",\n  \"Subtask 8\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 9\": \"Configure port load profile using edit_port_load_profile API to set burst mode with BurstCount=100.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Monitor traffic state using wait_stream_state API until transmission completes.\",\n  \"Subtask 12\": \"Wait 3 seconds after traffic stops to ensure statistics collection.\",\n  \"Subtask 13\": \"Retrieve StreamBlockStats using get_streamblock_statistic API for the created stream.\",\n  \"Subtask 14\": \"Verify TxStreamFrames equals RxStreamFrames and both equal the configured BurstCount (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Verify the accuracy of traffic statistics sent by the test instrument\n\nStep         :   Step 1: Reserve two loopback ports: Port_1 and Port_2;\n                Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                Step 3: Modify the IS-IS header content of traffic stream StreamTemplate_1;\n                Step 4: Subscribe to StreamBlockStats statistics;\n                Step 5: Send all traffic and wait for a period;\n                Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by   :   Tester-002\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l2psnpHeader'])\n\n    header = edit_header_isis_psnp(Stream=stream,\n                                   SourceId='102030405060',\n                                   CsnpDataTlvOptionHeader=['IsIsLspEntries', 'AuthentionInfo'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2psnpHeader', Attribute=header['SourceId'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='isIsLspEntries', LspEntries=2)\n\n    edit_header_isis_lsp_entry(Stream=stream, TlvIndex=0, LspIndex=1, RemainTime=10)\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l2psnpHeader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_lsp_entry:修改测试仪表流量模板中ISIS L1 Csnp报文中Tlv头部Lsp Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisp2phelloHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective      :   Test Objective: Verify the accuracy of flow statistics on the test instrument\n\nStep           :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the ISIS header content of stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats;\n                   Step 5: Transmit all streams and wait for a period;\n                   Step 6: Stop all streams and check StreamBlockStats statistics;\n\nCriteria       :   Expected Result 1: In Step 6, the transmitted and received packet counts for stream StreamTemplate_1 are equal;\n\nCreated by     :   Tester-002\n\nBugs           :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'p2phelloheader'])\n\n    header = edit_header_isis_p2p_hello(Stream=stream,\n                                        PDUType=10,\n                                        IsIsTlv=['AreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                 'IpInterfaceAddress', 'P2pAdjacencyState', 'RestartSignal',\n                                                 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='p2phelloheader', Attribute=header['PDUType'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AreaAddress', AreaAddressEntries=1)\n    edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, NlPIDEntriesField=2)\n    edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='p2pAdjacencyState', Index=5,\n                                **{'adjacencyStateInitializing.extendLocalCircuitId':'10203040'})\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容",
      "edit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Reserve two ports (Port_1 and Port_2) on the tester using the reserve_port API with specified locations.\",\n  \"Subtask 2\": \"Create a stream (StreamTemplate_1) on Port_1 using the add_stream API.\",\n  \"Subtask 3\": \"Modify the ISIS P2P Hello header of StreamTemplate_1 using edit_header_isis_p2p_hello API, setting PDUType=10 and including specified TLVs.\",\n  \"Subtask 4\": \"Configure increment modifiers for the ISIS header fields using edit_modifier API with Type='Increment' and Count=10.\",\n  \"Subtask 5\": \"Edit specific ISIS TLV headers (AreaAddress, Padding, AuthenticationInfo, etc.) using edit_header_isis_tlv_header and related entry APIs.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats and PortStats views using subscribe_result API.\",\n  \"Subtask 7\": \"Configure Port_1's load profile to burst mode with BurstCount=100 using edit_port_load_profile API.\",\n  \"Subtask 8\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 9\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 10\": \"Wait 3 seconds for statistics stabilization after traffic stops.\",\n  \"Subtask 11\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API.\",\n  \"Subtask 12\": \"Verify TxStreamFrames equals RxStreamFrames and both equal the configured BurstCount (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective      :   Test Objective: Verify the accuracy of flow statistics on the test instrument\n\nStep           :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                   Step 2: Create a stream StreamTemplate_1 on port Port_1;\n                   Step 3: Modify the ISIS header content of stream StreamTemplate_1;\n                   Step 4: Subscribe to StreamBlockStats;\n                   Step 5: Transmit all streams and wait for a period;\n                   Step 6: Stop all streams and check StreamBlockStats statistics;\n\nCriteria       :   Expected Result 1: In Step 6, the transmitted and received packet counts for stream StreamTemplate_1 are equal;\n\nCreated by     :   Tester-002\n\nBugs           :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'p2phelloheader'])\n\n    header = edit_header_isis_p2p_hello(Stream=stream,\n                                        PDUType=10,\n                                        IsIsTlv=['AreaAddress', 'Padding', 'AuthentionInfo', 'ProtocolSupport',\n                                                 'IpInterfaceAddress', 'P2pAdjacencyState', 'RestartSignal',\n                                                 'Ipv6InterfaceAddress'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='p2phelloheader', Attribute=header['PDUType'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AreaAddress', AreaAddressEntries=1)\n    edit_header_isis_area_address_entry(Stream=stream, TlvIndex=0, EntryIndex=1, AreaAddress='ff')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Padding', Index=1, TlvLength=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='AuthentionInfo', Index=2, AuthenticationLength=20)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ProtocolSupport', Index=3, NlPIDEntriesField=2)\n    edit_header_isis_nlpid_entry(Stream=stream, TlvIndex=3, NlpidIndex=0, TlvLength=30)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='p2pAdjacencyState', Index=5,\n                                **{'adjacencyStateInitializing.extendLocalCircuitId':'10203040'})\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容;\nedit_header_isis_nlpid_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部NLPID Entry内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ospfv2HelloInstance.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发ospfv2 hello报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的ospfv2 hello头部内容;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   Test Objective: Verify that the test instrument correctly counts transmitted OSPFv2 Hello packets\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Modify the OSPFv2 Hello header content in traffic stream StreamTemplate_1;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Transmit all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2hello']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 hello头部\n    header = edit_header_ospfv2_hello(Stream=stream, Level=0,\n                                      RouterID='2.2.2.2', AuthType='MD5',\n                                      NetworkMask='255.255.255.0',\n                                      Neighbors=['1.1.1.1', '2.2.2.2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2hello',\n                  Attribute=header['NetworkMask'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2hello',\n                  Attribute=header['Neighbors: 2.2.2.2'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.networkMask',\n                                               Value='255.255.255.0', MaxValue='255.255.255.0')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.ospfHeader.routerID',\n                                               Value='2.2.2.2',\n                                               MaxValue='2.2.2.2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.routerDeadInterval',\n                                               Value='50',\n                                               MaxValue='50')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ospfv2_hello:修改测试仪表流量模板中OSPFv2 Hello报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for the specified product (DarYu).\",\n  \"Subtask 2\": \"Reserve two ports at the given locations for testing.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed frame length.\",\n  \"Subtask 4\": \"Configure the stream headers to include EthernetII, IPv4, and OSPFv2 Hello protocols.\",\n  \"Subtask 5\": \"Modify the OSPFv2 Hello header with specific parameters: RouterID='2.2.2.2', AuthType='MD5', NetworkMask='255.255.255.0', Neighbors=['1.1.1.1', '2.2.2.2'].\",\n  \"Subtask 6\": \"Apply increment modifiers to the OSPFv2 Hello NetworkMask field with count=10 and step=2.\",\n  \"Subtask 7\": \"Apply increment modifiers to the OSPFv2 Hello Neighbors field with count=10 and step=2.\",\n  \"Subtask 8\": \"Create three PDU patterns for capture filtering on the second port targeting specific OSPFv2 fields: NetworkMask='255.255.255.0', RouterID='2.2.2.2', RouterDeadInterval='50'.\",\n  \"Subtask 9\": \"Configure packet capture filter on the second port using logical AND combination of the three PDU patterns.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 11\": \"Configure the first port's transmission mode to burst with burst count=100.\",\n  \"Subtask 12\": \"Save test configuration to file.\",\n  \"Subtask 13\": \"Start packet capture on the second port.\",\n  \"Subtask 14\": \"Start traffic transmission on the first port.\",\n  \"Subtask 15\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 16\": \"Stop traffic transmission.\",\n  \"Subtask 17\": \"Stop packet capture.\",\n  \"Subtask 18\": \"Download captured packets from the second port to local storage.\",\n  \"Subtask 19\": \"Retrieve StreamBlockStats results for the created stream.\",\n  \"Subtask 20\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 21\": \"Release all reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   Test Objective: Verify that the test instrument correctly counts transmitted OSPFv2 Hello packets\n\nStep         :   Step 1: Reserve two loopback ports, Port_1 and Port_2;\n                 Step 2: Modify the OSPFv2 Hello header content in traffic stream StreamTemplate_1;\n                 Step 3: Configure filtered packet capture;\n                 Step 4: Subscribe to StreamBlockStats;\n                 Step 5: Set port transmission mode to burst;\n                 Step 6: Transmit all traffic and wait for a period;\n                 Step 7: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria     :   Expected Result 1: In Step 6, transmitted and received packets for StreamTemplate_1 are equal;\n\nCreated by   :   Tester-004\n\nBugs         :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'ospfv2hello']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ospfv2 hello头部\n    header = edit_header_ospfv2_hello(Stream=stream, Level=0,\n                                      RouterID='2.2.2.2', AuthType='MD5',\n                                      NetworkMask='255.255.255.0',\n                                      Neighbors=['1.1.1.1', '2.2.2.2'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2hello',\n                  Attribute=header['NetworkMask'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='ospfv2hello',\n                  Attribute=header['Neighbors: 2.2.2.2'],\n                  Type='Increment',\n                  Count=10, Step=2)\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.networkMask',\n                                               Value='255.255.255.0', MaxValue='255.255.255.0')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.ospfHeader.routerID',\n                                               Value='2.2.2.2',\n                                               MaxValue='2.2.2.2')\n    pdu_pattern_3 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='Ospfv2Hello_1.routerDeadInterval',\n                                               Value='50',\n                                               MaxValue='50')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2} && {pdu_pattern_3}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ospfv2_hello:修改测试仪表流量模板中OSPFv2 Hello报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Isisl1lspHeader.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的isis头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective    :   Test Objective: Verify the accuracy of traffic statistics from the test instrument\n\nStep        :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Test Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n                Test Step 3: Modify the ISIS header content of stream StreamTemplate_1;\n                Test Step 4: Subscribe to StreamBlockStats;\n                Test Step 5: Transmit all traffic and wait for a period;\n                Test Step 6: Stop all traffic and check StreamBlockStats information;\n\nCriteria    :   Expected Result 1: Packets sent and received for stream StreamTemplate_1 are equal in Step 6;\n\nCreated by  :   Tester-002\n\nBugs        :   None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, )\n    edit_stream(Stream=stream, FrameLengthType='Auto')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1lspheader'])\n\n    header = edit_header_isis_lsp(Stream=stream, \n                                  InterRoutingProtocolDiscriminator=10,\n                                  PDULength=20,\n                                  LspisIsTlvOptionSet=['IsIsAreaAddress', 'IsIsReachability', 'ExtendedReachability',\n                                    'IsIsIpInterReachability', 'IsIsProtocolsSupported', 'IsIsIPExternalReachability',\n                                    'IpInterfaceAddress', 'Ipv6InterfaceAddress', 'IsIsIpv6Reachability'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=header['InterRoutingProtocolDiscriminator'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=header['PDULength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsAreaAddress', \n                                      TlvCode=10,\n                                      AreaAddressEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n    entry = edit_header_isis_area_address_entry(Stream=stream, TlvLength=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=entry['TlvLength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsReachability', Index=1,\n                                      VirtualFlag=10,\n                                      MetricEntries=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=tlv['VirtualFlag'],\n                  Type='Increment', Count=10)\n    entry = edit_header_isis_metric_entry(Stream=stream, TlvIndex=1, EntryIndex=1, DefaultMetric=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=entry['DefaultMetric'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ExtendedReachability', Index=2,\n                                IisNeighborSubTlv=['AdGroupSubtlv', 'Ipv4InterfaceAddressSubtlv', 'Ipv4NeighborAddressSubtlv',\n                                      'MaxLinkBandwidthSubtlv', 'ReservableLinkBandwidthSubtlv', 'UnReservedBandwidthSubtlv',\n                                      'InterfaceIpv6Subtlv', 'NeigbhorIpv6Subtlv'])\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='AdGroupSubtlv', TlvIndex=2, SubTlvIndex=0, tlvCode=20)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4InterfaceAddressSubtlv', TlvIndex=2, SubTlvIndex=1, Ipv4InterfaceAddressValue='1.1.1.1')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4NeighborAddressSubtlv', TlvIndex=2, SubTlvIndex=2, Ipv4NeighborAddressValue='2.2.2.2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='MaxLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=3, MaxBandwidthValue=30)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='ReservableLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=4, ReservableLinkBandwidthValue=40)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='UnReservedBandwidthSubtlv', TlvIndex=2, SubTlvIndex=5, ResBandwidth0Value=50)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='InterfaceIpv6Subtlv', TlvIndex=2, SubTlvIndex=6, InterfaceIpv6Value='2022::2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='NeigbhorIpv6Subtlv', TlvIndex=2, SubTlvIndex=7, Neighboripv6Value='2033::3')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsIpInterReachability', Index=3, InternalmetricEntries=1)\n    edit_header_isis_internal_metric_entry(Stream=stream, TlvIndex=3, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IpInterfaceAddress', Index=6, Ipv4InterfaceAddress=['1.1.1.1', '2.2.2.2'])\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Ipv6InterfaceAddress', Index=7, Ipv6InterfaceAddress=['2022::2', '2033::3'])\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    # start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "get_capture_info:在指定端口报文捕获信息",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容",
      "edit_header_isis_internal_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容",
      "edit_header_isis_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容",
      "edit_header_isis_sub_tlv:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Sub Tlv内容",
      "edit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester API with specified product platform.\",\n  \"Subtask 2\": \"Reserve two ports (Port_UP and Port_Down) using reserve_port API with provided locations.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_UP using add_stream API and configure frame length type with edit_stream API.\",\n  \"Subtask 4\": \"Build ISIS header structure using create_stream_header API with EthernetII and l1lspheader.\",\n  \"Subtask 5\": \"Modify ISIS LSP header fields (InterRoutingProtocolDiscriminator, PDULength) using edit_header_isis_lsp API and configure increment modifiers with edit_modifier API.\",\n  \"Subtask 6\": \"Configure ISIS Area Address TLV using edit_header_isis_tlv_header API, set modifiers for TlvCode and TlvLength fields.\",\n  \"Subtask 7\": \"Configure ISIS Reachability TLV using edit_header_isis_tlv_header API, set modifiers for VirtualFlag and DefaultMetric fields.\",\n  \"Subtask 8\": \"Configure Extended Reachability TLV with specific sub-TLVs (AdGroupSubtlv, Ipv4InterfaceAddressSubtlv, etc.) using edit_header_isis_sub_tlv API.\",\n  \"Subtask 9\": \"Configure ISIS IP Reachability, IP Interface Address, and IPv6 Interface Address TLVs using edit_header_isis_tlv_header API.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats and PortStats views using subscribe_result API.\",\n  \"Subtask 11\": \"Configure port load profile with burst mode and burst count (100) using edit_port_load_profile API.\",\n  \"Subtask 12\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 13\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 14\": \"Wait for traffic transmission completion using wait_stream_state API and pause for 3 seconds.\",\n  \"Subtask 15\": \"Retrieve StreamBlockStats for the traffic stream using get_streamblock_statistic API.\",\n  \"Subtask 16\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) and both match burst count (100).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective    :   Test Objective: Verify the accuracy of traffic statistics from the test instrument\n\nStep        :   Test Step 1: Reserve two loopback ports Port_1 and Port_2;\n                Test Step 2: Create traffic stream StreamTemplate_1 on port Port_1;\n                Test Step 3: Modify the ISIS header content of stream StreamTemplate_1;\n                Test Step 4: Subscribe to StreamBlockStats;\n                Test Step 5: Transmit all traffic and wait for a period;\n                Test Step 6: Stop all traffic and check StreamBlockStats information;\n\nCriteria    :   Expected Result 1: Packets sent and received for stream StreamTemplate_1 are equal in Step 6;\n\nCreated by  :   Tester-002\n\nBugs        :   None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, )\n    edit_stream(Stream=stream, FrameLengthType='Auto')\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'l1lspheader'])\n\n    header = edit_header_isis_lsp(Stream=stream, \n                                  InterRoutingProtocolDiscriminator=10,\n                                  PDULength=20,\n                                  LspisIsTlvOptionSet=['IsIsAreaAddress', 'IsIsReachability', 'ExtendedReachability',\n                                    'IsIsIpInterReachability', 'IsIsProtocolsSupported', 'IsIsIPExternalReachability',\n                                    'IpInterfaceAddress', 'Ipv6InterfaceAddress', 'IsIsIpv6Reachability'])\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=header['InterRoutingProtocolDiscriminator'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=header['PDULength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsAreaAddress', \n                                      TlvCode=10,\n                                      AreaAddressEntries=2)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=tlv['TlvCode'],\n                  Type='Increment', Count=10)\n    entry = edit_header_isis_area_address_entry(Stream=stream, TlvLength=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=entry['TlvLength'],\n                  Type='Increment', Count=10)\n\n    tlv = edit_header_isis_tlv_header(Stream=stream, Option='IsIsReachability', Index=1,\n                                      VirtualFlag=10,\n                                      MetricEntries=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=tlv['VirtualFlag'],\n                  Type='Increment', Count=10)\n    entry = edit_header_isis_metric_entry(Stream=stream, TlvIndex=1, EntryIndex=1, DefaultMetric=1)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l1lspheader', Attribute=entry['DefaultMetric'],\n                  Type='Increment', Count=10)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='ExtendedReachability', Index=2,\n                                IisNeighborSubTlv=['AdGroupSubtlv', 'Ipv4InterfaceAddressSubtlv', 'Ipv4NeighborAddressSubtlv',\n                                      'MaxLinkBandwidthSubtlv', 'ReservableLinkBandwidthSubtlv', 'UnReservedBandwidthSubtlv',\n                                      'InterfaceIpv6Subtlv', 'NeigbhorIpv6Subtlv'])\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='AdGroupSubtlv', TlvIndex=2, SubTlvIndex=0, tlvCode=20)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4InterfaceAddressSubtlv', TlvIndex=2, SubTlvIndex=1, Ipv4InterfaceAddressValue='1.1.1.1')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='Ipv4NeighborAddressSubtlv', TlvIndex=2, SubTlvIndex=2, Ipv4NeighborAddressValue='2.2.2.2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='MaxLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=3, MaxBandwidthValue=30)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='ReservableLinkBandwidthSubtlv', TlvIndex=2, SubTlvIndex=4, ReservableLinkBandwidthValue=40)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='UnReservedBandwidthSubtlv', TlvIndex=2, SubTlvIndex=5, ResBandwidth0Value=50)\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='InterfaceIpv6Subtlv', TlvIndex=2, SubTlvIndex=6, InterfaceIpv6Value='2022::2')\n    edit_header_isis_sub_tlv(Stream=stream, SubTlv='NeigbhorIpv6Subtlv', TlvIndex=2, SubTlvIndex=7, Neighboripv6Value='2033::3')\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IsIsIpInterReachability', Index=3, InternalmetricEntries=1)\n    edit_header_isis_internal_metric_entry(Stream=stream, TlvIndex=3, EntryIndex=1, DefaultMetricIEbit=1)\n\n    edit_header_isis_tlv_header(Stream=stream, Option='IpInterfaceAddress', Index=6, Ipv4InterfaceAddress=['1.1.1.1', '2.2.2.2'])\n\n    edit_header_isis_tlv_header(Stream=stream, Option='Ipv6InterfaceAddress', Index=7, Ipv6InterfaceAddress=['2022::2', '2033::3'])\n\n    # 配置过滤抓包\n    # pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n    #                                          HeaderTypes=['EthernetII', 'l1csnpheader'],\n    #                                          FieldName='IsIsL1Csnp_1.CsnpDataHeader.CsnpDataTlvOptionHeader.csnpisIsTlvs_0.isIsLspEntries.lspEntries.LSPEntry_0.remainTime',\n    #                                          Value=10,\n    #                                          MaxValue=10,\n    #                                          )\n    # edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    # start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nget_capture_info:在指定端口报文捕获信息;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_isis_area_address_entry:修改测试仪表流量模板中ISIS L1 Hello/Lsp报文中Tlv头部Area Address Entry内容;\nedit_header_isis_internal_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容;\nedit_header_isis_metric_entry:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Metric Entry内容;\nedit_header_isis_sub_tlv:修改测试仪表流量模板中ISIS L1 Lsp报文中Tlv头部Sub Tlv内容;\nedit_header_isis_tlv_header:修改测试仪表流量模板中ISIS L1 Csnp/Hello/Lsp/Psnp报文中Tlv头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/LoadProfile/EditLoadProfile_BaseOnPort_DarYu.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Port负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约4个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Port,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================",
    "intent_en": "Objective: To verify that the test instrument's load mode configuration \"Base On Port\" is successfully set.  \n\nStep 1: Reserve 4 offline ports;  \nStep 2: Set port load mode to \"Base On Port\" and configure all type parameters for the load;  \n\nCriteria: Expected Result 1: The port load configuration in Step 2 is successfully set;  \n\nCreated by: Tester-001  \n\nBugs:",
    "code": "from TesterLibrary.base import *\n\n\nProduct = 'DarYu'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'daryu':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Port, （端口负载：15, 负载单位：Percent(%)） 传输模式：Continuous, （突发报文数：10, 突发间隔：100, 突发间隔单位: ns）\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='PORT_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               BurstSize=10,\n                               InterFrameGap=100,\n                               InterFrameGapUnit='NS',\n                               Rate=15,\n                               Unit='PERCENT',)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Port （端口负载：20, 负载单位：Inter Frame Gap(ns)）, 传输模式：Burst, （突发报文数：15, 突发间隔：110, 突发间隔单位: us , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='PORT_BASE',\n                               Rate=20,\n                               Unit='NS',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=110,\n                               InterFrameGapUnit='US',\n                               BurstCount=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Port, （端口负载：25, 负载单位：Inter Frame Gap(byte)） 传输模式：Time, （突发报文数：20, 突发间隔：120, 突发间隔单位: ms, 发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='PORT_BASE',\n                               Rate=25,\n                               Unit='INTER_FRAME_GAP_BYTE',\n                               TransmitMode=\"TIME\",\n                               BurstSize=15,\n                               InterFrameGap=120,\n                               InterFrameGapUnit='MS',\n                               Seconds=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Port, （端口负载：30, 负载单位：Frames per Second） 传输模式：Step, （突发报文数：25, 突发间隔：130, 突发间隔单位: sec, 发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='PORT_BASE',\n                               Rate=30,\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               BurstSize=20,\n                               InterFrameGap=130,\n                               InterFrameGapUnit='SEC',\n                               Frames=20)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve 4 offline ports at locations ['//10.0.11.191/1/1', '//10.0.11.191/1/2', '//10.0.11.191/1/3', '//10.0.11.191/1/4'] using reserve_port API.\",\n  \"Subtask 3\": \"Set port 1 load mode to 'PORT_BASE' with parameters: TransmitMode='CONTINUOUS', BurstSize=10, InterFrameGap=100, InterFrameGapUnit='NS', Rate=15, Unit='PERCENT' using edit_port_load_profile API.\",\n  \"Subtask 4\": \"Set port 2 load mode to 'PORT_BASE' with parameters: TransmitMode='BURST', BurstSize=15, InterFrameGap=110, InterFrameGapUnit='US', Rate=20, Unit='NS', BurstCount=10 using edit_port_load_profile API.\",\n  \"Subtask 5\": \"Set port 3 load mode to 'PORT_BASE' with parameters: TransmitMode='TIME', BurstSize=15, InterFrameGap=120, InterFrameGapUnit='MS', Rate=25, Unit='INTER_FRAME_GAP_BYTE', Seconds=15 using edit_port_load_profile API.\",\n  \"Subtask 6\": \"Set port 4 load mode to 'PORT_BASE' with parameters: TransmitMode='STEP', BurstSize=20, InterFrameGap=130, InterFrameGapUnit='SEC', Rate=30, Unit='FRAME_PER_SEC', Frames=20 using edit_port_load_profile API.\",\n  \"Subtask 7\": \"Save the configuration to file using save_case API with path derived from current script location.\",\n  \"Subtask 8\": \"Verify all port load configurations were set successfully by checking no exceptions occurred during configuration steps.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: To verify that the test instrument's load mode configuration \"Base On Port\" is successfully set.  \n\nStep 1: Reserve 4 offline ports;  \nStep 2: Set port load mode to \"Base On Port\" and configure all type parameters for the load;  \n\nCriteria: Expected Result 1: The port load configuration in Step 2 is successfully set;  \n\nCreated by: Tester-001  \n\nBugs:\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\n\nProduct = 'DarYu'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'daryu':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Port, （端口负载：15, 负载单位：Percent(%)） 传输模式：Continuous, （突发报文数：10, 突发间隔：100, 突发间隔单位: ns）\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='PORT_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               BurstSize=10,\n                               InterFrameGap=100,\n                               InterFrameGapUnit='NS',\n                               Rate=15,\n                               Unit='PERCENT',)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Port （端口负载：20, 负载单位：Inter Frame Gap(ns)）, 传输模式：Burst, （突发报文数：15, 突发间隔：110, 突发间隔单位: us , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='PORT_BASE',\n                               Rate=20,\n                               Unit='NS',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=110,\n                               InterFrameGapUnit='US',\n                               BurstCount=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Port, （端口负载：25, 负载单位：Inter Frame Gap(byte)） 传输模式：Time, （突发报文数：20, 突发间隔：120, 突发间隔单位: ms, 发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='PORT_BASE',\n                               Rate=25,\n                               Unit='INTER_FRAME_GAP_BYTE',\n                               TransmitMode=\"TIME\",\n                               BurstSize=15,\n                               InterFrameGap=120,\n                               InterFrameGapUnit='MS',\n                               Seconds=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Port, （端口负载：30, 负载单位：Frames per Second） 传输模式：Step, （突发报文数：25, 突发间隔：130, 突发间隔单位: sec, 发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='PORT_BASE',\n                               Rate=30,\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               BurstSize=20,\n                               InterFrameGap=130,\n                               InterFrameGapUnit='SEC',\n                               Frames=20)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/LoadProfile/EditLoadProfile_BaseOnStream_DarYu.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Stream负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约4个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Stream,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Check that the test instrument's load mode is set to Base On Stream and the load configuration is successfully applied.\n\nStep: Step 1: Reserve 4 offline ports;\n      Step 2: Set port load mode to Base On Stream and configure all load parameter types;\n\nCriteria: Expected result 1: Port load configuration in step 2 is successfully set;\n\nCreated by: Tester-001\n\nBugs: \n=================================================================================",
    "code": "from TesterLibrary.base import *\n\n\nProduct = 'DarYu'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'daryu':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Stream,  传输模式：Continuous, （突发报文数：10, 突发间隔：100, 突发间隔单位: ns）\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               BurstSize=10,\n                               InterFrameGap=100,\n                               InterFrameGapUnit='NS')\n        # 创建流量\n        stream = add_stream(Ports=Ports[0], FixedLength=256)\n        # 负载单位：Percent(%) 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='PERCENT', Rate=5)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Stream, 传输模式：Burst, （（突发报文数：15, 突发间隔：110, 突发间隔单位: us , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=110,\n                               InterFrameGapUnit='US',\n                               BurstCount=10)\n        # 创建流量\n        stream = add_stream(Ports=Ports[1], FixedLength=256)\n        # 负载单位：Frames per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='FRAME_PER_SEC', Rate=10)\n        \n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Stream, 传输模式：Time, （突发报文数：20, 突发间隔：120, 突发间隔单位: ms, 发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"TIME\",\n                               BurstSize=15,\n                               InterFrameGap=120,\n                               InterFrameGapUnit='MS',\n                               Seconds=15)\n        # 创建流量\n        stream = add_stream(Ports=Ports[2], FixedLength=256)\n        # 负载单位：Byte per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='BYTE_PER_SEC', Rate=15)\n        \n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Stream, 传输模式：Step, （突发报文数：25, 突发间隔：130, 突发间隔单位: sec, 发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"STEP\",\n                               BurstSize=20,\n                               InterFrameGap=130,\n                               InterFrameGapUnit='SEC',\n                               Frames=20)\n        # 创建流量\n        stream = add_stream(Ports=Ports[3], FixedLength=256)\n        # 负载单位：Line Bits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='LINEBIT_PER_SEC', Rate=20)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "add_stream:测试仪表创建流量"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with product type 'DarYu' using init_tester API.\",\n  \"Subtask 2\": \"Reserve 4 offline ports at specified locations using reserve_port API.\",\n  \"Subtask 3\": \"For port 1: Set load mode to Base On Stream (STREAM_BASE) with Continuous transmit mode (BurstSize=10, InterFrameGap=100ns) using edit_port_load_profile API.\",\n  \"Subtask 4\": \"For port 1: Create traffic stream with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 5\": \"For port 1: Configure stream load profile with PERCENT unit and 5% rate using edit_stream_load_profile API.\",\n  \"Subtask 6\": \"For port 2: Set load mode to Base On Stream (STREAM_BASE) with Burst transmit mode (BurstSize=15, InterFrameGap=110us, BurstCount=10) using edit_port_load_profile API.\",\n  \"Subtask 7\": \"For port 2: Create traffic stream with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 8\": \"For port 2: Configure stream load profile with FRAME_PER_SEC unit and 10 fps rate using edit_stream_load_profile API.\",\n  \"Subtask 9\": \"For port 3: Set load mode to Base On Stream (STREAM_BASE) with Time transmit mode (BurstSize=15, InterFrameGap=120ms, Seconds=15) using edit_port_load_profile API.\",\n  \"Subtask 10\": \"For port 3: Create traffic stream with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 11\": \"For port 3: Configure stream load profile with BYTE_PER_SEC unit and 15 Bps rate using edit_stream_load_profile API.\",\n  \"Subtask 12\": \"For port 4: Set load mode to Base On Stream (STREAM_BASE) with Step transmit mode (BurstSize=20, InterFrameGap=130sec, Frames=20) using edit_port_load_profile API.\",\n  \"Subtask 13\": \"For port 4: Create traffic stream with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 14\": \"For port 4: Configure stream load profile with LINEBIT_PER_SEC unit and 20 bps rate using edit_stream_load_profile API.\",\n  \"Subtask 15\": \"Save the complete configuration to .xcfg file using save_case API.\",\n  \"Subtask 16\": \"Verify all port load configurations were successfully applied without errors (implicit through exception handling).\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Check that the test instrument's load mode is set to Base On Stream and the load configuration is successfully applied.\n\nStep: Step 1: Reserve 4 offline ports;\n      Step 2: Set port load mode to Base On Stream and configure all load parameter types;\n\nCriteria: Expected result 1: Port load configuration in step 2 is successfully set;\n\nCreated by: Tester-001\n\nBugs: \n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\n\nProduct = 'DarYu'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'daryu':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Stream,  传输模式：Continuous, （突发报文数：10, 突发间隔：100, 突发间隔单位: ns）\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               BurstSize=10,\n                               InterFrameGap=100,\n                               InterFrameGapUnit='NS')\n        # 创建流量\n        stream = add_stream(Ports=Ports[0], FixedLength=256)\n        # 负载单位：Percent(%) 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='PERCENT', Rate=5)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Stream, 传输模式：Burst, （（突发报文数：15, 突发间隔：110, 突发间隔单位: us , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=110,\n                               InterFrameGapUnit='US',\n                               BurstCount=10)\n        # 创建流量\n        stream = add_stream(Ports=Ports[1], FixedLength=256)\n        # 负载单位：Frames per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='FRAME_PER_SEC', Rate=10)\n        \n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Stream, 传输模式：Time, （突发报文数：20, 突发间隔：120, 突发间隔单位: ms, 发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"TIME\",\n                               BurstSize=15,\n                               InterFrameGap=120,\n                               InterFrameGapUnit='MS',\n                               Seconds=15)\n        # 创建流量\n        stream = add_stream(Ports=Ports[2], FixedLength=256)\n        # 负载单位：Byte per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='BYTE_PER_SEC', Rate=15)\n        \n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Stream, 传输模式：Step, （突发报文数：25, 突发间隔：130, 突发间隔单位: sec, 发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"STEP\",\n                               BurstSize=20,\n                               InterFrameGap=130,\n                               InterFrameGapUnit='SEC',\n                               Frames=20)\n        # 创建流量\n        stream = add_stream(Ports=Ports[3], FixedLength=256)\n        # 负载单位：Line Bits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='LINEBIT_PER_SEC', Rate=20)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nadd_stream:测试仪表创建流量\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/L2tpv3_ControlOverUdp.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发l2tpv3 control over udp报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的l2tpv3 control over udp头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-004\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Test Objective: Verify that the test instrument correctly counts transmitted and received packets for L2TPv3 control over UDP\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Modify the L2TPv3 control over UDP header content of traffic stream StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Transmit all traffic and wait for a period;\nTest Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3ControlOverUdp头部\n    header = edit_header_l2tpv3_control_over_udp(Stream=stream, Level=0, Type=1, SequenceNumberNr=1, Length=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header['Length'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header['SequenceNumberNr'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv3ControlOverUdp头部选项\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=0, Types='generalTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=1, Types='messageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=2, Types='resultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=3, Types='tieBreaker', TieBreakerValue='0000000000000001')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['TieBreakerValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=4, Types='receiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=5, Types='callSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=6, Types='physicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=7, Types='circuitError', AlignmentOverruns='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['AlignmentOverruns'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=8, Types='routeId', RouteId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['RouteId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=9, Types='assignedConnection', ConnectionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['ConnectionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=10, Types='localSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=11, Types='remoteSessionId',  SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=12, Types='assignedCookie', Cookie8Byte='1020304050607080')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['Cookie8Byte'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=13, Types='pwType', PwType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['PwType'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=14, Types='l2SpecificSub', L2SpecificSublayer='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['L2SpecificSublayer'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=15, Types='dataSequencing', DataSequencing='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['DataSequencing'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=16, Types='txConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=17, Types='rxConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=18, Types='circuitStatus', Nbit='1',Abit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['Abit'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3ControlOverUdp_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with product specification 'DarYu'.\",\n  \"Subtask 2\": \"Reserve two ports at specified locations for testing.\",\n  \"Subtask 3\": \"Create a traffic stream on the first reserved port with fixed length of 512 bytes.\",\n  \"Subtask 4\": \"Configure the stream header with protocol stack: EthernetII, IPv4, UDP, L2TPv3 control over UDP.\",\n  \"Subtask 5\": \"Edit the main L2TPv3 control header fields (Type, SequenceNumberNr, Length) and configure increment modifiers for Length and SequenceNumberNr fields with count=10.\",\n  \"Subtask 6\": \"Edit 18 L2TPv3 control options (generalTLV, messageType, resultCode, etc.) and configure increment modifiers for AttributeValue, MessageType, ErrorCode, and TieBreakerValue fields with count=10.\",\n  \"Subtask 7\": \"Create a PDU pattern on the second port to filter L2TPv3 control packets where type field equals 1.\",\n  \"Subtask 8\": \"Apply the PDU pattern as a capture filter on the second port.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 10\": \"Configure the first port's transmission mode to burst with burst count=100.\",\n  \"Subtask 11\": \"Save the test configuration to a file.\",\n  \"Subtask 12\": \"Start packet capture on the second port.\",\n  \"Subtask 13\": \"Start traffic transmission from the first port.\",\n  \"Subtask 14\": \"Wait for 10 seconds during traffic transmission.\",\n  \"Subtask 15\": \"Stop traffic transmission from the first port.\",\n  \"Subtask 16\": \"Stop packet capture on the second port.\",\n  \"Subtask 17\": \"Download captured packets from the second port to a specified directory.\",\n  \"Subtask 18\": \"Retrieve StreamBlockStats results for the created stream.\",\n  \"Subtask 19\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 20\": \"Release the reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Test Objective: Verify that the test instrument correctly counts transmitted and received packets for L2TPv3 control over UDP\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Modify the L2TPv3 control over UDP header content of traffic stream StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set port transmission mode to burst;\nTest Step 6: Transmit all traffic and wait for a period;\nTest Step 7: Stop all traffic and check StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In Step 6, transmitted and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-004\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=512)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'UDP', 'l2tpv3ControlOverUdp']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改l2tpv3ControlOverUdp头部\n    header = edit_header_l2tpv3_control_over_udp(Stream=stream, Level=0, Type=1, SequenceNumberNr=1, Length=1)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header['Length'],\n                  Type='Increment', Count=10)\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header['SequenceNumberNr'],\n                  Type='Increment', Count=10)\n    # 修改l2tpv3ControlOverUdp头部选项\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=0, Types='generalTLV', AttributeValue='11')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['AttributeValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=1, Types='messageType', MessageType='1')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['MessageType'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=2, Types='resultCode', ErrorCode='1', ErrorMessage='01')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['ErrorCode'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=3, Types='tieBreaker', TieBreakerValue='0000000000000001')\n    edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['TieBreakerValue'],\n                  Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=4, Types='receiveWindowSize', WindowSize='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['WindowSize'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=5, Types='callSerialNumber', CallSerialNumber='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['CallSerialNumber'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=6, Types='physicalChannelId', PhysicalChannelId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['PhysicalChannelId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=7, Types='circuitError', AlignmentOverruns='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['AlignmentOverruns'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=8, Types='routeId', RouteId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['RouteId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=9, Types='assignedConnection', ConnectionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['ConnectionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=10, Types='localSessionId', SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=11, Types='remoteSessionId',  SessionId='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SessionId'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=12, Types='assignedCookie', Cookie8Byte='1020304050607080')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['Cookie8Byte'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=13, Types='pwType', PwType='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['PwType'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=14, Types='l2SpecificSub', L2SpecificSublayer='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['L2SpecificSublayer'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=15, Types='dataSequencing', DataSequencing='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['DataSequencing'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=16, Types='txConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=17, Types='rxConnectSpeed', SpeedBps='0000000000000001')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['SpeedBps'],\n    #               Type='Increment', Count=10)\n\n    header_option = edit_header_l2tpv3_control_option(Stream=stream, Level=0, Index=18, Types='circuitStatus', Nbit='1',Abit='1')\n    # edit_modifier(Stream=stream, Level=0, HeaderType='l2tpv3ControlOverUdp', Attribute=header_option['Abit'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               FieldName='l2tpv3ControlOverUdp_1.type',\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/LoadProfile/EditLoadProfile_BaseOnPort_BigTao.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Port负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约6个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Port,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    : Check that the load mode of the testing instrument is set to Base On Port and the load configuration is set successfully.\n\nStep         : Step 1: Reserve 6 offline ports;\n              Step 2: Set the port load mode to Base On Port and configure all type parameters of the load configuration;\n\nCriteria     : Expected Result 1: In Step 2, the port load configuration is set successfully;\n\nCreated by   : Tester-001\n\nBugs         :\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\n\nProduct = 'BigTao'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n    '//10.0.11.191/1/5',\n    '//10.0.11.191/1/6',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'bigtao':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Port, （端口负载：15, 负载单位：Percent(%)） 传输模式：Continuous,\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='PORT_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=15,\n                               Unit='PERCENT')\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Port （端口负载：20, 负载单位：Inter Frame Gap(ns)）, 传输模式：Burst, （突发报文数：15, 突发间隔：2, 突发间隔单位: ms , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='PORT_BASE',\n                               Rate=20,\n                               Unit='NS',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=2,\n                               InterFrameGapUnit='MS',\n                               BurstCount=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Port, （端口负载：25, 负载单位：Inter Frame Gap(byte)） 传输模式：Time, （发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='PORT_BASE',\n                               Rate=25,\n                               Unit='INTER_FRAME_GAP_BYTE',\n                               TransmitMode=\"TIME\",\n                               Seconds=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Port, （端口负载：30, 负载单位：Frames per Second） 传输模式：Step, （发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='PORT_BASE',\n                               Rate=30,\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               Frames=20)\n\n        # =============== *设置模式5* ===============\n        # 负载模式：Base On Port, （端口负载：35, 负载单位：Byte per Second） 传输模式：On Stream, 流传输模式：Continuous\n        edit_port_load_profile(Ports=Ports[4],\n                               LoadProfileType='PORT_BASE',\n                               Rate=35,\n                               Unit='BYTE_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[4], FixedLength=256)\n        edit_stream_load_profile(Streams=stream, StreamTransmitMode='CONTINUOUS')\n\n        # =============== *设置模式6* ===============\n        # 负载模式：Base On Port, （端口负载：40, 负载单位：Data Bits per Second） 传输模式：On Stream, 流传输模式：Burst （突发间隔单位：MS, 突发次数：3, 突发间隔：4, 突发数量：10）\n        edit_port_load_profile(Ports=Ports[5],\n                               LoadProfileType='PORT_BASE',\n                               Rate=40,\n                               Unit='DATABIT_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[5], FixedLength=256)\n        edit_stream_load_profile(Streams=stream, StreamTransmitMode='BURST', BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "add_stream:测试仪表创建流量"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the testing instrument for product 'BigTao' using init_tester API.\",\n  \"Subtask 2\": \"Reserve 6 offline ports at specified locations using reserve_port API with Debug=True.\",\n  \"Subtask 3\": \"Configure port 1 load profile: set LoadProfileType='PORT_BASE', TransmitMode='CONTINUOUS', Rate=15, Unit='PERCENT' using edit_port_load_profile.\",\n  \"Subtask 4\": \"Configure port 2 load profile: set LoadProfileType='PORT_BASE', TransmitMode='BURST', Rate=20, Unit='NS' with BurstSize=15, InterFrameGap=2, InterFrameGapUnit='MS', BurstCount=10 using edit_port_load_profile.\",\n  \"Subtask 5\": \"Configure port 3 load profile: set LoadProfileType='PORT_BASE', TransmitMode='TIME', Rate=25, Unit='INTER_FRAME_GAP_BYTE' with Seconds=15 using edit_port_load_profile.\",\n  \"Subtask 6\": \"Configure port 4 load profile: set LoadProfileType='PORT_BASE', TransmitMode='STEP', Rate=30, Unit='FRAME_PER_SEC' with Frames=20 using edit_port_load_profile.\",\n  \"Subtask 7\": \"Configure port 5 load profile: set LoadProfileType='PORT_BASE', TransmitMode='ONSTREAM', Rate=35, Unit='BYTE_PER_SEC' using edit_port_load_profile. Then create stream with add_stream and set StreamTransmitMode='CONTINUOUS' using edit_stream_load_profile.\",\n  \"Subtask 8\": \"Configure port 6 load profile: set LoadProfileType='PORT_BASE', TransmitMode='ONSTREAM', Rate=40, Unit='DATABIT_PER_SEC' using edit_port_load_profile. Then create stream with add_stream and set StreamTransmitMode='BURST' with BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10 using edit_stream_load_profile.\",\n  \"Subtask 9\": \"Save the configuration to specified file path using save_case API.\",\n  \"Subtask 10\": \"Verify all port load configurations were applied successfully by confirming no exceptions occurred during configuration steps and final verdict is 'pass'.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    : Check that the load mode of the testing instrument is set to Base On Port and the load configuration is set successfully.\n\nStep         : Step 1: Reserve 6 offline ports;\n              Step 2: Set the port load mode to Base On Port and configure all type parameters of the load configuration;\n\nCriteria     : Expected Result 1: In Step 2, the port load configuration is set successfully;\n\nCreated by   : Tester-001\n\nBugs         :\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\n\nProduct = 'BigTao'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n    '//10.0.11.191/1/5',\n    '//10.0.11.191/1/6',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'bigtao':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Port, （端口负载：15, 负载单位：Percent(%)） 传输模式：Continuous,\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='PORT_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=15,\n                               Unit='PERCENT')\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Port （端口负载：20, 负载单位：Inter Frame Gap(ns)）, 传输模式：Burst, （突发报文数：15, 突发间隔：2, 突发间隔单位: ms , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='PORT_BASE',\n                               Rate=20,\n                               Unit='NS',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=2,\n                               InterFrameGapUnit='MS',\n                               BurstCount=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Port, （端口负载：25, 负载单位：Inter Frame Gap(byte)） 传输模式：Time, （发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='PORT_BASE',\n                               Rate=25,\n                               Unit='INTER_FRAME_GAP_BYTE',\n                               TransmitMode=\"TIME\",\n                               Seconds=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Port, （端口负载：30, 负载单位：Frames per Second） 传输模式：Step, （发送帧数：20）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='PORT_BASE',\n                               Rate=30,\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               Frames=20)\n\n        # =============== *设置模式5* ===============\n        # 负载模式：Base On Port, （端口负载：35, 负载单位：Byte per Second） 传输模式：On Stream, 流传输模式：Continuous\n        edit_port_load_profile(Ports=Ports[4],\n                               LoadProfileType='PORT_BASE',\n                               Rate=35,\n                               Unit='BYTE_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[4], FixedLength=256)\n        edit_stream_load_profile(Streams=stream, StreamTransmitMode='CONTINUOUS')\n\n        # =============== *设置模式6* ===============\n        # 负载模式：Base On Port, （端口负载：40, 负载单位：Data Bits per Second） 传输模式：On Stream, 流传输模式：Burst （突发间隔单位：MS, 突发次数：3, 突发间隔：4, 突发数量：10）\n        edit_port_load_profile(Ports=Ports[5],\n                               LoadProfileType='PORT_BASE',\n                               Rate=40,\n                               Unit='DATABIT_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[5], FixedLength=256)\n        edit_stream_load_profile(Streams=stream, StreamTransmitMode='BURST', BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nadd_stream:测试仪表创建流量\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/Ripv1.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发Ripv1报文统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 修改流量StreamTemplate_1的Ripv1头部内容;;\n                   测试步骤3: 配置过滤抓包;\n                   测试步骤4: 订阅StreamBlockStats统计;;\n                   测试步骤5: 设置端口发送模式为突发包;\n                   测试步骤6: 发送所有流量，等待一段时间;\n                   测试步骤7: 停止所有流量，查看StreamBlockStats统计信息;;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: Verify that the test instrument correctly counts RIP version 1 packets sent.\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Modify the RIP version 1 header content of traffic stream StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set the port transmission mode to burst packets;\nTest Step 6: Send all traffic and wait for a period of time;\nTest Step 7: Stop all traffic and view the StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, the sent and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-001\n\nBugs: None",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripv1']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripv1(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripv1', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripv1_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripv1_entry(Stream=stream, Level=0, Index=0, Ipaddr='192.168.0.11', Afi=1, Reserved=1, Reserved1=1, Reserved2=1, Metric=1)\n    edit_header_ripv1_entry(Stream=stream, Level=0, Index=1, Ipaddr='192.168.0.12', Afi=2, Reserved=2, Reserved1=2, Reserved2=2, Metric=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for product 'DarYu'.\",\n  \"Subtask 2\": \"Reserve two ports using specified locations for Port_1 and Port_2.\",\n  \"Subtask 3\": \"Create a traffic stream on Port_1 with fixed length 256 bytes.\",\n  \"Subtask 4\": \"Configure stream headers: EthernetII, IPv4, and Ripv1.\",\n  \"Subtask 5\": \"Edit Ripv1 header at level 0: set Command=2, Version=1, Reserved=2.\",\n  \"Subtask 6\": \"Apply increment modifier to Ripv1 Reserved field with count=3.\",\n  \"Subtask 7\": \"Insert two Ripv1 entries into the stream.\",\n  \"Subtask 8\": \"Edit first Ripv1 entry (index 0): set IP=192.168.0.11, Afi=1, Metric=1.\",\n  \"Subtask 9\": \"Edit second Ripv1 entry (index 1): set IP=192.168.0.12, Afi=2, Metric=2.\",\n  \"Subtask 10\": \"Create first PDU capture pattern on Port_2: match Ripv1 Reserved field between 1-2.\",\n  \"Subtask 11\": \"Create second PDU capture pattern on Port_2: match Ripv1 Version field fixed at 1.\",\n  \"Subtask 12\": \"Configure capture filter on Port_2 using logical AND of both PDU patterns.\",\n  \"Subtask 13\": \"Subscribe to StreamBlockStats statistics view.\",\n  \"Subtask 14\": \"Set Port_1 transmission mode to burst with burst count=100.\",\n  \"Subtask 15\": \"Save test configuration to specified file path.\",\n  \"Subtask 16\": \"Start packet capture on Port_2.\",\n  \"Subtask 17\": \"Start traffic transmission from Port_1.\",\n  \"Subtask 18\": \"Wait 10 seconds during traffic transmission and capture.\",\n  \"Subtask 19\": \"Stop traffic transmission.\",\n  \"Subtask 20\": \"Stop packet capture.\",\n  \"Subtask 21\": \"Wait 3 seconds for capture processing.\",\n  \"Subtask 22\": \"Download captured packets from Port_2 to local storage.\",\n  \"Subtask 23\": \"Retrieve StreamBlockStats for the traffic stream.\",\n  \"Subtask 24\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames).\",\n  \"Subtask 25\": \"Release reserved ports.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: Verify that the test instrument correctly counts RIP version 1 packets sent.\n\nStep: Test Step 1: Reserve two loopback ports, Port_1 and Port_2;\nTest Step 2: Modify the RIP version 1 header content of traffic stream StreamTemplate_1;\nTest Step 3: Configure filtered packet capture;\nTest Step 4: Subscribe to StreamBlockStats statistics;\nTest Step 5: Set the port transmission mode to burst packets;\nTest Step 6: Send all traffic and wait for a period of time;\nTest Step 7: Stop all traffic and view the StreamBlockStats statistics;\n\nCriteria: Expected Result 1: In step 6, the sent and received packets for traffic stream StreamTemplate_1 are equal;\n\nCreated by: Tester-001\n\nBugs: None\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations)\n    # 创建流量\n    stream = add_stream(Ports=Ports[0], FixedLength=256)\n    # 修改流量报文头部\n    HeaderTypes = ['EthernetII', 'IPv4', 'Ripv1']\n    create_stream_header(Stream=stream, HeaderTypes=HeaderTypes)\n    # 修改ripng头部\n    header_dict = edit_header_ripv1(Stream=stream, Level=0, Command=2, Version=1, Reserved=2)\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='Ripv1', Attribute=header_dict['Reserved'],\n                  Type='Increment', Count=3)\n    # 插入entry\n    insert_ripv1_entries(Stream=stream, Level=0, Count=2)\n\n    # 修改entry\n    edit_header_ripv1_entry(Stream=stream, Level=0, Index=0, Ipaddr='192.168.0.11', Afi=1, Reserved=1, Reserved1=1, Reserved2=1, Metric=1)\n    edit_header_ripv1_entry(Stream=stream, Level=0, Index=1, Ipaddr='192.168.0.12', Afi=2, Reserved=2, Reserved1=2, Reserved2=2, Metric=2)\n\n    # 配置过滤抓包\n    pdu_pattern_1 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Reserved'],\n                                               Value='1', MaxValue='2')\n    pdu_pattern_2 = create_capture_pdu_pattern(Port=Ports[1], HeaderTypes=HeaderTypes,\n                                               Level=2,\n                                               Attribute=header_dict['Version'],\n                                               Value='1', MaxValue='1')\n    edit_capture_filter(Port=Ports[1], Expression=f'{pdu_pattern_1} && {pdu_pattern_2}')\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n    # 设置端口发送模式为突发包\n    edit_port_load_profile(Ports=Ports[0], TransmitMode='BURST', BurstCount='100')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n    time.sleep(10)\n    stop_stream()\n    stop_capture()\n    time.sleep(3)\n    # 下载捕获到的报文\n    packages_path = download_packages(Port=Ports[1], FileDir=f'{dirname}/pcap', FileName=filename, MaxCount=100)\n    print(f'packages_path: {packages_path}')\n    # 获取流量StreamBlockStats，并判断流量收发是否正确\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n    assert TxStreamFrames == RxStreamFrames\n    # 释放端口资源\n    result = release_port(Locations=locations)\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_6/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.6 地址缓存能力\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2889 中规定，将交换机三个端口与测试仪连接，分别为端口 1（测试端口），端口 2（学习端口），端口 3（监视端口），见图 5；\n                   测试步骤2: 测试方法采用 RFC2889 标准测试方法。\n\n Criteria    \t:   预期结果1: 技术要求二层交换机不低于 4k；三层交换机不低于 16k。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective\t:   Objective: 6.4.6 Address Caching Capability\n\nStep\t\t\t:\tTest Step 1: According to RFC 2889, connect three ports of the switch to the tester, designated as Port 1 (test port), Port 2 (learning port), and Port 3 (monitoring port), as illustrated in Figure 5;\n                Test Step 2: The test method employs the RFC 2889 standard test procedure.\n\nCriteria    \t:   Expected Result 1: Technical requirements specify Layer 2 switches must support at least 4k entries, while Layer 3 switches must support at least 16k entries.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressCachingCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    # 提供学习的地址数和地址学习速率\n    edit_benchmark_address_learning_capacity(Config=Config,\n                                             MinAddressCount=cfg['arg']['learning_capacity']['default']['min_address_count']['default'],\n                                             MaxAddressCount=cfg['arg']['learning_capacity']['default']['max_address_count']['default'],\n                                             InitAddressCount=cfg['arg']['learning_capacity']['default']['init_address_count']['default'],\n                                             Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                             AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                             LearningRate=cfg['arg']['learning_capacity']['default']['learning_rate']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_address_learning_capacity:编辑RFC2889测试套件地址容量测试项参数",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester API based on provided RTSM IP or default settings.\",\n  \"Subtask 2\": \"Reserve three ports (Port1 as test port, Port2 as learning port, Port3 as monitoring port) using reserve_port API with specified locations.\",\n  \"Subtask 3\": \"Configure port parameters using edit_port API if not in debug mode, including force settings and wait for port status using wait_port_state API.\",\n  \"Subtask 4\": \"Create RFC2889 benchmark for addressCachingCapacity test item using create_benchmark API.\",\n  \"Subtask 5\": \"Assign reserved ports to benchmark roles (test port, learning port, monitoring port) using relate_benchmark_ports API.\",\n  \"Subtask 6\": \"Create Ethernet interfaces on test port and learning port using create_interface API.\",\n  \"Subtask 7\": \"Configure MAC addresses for created interfaces using edit_interface API with addresses from configuration.\",\n  \"Subtask 8\": \"Retrieve Ethernet layer objects from interfaces using get_layer_from_interfaces API for stream creation.\",\n  \"Subtask 9\": \"Create unidirectional traffic streams from test port to learning port with monitoring port using create_benchmark_streams API.\",\n  \"Subtask 10\": \"Configure latency settings (FIFO type, delay before/after) using edit_benchmark_latency API.\",\n  \"Subtask 11\": \"Set test duration parameters (number of trials) using edit_benchmark_duration API.\",\n  \"Subtask 12\": \"Configure custom frame size using edit_benchmark_frame API.\",\n  \"Subtask 13\": \"Configure address learning parameters (min/max/init address count, resolution, aging time, learning rate) using edit_benchmark_address_learning_capacity API.\",\n  \"Subtask 14\": \"Generate test script using expand_benchmark API.\",\n  \"Subtask 15\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 16\": \"Execute benchmark test using run_benchmark API with analyzer setting and timeout.\",\n  \"Subtask 17\": \"Retrieve and format test results using get_benchmark_result API.\",\n  \"Subtask 18\": \"Verify address caching capacity meets requirements: ≥4k entries for L2 switches or ≥16k entries for L3 switches.\",\n  \"Subtask 19\": \"Release reserved ports using release_port API.\",\n  \"Subtask 20\": \"Shutdown tester processes and perform cleanup using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective\t:   Objective: 6.4.6 Address Caching Capability\n\nStep\t\t\t:\tTest Step 1: According to RFC 2889, connect three ports of the switch to the tester, designated as Port 1 (test port), Port 2 (learning port), and Port 3 (monitoring port), as illustrated in Figure 5;\n                Test Step 2: The test method employs the RFC 2889 standard test procedure.\n\nCriteria    \t:   Expected Result 1: Technical requirements specify Layer 2 switches must support at least 4k entries, while Layer 3 switches must support at least 16k entries.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressCachingCapacity'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    # 提供学习的地址数和地址学习速率\n    edit_benchmark_address_learning_capacity(Config=Config,\n                                             MinAddressCount=cfg['arg']['learning_capacity']['default']['min_address_count']['default'],\n                                             MaxAddressCount=cfg['arg']['learning_capacity']['default']['max_address_count']['default'],\n                                             InitAddressCount=cfg['arg']['learning_capacity']['default']['init_address_count']['default'],\n                                             Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                             AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                             LearningRate=cfg['arg']['learning_capacity']['default']['learning_rate']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_address_learning_capacity:编辑RFC2889测试套件地址容量测试项参数;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_9/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.5.9 生成树协议\n\n Step\t\t\t:\t测试步骤1: 将4台交换机按照图9连接，级联口均采用100M光口；\n                   测试步骤2: 整个组网设备间运行标准生成树协议，配置各设备的生成树参数，\n                   测试步骤3: 观察设备能否根据配置的参数修剪环路，完成生成树\n                   测试步骤4: 阻断开设备目前的生成树链路，观察设备是否可自动完成网络拓扑重构；\n                   测试步骤5: 启用所有交换机的RSTP功能\n                   测试步骤6: 将交换机如图9连接；\n                   测试步骤7: 用SmartBits 在任意两台交换机之间加载95Mbps数据流量；\n                   测试步骤8: 拔插环网中的任一链路，查看网络是否可以正常收敛\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: 6.5.9 Spanning Tree Protocol\n\nStep\t\t\t:\tTest Step 1: Connect four switches as shown in Figure 9, using 100M optical ports for all cascade interfaces;\n                   Test Step 2: Run the standard Spanning Tree Protocol among all networking devices, configuring spanning tree parameters for each device;\n                   Test Step 3: Observe whether devices can prune loops according to configured parameters and complete spanning tree formation;\n                   Test Step 4: Block the current spanning tree link and observe whether devices automatically reconstruct the network topology;\n                   Test Step 5: Enable RSTP functionality on all switches;\n                   Test Step 6: Connect the switches as shown in Figure 9;\n                   Test Step 7: Use SmartBits to load 95Mbps data traffic between any two switches;\n                   Test Step 8: Unplug and replug any link in the ring network, verifying whether normal network convergence occurs.\n\nCriteria    \t:   Expected Result 1:\n\nCreated by   \t:   Tester-006\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95,)\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插链路\n        time.sleep(30)\n\n        # 查看收敛时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxFCSErr = Result['RxFCSErr']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=True)\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Connect four switches in a ring topology using 100M optical ports for all inter-switch links as specified in Figure 9.\",\n  \"Subtask 2\": \"Configure standard Spanning Tree Protocol (STP) parameters on all switches, including bridge priority, port costs, and STP timers.\",\n  \"Subtask 3\": \"Verify STP convergence by checking that switches successfully prune loops and establish a loop-free topology with designated root/blocked ports.\",\n  \"Subtask 4\": \"Manually block the current active STP forwarding link by disabling the corresponding switch port.\",\n  \"Subtask 5\": \"Observe and validate that switches automatically reconverge the topology by activating alternate paths within STP timers.\",\n  \"Subtask 6\": \"Enable Rapid Spanning Tree Protocol (RSTP) on all switches and ensure configuration consistency across devices.\",\n  \"Subtask 7\": \"Configure tester ports to generate 95Mbps bidirectional traffic between two switches using SmartBits, setting frame size to 64 bytes and continuous transmission mode.\",\n  \"Subtask 8\": \"Start traffic transmission and monitor baseline traffic statistics for stability before topology change.\",\n  \"Subtask 9\": \"Physically disconnect and reconnect a ring network link while traffic is running to simulate topology change.\",\n  \"Subtask 10\": \"Measure network convergence time by monitoring traffic interruption duration during link disruption using StreamBlock statistics.\",\n  \"Subtask 11\": \"Verify successful RSTP reconvergence by confirming traffic resumes to baseline levels (Tx/Rx frame counts match) after link restoration.\",\n  \"Subtask 12\": \"Validate no frame errors (e.g., RxFCSErr) occurred during convergence event to confirm data integrity.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: 6.5.9 Spanning Tree Protocol\n\nStep\t\t\t:\tTest Step 1: Connect four switches as shown in Figure 9, using 100M optical ports for all cascade interfaces;\n                   Test Step 2: Run the standard Spanning Tree Protocol among all networking devices, configuring spanning tree parameters for each device;\n                   Test Step 3: Observe whether devices can prune loops according to configured parameters and complete spanning tree formation;\n                   Test Step 4: Block the current spanning tree link and observe whether devices automatically reconstruct the network topology;\n                   Test Step 5: Enable RSTP functionality on all switches;\n                   Test Step 6: Connect the switches as shown in Figure 9;\n                   Test Step 7: Use SmartBits to load 95Mbps data traffic between any two switches;\n                   Test Step 8: Unplug and replug any link in the ring network, verifying whether normal network convergence occurs.\n\nCriteria    \t:   Expected Result 1:\n\nCreated by   \t:   Tester-006\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95,)\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插链路\n        time.sleep(30)\n\n        # 查看收敛时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxFCSErr = Result['RxFCSErr']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=4, result=True)\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_7/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.7 地址学习速率\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2889 中规定，将交换机三个端口与测试仪连接，分别为端口 1（测试端口），端口 2（学习端口），端口 3（监视端口），见图 5；\n                   测试步骤2: 测试方法采用 RFC2889 标准测试方法。\n\n Criteria    \t:   预期结果1: 技术要求应不低于 1000 帧/s。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   6.4.7 Address Learning Rate\n\nStep\t\t\t:\tStep 1: According to RFC 2889, connect three ports of the switch to the tester: Port 1 (test port), Port 2 (learning port), Port 3 (monitor port), as shown in Figure 5;\n                    Step 2: The test method adopts the standard test method of RFC 2889.\n\nCriteria    \t:   Expected Result 1: The technical requirement shall be no less than 1000 frames/s.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressLearningRate'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n\n    # 地址学习速率和地址数量\n    edit_benchmark_address_learning_rate(Config=Config,\n                                         MinRateCount=cfg['arg']['learning_capacity']['default']['min_rate_count']['default'],\n                                         MaxRateCount=cfg['arg']['learning_capacity']['default']['max_rate_count']['default'],\n                                         InitRateCount=cfg['arg']['learning_capacity']['default']['init_rate_count']['default'],\n                                         Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                         AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                         AddressCount=cfg['arg']['learning_capacity']['default']['address_count']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_address_learning_rate:编辑RFC2889测试套件地址容量测试项参数",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester using init_tester API, using RTSM IP if provided in testbed configuration.\",\n  \"Subtask 2\": \"Reserve three test ports (Port 1 as test port, Port 2 as learning port, Port 3 as monitor port) using reserve_port API with locations from configuration.\",\n  \"Subtask 3\": \"Edit port parameters using edit_port API according to testbed configuration and wait for port status using wait_port_state if required.\",\n  \"Subtask 4\": \"Create RFC2889 benchmark for addressLearningRate test item using create_benchmark API.\",\n  \"Subtask 5\": \"Assign reserved ports to benchmark roles (test port, learning port, monitor port) using relate_benchmark_ports API.\",\n  \"Subtask 6\": \"Create Ethernet interfaces on test port and learning port using create_interface API.\",\n  \"Subtask 7\": \"Configure MAC addresses for both interfaces using edit_interface API with addresses from configuration.\",\n  \"Subtask 8\": \"Retrieve Ethernet layer objects from interfaces using get_layer_from_interfaces API.\",\n  \"Subtask 9\": \"Create benchmark traffic streams between test port and learning port using create_benchmark_streams API, specifying monitor port and unidirectional traffic.\",\n  \"Subtask 10\": \"Configure latency settings (FIFO mode, 2s delay before, 10s delay after) using edit_benchmark_latency API.\",\n  \"Subtask 11\": \"Set test duration to 1 trial using edit_benchmark_duration API.\",\n  \"Subtask 12\": \"Configure custom frame size using edit_benchmark_frame API as specified in configuration.\",\n  \"Subtask 13\": \"Configure address learning rate parameters (min/max/init rate count, resolution, aging time, address count) using edit_benchmark_address_learning_rate API with values from configuration.\",\n  \"Subtask 14\": \"Generate test script by expanding benchmark configuration using expand_benchmark API.\",\n  \"Subtask 15\": \"Save test configuration to file using save_case API.\",\n  \"Subtask 16\": \"Execute benchmark test using run_benchmark API with 3600s timeout.\",\n  \"Subtask 17\": \"Retrieve test results in dataframe format using get_benchmark_result API for RFC2889 test type.\",\n  \"Subtask 18\": \"Verify address learning rate result meets criterion: no less than 1000 frames/s.\",\n  \"Subtask 19\": \"Release all reserved ports using release_port API.\",\n  \"Subtask 20\": \"Shutdown tester using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   6.4.7 Address Learning Rate\n\nStep\t\t\t:\tStep 1: According to RFC 2889, connect three ports of the switch to the tester: Port 1 (test port), Port 2 (learning port), Port 3 (monitor port), as shown in Figure 5;\n                    Step 2: The test method adopts the standard test method of RFC 2889.\n\nCriteria    \t:   Expected Result 1: The technical requirement shall be no less than 1000 frames/s.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down, port_monitor = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['addressLearningRate'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down, port_monitor])\n\n    # =============== *配置端点* ===============\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2, Monitors=port_monitor, Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n\n    # =============== *地址缓存容量参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n\n    # 地址学习速率和地址数量\n    edit_benchmark_address_learning_rate(Config=Config,\n                                         MinRateCount=cfg['arg']['learning_capacity']['default']['min_rate_count']['default'],\n                                         MaxRateCount=cfg['arg']['learning_capacity']['default']['max_rate_count']['default'],\n                                         InitRateCount=cfg['arg']['learning_capacity']['default']['init_rate_count']['default'],\n                                         Resolution=cfg['arg']['learning_capacity']['default']['resolution']['default'],\n                                         AgingTime=cfg['arg']['learning_capacity']['default']['aging_time']['default'],\n                                         AddressCount=cfg['arg']['learning_capacity']['default']['address_count']['default'])\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2889', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_address_learning_rate:编辑RFC2889测试套件地址容量测试项参数;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/LoadProfile/EditLoadProfile_BaseOnStream_BigTao.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表负载模式为Base On Stream负载配置设置成功\n\n Step\t\t\t:\t测试步骤1: 预约6个离线端口;\n                   测试步骤2: 设置端口负载模式：Base On Stream,并设置负载配置各个类型参数;\n\n Criteria    \t:   预期结果1: 步骤2中端口负载配置设置成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    :   To verify that the test instrument's load mode is successfully configured as Base On Stream load configuration\n\nStep         :   Test Step 1: Reserve 6 offline ports;\n                 Test Step 2: Set port load mode to Base On Stream and configure all parameter types for the load configuration;\n\nCriteria     :   Expected Result 1: The port load configuration in Step 2 is successfully set;\n\nCreated by   :   Tester-001\n\nBugs         :\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\n\nProduct = 'BigTao'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n    '//10.0.11.191/1/5',\n    '//10.0.11.191/1/6',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'bigtao':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Continuous,\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               LoadMode='FRAME_PER_SEC')\n        # 创建流量\n        stream = add_stream(Ports=Ports[0], FixedLength=256)\n        # 负载单位：Percent(%) 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='PERCENT', Rate=5)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Stream （调速模式：Byte per Second）, 传输模式：Burst, （突发报文数：15, 突发间隔：2, 突发间隔单位: ms , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='BYTE_PER_SEC',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=2,\n                               InterFrameGapUnit='MS',\n                               BurstCount=10)\n        # 创建流量\n        stream = add_stream(Ports=Ports[1], FixedLength=256)\n        # 负载单位：Frames per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='FRAME_PER_SEC', Rate=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Time, （发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"TIME\",\n                               Seconds=99)\n        # 创建流量\n        stream = add_stream(Ports=Ports[2], FixedLength=256)\n        # 负载单位：Byte per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='BYTE_PER_SEC', Rate=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Step, （发送帧数：15）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               Frames=110)\n        # 创建流量\n        stream = add_stream(Ports=Ports[3], FixedLength=256)\n        # 负载单位：Line Bits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='LINEBIT_PER_SEC', Rate=20)\n\n        # =============== *设置模式5* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：On Stream, 流传输模式：Continuous\n        edit_port_load_profile(Ports=Ports[4],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[4], FixedLength=256)\n        # 负载单位：Line KBits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='KLINEBIT_PER_SEC', Rate=25)\n\n        # =============== *设置模式6* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：On Stream, 流传输模式：Burst （突发间隔单位：MS, 突发次数：3, 突发间隔：4, 突发数量：10）\n        edit_port_load_profile(Ports=Ports[5],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[5], FixedLength=256)\n        # 负载单位：Line KBits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='MLINEBIT_PER_SEC', Rate=30, StreamTransmitMode='BURST', BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "add_stream:测试仪表创建流量"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester for product 'BigTao' using init_tester API.\",\n  \"Subtask 2\": \"Reserve 6 ports at specified locations using reserve_port API with Debug mode enabled.\",\n  \"Subtask 3\": \"Configure port 1: Set load profile to STREAM_BASE with TransmitMode=CONTINUOUS and LoadMode=FRAME_PER_SEC using edit_port_load_profile API.\",\n  \"Subtask 4\": \"Create a stream on port 1 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 5\": \"Configure stream on port 1: Set load unit to PERCENT with rate 5 using edit_stream_load_profile API.\",\n  \"Subtask 6\": \"Configure port 2: Set load profile to STREAM_BASE with LoadMode=BYTE_PER_SEC, TransmitMode=BURST, BurstSize=15, InterFrameGap=2ms, and BurstCount=10 using edit_port_load_profile API.\",\n  \"Subtask 7\": \"Create a stream on port 2 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 8\": \"Configure stream on port 2: Set load unit to FRAME_PER_SEC with rate 10 using edit_stream_load_profile API.\",\n  \"Subtask 9\": \"Configure port 3: Set load profile to STREAM_BASE with LoadMode=FRAME_PER_SEC, TransmitMode=TIME, and Duration=99 seconds using edit_port_load_profile API.\",\n  \"Subtask 10\": \"Create a stream on port 3 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 11\": \"Configure stream on port 3: Set load unit to BYTE_PER_SEC with rate 15 using edit_stream_load_profile API.\",\n  \"Subtask 12\": \"Configure port 4: Set load profile to STREAM_BASE with LoadMode=FRAME_PER_SEC, TransmitMode=STEP, and Frames=110 using edit_port_load_profile API.\",\n  \"Subtask 13\": \"Create a stream on port 4 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 14\": \"Configure stream on port 4: Set load unit to LINEBIT_PER_SEC with rate 20 using edit_stream_load_profile API.\",\n  \"Subtask 15\": \"Configure port 5: Set load profile to STREAM_BASE with LoadMode=FRAME_PER_SEC and TransmitMode=ONSTREAM using edit_port_load_profile API.\",\n  \"Subtask 16\": \"Create a stream on port 5 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 17\": \"Configure stream on port 5: Set load unit to KLINEBIT_PER_SEC with rate 25 using edit_stream_load_profile API.\",\n  \"Subtask 18\": \"Configure port 6: Set load profile to STREAM_BASE with LoadMode=FRAME_PER_SEC and TransmitMode=ONSTREAM using edit_port_load_profile API.\",\n  \"Subtask 19\": \"Create a stream on port 6 with fixed length 256 bytes using add_stream API.\",\n  \"Subtask 20\": \"Configure stream on port 6: Set load unit to MLINEBIT_PER_SEC with rate 30, StreamTransmitMode=BURST, BurstGap=4ms, BurstCount=3, and FramePerBurst=10 using edit_stream_load_profile API.\",\n  \"Subtask 21\": \"Save the test configuration to file using save_case API.\",\n  \"Subtask 22\": \"Verify all port load configurations completed successfully by checking for absence of runtime exceptions.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    :   To verify that the test instrument's load mode is successfully configured as Base On Stream load configuration\n\nStep         :   Test Step 1: Reserve 6 offline ports;\n                 Test Step 2: Set port load mode to Base On Stream and configure all parameter types for the load configuration;\n\nCriteria     :   Expected Result 1: The port load configuration in Step 2 is successfully set;\n\nCreated by   :   Tester-001\n\nBugs         :\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\n\nProduct = 'BigTao'\nlocations = [\n    '//10.0.11.191/1/1',\n    '//10.0.11.191/1/2',\n    '//10.0.11.191/1/3',\n    '//10.0.11.191/1/4',\n    '//10.0.11.191/1/5',\n    '//10.0.11.191/1/6',\n]\nverdict = 'pass'\nerrInfo = ''\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n    # 创建端口，并预约端口\n    Ports = reserve_port(Locations=locations, Debug=True)\n    if Product.lower() == 'bigtao':\n\n        # =============== *设置模式1* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Continuous,\n        edit_port_load_profile(Ports=Ports[0],\n                               LoadProfileType='STREAM_BASE',\n                               TransmitMode=\"CONTINUOUS\",\n                               LoadMode='FRAME_PER_SEC')\n        # 创建流量\n        stream = add_stream(Ports=Ports[0], FixedLength=256)\n        # 负载单位：Percent(%) 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='PERCENT', Rate=5)\n\n        # =============== *设置模式2* ===============\n        # 负载模式：Base On Stream （调速模式：Byte per Second）, 传输模式：Burst, （突发报文数：15, 突发间隔：2, 突发间隔单位: ms , 突发次数: 10）\n        edit_port_load_profile(Ports=Ports[1],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='BYTE_PER_SEC',\n                               TransmitMode=\"BURST\",\n                               BurstSize=15,\n                               InterFrameGap=2,\n                               InterFrameGapUnit='MS',\n                               BurstCount=10)\n        # 创建流量\n        stream = add_stream(Ports=Ports[1], FixedLength=256)\n        # 负载单位：Frames per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='FRAME_PER_SEC', Rate=10)\n\n        # =============== *设置模式3* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Time, （发送时间：15）\n        edit_port_load_profile(Ports=Ports[2],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"TIME\",\n                               Seconds=99)\n        # 创建流量\n        stream = add_stream(Ports=Ports[2], FixedLength=256)\n        # 负载单位：Byte per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='BYTE_PER_SEC', Rate=15)\n\n        # =============== *设置模式4* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：Step, （发送帧数：15）\n        edit_port_load_profile(Ports=Ports[3],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"STEP\",\n                               Frames=110)\n        # 创建流量\n        stream = add_stream(Ports=Ports[3], FixedLength=256)\n        # 负载单位：Line Bits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='LINEBIT_PER_SEC', Rate=20)\n\n        # =============== *设置模式5* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：On Stream, 流传输模式：Continuous\n        edit_port_load_profile(Ports=Ports[4],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[4], FixedLength=256)\n        # 负载单位：Line KBits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='KLINEBIT_PER_SEC', Rate=25)\n\n        # =============== *设置模式6* ===============\n        # 负载模式：Base On Stream, （调速模式：Frames per Second） 传输模式：On Stream, 流传输模式：Burst （突发间隔单位：MS, 突发次数：3, 突发间隔：4, 突发数量：10）\n        edit_port_load_profile(Ports=Ports[5],\n                               LoadProfileType='STREAM_BASE',\n                               LoadMode='FRAME_PER_SEC',\n                               TransmitMode=\"ONSTREAM\")\n        # 创建流量\n        stream = add_stream(Ports=Ports[5], FixedLength=256)\n        # 负载单位：Line KBits per Second 速率：5\n        edit_stream_load_profile(Streams=stream, Unit='MLINEBIT_PER_SEC', Rate=30, StreamTransmitMode='BURST', BurstGapUnit='MS', BurstCount=3, BurstGap=4, FramePerBurst=10)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nadd_stream:测试仪表创建流量\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_6/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.6 IGMP-Snooping 组播: 二层交换机应支持 IGMP-Snooping 组播功能\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示，交换机端口为同一VLAN 内的UNTAGGED 端口；\n                   测试步骤2: 端口1 向端口2 发送1 个组的组播流量\n                   测试步骤3: 在被测交换机上禁用IGMP Snooping 功能，观察端口2 流量接收情况；\n                   测试步骤4: 在被测交换机上启用IGMP Snooping 功能，观察端口2 流量接收情况；\n                   测试步骤5: 端口2 使用IGMP 协议V2 加入组播组，观察端口2 流量接收情况；\n                   测试步骤6: 端口2 发送离开组请求，观察端口2 流量接收情况。\n\n Criteria    \t:   预期结果1: 步骤2）在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量；\n                   预期结果2: 步骤3）在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量；\n                   预期结果3: 步骤4）端口2 发送组加入请求后，可接收组播流量；\n                   预期结果4: 步骤5）端口2 发送离开组请求后，不能接收组播流量。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "Objective: 6.5.6 IGMP-Snooping Multicast: The Layer 2 switch should support IGMP-Snooping multicast function.\n\nStep 1: Connect the traffic generator to the switch as shown in Figure 4, with switch ports configured as UNTAGGED ports within the same VLAN.\nStep 2: Port 1 sends multicast traffic for one group to Port 2.\nStep 3: Disable IGMP Snooping function on the switch under test, and observe traffic reception on Port 2.\nStep 4: Enable IGMP Snooping function on the switch under test, and observe traffic reception on Port 2.\nStep 5: Port 2 joins the multicast group using IGMP protocol V2, and observe traffic reception on Port 2.\nStep 6: Port 2 sends a leave group request, and observe traffic reception on Port 2.\n\nCriterion 1: In step 2), when IGMP Snooping is disabled on the switch under test, all ports should receive multicast traffic.\nCriterion 2: In step 3), when IGMP Snooping is enabled on the switch under test, non-multicast client ports should not receive multicast traffic.\nCriterion 3: In step 4), after Port 2 sends a join group request, it should receive multicast traffic.\nCriterion 4: In step 5), after Port 2 sends a leave group request, it should not receive multicast traffic.\n\nCreated by: Tester-008\n\nTags: function",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port_1, port_2 = ports\n    # 创建接口\n    interface_1 = create_interface(Port=port_1,Layers=['eth', 'ipv4'])\n    interface_2 = create_interface(Port=port_2,Layers=['eth', 'ipv4'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_2, Version='IGMPV2')\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interface_2)\n\n    # 创建全局组播组\n    multicast_group = create_multicast_group(Start='225.0.1.2',Count=1)\n\n    # 创建组播协议和组播组绑定关系对象\n    memberships = create_memberships(Session=igmp)\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP绑定流\n    src_point = get_layer_from_interfaces(Interfaces=interface_1)\n\n    stream = add_stream(Type='binding', SrcPoints=src_point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        # 获取流量统计结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'RxLossStreamFrames',\n                                                                    'RealtimeLossRate'])\n        if  Result['RxStreamFrames'] > 0  and Result['RxLossStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，没有所有端口都接收到组播流量', step=5, result=False)\n\n        # 被测设备使能igmp snooping\n        cmd_cfg = '_'.join('DeviceA_Step3'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        # 清空统计计数\n        clear_result()\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        printf(message='step3：端口1向端口2发送1个组的组播流量, 在被测交换机上启用IGMP Snooping 功能')\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=False)\n\n        igmp_send_report(Sessions=igmp)\n        time.sleep(3)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=False)\n\n        igmp_send_leave(Sessions=igmp)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if Result['TxStreamFrames'] != Result['RxStreamFrames'] and Result['RxStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "create_igmp:创建IGMP协议会话对象",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize tester and reserve ports using init_tester and reserve_port APIs based on testbed configuration.\",\n  \"Subtask 2\": \"Configure switch ports as UNTAGGED in the same VLAN per test topology (DUT configuration step).\",\n  \"Subtask 3\": \"Create Ethernet and IPv4 interfaces on Port 1 and Port 2 using create_interface API.\",\n  \"Subtask 4\": \"Create IGMPv2 session on Port 2 using create_igmp API.\",\n  \"Subtask 5\": \"Bind IGMP session to Port 2 interface using select_interface API.\",\n  \"Subtask 6\": \"Create multicast group (start=225.0.1.2, count=1) using create_multicast_group API.\",\n  \"Subtask 7\": \"Create memberships object for IGMP session using create_memberships API.\",\n  \"Subtask 8\": \"Bind multicast group to IGMP session memberships using binding_multicast_group API.\",\n  \"Subtask 9\": \"Get layer objects from Port 1 interface using get_layer_from_interfaces API.\",\n  \"Subtask 10\": \"Create multicast traffic stream from Port 1 to multicast group using add_stream API.\",\n  \"Subtask 11\": \"Subscribe to StreamBlockStats view using subscribe_result API.\",\n  \"Subtask 12\": \"Disable IGMP Snooping on switch under test (DUT configuration step).\",\n  \"Subtask 13\": \"Clear statistics, start traffic stream for 10 seconds using start_stream, then stop stream using stop_stream.\",\n  \"Subtask 14\": \"Verify Port 2 receives multicast traffic (RxStreamFrames > 0 and RxLossStreamFrames = 0) using get_streamblock_statistic API.\",\n  \"Subtask 15\": \"Enable IGMP Snooping on switch under test (DUT configuration step).\",\n  \"Subtask 16\": \"Start IGMP protocol using start_protocol API and wait for stable state using wait_igmp_state API.\",\n  \"Subtask 17\": \"Clear statistics, start traffic stream for 10 seconds, then stop stream.\",\n  \"Subtask 18\": \"Verify Port 2 does not receive multicast traffic (RxStreamFrames = 0) using get_streamblock_statistic API.\",\n  \"Subtask 19\": \"Send IGMP join report from Port 2 using IGMP session.\",\n  \"Subtask 20\": \"Clear statistics, start traffic stream for 10 seconds, then stop stream.\",\n  \"Subtask 21\": \"Verify Port 2 receives multicast traffic (RxStreamFrames = TxStreamFrames) using get_streamblock_statistic API.\",\n  \"Subtask 22\": \"Send IGMP leave request from Port 2 using IGMP session.\",\n  \"Subtask 23\": \"Clear statistics, start traffic stream for 10 seconds, then stop stream.\",\n  \"Subtask 24\": \"Verify Port 2 does not receive multicast traffic (RxStreamFrames = 0) using get_streamblock_statistic API.\",\n  \"Subtask 25\": \"Release tester ports using release_port API and perform cleanup.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: 6.5.6 IGMP-Snooping Multicast: The Layer 2 switch should support IGMP-Snooping multicast function.\n\nStep 1: Connect the traffic generator to the switch as shown in Figure 4, with switch ports configured as UNTAGGED ports within the same VLAN.\nStep 2: Port 1 sends multicast traffic for one group to Port 2.\nStep 3: Disable IGMP Snooping function on the switch under test, and observe traffic reception on Port 2.\nStep 4: Enable IGMP Snooping function on the switch under test, and observe traffic reception on Port 2.\nStep 5: Port 2 joins the multicast group using IGMP protocol V2, and observe traffic reception on Port 2.\nStep 6: Port 2 sends a leave group request, and observe traffic reception on Port 2.\n\nCriterion 1: In step 2), when IGMP Snooping is disabled on the switch under test, all ports should receive multicast traffic.\nCriterion 2: In step 3), when IGMP Snooping is enabled on the switch under test, non-multicast client ports should not receive multicast traffic.\nCriterion 3: In step 4), after Port 2 sends a join group request, it should receive multicast traffic.\nCriterion 4: In step 5), after Port 2 sends a leave group request, it should not receive multicast traffic.\n\nCreated by: Tester-008\n\nTags: function\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port_1, port_2 = ports\n    # 创建接口\n    interface_1 = create_interface(Port=port_1,Layers=['eth', 'ipv4'])\n    interface_2 = create_interface(Port=port_2,Layers=['eth', 'ipv4'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_2, Version='IGMPV2')\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interface_2)\n\n    # 创建全局组播组\n    multicast_group = create_multicast_group(Start='225.0.1.2',Count=1)\n\n    # 创建组播协议和组播组绑定关系对象\n    memberships = create_memberships(Session=igmp)\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP绑定流\n    src_point = get_layer_from_interfaces(Interfaces=interface_1)\n\n    stream = add_stream(Type='binding', SrcPoints=src_point, DstPoints=multicast_group, Bidirection=False)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        # 获取流量统计结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'RxLossStreamFrames',\n                                                                    'RealtimeLossRate'])\n        if  Result['RxStreamFrames'] > 0  and Result['RxLossStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，所有端口应均可接收到组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上禁用IGMP Snooping 功能时，没有所有端口都接收到组播流量', step=5, result=False)\n\n        # 被测设备使能igmp snooping\n        cmd_cfg = '_'.join('DeviceA_Step3'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        # 清空统计计数\n        clear_result()\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        printf(message='step3：端口1向端口2发送1个组的组播流量, 在被测交换机上启用IGMP Snooping 功能')\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'在被测交换机上启用IGMP Snooping 功能时，非组播客户端端不能接收组播流量', step=5, result=False)\n\n        igmp_send_report(Sessions=igmp)\n        time.sleep(3)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送组加入请求后，可接收组播流量', step=5, result=False)\n\n        igmp_send_leave(Sessions=igmp)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        time.sleep(5)\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if Result['TxStreamFrames'] != Result['RxStreamFrames'] and Result['RxStreamFrames'] == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'端口2 发送离开组请求后，不能接收组播流量', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\ncreate_igmp:创建IGMP协议会话对象;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_3/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  6.7.3动态主机配置协议（DHCP）\n\n Step\t\t\t:\t测试步骤1: ：按图10搭建测试环境\n                   测试步骤2: DUT port1 地址为192.168.1.1/24，DUT 上开启 DHCP 服务，设置为DHCP服务器，配置地址池192.168.1.2~192.168.1.254；\n                   测试步骤3: tester port1 作为 DHCP 客户端，发送DHCP请求\n                   测试步骤4: 观察客户端能否接收到正确的地址配置\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: 6.7.3 Dynamic Host Configuration Protocol (DHCP)  \n\nStep:  \nStep 1: Set up the test environment according to Figure 10  \nStep 2: Configure DUT port1 with address 192.168.1.1/24. Enable DHCP service on DUT as DHCP server, configuring address pool 192.168.1.2~192.168.1.254  \nStep 3: Set tester port1 as DHCP client to send DHCP request  \nStep 4: Observe whether the client receives correct address configuration  \n\nCriteria:  \nExpected Result 1: The client receives correct address configuration  \n\nCreated by: Tester-006  \n\nBugs: None",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    # 创建DHCPv4协议会话\n    client = create_dhcp_client(Port=port_up)\n\n    # DHCPv4协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_up)\n\n    # # 获取DHCP Server地址池\n    # configDict = get_configs(Configs='Dhcpv4AddressPool')\n    # dhcpv4AddressPool = list(configDict.values())[0]\n    # edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='192.168.1.2', PrefixLength=19, PoolAddressCount=253)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n        start_protocol()\n        # dhcp_bind(Sessions=client)\n        # 等待DHCP协议协议会话状态正确\n        result = wait_dhcp_client_state(Sessions=client)\n\n        if result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is Bound', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is not Bound', step=4, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "create_dhcp_client:创建DHCPv4客户端协议会话对象",
      "wait_dhcp_client_state:等待DHCP协议会话达到指定状态"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester system and reserve required ports based on test configuration.\",\n  \"Subtask 2\": \"Configure DUT port1 with IP address 192.168.1.1/24 and enable DHCP server with address pool 192.168.1.2-192.168.1.254.\",\n  \"Subtask 3\": \"On tester port1, create a network interface and configure it for DHCP client operation without static IP assignment.\",\n  \"Subtask 4\": \"Create DHCPv4 client session on tester port1 and bind it to the created interface.\",\n  \"Subtask 5\": \"Start DHCP protocol operation and wait for client session to reach BOUND state.\",\n  \"Subtask 6\": \"Verify DHCP client received IP address within configured pool (192.168.1.2-192.168.1.254) and confirm correct network configuration.\",\n  \"Subtask 7\": \"Release reserved ports and shut down tester system after test completion.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: 6.7.3 Dynamic Host Configuration Protocol (DHCP)  \n\nStep:  \nStep 1: Set up the test environment according to Figure 10  \nStep 2: Configure DUT port1 with address 192.168.1.1/24. Enable DHCP service on DUT as DHCP server, configuring address pool 192.168.1.2~192.168.1.254  \nStep 3: Set tester port1 as DHCP client to send DHCP request  \nStep 4: Observe whether the client receives correct address configuration  \n\nCriteria:  \nExpected Result 1: The client receives correct address configuration  \n\nCreated by: Tester-006  \n\nBugs: None\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    # 创建DHCPv4协议会话\n    client = create_dhcp_client(Port=port_up)\n\n    # DHCPv4协议会话与接口绑定\n    select_interface(Session=client, Interface=interfaces_up)\n\n    # # 获取DHCP Server地址池\n    # configDict = get_configs(Configs='Dhcpv4AddressPool')\n    # dhcpv4AddressPool = list(configDict.values())[0]\n    # edit_configs(Configs=dhcpv4AddressPool, PoolAddressStart='192.168.1.2', PrefixLength=19, PoolAddressCount=253)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n        start_protocol()\n        # dhcp_bind(Sessions=client)\n        # 等待DHCP协议协议会话状态正确\n        result = wait_dhcp_client_state(Sessions=client)\n\n        if result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is Bound', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'The State Of Dhcp is not Bound', step=4, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\ncreate_dhcp_client:创建DHCPv4客户端协议会话对象;\nwait_dhcp_client_state:等待DHCP协议会话达到指定状态\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_3/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.3 队头阻塞测试\n\n Step\t\t\t:\t测试步骤1: 按图7，从交换机任意选取4 个端口与测试仪相连接，分别定为端口A、端口B、端口C 和端口D；\n                   测试步骤2: 网络测试仪、交换机均关闭流控，12 发送100%流量，32 发送50%流量，34 发送50%流量；\n                    1) 口建立untag流量 连接交换机端口 access vlan 100,\n                    2) 口连接交换机trunk vlan 100,200\n                    3) 口建立vlan 200,vlan4094流量 连接交换机trunk vlan 200,4094\n                    4) 口连接交换机access vlan 4094\n                   测试步骤3: 记录端口D 是否有丢包。\n\n Criteria    \t:   预期结果1: 记录端口D 是否有丢包。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective     : Objective: 6.5.3 Head-of-Line Blocking Test\n\nStep          : Step 1: As per Figure 7, arbitrarily select 4 ports from the switch and connect them to the tester, designated as Port A, Port B, Port C, and Port D respectively;\n               Step 2: Disable flow control on both the network tester and the switch. Send 100% traffic from 1→2, 50% traffic from 3→2, and 50% traffic from 3→4;\n               1) Port 1: Establish untagged traffic and connect to the switch port in access mode for VLAN 100;\n               2) Port 2: Connect to the switch trunk port allowing VLANs 100 and 200;\n               3) Port 3: Establish traffic for VLAN 200 and VLAN 4094, and connect to the switch trunk port allowing VLANs 200 and 4094;\n               4) Port 4: Connect to the switch port in access mode for VLAN 4094;\n               Step 3: Record whether there is packet loss on Port D.\n\nCriteria      : Expected Result 1: Record whether there is packet loss on Port D.\n\nCreated by    : Tester-008\n\nTags          : function\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=100, Seconds=30)\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 绑定流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4', 'tcp'])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 绑定流量\n    edit_port_load_profile(Ports=port3, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    #edit_port_load_profile(Ports=port3, Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan200_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 50)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan4094_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=4094)\n    edit_stream_load_profile(Streams=stream, Rate=50)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        stream1=get_streams(Ports=port1)\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n        stream_object = get_streams(Ports=port3)\n        for stream in stream_object:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=3, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=3, result=True)\n\n        stream = stream_object[1]\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames}),端口D丢包',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),端口D未丢包',\n                step=4, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester using the init_tester API function.\",\n  \"Subtask 2\": \"Reserve four test ports designated as Port1, Port2, Port3, Port4 using reserve_port API and assign MAC addresses to each port.\",\n  \"Subtask 3\": \"Import switch configuration topology using NTO actions_import to set Port1 as access mode VLAN100, Port2 as trunk mode allowing VLAN100/200, Port3 as trunk mode allowing VLAN200/4094, and Port4 as access mode VLAN4094.\",\n  \"Subtask 4\": \"Disable flow control by configuring test port parameters using edit_port API according to testbed specifications.\",\n  \"Subtask 5\": \"Configure Port1 load profile: set transmit mode to TIME, rate to 100%, duration to 30 seconds using edit_port_load_profile API.\",\n  \"Subtask 6\": \"Create untagged VLAN100 traffic stream on Port1: add stream, set frame length to 128 bytes, build Ethernet/VLAN/IPv4/TCP headers, and configure source/destination MAC addresses using add_stream, edit_stream, create_stream_header, and edit_header_ethernet APIs.\",\n  \"Subtask 7\": \"Configure Port3 load profile: set type to STREAM_BASE, transmit mode to TIME, duration to 30 seconds using edit_port_load_profile API.\",\n  \"Subtask 8\": \"Create VLAN200 traffic stream on Port3: add stream, set frame length to 128 bytes, build headers, configure MAC addresses, set VLAN ID to 200, and set rate to 50% using add_stream, edit_stream, create_stream_header, edit_header_ethernet, edit_header_vlan, and edit_stream_load_profile APIs.\",\n  \"Subtask 9\": \"Create VLAN4094 traffic stream on Port3: add stream, set frame length to 128 bytes, build headers, configure MAC addresses, set VLAN ID to 4094, and set rate to 50% using add_stream, edit_stream, create_stream_header, edit_header_ethernet, edit_header_vlan, and edit_stream_load_profile APIs.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats view using subscribe_result API for traffic monitoring.\",\n  \"Subtask 11\": \"Save test configuration using save_case API.\",\n  \"Subtask 12\": \"Start Layer 2 address learning using start_l2_learning API and wait 5 seconds.\",\n  \"Subtask 13\": \"Start traffic transmission on all ports simultaneously using start_stream API.\",\n  \"Subtask 14\": \"Wait for traffic transmission to complete using wait_stream_state API.\",\n  \"Subtask 15\": \"Verify transmitted frame counts for all streams are non-zero using get_streamblock_statistic API.\",\n  \"Subtask 16\": \"Retrieve transmitted (TxStreamFrames) and received (RxStreamFrames) frame counts for VLAN4094 stream (Port3 to Port4) using get_streamblock_statistic API.\",\n  \"Subtask 17\": \"Compare TxStreamFrames and RxStreamFrames for VLAN4094 stream to detect packet loss on Port4.\",\n  \"Subtask 18\": \"Record test result indicating presence/absence of packet loss on Port4 based on frame count comparison.\",\n  \"Subtask 19\": \"Clear statistical results using clear_result API.\",\n  \"Subtask 20\": \"Release reserved ports using release_port API.\",\n  \"Subtask 21\": \"Shutdown tester using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective     : Objective: 6.5.3 Head-of-Line Blocking Test\n\nStep          : Step 1: As per Figure 7, arbitrarily select 4 ports from the switch and connect them to the tester, designated as Port A, Port B, Port C, and Port D respectively;\n               Step 2: Disable flow control on both the network tester and the switch. Send 100% traffic from 1→2, 50% traffic from 3→2, and 50% traffic from 3→4;\n               1) Port 1: Establish untagged traffic and connect to the switch port in access mode for VLAN 100;\n               2) Port 2: Connect to the switch trunk port allowing VLANs 100 and 200;\n               3) Port 3: Establish traffic for VLAN 200 and VLAN 4094, and connect to the switch trunk port allowing VLANs 200 and 4094;\n               4) Port 4: Connect to the switch port in access mode for VLAN 4094;\n               Step 3: Record whether there is packet loss on Port D.\n\nCriteria      : Expected Result 1: Record whether there is packet loss on Port D.\n\nCreated by    : Tester-008\n\nTags          : function\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=100, Seconds=30)\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 绑定流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4', 'tcp'])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 绑定流量\n    edit_port_load_profile(Ports=port3, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    #edit_port_load_profile(Ports=port3, Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan200_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 50)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_vlan4094_50%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=4094)\n    edit_stream_load_profile(Streams=stream, Rate=50)\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        stream1=get_streams(Ports=port1)\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n        stream_object = get_streams(Ports=port3)\n        for stream in stream_object:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=3, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=3, result=True)\n\n        stream = stream_object[1]\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if RxStreamFrames != TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames}),端口D丢包',\n                step=4, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),端口D未丢包',\n                step=4, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_1/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.1IP 广播功能\n\n Step\t\t\t:\t测试步骤1: ：1.按图10搭建测试环境；\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为 192.168.2.100/24；\n                   测试步骤3: DUT port1 地址为 192.168.1.1/24，port2 地址为 192.168.2.1/24；port1和port2 均开启直接广播支持；\n                   测试步骤4: tester port1 发送目的地址为255.255.255.255的数据包；\n                   测试步骤5: tester port1 发送目的地址为192.168.2.255的数据包；\n                   测试步骤6: DUT port2 配置192.168.3.0 路由；\n                   测试步骤7: tester port1 发送目的地址为192.168.3.255的数据包；\n                   测试步骤8: 记录步骤4、5、7中tester port2是否收到广播包。\n\n Criteria    \t:   预期结果1: 1.有限广播不能转发。2.三层交换机必须将网络前缀直接广播作为有效\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: 6.7.1 IP Broadcast Function Test  \nStep:  \n1. Set up test environment according to Figure 10.  \n2. Tester port1 address: 192.168.1.100/24, port2 address: 192.168.2.100/24.  \n3. DUT port1 address: 192.168.1.1/24, port2 address: 192.168.2.1/24; enable directed broadcast support on both port1 and port2.  \n4. Tester port1 sends packet with destination address 255.255.255.255.  \n5. Tester port1 sends packet with destination address 192.168.2.255.  \n6. Configure route 192.168.3.0 on DUT port2.  \n7. Tester port1 sends packet with destination address 192.168.3.255.  \n8. Record whether tester port2 receives broadcast packets in steps 4, 5, and 7.  \n\nCriteria:  \n1. Limited broadcast (255.255.255.255) must not be forwarded.  \n2. Layer 3 switch must treat directed broadcast to network prefix as valid.  \n\nCreated by: Tester-006  \nBugs: None",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        TransmitMode=\"CONTINUOUS\",\n    #                        Frames=100,\n    #                        Unit='FRAME_PER_SEC')\n    # edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['255.255.255.255', '192.168.2.255', '192.168.3.255']\n\n    # 创建广播流量\n    # edit_port_load_profile(Ports=port1,LoadProfileType='PORT_BASE',Rate=30,Unit='FRAME_PER_SEC',TransmitMode=\"STEP\",Frames=20)\n    # tester port1 发送目的地址为255.255.255.255的数据包\n    stream = add_stream(Ports=port1, Names=f'step4')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168\n    # .2.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step5')\n\n    edit_stream(Stream=stream, FixedLength=64, )\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168.3.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[2],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_port_load_profile(Ports=port1, LoadProfileType='STREAM_BASE', TransmitMode='TIME', Seconds=30)\n\n    # 订阅统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        streams = get_streams(Ports=port1)\n        start_stream(Type='stream', Objects=streams[0])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[0],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 未收到广播包',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 收到广播包',\n                step=3, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[1])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[1],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=4, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[2])\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[2],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=5, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l3_learning:启动测试仪表流量三层ARP ND学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester and reserve ports according to testbed configuration.\",\n  \"Subtask 2\": \"Configure tester port parameters including force, debug, and wait_for_status_up settings.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both tester ports with specified MAC and IP addresses: port1 at 192.168.1.100/24 (gateway 192.168.1.1), port2 at 192.168.2.100/24 (gateway 192.168.2.1).\",\n  \"Subtask 4\": \"Configure DUT ports: set port1 to 192.168.1.1/24 and port2 to 192.168.2.1/24, enabling directed broadcast support on both ports.\",\n  \"Subtask 5\": \"Set port load profiles for continuous transmission at 100 frames per second.\",\n  \"Subtask 6\": \"Create first test stream on port1 with destination IP 255.255.255.255 (limited broadcast), fixed length 64 bytes.\",\n  \"Subtask 7\": \"Create second test stream on port1 with destination IP 192.168.2.255 (directed broadcast), fixed length 64 bytes.\",\n  \"Subtask 8\": \"Configure DUT to add route for network 192.168.3.0 on port2.\",\n  \"Subtask 9\": \"Create third test stream on port1 with destination IP 192.168.3.255 (directed broadcast), fixed length 64 bytes.\",\n  \"Subtask 10\": \"Subscribe to StreamBlockStats view for result collection.\",\n  \"Subtask 11\": \"Save test configuration to file.\",\n  \"Subtask 12\": \"For first stream (limited broadcast): start L3 learning, clear statistics, transmit traffic, then verify port2 received 0 packets (no forwarding).\",\n  \"Subtask 13\": \"For second stream (directed broadcast): start L3 learning, clear statistics, transmit traffic, then verify port2 received packets (successful forwarding).\",\n  \"Subtask 14\": \"For third stream (routed directed broadcast): start L3 learning, clear statistics, transmit traffic, then verify port2 received packets (successful forwarding).\",\n  \"Subtask 15\": \"Release tester ports and shutdown tester after test completion.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: 6.7.1 IP Broadcast Function Test  \nStep:  \n1. Set up test environment according to Figure 10.  \n2. Tester port1 address: 192.168.1.100/24, port2 address: 192.168.2.100/24.  \n3. DUT port1 address: 192.168.1.1/24, port2 address: 192.168.2.1/24; enable directed broadcast support on both port1 and port2.  \n4. Tester port1 sends packet with destination address 255.255.255.255.  \n5. Tester port1 sends packet with destination address 192.168.2.255.  \n6. Configure route 192.168.3.0 on DUT port2.  \n7. Tester port1 sends packet with destination address 192.168.3.255.  \n8. Record whether tester port2 receives broadcast packets in steps 4, 5, and 7.  \n\nCriteria:  \n1. Limited broadcast (255.255.255.255) must not be forwarded.  \n2. Layer 3 switch must treat directed broadcast to network prefix as valid.  \n\nCreated by: Tester-006  \nBugs: None\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, \\\n    edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        TransmitMode=\"CONTINUOUS\",\n    #                        Frames=100,\n    #                        Unit='FRAME_PER_SEC')\n    # edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['255.255.255.255', '192.168.2.255', '192.168.3.255']\n\n    # 创建广播流量\n    # edit_port_load_profile(Ports=port1,LoadProfileType='PORT_BASE',Rate=30,Unit='FRAME_PER_SEC',TransmitMode=\"STEP\",Frames=20)\n    # tester port1 发送目的地址为255.255.255.255的数据包\n    stream = add_stream(Ports=port1, Names=f'step4')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168\n    # .2.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step5')\n\n    edit_stream(Stream=stream, FixedLength=64, )\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # tester port1 发送目的地址为192.168.3.255的数据包；\n    stream = add_stream(Ports=port1, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[2],\n                     Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_port_load_profile(Ports=port1, LoadProfileType='STREAM_BASE', TransmitMode='TIME', Seconds=30)\n\n    # 订阅统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        streams = get_streams(Ports=port1)\n        start_stream(Type='stream', Objects=streams[0])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[0],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 未收到广播包',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 收到广播包',\n                step=3, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[1])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[1],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=4, result=False)\n\n        start_l3_learning()\n        time.sleep(5)\n        clear_result()\n        # 启动流量测试\n        start_stream(Type='stream', Objects=streams[2])\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=streams[2],\n                                           StaItems=['StreamBlockID', 'TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        StreamBlockID = Result['StreamBlockID']\n        if TxStreamFrames > 0 and RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID}, tester port2 收到广播包',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{StreamBlockID} , tester port2 未收到广播包',\n                step=5, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l3_learning:启动测试仪表流量三层ARP ND学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_6_1/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.6.1 三层转发速率\n\n Step\t\t\t:\t测试步骤1: 按拓扑图搭建测试环境；\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为192.168.2.100/24；\n                   测试步骤3: DUT port1 地址为 192.168.1.1/24，port2 地址为 192.168.2.1/24；\n                   测试步骤4: 测试仪从端口以最大负荷，不同帧长度（64、128、256、512、1024、1518byte）发送数据，测试时间为 30 秒。\n\n Criteria    \t:   预期结果1: 记录转发速率。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   6.6.1 Layer 3 Forwarding Rate\n\nStep\t\t\t:\tStep 1: Set up the test environment according to the topology diagram;\n                   Step 2: Set tester port1 address to 192.168.1.100/24 and port2 address to 192.168.2.100/24;\n                   Step 3: Set DUT port1 address to 192.168.1.1/24 and port2 address to 192.168.2.1/24;\n                   Step 4: The tester sends data from the ports at maximum load with different frame sizes (64, 128, 256, 512, 1024, 1518 bytes) for a test duration of 30 seconds.\n\nCriteria    \t:   Expected result 1: Record the forwarding rate.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['seconds']['default'])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 初始化一个空的DataFrame来存储所有数据\n        printf(message='Test start')\n        all_data = pd.DataFrame()\n        for frame_size in cfg['arg']['stream']['default']['frame_size']['default']:\n            # 修改帧长\n            for s in streams:\n                s.edit(FixedLength=frame_size)\n            # 发送流量\n            start_stream()\n            time.sleep(3)\n            df = get_streamblock_statistic()\n            wait_stream_state(TimeOut=cfg['arg']['load_profile']['default']['seconds']['default'] + 3)\n            time.sleep(3)\n            result = get_streamblock_statistic()\n            # 使用 concat 拼接 DataFrame\n            df = pd.concat([df, result])\n            # 重置索引\n            df = df.reset_index(drop=True)\n            # 添加一列帧长，全部值为当前循环的frame_length，并命名为'frame_length'\n            # 注意：这里我们假设原始DataFrame中没有名为'frame_length'的列，或者即使有，我们也想要覆盖它\n            df['FrameSize'] = frame_size\n            # 但是，由于我们想要将'frame_length'放在第二列，我们需要重新排列列\n            # 首先获取当前列名列表\n            columns = df.columns.tolist()\n            # 如果'FrameSize'已经在列表中，移除它以便我们可以重新插入到正确的位置\n            if 'FrameSize' in columns:\n                columns.remove('FrameSize')\n            # 将'frame_length'插入到第二列的位置（索引为1）\n            columns.insert(1, 'FrameSize')\n            # 重新排序DataFrame的列\n            df = df.reindex(columns=columns)\n            # 将当前循环的数据追加到所有数据的DataFrame中\n            all_data = pd.concat([all_data, df])\n            # 重置all_data的索引，虽然这不是严格必要的，但可以保持索引的连续性\n            all_data = all_data.reset_index(drop=True)\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(all_data, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(all_data)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester system using init_tester API.\",\n  \"Subtask 2\": \"Reserve tester ports using reserve_port API according to test topology.\",\n  \"Subtask 3\": \"Set up DUT port configurations: port1 to 192.168.1.1/24 and port2 to 192.168.2.1/24 (handled by setup function).\",\n  \"Subtask 4\": \"Create IPv4 interfaces on reserved ports using create_interface API.\",\n  \"Subtask 5\": \"Configure tester interface parameters: port1 to 192.168.1.100/24 (gateway 192.168.1.1) and port2 to 192.168.2.100/24 (gateway 192.168.2.1) using edit_interface API.\",\n  \"Subtask 6\": \"Retrieve IPv4 layer objects from interfaces using get_layer_from_interfaces API.\",\n  \"Subtask 7\": \"Create bidirectional traffic streams between port1 and port2 IPv4 layers using add_stream API.\",\n  \"Subtask 8\": \"Configure load profile: maximum load (100%), PERCENT unit, TIME mode, 30-second duration using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Subscribe to PortStats and StreamBlockStats views using subscribe_result API.\",\n  \"Subtask 10\": \"Save test configuration using save_case API.\",\n  \"Subtask 11\": \"For each frame size in [64, 128, 256, 512, 1024, 1518] bytes: modify stream frame length and start traffic using start_stream API.\",\n  \"Subtask 12\": \"Run traffic for 30 seconds, wait for completion using wait_stream_state API.\",\n  \"Subtask 13\": \"Capture and record forwarding rate statistics using get_streamblock_statistic API after each test iteration.\",\n  \"Subtask 14\": \"Release tester ports using release_port API after all test iterations.\",\n  \"Subtask 15\": \"Shutdown tester system using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   6.6.1 Layer 3 Forwarding Rate\n\nStep\t\t\t:\tStep 1: Set up the test environment according to the topology diagram;\n                   Step 2: Set tester port1 address to 192.168.1.100/24 and port2 address to 192.168.2.100/24;\n                   Step 3: Set DUT port1 address to 192.168.1.1/24 and port2 address to 192.168.2.1/24;\n                   Step 4: The tester sends data from the ports at maximum load with different frame sizes (64, 128, 256, 512, 1024, 1518 bytes) for a test duration of 30 seconds.\n\nCriteria    \t:   Expected result 1: Record the forwarding rate.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['seconds']['default'])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 初始化一个空的DataFrame来存储所有数据\n        printf(message='Test start')\n        all_data = pd.DataFrame()\n        for frame_size in cfg['arg']['stream']['default']['frame_size']['default']:\n            # 修改帧长\n            for s in streams:\n                s.edit(FixedLength=frame_size)\n            # 发送流量\n            start_stream()\n            time.sleep(3)\n            df = get_streamblock_statistic()\n            wait_stream_state(TimeOut=cfg['arg']['load_profile']['default']['seconds']['default'] + 3)\n            time.sleep(3)\n            result = get_streamblock_statistic()\n            # 使用 concat 拼接 DataFrame\n            df = pd.concat([df, result])\n            # 重置索引\n            df = df.reset_index(drop=True)\n            # 添加一列帧长，全部值为当前循环的frame_length，并命名为'frame_length'\n            # 注意：这里我们假设原始DataFrame中没有名为'frame_length'的列，或者即使有，我们也想要覆盖它\n            df['FrameSize'] = frame_size\n            # 但是，由于我们想要将'frame_length'放在第二列，我们需要重新排列列\n            # 首先获取当前列名列表\n            columns = df.columns.tolist()\n            # 如果'FrameSize'已经在列表中，移除它以便我们可以重新插入到正确的位置\n            if 'FrameSize' in columns:\n                columns.remove('FrameSize')\n            # 将'frame_length'插入到第二列的位置（索引为1）\n            columns.insert(1, 'FrameSize')\n            # 重新排序DataFrame的列\n            df = df.reindex(columns=columns)\n            # 将当前循环的数据追加到所有数据的DataFrame中\n            all_data = pd.concat([all_data, df])\n            # 重置all_data的索引，虽然这不是严格必要的，但可以保持索引的连续性\n            all_data = all_data.reset_index(drop=True)\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(all_data, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(all_data)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_8_1/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.8.1错误帧过滤功能\n\n Step\t\t\t:\t测试步骤1: ：按图4，任选交换机两个端口作为测试端口；\n                   测试步骤2: 端口1向端口2发送CRC校验错误帧，观察接收情况；\n                   测试步骤3: 端口1向端口2发送源MAC地址错误帧，观察接收情况\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective    : Purpose: 6.8.1 Error Frame Filtering Function\n\nStep        : Test Step 1: According to Figure 4, select any two ports of the switch as test ports.\n              Test Step 2: Port 1 sends a CRC error frame to Port 2; observe reception status.\n              Test Step 3: Port 1 sends a source MAC address error frame to Port 2; observe reception status.\n\nCriteria     : Expected Result 1:\n\nCreated by   : Tester-006\n\nBugs         : None\n=================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100,\n                           GenerateError='CRC')\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=False)\n\n        clear_result()\n        edit_port_load_profile(Ports=port1,\n                               LoadProfileType='PORT_BASE',\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=100,\n                               GenerateError='NO_ERROR')\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames == RxStreamFrames and  RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester system and reserve two specified ports from the testbed configuration.\",\n  \"Subtask 2\": \"Create network interfaces on both reserved ports with IPv4 layers and configure MAC/IPv4 addresses according to test parameters.\",\n  \"Subtask 3\": \"Configure port1's load profile to generate CRC errors with continuous transmission at 100 frames/sec.\",\n  \"Subtask 4\": \"Create stream1 on port1 with valid source MAC address, destination MAC address, and fixed 64-byte frame length.\",\n  \"Subtask 5\": \"Create stream2 on port1 with invalid source MAC address (00:00:00:00:00:00), same destination MAC, and fixed 64-byte frame length.\",\n  \"Subtask 6\": \"Subscribe to PortStats and StreamBlockStats views for result monitoring.\",\n  \"Subtask 7\": \"Start L2 learning process and transmit stream1 (CRC error frames) for 10 seconds.\",\n  \"Subtask 8\": \"Retrieve stream1 statistics and verify that TxStreamFrames > 0 while RxStreamFrames = 0.\",\n  \"Subtask 9\": \"Reconfigure port1's load profile to disable error generation (NO_ERROR setting).\",\n  \"Subtask 10\": \"Start L2 learning process and transmit stream2 (source MAC error frames) for 10 seconds.\",\n  \"Subtask 11\": \"Retrieve stream2 statistics and verify that TxStreamFrames = RxStreamFrames > 0.\",\n  \"Subtask 12\": \"Release reserved ports and shutdown tester system.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective    : Purpose: 6.8.1 Error Frame Filtering Function\n\nStep        : Test Step 1: According to Figure 4, select any two ports of the switch as test ports.\n              Test Step 2: Port 1 sends a CRC error frame to Port 2; observe reception status.\n              Test Step 3: Port 1 sends a source MAC address error frame to Port 2; observe reception status.\n\nCriteria     : Expected Result 1:\n\nCreated by   : Tester-006\n\nBugs         : None\n=================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100,\n                           GenerateError='CRC')\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames > 0 and RxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream1 RxStreamFrames({RxStreamFrames}) is equal to 0',\n                step=3, result=False)\n\n        clear_result()\n        edit_port_load_profile(Ports=port1,\n                               LoadProfileType='PORT_BASE',\n                               Unit='FRAME_PER_SEC',\n                               TransmitMode=\"CONTINUOUS\",\n                               Rate=100,\n                               GenerateError='NO_ERROR')\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(3)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        time.sleep(3)\n\n        # 检查统计结果\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        if TxStreamFrames == RxStreamFrames and  RxStreamFrames > 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream2 RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_5/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.5 多链路聚合: 链路聚合时不应丢失数据\n\n Step\t\t\t:\t测试步骤1: 按图8 建立测试环境；\n                   测试步骤2: 将交换机1 的2 个端口和交换机2 的2 个端口对应连接。将交换机1 的 2个端口配置为一个静态聚合端口，交换机2 的2 个端口配置为一个静态聚合端口；\n                   测试步骤3: 由测试仪1、3 端口分别向2、4 端口发送数据流，负载率为100%；\n                   测试步骤4: 在测试仪的2、4 端口观察流量的接收情况，应无丢包；\n                   测试步骤5: 断开交换机1 和交换机2 间的1 条链路，观察流量的接收情况，应各丢 50%；\n                   测试步骤6: 停掉3 向4 的数据流，观察1 向2 的数据流的接收情况，应无丢包。\n\n Criteria    \t:   预期结果1: 记录端口4 接收到的数据帧数量，判断镜像功能是否设置成功。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "Objective: Test Purpose: 6.5.5 Multi-Link Aggregation: No data loss should occur during link aggregation.\n\nStep: Test Step 1: Establish the test environment according to Figure 8;  \nTest Step 2: Connect two ports of Switch 1 to two ports of Switch 2 respectively. Configure the two ports of Switch 1 as one static aggregation port, and the two ports of Switch 2 as one static aggregation port;  \nTest Step 3: Send data streams from ports 1 and 3 of the tester to ports 2 and 4 respectively at 100% load rate;  \nTest Step 4: Observe traffic reception at ports 2 and 4 of the tester—no packet loss should occur;  \nTest Step 5: Disconnect one link between Switch 1 and Switch 2—observe traffic reception, 50% packet loss should occur on each;  \nTest Step 6: Stop the data stream from port 3 to port 4—observe reception of the data stream from port 1 to port 2—no packet loss should occur.\n\nCriteria: Expected Result 1: Record the number of data frames received at port 4 to determine whether the mirroring function is successfully configured.\n\nCreated by: Tester-008\n\nTags: function",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    # 端口1创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream1 = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream1, FixedLength=128)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 端口3创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream2 = add_stream(Ports=port3, Names=f'{port3.Name}_100%')\n    edit_stream(Stream=stream2, FixedLength=128)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取流量结果\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step4：get  stream statistic')\n        # 获取流量1统计结果\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames'] and Result2['TxStreamFrames']==Result2['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames']*2 and Result2['TxStreamFrames']==Result2['RxStreamFrames']*2:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        # 停止3口流量\n        stop_stream(Type='stream',Objects=stream2)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result1['TxStreamFrames'] == Result1['RxStreamFrames']  and Result2['TxStreamFrames'] == Result2[\n            'RxStreamFrames'] :\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester and reserve ports 1, 2, 3, and 4 according to testbed configuration.\",\n  \"Subtask 2\": \"Configure all reserved ports with required parameters (transmit mode, rate) using edit_port_load_profile.\",\n  \"Subtask 3\": \"Create stream on port 1 with Ethernet header (source MAC 00:00:00:13:40:21, destination MAC 00:00:01:13:40:20), fixed length 128 bytes.\",\n  \"Subtask 4\": \"Create stream on port 3 with Ethernet header (source MAC 00:00:00:13:40:22, destination MAC 00:00:01:13:40:21), fixed length 128 bytes.\",\n  \"Subtask 5\": \"Subscribe to StreamBlockStats view for traffic monitoring.\",\n  \"Subtask 6\": \"Start L2 learning process and wait 5 seconds for MAC address learning.\",\n  \"Subtask 7\": \"Clear existing statistics, start both streams (port1→port2 and port3→port4) at 100% load rate.\",\n  \"Subtask 8\": \"Wait for streams to complete, then verify no packet loss by comparing TxStreamFrames and RxStreamFrames for both streams.\",\n  \"Subtask 9\": \"Clear statistics again, restart both streams to simulate link disconnection scenario.\",\n  \"Subtask 10\": \"After streams complete, verify 50% packet loss by checking TxStreamFrames = 2 * RxStreamFrames for both streams.\",\n  \"Subtask 11\": \"Clear statistics, stop port3→port4 stream while keeping port1→port2 stream active.\",\n  \"Subtask 12\": \"Verify no packet loss on port1→port2 stream by comparing TxStreamFrames and RxStreamFrames.\",\n  \"Subtask 13\": \"Release all reserved ports and shutdown tester after test completion.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Purpose: 6.5.5 Multi-Link Aggregation: No data loss should occur during link aggregation.\n\nStep: Test Step 1: Establish the test environment according to Figure 8;  \nTest Step 2: Connect two ports of Switch 1 to two ports of Switch 2 respectively. Configure the two ports of Switch 1 as one static aggregation port, and the two ports of Switch 2 as one static aggregation port;  \nTest Step 3: Send data streams from ports 1 and 3 of the tester to ports 2 and 4 respectively at 100% load rate;  \nTest Step 4: Observe traffic reception at ports 2 and 4 of the tester—no packet loss should occur;  \nTest Step 5: Disconnect one link between Switch 1 and Switch 2—observe traffic reception, 50% packet loss should occur on each;  \nTest Step 6: Stop the data stream from port 3 to port 4—observe reception of the data stream from port 1 to port 2—no packet loss should occur.\n\nCriteria: Expected Result 1: Record the number of data frames received at port 4 to determine whether the mirroring function is successfully configured.\n\nCreated by: Tester-008\n\nTags: function\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    # 端口1创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream1 = add_stream(Ports=port1, Names=f'{port1.Name}_100%')\n    edit_stream(Stream=stream1, FixedLength=128)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 端口3创建 流量\n    # 数据流：untag 的 tcp 报文\n    stream2 = add_stream(Ports=port3, Names=f'{port3.Name}_100%')\n    edit_stream(Stream=stream2, FixedLength=128)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取流量结果\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step4：get  stream statistic')\n        # 获取流量1统计结果\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames'] and Result2['TxStreamFrames']==Result2['RxStreamFrames']:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                    'RxStreamFrames', 'TxTotalBytes',\n                                                                    'RxTotalBytes'])\n        if  Result1['TxStreamFrames']==Result1['RxStreamFrames']*2 and Result2['TxStreamFrames']==Result2['RxStreamFrames']*2:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 断开交换机1 和2 之间的一条链路获取流量统计结果，各丢50%\n        # 清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(10)\n        # 停止3口流量\n        stop_stream(Type='stream',Objects=stream2)\n        wait_stream_state()\n        time.sleep(3)\n        Result1 = get_streamblock_statistic(Stream=stream1, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        Result2 = get_streamblock_statistic(Stream=stream2, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                      'RxStreamFrames', 'TxTotalBytes',\n                                                                      'RxTotalBytes'])\n        if Result1['TxStreamFrames'] == Result1['RxStreamFrames']  and Result2['TxStreamFrames'] == Result2[\n            'RxStreamFrames'] :\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is equal to TxStream1Frames', step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'Stream RxStreamFrames is not equal to TxStream1Frames', step=4, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_7/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.7 网络风暴抑制: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示；\n                   测试步骤2: 测试帧长设为64，端口负载为满负载，测试时间30s；\n                   测试步骤3: 交换机分别开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能；\n                   测试步骤4: 使用默认抑制值或者设置抑制值为1M；\n                   测试步骤5: 端口1 向端口2 发送3 条数据流，分别为Stream1（广播帧）、Stream2（广播帧）、Stream3（IPv4 帧），端口2 向端口1 发送2 条数据流，分别为Stream1（组播帧）、Stream2（未知单播帧）；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断网络风暴抑制功能是否设置成功；\n                   测试步骤7: 根据帧丢失率，计算网络风暴抑制比偏差。\n\n Criteria    \t:   预期结果1: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启；\n                   预期结果2: 网络风暴实际抑制值不应超过抑制设定值的110%。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective     : Test Objective : 6.5.7 Network Storm Control: Shall support broadcast, multicast, and unknown unicast storm control functions. Broadcast storm control is enabled by default.\n\nStep          : Test Step 1: Connect traffic generator to switch as shown in Figure 4;\n                Test Step 2: Set frame length to 64 bytes, port load to 100%, test duration 30s;\n                Test Step 3: Enable broadcast, multicast, and unknown unicast storm control functions on the switch;\n                Test Step 4: Use default suppression value or set suppression value to 1M;\n                Test Step 5: Port 1 sends 3 streams to Port 2: Stream1 (broadcast frames), Stream2 (broadcast frames), Stream3 (IPv4 frames). Port 2 sends 2 streams to Port 1: Stream1 (multicast frames), Stream2 (unknown unicast frames);\n                Test Step 6: Record frame loss rate for each stream to verify storm control configuration;\n                Test Step 7: Calculate storm control ratio deviation based on frame loss rate.\n\nCriteria      : Expected Result 1: Shall support broadcast, multicast, and unknown unicast storm control functions. Broadcast storm control is enabled by default;\n                Expected Result 2: Actual suppression value shall not exceed 110% of configured suppression value.\n\nCreated by    : Tester-008\n\nTags          : Function\n=================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        expected_value = 0.1 * 1.1\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 3 * 2\n\n            if round(prss, 2) < expected_value:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 2\n            if round(prss, 2) < expected_value:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester and reserve ports as specified in the testbed configuration.\",\n  \"Subtask 2\": \"Set frame length to 64 bytes, port load to 100%, and test duration to 30 seconds for all test ports.\",\n  \"Subtask 3\": \"Enable broadcast, multicast, and unknown unicast storm control on the switch with suppression value set to 1Mbps.\",\n  \"Subtask 4\": \"Create three streams on port1: Stream1 (broadcast frames), Stream2 (broadcast frames), Stream3 (IPv4 frames) with specified source/destination MAC addresses.\",\n  \"Subtask 5\": \"Create two streams on port2: Stream1 (multicast frames), Stream2 (unknown unicast frames) with specified source/destination MAC addresses.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats view for traffic statistics collection.\",\n  \"Subtask 7\": \"Start traffic transmission from port1 and wait for completion.\",\n  \"Subtask 8\": \"For each stream on port1: retrieve transmitted/received frame counts, calculate frame loss rate, and verify broadcast streams show suppression within 110% threshold while IPv4 stream forwards without loss.\",\n  \"Subtask 9\": \"Clear statistics and start traffic transmission from port2.\",\n  \"Subtask 10\": \"For each stream on port2: retrieve transmitted/received frame counts, calculate frame loss rate, and verify multicast/unknown unicast streams show suppression within 110% threshold.\",\n  \"Subtask 11\": \"Calculate storm control ratio deviation based on frame loss rates for all suppressed streams.\",\n  \"Subtask 12\": \"Release all reserved ports and perform cleanup operations.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective     : Test Objective : 6.5.7 Network Storm Control: Shall support broadcast, multicast, and unknown unicast storm control functions. Broadcast storm control is enabled by default.\n\nStep          : Test Step 1: Connect traffic generator to switch as shown in Figure 4;\n                Test Step 2: Set frame length to 64 bytes, port load to 100%, test duration 30s;\n                Test Step 3: Enable broadcast, multicast, and unknown unicast storm control functions on the switch;\n                Test Step 4: Use default suppression value or set suppression value to 1M;\n                Test Step 5: Port 1 sends 3 streams to Port 2: Stream1 (broadcast frames), Stream2 (broadcast frames), Stream3 (IPv4 frames). Port 2 sends 2 streams to Port 1: Stream1 (multicast frames), Stream2 (unknown unicast frames);\n                Test Step 6: Record frame loss rate for each stream to verify storm control configuration;\n                Test Step 7: Calculate storm control ratio deviation based on frame loss rate.\n\nCriteria      : Expected Result 1: Shall support broadcast, multicast, and unknown unicast storm control functions. Broadcast storm control is enabled by default;\n                Expected Result 2: Actual suppression value shall not exceed 110% of configured suppression value.\n\nCreated by    : Tester-008\n\nTags          : Function\n=================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        expected_value = 0.1 * 1.1\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 3 * 2\n\n            if round(prss, 2) < expected_value:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            prss = Result['RxStreamFrames'] / Result['TxStreamFrames'] / 2\n            if round(prss, 2) < expected_value:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功，且抑制比小于预设值', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_8/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.8 网络风暴抑制: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启\n\n Step\t\t\t:\t测试步骤1: 连接流量发生器与交换机，如图4 所示；\n                   测试步骤2: 测试帧长设为64，端口负载为满负载，测试时间30s；\n                   测试步骤3: 交换机分别开启广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能；\n                   测试步骤4: 设置抑制值为1M+粒度；\n                   测试步骤5: 端口1 向端口2 发送3 条数据流，分别为Stream1（广播帧）、Stream2（广播帧）、Stream3（IPv4 帧），端口2 向端口1 发送2 条数据流，分别为Stream1（组播帧）、Stream2（未知单播帧）；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断网络风暴抑制功能是否设置成功；\n                   测试步骤7: 根据帧丢失率，计算网络风暴抑制比偏差。\n\n Criteria    \t:   预期结果1: 应支持广播风暴抑制、组播风暴抑制和未知单播风暴抑制功能，默认设置广播风暴抑制功能开启；\n                   预期结果2: 网络风暴实际抑制值不应超过抑制设定值的110%。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective     : 6.5.8 Network Storm Suppression: Must support broadcast storm suppression, multicast storm suppression, and unknown unicast storm suppression functions. The broadcast storm suppression function is enabled by default.\n\nStep          : Step 1: Connect the traffic generator to the switch as shown in Figure 4;\n               Step 2: Set test frame length to 64, port load to full load, and test duration to 30 seconds;\n               Step 3: Enable broadcast storm suppression, multicast storm suppression, and unknown unicast storm suppression functions on the switch;\n               Step 4: Set suppression value to 1M+ granularity;\n               Step 5: Port 1 sends three data streams to Port 2: Stream1 (broadcast frame), Stream2 (broadcast frame), Stream3 (IPv4 frame). Port 2 sends two data streams to Port 1: Stream1 (multicast frame), Stream2 (unknown unicast frame);\n               Step 6: Record frame loss rates for each data stream and determine if network storm suppression is successfully configured;\n               Step 7: Calculate network storm suppression ratio deviation based on frame loss rates.\n\nCriteria      : Expected Result 1: Must support broadcast storm suppression, multicast storm suppression, and unknown unicast storm suppression functions. The broadcast storm suppression function is enabled by default;\n               Expected Result 2: Actual network storm suppression value must not exceed 110% of the configured suppression value.\n\nCreated by    : Tester-008\n\nTags          : function\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester and reserve ports according to the testbed configuration.\",\n  \"Subtask 2\": \"Configure switch settings: enable broadcast storm suppression (default), multicast storm suppression, and unknown unicast storm suppression with 1M+ granularity suppression value.\",\n  \"Subtask 3\": \"Set test parameters: frame length to 64 bytes, port load to 100%, and test duration to 30 seconds using edit_port_load_profile.\",\n  \"Subtask 4\": \"Create three streams on Port 1: Stream1 (broadcast frames), Stream2 (broadcast frames), Stream3 (IPv4 frames) with specified MAC addresses using add_stream, edit_stream, create_stream_header, and edit_header_ethernet.\",\n  \"Subtask 5\": \"Create two streams on Port 2: Stream1 (multicast frames), Stream2 (unknown unicast frames) with specified MAC addresses using add_stream, edit_stream, create_stream_header, and edit_header_ethernet.\",\n  \"Subtask 6\": \"Subscribe to StreamBlockStats view using subscribe_result and save test configuration with save_case.\",\n  \"Subtask 7\": \"Start all streams on Port 1 using start_stream, wait for transmission completion with wait_stream_state, then collect frame loss statistics using get_streamblock_statistic.\",\n  \"Subtask 8\": \"Verify broadcast streams (Stream1-2) show >99% frame loss indicating successful suppression, and IPv4 stream (Stream3) shows 0% frame loss indicating normal forwarding.\",\n  \"Subtask 9\": \"Clear statistics using clear_result.\",\n  \"Subtask 10\": \"Start all streams on Port 2 using start_stream, wait for transmission completion with wait_stream_state, then collect frame loss statistics using get_streamblock_statistic.\",\n  \"Subtask 11\": \"Verify multicast and unknown unicast streams (Port2 Stream1-2) show >99% frame loss indicating successful suppression.\",\n  \"Subtask 12\": \"Calculate actual suppression value from received frame rates and verify deviation does not exceed 110% of configured 1M+ suppression value.\",\n  \"Subtask 13\": \"Release reserved ports using release_port and shut down tester.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective     : 6.5.8 Network Storm Suppression: Must support broadcast storm suppression, multicast storm suppression, and unknown unicast storm suppression functions. The broadcast storm suppression function is enabled by default.\n\nStep          : Step 1: Connect the traffic generator to the switch as shown in Figure 4;\n               Step 2: Set test frame length to 64, port load to full load, and test duration to 30 seconds;\n               Step 3: Enable broadcast storm suppression, multicast storm suppression, and unknown unicast storm suppression functions on the switch;\n               Step 4: Set suppression value to 1M+ granularity;\n               Step 5: Port 1 sends three data streams to Port 2: Stream1 (broadcast frame), Stream2 (broadcast frame), Stream3 (IPv4 frame). Port 2 sends two data streams to Port 1: Stream1 (multicast frame), Stream2 (unknown unicast frame);\n               Step 6: Record frame loss rates for each data stream and determine if network storm suppression is successfully configured;\n               Step 7: Calculate network storm suppression ratio deviation based on frame loss rates.\n\nCriteria      : Expected Result 1: Must support broadcast storm suppression, multicast storm suppression, and unknown unicast storm suppression functions. The broadcast storm suppression function is enabled by default;\n               Expected Result 2: Actual network storm suppression value must not exceed 110% of the configured suppression value.\n\nCreated by    : Tester-008\n\nTags          : function\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2 = ports\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['ff:ff:ff:ff:ff:ff', '01:00:00:13:40:22', '00:00:01:13:40:22', '01:00:5E:00:01:01']\n    # 端口1创建流量\n    # 数据流 1：Stream1(广播帧)\n    stream = add_stream(Ports=port1, Names=f'Stream1(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    # 数据流 2：Stream2(广播帧)；\n    stream = add_stream(Ports=port1, Names=f'Stream2(广播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[0])\n    # 数据流 3：Stream3(IPv4帧)；\n    stream = add_stream(Ports=port1, Names=f'IPv4帧')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n\n    # 端口2创建流量\n    # 数据流 1：Stream1（组播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream2（组播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[3])\n    # 数据流 2：Stream2（未知单播帧)\n    stream = add_stream(Ports=port2, Names=f'Stream3（未知单播帧)')\n    edit_stream(Stream=stream, FixedLength=64)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[2])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=port1)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port1)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                if 'IPv4' in StreamBlockID:\n                    if Result['TxStreamFrames'] == Result['RxStreamFrames']:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发成功', step=5, result=True)\n                    else:\n                        CustomData.verdict, CustomData.errInfo = printf(\n                            message=f'{StreamBlockID}转发失败或者风暴抑制失败', step=5, result=False)\n\n        clear_result()\n        # 端口2测试\n        start_stream(Type='port', Objects=port2)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        streams_obj = get_streams(port2)\n        for stream in streams_obj:\n            # 获取流量统计结果\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'RxLossStreamFrames',\n                                                                        'RealtimeLossRate'])\n            StreamBlockID = Result['StreamBlockID']\n            if Result['RealtimeLossRate'] > 99:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制成功', step=5, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID}网络风暴抑制失败', step=5, result=False)\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_4/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.4 端口镜像:支持单端口镜像和多端口镜像，镜像端口在不丢失数据的前提下应保证系统要求的转发速率。\n\n Step\t\t\t:\t测试步骤1: 测试帧长度为 64 字节，测试时间不小于 30s；\n                   测试步骤2: 测试配置图如图 7 所示，交换机端口 4 设置成镜像端口，端口 1 和端口 3设置成被镜像端口，镜像方式为输入和输出同时镜像；\n                   测试步骤3: 端口 1 向端口 2 双向发送数据，端口 2 和端口 3 双向发送数据，负载率分别为 25%；\n\n Criteria    \t:   预期结果1: 记录端口 4 接收到的数据帧数量，判断镜像功能是否设置成功。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective      :   Test Purpose : 6.5.4 Port Mirroring: Supports single-port and multi-port mirroring. The mirror port shall maintain the system-required forwarding rate without packet loss.\n\nStep           :   Test Step 1: Frame length = 64 bytes, test duration ≥ 30s;\n                   Test Step 2: Test configuration as per Figure 7. Switch Port 4 configured as mirror port, Ports 1 and 3 as mirrored ports with bidirectional mirroring (input/output);\n                   Test Step 3: Port 1 ↔ Port 2 bidirectional transmission, Port 2 ↔ Port 3 bidirectional transmission, each at 25% load rate.\n\nCriteria       :   Expected Result 1: Record frame count received at Port 4 to verify mirroring configuration success.\n\nCreated by     :   Tester-008\n\nTags           :   function\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_25%')\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=25, Seconds=30)\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 流量\n    edit_port_load_profile(Ports=port2, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan200_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 25)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan100_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_stream_load_profile(Streams=stream, Rate= 25)\n\n    # 端口3创建绑定1-》2 绑定流量\n    edit_port_load_profile(Ports=port3, TransmitMode='TIME', Rate=25, Seconds=30)\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        #清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        result = get_port_statistic(StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port1_Result = get_port_statistic(Port=port1, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port3_Result = get_port_statistic(Port=port3, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port4_Result = get_port_statistic(Port=port4, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        MirrotFrames = Port1_Result['TxStreamFrames']+Port1_Result['RxSignatureStreamFrames']+Port3_Result['TxStreamFrames']+Port3_Result['RxSignatureStreamFrames']\n        RX_Result=Port4_Result['RxSignatureStreamFrames']\n        if MirrotFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is not equal to 0',\n                step=3, result=True)\n\n        if  MirrotFrames == RX_Result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is not equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "edit_stream_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_port_statistic:获取测试仪表端口统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using init_tester API.\",\n  \"Subtask 2\": \"Reserve ports 1, 2, 3, and 4 using reserve_port API with locations from configuration.\",\n  \"Subtask 3\": \"Configure switch settings: Set port 4 as mirror port, ports 1 and 3 as mirrored ports with bidirectional mirroring (input/output).\",\n  \"Subtask 4\": \"Edit port parameters (speed/duplex) per testbed configuration using edit_port API.\",\n  \"Subtask 5\": \"Create traffic streams: On port 1, add untagged TCP stream to port 2 with 64-byte frames and 25% load rate.\",\n  \"Subtask 6\": \"Create traffic streams: On port 2, add two VLAN-tagged TCP streams (VLAN 200 and VLAN 100) to port 3 with 64-byte frames and 25% load rate each.\",\n  \"Subtask 7\": \"Create traffic streams: On port 3, add untagged TCP stream to port 2 with 64-byte frames and 25% load rate.\",\n  \"Subtask 8\": \"Set all streams to 30-second duration using edit_stream_load_profile API.\",\n  \"Subtask 9\": \"Configure Ethernet headers for all streams with appropriate source/destination MAC addresses using edit_header_ethernet API.\",\n  \"Subtask 10\": \"Subscribe to PortStats view using subscribe_result API for statistics collection.\",\n  \"Subtask 11\": \"Start Layer 2 learning using start_l2_learning API and wait 5 seconds for MAC address stabilization.\",\n  \"Subtask 12\": \"Clear all port statistics using clear_result API.\",\n  \"Subtask 13\": \"Start all traffic streams simultaneously using start_stream API.\",\n  \"Subtask 14\": \"Wait for test duration completion (≥30 seconds) and verify streams stop using wait_stream_state API.\",\n  \"Subtask 15\": \"Collect port statistics: Get TxStreamFrames and RxSignatureStreamFrames for port 1 using get_port_statistic API.\",\n  \"Subtask 16\": \"Collect port statistics: Get TxStreamFrames and RxSignatureStreamFrames for port 3 using get_port_statistic API.\",\n  \"Subtask 17\": \"Collect port statistics: Get RxSignatureStreamFrames for mirror port 4 using get_port_statistic API.\",\n  \"Subtask 18\": \"Calculate total mirrored frames: Sum of (port 1 Tx + port 1 Rx + port 3 Tx + port 3 Rx) frames.\",\n  \"Subtask 19\": \"Verify mirroring success: Confirm port 4 received frames equal calculated total mirrored frames.\",\n  \"Subtask 20\": \"Release all reserved ports using release_port API.\",\n  \"Subtask 21\": \"Shutdown test instrument using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective      :   Test Purpose : 6.5.4 Port Mirroring: Supports single-port and multi-port mirroring. The mirror port shall maintain the system-required forwarding rate without packet loss.\n\nStep           :   Test Step 1: Frame length = 64 bytes, test duration ≥ 30s;\n                   Test Step 2: Test configuration as per Figure 7. Switch Port 4 configured as mirror port, Ports 1 and 3 as mirrored ports with bidirectional mirroring (input/output);\n                   Test Step 3: Port 1 ↔ Port 2 bidirectional transmission, Port 2 ↔ Port 3 bidirectional transmission, each at 25% load rate.\n\nCriteria       :   Expected Result 1: Record frame count received at Port 4 to verify mirroring configuration success.\n\nCreated by     :   Tester-008\n\nTags           :   function\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    port1, port2, port3, port4 = ports\n\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建绑定1-》2 流量\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_25%')\n    edit_port_load_profile(Ports=port1, TransmitMode='TIME', Rate=25, Seconds=30)\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 端口3创建创建绑定3-》2 流量\n    edit_port_load_profile(Ports=port2, LoadProfileType='STREAM_BASE',TransmitMode='TIME', Seconds=30)\n    # 数据流 1：vlan 200 的 tcp 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan200_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, ID=200)\n    edit_stream_load_profile(Streams=stream,Rate= 25)\n    # 数据流 2：vlan 4094 的 tcp 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_vlan100_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan','ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, ID=100)\n    edit_stream_load_profile(Streams=stream, Rate= 25)\n\n    # 端口3创建绑定1-》2 绑定流量\n    edit_port_load_profile(Ports=port3, TransmitMode='TIME', Rate=25, Seconds=30)\n    # 数据流 1：untag 的 tcp 报文\n    stream = add_stream(Ports=port3, Names=f'{port3.Name}_25%')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'tcp'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        #清空统计计数\n        clear_result()\n        # 启动流量测试\n        start_stream()\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(3)\n        # 检查统计结果\n        # 获取端口流量结果\n        result = get_port_statistic(StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port1_Result = get_port_statistic(Port=port1, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port3_Result = get_port_statistic(Port=port3, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        Port4_Result = get_port_statistic(Port=port4, StaItems=['TxStreamFrames', 'RxSignatureStreamFrames'])\n        MirrotFrames = Port1_Result['TxStreamFrames']+Port1_Result['RxSignatureStreamFrames']+Port3_Result['TxStreamFrames']+Port3_Result['RxSignatureStreamFrames']\n        RX_Result=Port4_Result['RxSignatureStreamFrames']\n        if MirrotFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port1.Name} TxStreamFrames is not equal to 0',\n                step=3, result=True)\n\n        if  MirrotFrames == RX_Result:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port4.Name} RxStreamFrames({RX_Result}) is not equal to TxStreamFrames({MirrotFrames})',\n                step=4, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nedit_stream_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_port_statistic:获取测试仪表端口统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_6/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  开放式最短路径优先路由协议（OSPF)\n\n Step\t\t\t:\t测试步骤1: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24；\n                   测试步骤2: DUT port1 IP地址为192.168.1.1/24，port2为 192.168.2.1/24；\n                   测试步骤3: 在DUT上配置OSPFv2路由协议；\n                   测试步骤4: 测试仪tester使用port1、port2建立OSPF路由器，在port1插入一些LSA，并使port1和DUT的port1达到FULL状态，port2和DUT的port2达到FULL状态，观察port2是否能得到port1的LSA。\n\n Criteria    \t:   预期结果1: ospf建立成功，可以收到lsa\n =================================================================================",
    "intent_en": "Objective: Open Shortest Path First routing protocol (OSPF)  \n\nStep 1: Tester port1 IP address is 192.168.1.100/24, port2 is 192.168.2.100/24;  \nStep 2: DUT port1 IP address is 192.168.1.1/24, port2 is 192.168.2.1/24;  \nStep 3: Configure OSPFv2 routing protocol on the DUT;  \nStep 4: The tester uses port1 and port2 to establish OSPF routers, injects LSAs on port1, ensures port1 and DUT's port1 reach FULL state, and port2 and DUT's port2 reach FULL state. Observe whether port2 receives the LSAs from port1.  \n\nCriteria 1: OSPF establishes successfully and LSAs are received.",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    #创建ospf协议\n    session_1 = create_ospf(Port=port_up, Priority=1)\n    session_2 = create_ospf(Port=port_down, Priority=2)\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    # OSPFv2协议会话1创建Summary Lsa\n    summary_lsa = create_ospf_summary_lsa(Session=session_1)\n\n    # OSPFv2协议会话2创建External Lsa\n    external_lsa = create_ospf_external_lsa(Session=session_2)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=summary_lsa)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        advertise_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n\n        # 发送流量\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        withdraw_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n        stop_protocol()\n        time.sleep(3)\n\n        # 获取OSPFv2会话1统计\n        import pandas\n        result = get_ospf_statistic()\n        print(result)\n        if not isinstance(result, pandas.DataFrame):\n            verdict = 'fail'\n\n        result = get_ospf_statistic(Session=session_1)\n        print(result)\n        TxSummaryLsa = result['TxSummaryLsa']\n        RxAsExternalLsa = result['RxAsExternalLsa']\n        print('TxSummaryLsa: {}'.format(TxSummaryLsa))\n        print('RxAsExternalLsa: {}'.format(RxAsExternalLsa))\n\n        # 获取OSPFv2会话2统计\n        result = get_ospf_statistic(Session=session_2)\n        print(result)\n        RxSummaryLsa = result['RxSummaryLsa']\n        TxAsExternalLsa = result['TxAsExternalLsa']\n        print('RxSummaryLsa: {}'.format(RxSummaryLsa))\n        print('TxAsExternalLsa: {}'.format(TxAsExternalLsa))\n\n        # 获取流量1统计\n        result = get_streamblock_statistic(Stream=streams[0])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name,TxStreamFrames,RxStreamFrames)\n\n        # 获取流量2统计\n\n        result = get_streamblock_statistic(Stream=streams[1])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name,TxStreamFrames,RxStreamFrames)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_ospf_lsa:通告 OSPFv2 协议会话 lsa",
      "create_ospf:创建OSPFv2协议会话对象",
      "create_ospf_external_lsa:创建OSPFv2 External LSA对象",
      "create_ospf_summary_lsa:创建OSPFv2 Summary LSA对象",
      "get_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象",
      "get_ospf_statistic:获取OSPFv2协议会话统计结果",
      "wait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态",
      "withdraw_ospf_lsa:撤销OSPFv2协议会话lsa",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester and reserve ports for both tester interfaces (port1 and port2) using reserve_port API.\",\n  \"Subtask 2\": \"Configure port parameters for both reserved ports using edit_port API as per testbed specifications.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both tester ports (port1 and port2) using create_interface API with specified IP addresses: 192.168.1.100/24 for port1 and 192.168.2.100/24 for port2.\",\n  \"Subtask 4\": \"Set MAC addresses and IPv4 gateways for both interfaces using edit_interface API, with gateways pointing to DUT ports (192.168.1.1 for port1 interface, 192.168.2.1 for port2 interface).\",\n  \"Subtask 5\": \"Create OSPFv2 sessions on both tester ports using create_ospf API with specified priorities (1 for port1, 2 for port2).\",\n  \"Subtask 6\": \"Bind the OSPFv2 sessions to their respective interfaces using select_interface API.\",\n  \"Subtask 7\": \"Create Summary LSA on port1's OSPF session using create_ospf_summary_lsa API.\",\n  \"Subtask 8\": \"Start OSPF protocol on both ports using start_protocol API.\",\n  \"Subtask 9\": \"Wait until both OSPF sessions reach FULL adjacency state with DUT ports using wait_ospf_adjacency_state API.\",\n  \"Subtask 10\": \"Advertise the created Summary LSA on port1 using advertise_ospf_lsa API.\",\n  \"Subtask 11\": \"Retrieve OSPF statistics for port2's session using get_ospf_statistic API and verify receipt of Summary LSA by checking RxSummaryLsa count.\",\n  \"Subtask 12\": \"Stop OSPF protocol using stop_protocol API and release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Open Shortest Path First routing protocol (OSPF)  \n\nStep 1: Tester port1 IP address is 192.168.1.100/24, port2 is 192.168.2.100/24;  \nStep 2: DUT port1 IP address is 192.168.1.1/24, port2 is 192.168.2.1/24;  \nStep 3: Configure OSPFv2 routing protocol on the DUT;  \nStep 4: The tester uses port1 and port2 to establish OSPF routers, injects LSAs on port1, ensures port1 and DUT's port1 reach FULL state, and port2 and DUT's port2 reach FULL state. Observe whether port2 receives the LSAs from port1.  \n\nCriteria 1: OSPF establishes successfully and LSAs are received.\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    #创建ospf协议\n    session_1 = create_ospf(Port=port_up, Priority=1)\n    session_2 = create_ospf(Port=port_down, Priority=2)\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    # OSPFv2协议会话1创建Summary Lsa\n    summary_lsa = create_ospf_summary_lsa(Session=session_1)\n\n    # OSPFv2协议会话2创建External Lsa\n    external_lsa = create_ospf_external_lsa(Session=session_2)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=summary_lsa)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 订阅统计\n\n    subscribe_result(Types=['Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        advertise_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n\n        # 发送流量\n        start_stream()\n        time.sleep(10)\n        stop_stream()\n        withdraw_ospf_lsa(Lsa=[summary_lsa, external_lsa])\n        time.sleep(5)\n        stop_protocol()\n        time.sleep(3)\n\n        # 获取OSPFv2会话1统计\n        import pandas\n        result = get_ospf_statistic()\n        print(result)\n        if not isinstance(result, pandas.DataFrame):\n            verdict = 'fail'\n\n        result = get_ospf_statistic(Session=session_1)\n        print(result)\n        TxSummaryLsa = result['TxSummaryLsa']\n        RxAsExternalLsa = result['RxAsExternalLsa']\n        print('TxSummaryLsa: {}'.format(TxSummaryLsa))\n        print('RxAsExternalLsa: {}'.format(RxAsExternalLsa))\n\n        # 获取OSPFv2会话2统计\n        result = get_ospf_statistic(Session=session_2)\n        print(result)\n        RxSummaryLsa = result['RxSummaryLsa']\n        TxAsExternalLsa = result['TxAsExternalLsa']\n        print('RxSummaryLsa: {}'.format(RxSummaryLsa))\n        print('TxAsExternalLsa: {}'.format(TxAsExternalLsa))\n\n        # 获取流量1统计\n        result = get_streamblock_statistic(Stream=streams[0])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[0].Name,TxStreamFrames,RxStreamFrames)\n\n        # 获取流量2统计\n\n        result = get_streamblock_statistic(Stream=streams[1])\n        print(result)\n        TxStreamFrames = result['TxStreamFrames']\n        RxStreamFrames = result['RxStreamFrames']\n        print('TxStreamFrames: {}'.format(TxStreamFrames))\n        print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n        if TxStreamFrames != RxStreamFrames:\n            verdict = 'fail'\n            errInfo += '{} TxStreamFrames({}) is not equal to RxStreamFrames({})\\n'.format(streams[1].Name,TxStreamFrames,RxStreamFrames)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_ospf_lsa:通告 OSPFv2 协议会话 lsa;\ncreate_ospf:创建OSPFv2协议会话对象;\ncreate_ospf_external_lsa:创建OSPFv2 External LSA对象;\ncreate_ospf_summary_lsa:创建OSPFv2 Summary LSA对象;\nget_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象;\nget_ospf_statistic:获取OSPFv2协议会话统计结果;\nwait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态;\nwithdraw_ospf_lsa:撤销OSPFv2协议会话lsa;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_4/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  6.7.4静态路由\n\n Step\t\t\t:\t测试步骤1: ：按图搭建测试环境\n                   测试步骤2: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24\n                   测试步骤3:  DUT1 port1 IP地址为192.168.1.1/24，port2 为1.1.1.1/24；\n                   测试步骤4:  DUT2 port2 IP地址为192.168.2.1/24，port1 为1.1.1.2/24；\n                   测试步骤5: 在DUT1、DUT2上配置tester port1和port2之间的静态路由；\n                   测试步骤6: 测试仪tester使用port1、port2发送双向数据流，检验连通性\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: 6.7.4 Static Routing  \n\nStep:  \nTest Step 1: Set up the test environment according to the diagram  \nTest Step 2: Configure tester port1 IP address as 192.168.1.100/24 and port2 as 192.168.2.100/24  \nTest Step 3: Configure DUT1 port1 IP address as 192.168.1.1/24 and port2 as 1.1.1.1/24  \nTest Step 4: Configure DUT2 port2 IP address as 192.168.2.1/24 and port1 as 1.1.1.2/24  \nTest Step 5: Configure static routing between tester port1 and port2 on DUT1 and DUT2  \nTest Step 6: The tester uses port1 and port2 to send bidirectional traffic to verify connectivity  \n\nCriteria:  \nExpected Result 1: The client can receive the correct address configuration  \n\nCreated by: Tester-006  \n\nBugs: None",
    "code": "import time\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    sip_address_list = ['192.168.1.100','192.168.2.100']\n    dip_address_list = ['192.168.3.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'stream1_2')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0])\n\n    stream = add_stream(Ports=port_down, Names=f'stream2_1')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[1], Destination=dip_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        if RxStreamFrames == TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is avaliable',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is not avaliable',\n                step=6, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument using init_tester API.\",\n  \"Subtask 2\": \"Reserve test ports based on configuration using reserve_port API.\",\n  \"Subtask 3\": \"Edit port parameters (if required) and wait for port status using edit_port and wait_port_state APIs.\",\n  \"Subtask 4\": \"Create IPv4 interfaces on both test ports using create_interface API.\",\n  \"Subtask 5\": \"Configure MAC addresses for both interfaces using edit_interface API on Ethernet layer.\",\n  \"Subtask 6\": \"Configure IPv4 addresses and gateways for both interfaces: port1 as 192.168.1.100/24 (gateway 192.168.1.1), port2 as 192.168.2.100/24 (gateway 192.168.2.1) using edit_interface API on IPv4 layer.\",\n  \"Subtask 7\": \"Set port load profile parameters: TransmitMode=TIME, Rate=100%, Duration=30 seconds using edit_port_load_profile API.\",\n  \"Subtask 8\": \"Create stream from port1 to destination 192.168.2.100: add_stream, create_stream_header (Ethernet+IPv4), and set IPv4 source=192.168.1.100, destination=192.168.2.100 using edit_header_ipv4.\",\n  \"Subtask 9\": \"Create stream from port2 to destination 192.168.1.100: add_stream, create_stream_header (Ethernet+IPv4), and set IPv4 source=192.168.2.100, destination=192.168.1.100 using edit_header_ipv4.\",\n  \"Subtask 10\": \"Subscribe to PortStats and StreamBlockStats views using subscribe_result API.\",\n  \"Subtask 11\": \"Save test configuration using save_case API.\",\n  \"Subtask 12\": \"Start bidirectional traffic transmission on both ports using start_stream API.\",\n  \"Subtask 13\": \"Wait for stream transmission completion using wait_stream_state API.\",\n  \"Subtask 14\": \"Retrieve and verify stream statistics: check TxStreamFrames > 0 using get_streamblock_statistic API.\",\n  \"Subtask 15\": \"Validate bidirectional connectivity: confirm RxStreamFrames match TxStreamFrames for both streams using get_streamblock_statistic API.\",\n  \"Subtask 16\": \"Clear statistical results using clear_result API.\",\n  \"Subtask 17\": \"Release reserved ports using release_port API.\",\n  \"Subtask 18\": \"Shutdown test instrument using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: 6.7.4 Static Routing  \n\nStep:  \nTest Step 1: Set up the test environment according to the diagram  \nTest Step 2: Configure tester port1 IP address as 192.168.1.100/24 and port2 as 192.168.2.100/24  \nTest Step 3: Configure DUT1 port1 IP address as 192.168.1.1/24 and port2 as 1.1.1.1/24  \nTest Step 4: Configure DUT2 port2 IP address as 192.168.2.1/24 and port1 as 1.1.1.2/24  \nTest Step 5: Configure static routing between tester port1 and port2 on DUT1 and DUT2  \nTest Step 6: The tester uses port1 and port2 to send bidirectional traffic to verify connectivity  \n\nCriteria:  \nExpected Result 1: The client can receive the correct address configuration  \n\nCreated by: Tester-006  \n\nBugs: None\n- Code Snippet: \n  ```python\n  import time\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    sip_address_list = ['192.168.1.100','192.168.2.100']\n    dip_address_list = ['192.168.3.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'stream1_2')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0])\n\n    stream = add_stream(Ports=port_down, Names=f'stream2_1')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[1], Destination=dip_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n\n        # 获取端口流量结果\n        Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        if TxStreamFrames == 0:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                step=3, result=False)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'{port_up.Name} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                step=3, result=True)\n\n        result = get_streamblock_statistic(Stream=stream,\n                                           StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxTotalBytes',\n                                                     'RxTotalBytes'])\n        RxStreamFrames = Result['RxStreamFrames']\n        if RxStreamFrames == TxStreamFrames:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is avaliable',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'stream is not avaliable',\n                step=6, result=False)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_1/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.1 虚拟局域网 VLAN 功能\n\n Step\t\t\t:\t测试步骤1: 测试帧长度为 128 字节，测试时间为 30；\n                   测试步骤2: 任意选取 3 个端口与测试仪相连接，测试配置图如图 6 所示；\n                   测试步骤3: 在测试仪端口 3 上构造 7 个数据流；\n                   测试步骤4: 交换机端口均设置为 untagged，端口 A 设置为 VLAN100，端口 B 设置为 VLAN4094，端口 C 设置为 TRUNK 口、VLAN1，其他端口默认设；\n                   测试步骤5: 网络测试仪端口 3 向端口 1、端口 2 分别以 10%负载发送数；\n                   测试步骤6: 记录不同数据流的帧丢失率，判断 VLAN 是否划分成功；\n                   测试步骤7: 在测试仪端口 1、端口 2 上构造以上 7 个数据；\n                   测试步骤8: 端口 1、端口 2 分别向端口 3 以 10%负载发送数据；\n                   测试步骤9: 记录不同数据流的帧丢失率，判断 VLAN TRUNK 是否成功。\n\n Criteria    \t:   预期结果1: 测试仪发送到交换机的数据流，若 VLAN ID 不同，则交换机丢弃该数据流（入口不透传）或转发至相应 VLAN 端口（入口透传）；若相同则转发至相同 VLAN 的端口。广播风暴仅可在 VLAN 内广播。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   6.5.1 Virtual Local Area Network (VLAN) Functionality\n\nStep\t\t\t:\tStep 1: Set test frame length to 128 bytes, test duration to 30 seconds;\n                   Step 2: Arbitrarily select 3 ports to connect to the tester; test configuration diagram shown in Figure 6;\n                   Step 3: Construct 7 data streams on tester port 3;\n                   Step 4: Set all switch ports to untagged; configure port A as VLAN100, port B as VLAN4094, port C as TRUNK port (VLAN1); other ports retain default settings;\n                   Step 5: Tester port 3 sends data to port 1 and port 2 at 10% load respectively;\n                   Step 6: Record frame loss rates for different data streams to determine VLAN segmentation success;\n                   Step 7: Construct the aforementioned 7 data streams on tester port 1 and port 2;\n                   Step 8: Port 1 and port 2 send data to port 3 at 10% load respectively;\n                   Step 9: Record frame loss rates for different data streams to determine VLAN TRUNK success.\n\nCriteria    \t:   Expected Result 1: For data streams sent from tester to switch:\n                   - If VLAN IDs differ, switch discards stream (non-pass-through ingress) or forwards to corresponding VLAN port (pass-through ingress);\n                   - If VLAN IDs match, forwards to ports in same VLAN.\n                   Broadcast storms are confined within the VLAN.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   function\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n\n    # 端口1创建流量\n    mac_address_list = ['00:02:00:00:00:01', '00:02:00:00:00:02', '00:02:00:00:00:03']\n    vlan_id_list = [100, 4094, 1]\n\n    # interfaces_1 = create_interface(Port=ports[0], Layers=['eth', 'vlan'])\n    # interfaces_2 = create_interface(Port=ports[1], Layers=['eth', 'vlan'])\n    # interfaces_3 = create_interface(Port=ports[2], Layers=['eth', 'vlan'])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[2])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[2])\n\n    streams = {}\n    # 端口创建7条流量\n    number = -1\n    for port in ports:\n        number += 1\n        test_mac_address = mac_address_list.copy()\n        source_mac = test_mac_address.pop(number)\n        # 数据流 1：无 VID 标识 IPv4 报文\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 2：VID 为 100 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 3：VID 为 4094 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 4：无 VID 标识的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n        # 数据流 5：VID 为 100 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 6：VID 为 4094 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 7：广播报文，无 VID 标识；\n        stream_port1_VID_100 = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Broadcast')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream_port1_VID_100, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream_port1_VID_100, SourceMacAdd=source_mac,\n                                      DestMacAdd='ff:ff:ff:ff:ff:ff')\n        streams.update({stream[0].Name: stream})\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 步骤5：端口3发流量测试\n        printf(message='step5：port3 start stream')\n        start_stream(Type='port', Objects=ports[2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step6：get port3 stream statistic')\n        # 获取端口3下所有流量统计结果\n        streams_obj = get_streams(ports[2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=6, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=6, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0', step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0', step=6,\n                        result=False)\n            if 'VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_1':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n            if 'VID_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n        clear_result()\n        # 步骤8：端口1，2发流量测试\n        printf(message='step8：port1,port2 start stream')\n        start_stream(Type='port', Objects=ports[:2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，3口收到报文\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=9, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=9, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}))',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=9, result=False)\n            if 'Port_1_VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_3':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            if 'Port_2_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            else:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0,RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0',\n                        step=9, result=True)\n\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the network tester and reserve 3 test ports according to the test configuration diagram.\",\n  \"Subtask 2\": \"Set frame length to 128 bytes and test duration to 30 seconds for all test ports using port load profile configuration.\",\n  \"Subtask 3\": \"Configure the switch ports: set all ports to untagged mode, assign port A to VLAN100, port B to VLAN4094, and port C as TRUNK port (VLAN1).\",\n  \"Subtask 4\": \"Create 7 data streams on tester port 3 with specified characteristics: no VLAN/IPv4, VLAN100/IPv4, VLAN4094/IPv4, no VLAN/multicast, VLAN100/multicast, VLAN4094/multicast, no VLAN/broadcast.\",\n  \"Subtask 5\": \"Start transmission of all streams from port 3 to ports 1 and 2 at 10% load rate.\",\n  \"Subtask 6\": \"Collect and analyze frame loss statistics for each stream on ports 1 and 2 to verify VLAN segmentation behavior: confirm non-matching VLANs are discarded/forwarded correctly and broadcast storms are contained within VLAN.\",\n  \"Subtask 7\": \"Create identical 7 data streams on tester ports 1 and 2 with the same stream characteristics.\",\n  \"Subtask 8\": \"Start transmission of all streams from ports 1 and 2 to port 3 at 10% load rate.\",\n  \"Subtask 9\": \"Collect and analyze frame loss statistics for each stream on port 3 to verify VLAN TRUNK functionality: confirm proper forwarding behavior between VLAN ports.\",\n  \"Subtask 10\": \"Release all reserved test ports and shut down the tester after completing measurements.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   6.5.1 Virtual Local Area Network (VLAN) Functionality\n\nStep\t\t\t:\tStep 1: Set test frame length to 128 bytes, test duration to 30 seconds;\n                   Step 2: Arbitrarily select 3 ports to connect to the tester; test configuration diagram shown in Figure 6;\n                   Step 3: Construct 7 data streams on tester port 3;\n                   Step 4: Set all switch ports to untagged; configure port A as VLAN100, port B as VLAN4094, port C as TRUNK port (VLAN1); other ports retain default settings;\n                   Step 5: Tester port 3 sends data to port 1 and port 2 at 10% load respectively;\n                   Step 6: Record frame loss rates for different data streams to determine VLAN segmentation success;\n                   Step 7: Construct the aforementioned 7 data streams on tester port 1 and port 2;\n                   Step 8: Port 1 and port 2 send data to port 3 at 10% load respectively;\n                   Step 9: Record frame loss rates for different data streams to determine VLAN TRUNK success.\n\nCriteria    \t:   Expected Result 1: For data streams sent from tester to switch:\n                   - If VLAN IDs differ, switch discards stream (non-pass-through ingress) or forwards to corresponding VLAN port (pass-through ingress);\n                   - If VLAN IDs match, forwards to ports in same VLAN.\n                   Broadcast storms are confined within the VLAN.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   function\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=10, Seconds=30)\n\n    # 端口1创建流量\n    mac_address_list = ['00:02:00:00:00:01', '00:02:00:00:00:02', '00:02:00:00:00:03']\n    vlan_id_list = [100, 4094, 1]\n\n    # interfaces_1 = create_interface(Port=ports[0], Layers=['eth', 'vlan'])\n    # interfaces_2 = create_interface(Port=ports[1], Layers=['eth', 'vlan'])\n    # interfaces_3 = create_interface(Port=ports[2], Layers=['eth', 'vlan'])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='EthIILayer',\n    #                Address=mac_address_list[2])\n    # edit_interface(Interface=interfaces_1,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[0])\n    # edit_interface(Interface=interfaces_2,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[1])\n    # edit_interface(Interface=interfaces_3,\n    #                Layer='VLANLayer',\n    #                VlanId=vlan_id_list[2])\n\n    streams = {}\n    # 端口创建7条流量\n    number = -1\n    for port in ports:\n        number += 1\n        test_mac_address = mac_address_list.copy()\n        source_mac = test_mac_address.pop(number)\n        # 数据流 1：无 VID 标识 IPv4 报文\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 2：VID 为 100 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 3：VID 为 4094 的 IPv4 报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 4：无 VID 标识的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n        # 数据流 5：VID 为 100 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_100_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[0])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 6：VID 为 4094 的组播报文；\n        stream = add_stream(Ports=port, Names=f'{port.Name}_VID_4094_Multicast ')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream, SourceMacAdd=source_mac, DestMacAdd=mac_address_list[1])\n        edit_modifier(Stream=stream, Attribute=params['DestMacAdd'], Type='List', List=test_mac_address,\n                      StreamType='InterModifier')\n        edit_header_vlan(Stream=stream, ID=vlan_id_list[1])\n        edit_header_ipv4(Stream=stream, Destination='225.0.0.1')\n        streams.update({stream[0].Name: stream})\n\n        # 数据流 7：广播报文，无 VID 标识；\n        stream_port1_VID_100 = add_stream(Ports=port, Names=f'{port.Name}_VID_NO_Broadcast')\n        edit_stream(Stream=stream, FixedLength=128)\n        create_stream_header(Stream=stream_port1_VID_100, HeaderTypes=['ethernetii', 'ipv4'])\n        params = edit_header_ethernet(Stream=stream_port1_VID_100, SourceMacAdd=source_mac,\n                                      DestMacAdd='ff:ff:ff:ff:ff:ff')\n        streams.update({stream[0].Name: stream})\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 步骤5：端口3发流量测试\n        printf(message='step5：port3 start stream')\n        start_stream(Type='port', Objects=ports[2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，1,2口没有收到报文\n        printf(message='step6：get port3 stream statistic')\n        # 获取端口3下所有流量统计结果\n        streams_obj = get_streams(ports[2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=6, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=6, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0', step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0', step=6,\n                        result=False)\n            if 'VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_1':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n            if 'VID_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=6, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=6,\n                        result=False)\n        clear_result()\n        # 步骤8：端口1，2发流量测试\n        printf(message='step8：port1,port2 start stream')\n        start_stream(Type='port', Objects=ports[:2])\n        time.sleep(5)\n        wait_stream_state()\n\n        # 检查统计结果，3口收到报文\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['StreamBlockID', 'RxPortID', 'TxStreamFrames',\n                                                                        'RxStreamFrames', 'TxTotalBytes',\n                                                                        'RxTotalBytes'])\n            # 判断流量是否发出\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            StreamBlockID = Result['StreamBlockID']\n            RxPortID = Result['RxPortID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0', step=9, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0', step=9, result=True)\n\n            if 'VID_NO' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}))',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=9, result=False)\n            if 'Port_1_VID_100' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_3':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            if 'Port_2_4094' in StreamBlockID:\n                if RxStreamFrames == TxStreamFrames and RxPortID == 'Port_2':\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames}),RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})) or RxPortID is not({RxPortID})',\n                        step=9,\n                        result=False)\n            else:\n                if RxStreamFrames == 0:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to 0,RxPortID is ({RxPortID})',\n                        step=9, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to 0',\n                        step=9, result=True)\n\n        # 释放端口资源\n        release_port(locations)\n        printf(message='Test completed')\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_3/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.3 端口吞吐量\n\n Step\t\t\t:\t测试步骤1: 按照 RFC 2544 中规定，将交换机任意两个同类型端口与测试仪相连接，见图 3；\n                   测试步骤2: 配置流量发生器：测试帧长度分别为（64、65、256、1024、1518）字节；\n                   测试步骤3: 测试时间为 60s。\n\n Criteria    \t:   预期结果1: 技术要求吞吐量为100%。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective     : Objective: 6.4.3 Port Throughput\n\nStep          : Test Step 1: According to RFC 2544, connect any two ports of the same type on the switch to the tester, as shown in Figure 3;\n                Test Step 2: Configure the traffic generator: test frame lengths are (64, 65, 256, 1024, 1518) bytes;\n                Test Step 3: Test duration is 60 seconds.\n\nCriteria      : Expected Result 1: The technical requirement for throughput is 100%.\n\nCreated by    : Tester-001\n\nTags          : performance\n=================================================================================",
    "code": "import sys\nimport os\nimport time\n\nstart_time=time.time()\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_search(Config=Config, Mode='binary', Init=cfg['arg']['search']['default']['init']['default'],\n                          Lower=cfg['arg']['search']['default']['lower']['default'], Upper=cfg['arg']['search']['default']['upper']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester API to prepare the testing environment.\",\n  \"Subtask 2\": \"Reserve two test ports using reserve_port API based on testbed configuration locations.\",\n  \"Subtask 3\": \"Configure reserved ports' parameters using edit_port API with testbed settings.\",\n  \"Subtask 4\": \"Wait for ports to reach operational state using wait_port_state API.\",\n  \"Subtask 5\": \"Create Ethernet interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 6\": \"Configure source and destination MAC addresses for interfaces using edit_interface API.\",\n  \"Subtask 7\": \"Retrieve Ethernet layer objects from interfaces using get_layer_from_interfaces API.\",\n  \"Subtask 8\": \"Create bidirectional traffic stream between Ethernet layers using add_stream API.\",\n  \"Subtask 9\": \"Create RFC2544 throughput benchmark suite using create_benchmark API.\",\n  \"Subtask 10\": \"Assign reserved ports to benchmark suite using relate_benchmark_ports API.\",\n  \"Subtask 11\": \"Configure benchmark to use pre-created traffic stream using benchmark_stream_use_exist API.\",\n  \"Subtask 12\": \"Set benchmark MAC learning to occur once before test using edit_benchmark_learning API.\",\n  \"Subtask 13\": \"Configure test duration to 60 seconds using edit_benchmark_duration API.\",\n  \"Subtask 14\": \"Set frame sizes to (64, 65, 256, 1024, 1518) bytes using edit_benchmark_frame API.\",\n  \"Subtask 15\": \"Configure binary search parameters for throughput test using edit_benchmark_search API.\",\n  \"Subtask 16\": \"Generate benchmark configuration using expand_benchmark API.\",\n  \"Subtask 17\": \"Save test configuration using save_case API.\",\n  \"Subtask 18\": \"Execute benchmark test using run_benchmark API with 3600s timeout.\",\n  \"Subtask 19\": \"Retrieve throughput results using get_benchmark_result API.\",\n  \"Subtask 20\": \"Verify throughput results meet 100% requirement for all frame sizes.\",\n  \"Subtask 21\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective     : Objective: 6.4.3 Port Throughput\n\nStep          : Test Step 1: According to RFC 2544, connect any two ports of the same type on the switch to the tester, as shown in Figure 3;\n                Test Step 2: Configure the traffic generator: test frame lengths are (64, 65, 256, 1024, 1518) bytes;\n                Test Step 3: Test duration is 60 seconds.\n\nCriteria      : Expected Result 1: The technical requirement for throughput is 100%.\n\nCreated by    : Tester-001\n\nTags          : performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\nimport time\n\nstart_time=time.time()\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_search(Config=Config, Mode='binary', Init=cfg['arg']['search']['default']['init']['default'],\n                          Lower=cfg['arg']['search']['default']['lower']['default'], Upper=cfg['arg']['search']['default']['upper']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_4/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.4 存储转发时延\n\n Step\t\t\t:\t测试步骤1: 按照图 4，将交换机任意两个同类型端口与测试仪相连接；\n                   测试步骤2: 两个端口同时以相应负载互相发送数据，测试帧长度分别为（64、65、256、1024、1518）字节，测试时间为 60s；负载率设置为：重载 95%，轻载10%；\n                   测试步骤3: 记录不同帧长的平均存储转发时延。\n\n Criteria    \t:   预期结果1: 技术要求平均时延应小于10µs。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   Test Objective: 6.4.4 Store-and-Forward Delay\n\nStep\t\t\t:\tTest Step 1: According to Figure 4, connect any two same-type ports of the switch to the tester;\n                    Test Step 2: Both ports simultaneously send data to each other with corresponding loads. Test frame lengths are (64, 65, 256, 1024, 1518) bytes, with a test duration of 60 seconds. Load rates set to: heavy load 95%, light load 10%;\n                    Test Step 3: Record the average store-and-forward delay for different frame lengths.\n\nCriteria    \t:   Expected Result 1: The technical requirement specifies that the average delay must be less than 10µs.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================",
    "code": "import sys\nimport os\nimport time\n\nstart_time=time.time()\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        print(\"111\",testbed['tester']['rtsm']['ip'])\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    print(\"port_up\",port_up)\n    print(\"port_down\", port_down)\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    for k, v in testbed['tester'].items():\n        edit_port_kwargs = {}\n        if k in edit_port_params:\n            edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    print(\"interfaces_up\", interfaces_up)\n    print(\"interfaces_down\", interfaces_down)\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['latency'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using the init_tester API to establish communication with the test equipment.\",\n  \"Subtask 2\": \"Reserve two same-type test ports using reserve_port API based on configuration parameters.\",\n  \"Subtask 3\": \"Configure port parameters using edit_port API with settings from the testbed configuration.\",\n  \"Subtask 4\": \"Create Ethernet interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 5\": \"Set MAC addresses for both interfaces using edit_interface API as per configuration specifications.\",\n  \"Subtask 6\": \"Create bidirectional traffic streams between the interfaces using add_stream API with Bidirection=True.\",\n  \"Subtask 7\": \"Create RFC2544 benchmark for latency measurement using create_benchmark API.\",\n  \"Subtask 8\": \"Assign reserved ports to the benchmark using relate_benchmark_ports API.\",\n  \"Subtask 9\": \"Configure benchmark to use existing streams using benchmark_stream_use_exist API.\",\n  \"Subtask 10\": \"Set benchmark address learning to 'once' with edit_benchmark_learning API.\",\n  \"Subtask 11\": \"Configure test duration to 60 seconds using edit_benchmark_duration API.\",\n  \"Subtask 12\": \"Set custom frame sizes [64, 65, 256, 1024, 1518] bytes using edit_benchmark_frame API.\",\n  \"Subtask 13\": \"Configure traffic loads [10%, 95%] using edit_benchmark_traffic_load_loop API with LoadMode='custom'.\",\n  \"Subtask 14\": \"Generate test configuration using expand_benchmark API.\",\n  \"Subtask 15\": \"Save test configuration using save_case API.\",\n  \"Subtask 16\": \"Execute benchmark test using run_benchmark API with 60-second duration.\",\n  \"Subtask 17\": \"Retrieve latency results using get_benchmark_result API with ReturnType='dataframe'.\",\n  \"Subtask 18\": \"Verify average store-and-forward delay is below 10µs for all frame sizes and loads.\",\n  \"Subtask 19\": \"Release test ports using release_port API.\",\n  \"Subtask 20\": \"Shutdown tester connection using shutdown_tester API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective   \t:   Test Objective: 6.4.4 Store-and-Forward Delay\n\nStep\t\t\t:\tTest Step 1: According to Figure 4, connect any two same-type ports of the switch to the tester;\n                    Test Step 2: Both ports simultaneously send data to each other with corresponding loads. Test frame lengths are (64, 65, 256, 1024, 1518) bytes, with a test duration of 60 seconds. Load rates set to: heavy load 95%, light load 10%;\n                    Test Step 3: Record the average store-and-forward delay for different frame lengths.\n\nCriteria    \t:   Expected Result 1: The technical requirement specifies that the average delay must be less than 10µs.\n\nCreated by   \t:   Tester-001\n\nTags   \t    :   performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\nimport time\n\nstart_time=time.time()\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        print(\"111\",testbed['tester']['rtsm']['ip'])\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    print(\"port_up\",port_up)\n    print(\"port_down\", port_down)\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    for k, v in testbed['tester'].items():\n        edit_port_kwargs = {}\n        if k in edit_port_params:\n            edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    print(\"interfaces_up\", interfaces_up)\n    print(\"interfaces_down\", interfaces_down)\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['latency'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n\nend_time=time.time()\nprint(\"用时\",end_time-start_time)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_2/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :  6.7.2互联网控制消息协议（ICMP）\n\n Step\t\t\t:\t测试步骤1: ：按图10搭建测试环境\n                   测试步骤2: tester port1 地址为 192.168.1.100/24，port2 地址为192.168.2.100/24\n                   测试步骤3: DUT port1 地址为192.168.1.1/24，port2 地址为192.168.2.1/24\n                   测试步骤4: tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n                   测试步骤5: tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n                   测试步骤6: tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n                   测试步骤7: tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n\n Criteria    \t:   预期结果1: 客户端能接收到正确的地址配置\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: 6.7.2 Internet Control Message Protocol (ICMP)\n\nStep: Test Step 1: Set up test environment according to Figure 10\n      Test Step 2: Tester Port1 address: 192.168.1.100/24, Port2 address: 192.168.2.100/24\n      Test Step 3: DUT Port1 address: 192.168.1.1/24, Port2 address: 192.168.2.1/24\n      Test Step 4: Send ping packet from Tester Port1 to 192.168.1.1, observe if correct response is received\n      Test Step 5: Send IP packet from Tester Port1 to 192.168.3.1, observe if correct response (Network Unreachable, Type 3, Code 0) is received\n      Test Step 6: Send IP packet with protocol number 100 from Tester Port1 to 192.168.1.1, observe if correct response (Protocol Unreachable, Type 3, Code 2) is received\n      Test Step 7: Send IP packet with protocol number 17 and port 100 from Tester Port1 to 192.168.1.1, observe if correct response (Port Unreachable, Type 3, Code 3) is received\n\nCriteria: Expected Result 1: Client can receive correct address configuration\n\nCreated by: Tester-006\n\nBugs: None\n=================================================================================",
    "code": "import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # edit_port_load_profile(Ports=port_up, TransmitMode='TIME', Rate=1, Seconds=30)\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['192.168.3.1 ','192.168.1.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'step5')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0], Gateway='192.168.1.1')\n\n    # step6 tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n    stream = add_stream(Ports=port_up, Names=f'step6')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=100, Gateway='192.168.1.1')\n\n    # step7 tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n    stream = add_stream(Ports=port_up, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=17, Gateway='192.168.1.1')\n    edit_header_udp(Stream=stream, SourcePort=100)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.1.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n\n        stream1, stream2, stream3 = get_streams(Ports=port_up)\n        # 端口1测试\n        net_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step5', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '0' and pkt.icmp.type == '3':\n                net_unreached_pkt.append(pkt)\n\n        if len(net_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到网络不可达报文，类型为 3，编码为 0',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到网络不可达报文',\n                step=5, result=False)\n\n        protocol_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '2' and pkt.icmp.type == '3':\n                protocol_unreached_pkt.append(pkt)\n        if len(protocol_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到协议不可达报文，类型为 3，编码为 2',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到协议不可达报文',\n                step=6, result=False)\n\n        port_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream3)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '3' and pkt.icmp.code == '3':\n                port_unreached_pkt.append(pkt)\n\n        if len(port_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到端口不可达报文，类型为 3，编码为 3',\n                step=7, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到端口不可达报文',\n                step=7, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "edit_header_udp:修改测试仪表流量模板中UDP报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l3_learning:启动测试仪表流量三层ARP ND学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester system and reserve required testing ports based on configuration parameters.\",\n  \"Subtask 2\": \"Configure port parameters including force, debug, and wait-for-status-up settings, then wait for ports to reach operational state.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on tester ports with specified IP addresses (192.168.1.100/24) and gateways (192.168.1.1).\",\n  \"Subtask 4\": \"Configure port load profiles with continuous transmission mode at 100 frames per second.\",\n  \"Subtask 5\": \"Create and configure three test streams: Stream1 (destination 192.168.3.1), Stream2 (protocol 100 to 192.168.1.1), Stream3 (UDP port 100 to 192.168.1.1) with appropriate Ethernet/IPv4/UDP headers.\",\n  \"Subtask 6\": \"Save test configuration to case file and subscribe to port statistics monitoring.\",\n  \"Subtask 7\": \"Execute ICMP ping test from Tester Port1 to 192.168.1.1 and verify response reception.\",\n  \"Subtask 8\": \"For Stream1: Start Layer3 learning, capture traffic, transmit stream to 192.168.3.1, then analyze captured packets for ICMP Network Unreachable (Type=3, Code=0).\",\n  \"Subtask 9\": \"For Stream2: Start Layer3 learning, capture traffic, transmit stream with protocol 100 to 192.168.1.1, then analyze captured packets for ICMP Protocol Unreachable (Type=3, Code=2).\",\n  \"Subtask 10\": \"For Stream3: Start Layer3 learning, capture traffic, transmit UDP stream to port 100 at 192.168.1.1, then analyze captured packets for ICMP Port Unreachable (Type=3, Code=3).\",\n  \"Subtask 11\": \"Release reserved ports and perform test environment teardown after completion.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: 6.7.2 Internet Control Message Protocol (ICMP)\n\nStep: Test Step 1: Set up test environment according to Figure 10\n      Test Step 2: Tester Port1 address: 192.168.1.100/24, Port2 address: 192.168.2.100/24\n      Test Step 3: DUT Port1 address: 192.168.1.1/24, Port2 address: 192.168.2.1/24\n      Test Step 4: Send ping packet from Tester Port1 to 192.168.1.1, observe if correct response is received\n      Test Step 5: Send IP packet from Tester Port1 to 192.168.3.1, observe if correct response (Network Unreachable, Type 3, Code 0) is received\n      Test Step 6: Send IP packet with protocol number 100 from Tester Port1 to 192.168.1.1, observe if correct response (Protocol Unreachable, Type 3, Code 2) is received\n      Test Step 7: Send IP packet with protocol number 17 and port 100 from Tester Port1 to 192.168.1.1, observe if correct response (Port Unreachable, Type 3, Code 3) is received\n\nCriteria: Expected Result 1: Client can receive correct address configuration\n\nCreated by: Tester-006\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  import time\nimport sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pandas\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'],\n                         Debug=testbed['tester']['debug']['default'],\n                         WaitForStatusUp=testbed['tester']['wait_for_status_up']['default'])\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'],\n                  username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'],\n                  content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    # edit_port_load_profile(Ports=port_up, TransmitMode='TIME', Rate=1, Seconds=30)\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=100)\n    sip_address_list = ['192.168.1.100']\n    dip_address_list = ['192.168.3.1 ','192.168.1.1']\n\n    # step5：tester port1 向 192.168.3.1 发送 ip 包，观察是否能收到正确的响应（网络不可达，类型为3，编码为0）；\n    stream = add_stream(Ports=port_up, Names=f'step5')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[0], Gateway='192.168.1.1')\n\n    # step6 tester port1 向 192.168.1.1 发送 ip 包，协议号为100，观察是否能收到正确的响应（协议不可达，类型为3，编码为2）\n    stream = add_stream(Ports=port_up, Names=f'step6')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=100, Gateway='192.168.1.1')\n\n    # step7 tester port1 向 192.168.1.1 发送 ip 包，协议号为17端口为100，观察是否能收到正确的响应（端口不可达，类型为3，编码为3）\n    stream = add_stream(Ports=port_up, Names=f'step7')\n    edit_stream(Stream=stream, FixedLength=128)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4', 'udp'])\n    edit_header_ipv4(Stream=stream, Source=sip_address_list[0], Destination=dip_address_list[1],Protocol=17, Gateway='192.168.1.1')\n    edit_header_udp(Stream=stream, SourcePort=100)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # tester port1 向 192.168.1.1 发送 ping 包，观察是否能收到正确的响应；\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.1.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n\n        stream1, stream2, stream3 = get_streams(Ports=port_up)\n        # 端口1测试\n        net_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step5', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '0' and pkt.icmp.type == '3':\n                net_unreached_pkt.append(pkt)\n\n        if len(net_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到网络不可达报文，类型为 3，编码为 0',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到网络不可达报文',\n                step=5, result=False)\n\n        protocol_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream2)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '2' and pkt.icmp.type == '3':\n                protocol_unreached_pkt.append(pkt)\n        if len(protocol_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到协议不可达报文，类型为 3，编码为 2',\n                step=6, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到协议不可达报文',\n                step=6, result=False)\n\n        port_unreached_pkt = []\n        start_l3_learning()\n        time.sleep(5)\n        start_capture(Ports=port_up)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream3)\n        time.sleep(10)\n        stop_stream()\n        stop_capture(Ports=port_up)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port_up, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='icmp.type == 3')\n        for pkt in cap:\n            if pkt.icmp.code == '3' and pkt.icmp.code == '3':\n                port_unreached_pkt.append(pkt)\n\n        if len(port_unreached_pkt) > 1:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 收到端口不可达报文，类型为 3，编码为 3',\n                step=7, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'tester port1 没有收到端口不可达报文',\n                step=7, result=False)\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nedit_header_udp:修改测试仪表流量模板中UDP报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l3_learning:启动测试仪表流量三层ARP ND学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_5/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.5 路由信息协议（RIP）\n\n Step\t\t\t:\t测试步骤1: 按图4，任选交换机两个端口作为测试端口；\n                   测试步骤2:  tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24;\n                   测试步骤3:  DUT1 port1 IP 地 址 为 192.168.1.1/24 ， port2 IP 地 址 为192.168.2.1/24\n                   测试步骤3:  在DUT上配置RIPv2路由协议；\n                   测试步骤3:   tester port1 从 UDP端口520向组播地址224.0.0.9的520 UDP端口发\n                               送地址簇为2，RIP条目为192.168.4.0/255.255.255.0/8 的RIPv2 应答报\n                               文，周期为1s，观察DUT的路由表变化，观察testerport2是否收到路由更新报文；\n                   测试步骤3:  停止发送步骤6的报文，tester port1 从UDP端口520向组播地址\n                               224.0.0.9 的 520 UDP 端 口 发 送 地 址 簇 为 2 ， RIP 条 目 为\n                               192.168.4.0/255.255.255.0/6 的 RIPv2 应答报文，周期为 1s，观察 DUT\n                               的路由表变化，观察tester port2是否收到路由更新报文；\n                   测试步骤3:   停止发送步骤7的报文，tester port1 从UDP端口520向组播地址\n                               224.0.0.9 的 520 UDP 端 口 发 送 地 址 簇 为 2 ， RIP 条 目 为\n                               192.168.4.0/255.255.255.0/10 的 RIPv2 应答报文，周期为 1s，观察 DUT\n                               的路由表变化，观察tester port2是否收到路由更新报文\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: 6.7.5 Routing Information Protocol (RIP)\n\nStep: Test Step 1: According to Figure 4, select any two ports of the switch as test ports;\nTest Step 2: Tester port1 IP address is 192.168.1.100/24, port2 is 192.168.2.100/24;\nTest Step 3: DUT1 port1 IP address is 192.168.1.1/24, port2 IP address is 192.168.2.1/24;\nTest Step 3: Configure the RIPv2 routing protocol on the DUT;\nTest Step 3: Tester port1 sends RIPv2 response packets from UDP port 520 to multicast address 224.0.0.9 UDP port 520, with address family 2 and RIP entry 192.168.4.0/255.255.255.0/8, at a period of 1s; observe DUT's routing table changes and whether tester port2 receives routing update packets;\nTest Step 3: Stop sending packets from Step 6; tester port1 sends RIPv2 response packets from UDP port 520 to multicast address 224.0.0.9 UDP port 520, with address family 2 and RIP entry 192.168.4.0/255.255.255.0/6, at a period of 1s; observe DUT's routing table changes and whether tester port2 receives routing update packets;\nTest Step 3: Stop sending packets from Step 7; tester port1 sends RIPv2 response packets from UDP port 520 to multicast address 224.0.0.9 UDP port 520, with address family 2 and RIP entry 192.168.4.0/255.255.255.0/10, at a period of 1s; observe DUT's routing table changes and whether tester port2 receives routing update packets;\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建RIP协议会话\n    session_1 = create_rip(Port=port_up)\n    session_2 = create_rip(Port=port_down)\n\n    # RIP协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    #创建流量\n    port1, port2 = ports\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n\n        route = create_rip_ipv4_route(Session=session_1, StartIpv4Prefix='192.168.4.0', Increment=8)\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 6\n        save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 10\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step8', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "download_packages:下载指定端口捕获到的数据包",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_rip:通告RIP协议路由",
      "create_rip:创建RIP协议会话对象",
      "create_rip_ipv4_route:创建RIP IPv4路由对象",
      "wait_rip_state:等待RIP协议会话达到指定状态",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester system and reserve two test ports as specified in the testbed configuration.\",\n  \"Subtask 2\": \"Configure tester port parameters including force, debug, and wait_for_status_up settings based on testbed specifications.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both reserved ports with MAC addresses, IP addresses (192.168.1.100/24 for port1, 192.168.2.100/24 for port2), and gateways (192.168.1.1 for port1, 192.168.2.1 for port2).\",\n  \"Subtask 4\": \"Create RIPv2 protocol sessions on both tester ports and bind each session to its respective interface.\",\n  \"Subtask 5\": \"Create an RIP IPv4 route object on port1's session with StartIpv4Prefix='192.168.4.0' and Increment=8.\",\n  \"Subtask 6\": \"Start RIP protocol on both sessions and wait until both sessions reach the established state.\",\n  \"Subtask 7\": \"Start packet capture on port2 to monitor routing update packets.\",\n  \"Subtask 8\": \"Advertise the RIP route from port1's session to multicast address 224.0.0.9 on UDP port 520.\",\n  \"Subtask 9\": \"Stop packet capture on port2 after 3 seconds of transmission.\",\n  \"Subtask 10\": \"Download captured packets from port2 and save as 'step6.pcap' for analysis.\",\n  \"Subtask 11\": \"Analyze captured packets to verify reception of RIPv2 update containing 192.168.4.0 route with metric 8 at port2.\",\n  \"Subtask 12\": \"Stop RIP protocol on both sessions.\",\n  \"Subtask 13\": \"Modify the RIP IPv4 route object on port1 to set Increment=6.\",\n  \"Subtask 14\": \"Restart RIP protocol on both sessions and wait for established state.\",\n  \"Subtask 15\": \"Start packet capture on port2 for metric 6 test iteration.\",\n  \"Subtask 16\": \"Re-advertise the modified RIP route from port1's session.\",\n  \"Subtask 17\": \"Stop packet capture on port2 after 3 seconds and save as 'step7.pcap'.\",\n  \"Subtask 18\": \"Verify reception of RIPv2 update with 192.168.4.0 route and metric 6 at port2.\",\n  \"Subtask 19\": \"Stop RIP protocol on both sessions.\",\n  \"Subtask 20\": \"Update RIP IPv4 route object on port1 to set Increment=10.\",\n  \"Subtask 21\": \"Restart RIP protocol on both sessions and wait for established state.\",\n  \"Subtask 22\": \"Start packet capture on port2 for metric 10 test iteration.\",\n  \"Subtask 23\": \"Advertise the updated RIP route from port1's session.\",\n  \"Subtask 24\": \"Stop packet capture on port2 after 3 seconds and save as 'step8.pcap'.\",\n  \"Subtask 25\": \"Verify reception of RIPv2 update with 192.168.4.0 route and metric 10 at port2.\",\n  \"Subtask 26\": \"Release reserved tester ports and shutdown tester system after completing all test iterations.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: 6.7.5 Routing Information Protocol (RIP)\n\nStep: Test Step 1: According to Figure 4, select any two ports of the switch as test ports;\nTest Step 2: Tester port1 IP address is 192.168.1.100/24, port2 is 192.168.2.100/24;\nTest Step 3: DUT1 port1 IP address is 192.168.1.1/24, port2 IP address is 192.168.2.1/24;\nTest Step 3: Configure the RIPv2 routing protocol on the DUT;\nTest Step 3: Tester port1 sends RIPv2 response packets from UDP port 520 to multicast address 224.0.0.9 UDP port 520, with address family 2 and RIP entry 192.168.4.0/255.255.255.0/8, at a period of 1s; observe DUT's routing table changes and whether tester port2 receives routing update packets;\nTest Step 3: Stop sending packets from Step 6; tester port1 sends RIPv2 response packets from UDP port 520 to multicast address 224.0.0.9 UDP port 520, with address family 2 and RIP entry 192.168.4.0/255.255.255.0/6, at a period of 1s; observe DUT's routing table changes and whether tester port2 receives routing update packets;\nTest Step 3: Stop sending packets from Step 7; tester port1 sends RIPv2 response packets from UDP port 520 to multicast address 224.0.0.9 UDP port 520, with address family 2 and RIP entry 192.168.4.0/255.255.255.0/10, at a period of 1s; observe DUT's routing table changes and whether tester port2 receives routing update packets;\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\nimport pyshark\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建RIP协议会话\n    session_1 = create_rip(Port=port_up)\n    session_2 = create_rip(Port=port_down)\n\n    # RIP协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    #创建流量\n    port1, port2 = ports\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动协议\n\n        route = create_rip_ipv4_route(Session=session_1, StartIpv4Prefix='192.168.4.0', Increment=8)\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step6', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 6\n        save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step7', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n\n        stop_protocol()\n        route.Increment = 10\n        start_protocol()\n        wait_rip_state(Sessions=[session_1, session_2])\n        start_capture(Ports=port2)\n        advertise_rip(Sessions=session_1)\n        time.sleep(3)\n        stop_capture(Ports=port2)\n        time.sleep(3)\n        # 下载捕获到的报文\n        packages_path = download_packages(Port=port2, FileDir=f'{dirname}/pcap', FileName='step8', MaxCount=100)\n        print(f'packages_path: {packages_path}')\n        cap = pyshark.FileCapture(packages_path, keep_packets=True, display_filter='rip.version == 1')\n        for pkt in cap:\n            if pkt.rip.ip == '192.168.4.0':\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 收到路由更新报文',\n                    step=6, result=True)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'tester port2 没有收到路由更新报文',\n                    step=6, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ndownload_packages:下载指定端口捕获到的数据包;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_rip:通告RIP协议路由;\ncreate_rip:创建RIP协议会话对象;\ncreate_rip_ipv4_route:创建RIP IPv4路由对象;\nwait_rip_state:等待RIP协议会话达到指定状态;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_4_5/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.4.5 帧丢失率\n\n Step\t\t\t:\t测试步骤1: 按照图 4，将交换机任意两个同类型端口与测试仪相连接；\n                   测试步骤2: 两个端口同时互相发送数据，测试帧长度分别为（64、65、256、1024、1518）字节，测试时间为 60s；负载率设置为 100%；\n                   测试步骤3: 记录不同帧长的丢包率。\n\n Criteria    \t:   预期结果1: 技术要求在端口转发速率达到 100%的情况下，丢包率应为0。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective     : Test Objective: 6.4.5 Frame Loss Rate\n\nStep          : Test Step 1: According to Figure 4, connect any two ports of the same type on the switch to the tester;\n                Test Step 2: Both ports simultaneously send data to each other. Test frame lengths are (64, 65, 256, 1024, 1518) bytes, test duration is 60s; load rate is set to 100%;\n                Test Step 3: Record the packet loss rate for different frame lengths.\n\nCriteria      : Expected Result 1: According to technical requirements, when port forwarding rate reaches 100%, packet loss rate should be 0.\n\nCreated by    : Tester-001\n\nTags          : performance\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['frameloss'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester API to prepare for network testing.\",\n  \"Subtask 2\": \"Reserve two test ports using reserve_port API based on configuration, ensuring they are of the same type as required for the frame loss test.\",\n  \"Subtask 3\": \"Edit port parameters using edit_port API if required, and wait for port status using wait_port_state API to confirm link readiness.\",\n  \"Subtask 4\": \"Create Ethernet interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 5\": \"Configure MAC addresses on both interfaces using edit_interface API according to test specifications.\",\n  \"Subtask 6\": \"Create bidirectional traffic streams between the interfaces using add_stream API with Type='binding' and Bidirection=True.\",\n  \"Subtask 7\": \"Create RFC2544 benchmark test suite for frame loss measurement using create_benchmark API with 'frameloss' item.\",\n  \"Subtask 8\": \"Assign reserved ports to the benchmark using relate_benchmark_ports API.\",\n  \"Subtask 9\": \"Configure benchmark to use existing traffic streams using benchmark_stream_use_exist API.\",\n  \"Subtask 10\": \"Set benchmark address learning to occur once using edit_benchmark_learning API.\",\n  \"Subtask 11\": \"Configure test duration to 60 seconds using edit_benchmark_duration API with Mode='second'.\",\n  \"Subtask 12\": \"Set frame sizes to (64, 65, 256, 1024, 1518) bytes using edit_benchmark_frame API with Type='custom'.\",\n  \"Subtask 13\": \"Configure traffic load to 100% using edit_benchmark_traffic_load_loop API with LoadMode='custom' and LoadCustom=100.\",\n  \"Subtask 14\": \"Generate benchmark configuration using expand_benchmark API.\",\n  \"Subtask 15\": \"Save test configuration using save_case API for reference.\",\n  \"Subtask 16\": \"Execute benchmark test using run_benchmark API with 3600s timeout.\",\n  \"Subtask 17\": \"Retrieve frame loss results for all frame sizes using get_benchmark_result API with ReturnType='dataframe'.\",\n  \"Subtask 18\": \"Validate that packet loss rate is 0% for all frame sizes at 100% load as per technical requirements.\",\n  \"Subtask 19\": \"Release reserved ports using release_port API after test completion.\",\n  \"Subtask 20\": \"Shutdown tester using shutdown_tester API to clean up resources.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective     : Test Objective: 6.4.5 Frame Loss Rate\n\nStep          : Test Step 1: According to Figure 4, connect any two ports of the same type on the switch to the tester;\n                Test Step 2: Both ports simultaneously send data to each other. Test frame lengths are (64, 65, 256, 1024, 1518) bytes, test duration is 60s; load rate is set to 100%;\n                Test Step 3: Record the packet loss rate for different frame lengths.\n\nCriteria      : Expected Result 1: According to technical requirements, when port forwarding rate reaches 100%, packet loss rate should be 0.\n\nCreated by    : Tester-001\n\nTags          : performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_down = create_interface(Port=port_down, Layers=['eth'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['up']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['down']['default'])\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_up, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_down, Layer='eth')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['frameloss'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableLearning=True)\n    edit_benchmark_duration(Config=Config, Mode='second', Count=cfg['arg']['duration']['default'])\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=cfg['arg']['frame_size']['default'])\n    edit_benchmark_traffic_load_loop(Config=Config, LoadUnit=cfg['arg']['traffic_load_loop']['default']['load_unit']['default'],\n                                     LoadMode='custom', LoadCustom=cfg['arg']['traffic_load_loop']['default']['load_custom']['default'])\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 执行测试\n        printf(message='Test start')\n        db = run_benchmark(Mode=0, Timer=3600, Analyzer=testbed['tester']['analyzer']['default'])\n        df = get_benchmark_result(DB=db, Type='RFC2544', ReturnType='dataframe')\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(df, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        printf(message='Test completed')\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n    # 释放端口资源\n    release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Stream/Header/DHCPv4Client.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查测试仪表发流统计正确\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 端口Port_1创建一条流量StreamTemplate_1;\n                   测试步骤3: 修改流量StreamTemplate_1的DHCPv4 Client头部内容;\n                   测试步骤4: 订阅StreamBlockStats统计;\n                   测试步骤5: 发送所有流量，等待一段时间;\n                   测试步骤6: 停止所有流量，查看StreamBlockStats统计信息;\n\n Criteria    \t:   预期结果1: 步骤6中流量StreamTemplate_1收发包相等;\n\n Created by   \t:  \tTester-003\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of traffic statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Test Step 3: Modify the DHCPv4 Client header content of stream StreamTemplate_1;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Transmit all traffic and wait for a period;\n                   Test Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-003\n\nBugs   \t    :   None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Client'])\n\n    # 修改dhcpv4 client头部\n    header = edit_header_dhcpv4_client(Stream=stream, Level=0,\n                                       MessageType=1,\n                                       HardwareType=1,\n                                       Hops=1,\n                                       Bootpflags='0001',\n                                       )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=0,\n                                              Types='serverId',\n                                              ReqAddr='1.1.1.1',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ReqAddr'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=1,\n                                              Types='message',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=2,\n                                              Types='leaseTime',\n                                              LeaseTime=1,\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['LeaseTime'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=3,\n                                              Types='endOfOptions',\n                                              Type='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Type'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=4,\n                                              Types='messageSize',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=5,\n                                              Types='clientIdHW',\n                                              IdType='01',\n                                              ClientHWA='00:00:00:00:00:01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ClientHWA'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=6,\n                                              Types='clientIdNoneHW',\n                                              IdType='01',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=7,\n                                              Types='hostName',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=8,\n                                              Types='paramReqList',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=9,\n                                              Types='reqAddr',\n                                              ReqAddr='1.1.1.1',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ReqAddr'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=10,\n                                              Types='optionOverload',\n                                              Overload=1,\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=11,\n                                              Types='customOption',\n                                              Overload='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=12,\n                                              Types='generalTLV',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=13,\n                                              Types='messageType',\n                                              Code=4,\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Code'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Client'],\n                                             FieldName='dhcpv4Client_1.hops',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "create_capture_pdu_pattern:在指定端口上创建Pdu Pattern",
      "download_packages:下载指定端口捕获到的数据包",
      "edit_capture_filter:在指定端口上设置报文过滤逻辑表达式",
      "get_capture_info:在指定端口报文捕获信息",
      "start_capture:启动测试仪表端口数据抓包",
      "stop_capture:停止测试仪表端口数据抓包",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "reserve_port:预约测试仪表的端口",
      "get_port_statistic:获取测试仪表端口统计结果",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_modifier:修改测试仪表流量模板中指定报文字段的跳变域",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester API with specified product platform.\",\n  \"Subtask 2\": \"Reserve two loopback ports (Port_1 and Port_2) using reserve_port API.\",\n  \"Subtask 3\": \"Create a traffic stream (StreamTemplate_1) on Port_1 with fixed frame length using add_stream API.\",\n  \"Subtask 4\": \"Build stream header layers (EthernetII, IPv4, UDP, DHCPv4Client) for StreamTemplate_1 using create_stream_header API.\",\n  \"Subtask 5\": \"Modify main DHCPv4 Client header fields (MessageType, HardwareType, Hops, Bootpflags) using edit_header_dhcpv4_client API.\",\n  \"Subtask 6\": \"Add DHCPv4 option header (serverId type) and configure ReqAddr field using edit_header_dhcpv4_option API.\",\n  \"Subtask 7\": \"Apply increment modifier to DHCPv4 Client MessageType field with count=10 using edit_modifier API.\",\n  \"Subtask 8\": \"Set port transmission mode to BURST with burst count=100 using edit_port_load_profile API.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats statistics using subscribe_result API.\",\n  \"Subtask 10\": \"Start traffic transmission using start_stream API.\",\n  \"Subtask 11\": \"Wait for traffic completion using wait_stream_state API and pause 3 seconds for statistics stabilization.\",\n  \"Subtask 12\": \"Retrieve StreamBlockStats for StreamTemplate_1 using get_streamblock_statistic API.\",\n  \"Subtask 13\": \"Verify transmitted frames (TxStreamFrames) equal received frames (RxStreamFrames) in StreamBlockStats.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective   \t:   Test Objective: Verify the accuracy of traffic statistics on the test instrument\n\nStep\t\t\t:\tTest Step 1: Reserve two loopback ports Port_1 and Port_2;\n                   Test Step 2: Create a traffic stream StreamTemplate_1 on port Port_1;\n                   Test Step 3: Modify the DHCPv4 Client header content of stream StreamTemplate_1;\n                   Test Step 4: Subscribe to StreamBlockStats statistics;\n                   Test Step 5: Transmit all traffic and wait for a period;\n                   Test Step 6: Stop all traffic and view StreamBlockStats statistics;\n\nCriteria    \t:   Expected Result 1: In step 6, transmitted and received packets for stream StreamTemplate_1 are equal;\n\nCreated by   \t:   Tester-003\n\nBugs   \t    :   None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/7', '//10.0.11.191/1/8'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations)\n\n    # 创建流量\n    stream = add_stream(Ports=Port_UP, FixedLength=512)\n\n    # 修改流量报文头部\n    create_stream_header(Stream=stream, HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Client'])\n\n    # 修改dhcpv4 client头部\n    header = edit_header_dhcpv4_client(Stream=stream, Level=0,\n                                       MessageType=1,\n                                       HardwareType=1,\n                                       Hops=1,\n                                       Bootpflags='0001',\n                                       )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header['MessageType'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=0,\n                                              Types='serverId',\n                                              ReqAddr='1.1.1.1',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ReqAddr'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=1,\n                                              Types='message',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=2,\n                                              Types='leaseTime',\n                                              LeaseTime=1,\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['LeaseTime'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=3,\n                                              Types='endOfOptions',\n                                              Type='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Type'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=4,\n                                              Types='messageSize',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n                  Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=5,\n                                              Types='clientIdHW',\n                                              IdType='01',\n                                              ClientHWA='00:00:00:00:00:01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ClientHWA'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=6,\n                                              Types='clientIdNoneHW',\n                                              IdType='01',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=7,\n                                              Types='hostName',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=8,\n                                              Types='paramReqList',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=9,\n                                              Types='reqAddr',\n                                              ReqAddr='1.1.1.1',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['ReqAddr'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=10,\n                                              Types='optionOverload',\n                                              Overload=1,\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=11,\n                                              Types='customOption',\n                                              Overload='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Overload'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=12,\n                                              Types='generalTLV',\n                                              Value='01',\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Value'],\n    #               Type='Increment', Count=10)\n\n    # 修改dhcpv4 client头部，添加一个Option头部\n    header_option = edit_header_dhcpv4_option(Stream=stream, Level=0,\n                                              Index=13,\n                                              Types='messageType',\n                                              Code=4,\n                                              )\n    # 设置跳变\n    # edit_modifier(Stream=stream, Level=0, HeaderType='dhcpv4Client', Attribute=header_option['Code'],\n    #               Type='Increment', Count=10)\n\n    # 配置过滤抓包\n    pdu_pattern = create_capture_pdu_pattern(Port=Port_Down,\n                                             HeaderTypes=['EthernetII', 'IPv4', 'UDP', 'dhcpv4Client'],\n                                             FieldName='dhcpv4Client_1.hops',\n                                             Value=1,\n                                             MaxValue=1,\n                                             )\n    edit_capture_filter(Port=Port_Down, Expression=pdu_pattern)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 设置端口发送模式为突发包\n    BurstCount = 100\n    edit_port_load_profile(Ports=Port_UP, TransmitMode='BURST', BurstCount=BurstCount)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # 启动抓包，发送流量\n    start_capture()\n    start_stream()\n\n    # 等待流量停止\n    wait_stream_state()\n    stop_capture()\n\n    # 流量停止后，必须等待大于等于3sec才能正确获得统计结果\n    time.sleep(3)\n\n    # 下载捕获到的报文\n    pkt = download_packages(Port=Port_Down, FileDir=f'{dirname}/pcap/', FileName=filename, MaxCount=100)\n    print(pkt)\n\n    # 获取端口捕获报文信息\n    capture_info = get_capture_info(Port=Port_Down)\n    print(capture_info)\n    if capture_info['CapturedPacketCount'] != capture_info['DownloadedPacketCount'] != BurstCount:\n        verdict = 'fail'\n        errInfo += f'Download packages is not equal to BurstCount({BurstCount})\\n'\n\n    # 获取流量StreamBlockStats\n    result = get_streamblock_statistic(Stream=stream)\n    print(result)\n    TxStreamFrames = result['TxStreamFrames']\n    RxStreamFrames = result['RxStreamFrames']\n    print('TxStreamFrames: {}'.format(TxStreamFrames))\n    print('RxStreamFrames: {}'.format(RxStreamFrames))\n\n    if TxStreamFrames != RxStreamFrames != BurstCount:\n        verdict = 'fail'\n        errInfo += f'{stream} TxStreamFrames({TxStreamFrames}) is not equal to RxStreamFrames({RxStreamFrames})\\n'\n\n    # 获取报文过滤统计结果\n    StaItems = ['RxFilter0Count', 'RxFilter1Count', 'RxFilter2Count', 'RxFilter3Count', 'RxFilter4Count',\n                'RxFilter5Count', 'RxFilter6Count', 'RxFilter7Count']\n    result = get_port_statistic(Port=Port_Down, StaItems=StaItems)\n    print(result)\n\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\ncreate_capture_pdu_pattern:在指定端口上创建Pdu Pattern;\ndownload_packages:下载指定端口捕获到的数据包;\nedit_capture_filter:在指定端口上设置报文过滤逻辑表达式;\nget_capture_info:在指定端口报文捕获信息;\nstart_capture:启动测试仪表端口数据抓包;\nstop_capture:停止测试仪表端口数据抓包;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nreserve_port:预约测试仪表的端口;\nget_port_statistic:获取测试仪表端口统计结果;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_modifier:修改测试仪表流量模板中指定报文字段的跳变域;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_6_2/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.6.2 路由表容量\n\n Step\t\t\t:\t测试步骤1: 按拓扑图搭建测试环境；\n                   测试步骤2: tester port1 IP 地址为 192.168.1.100/24，port2 为 192.168.2.100/24；\n                   测试步骤3: DUT port1 IP地址为192.168.1.1/24，port2 IP地址为192.168.2.1/24；\n                   测试步骤4: 配置 DUT 与 tester 在相同 Area 域，DUT 的接口 1、2 分别和 tester 建立 OSPF 邻居；\n                   测试步骤5: Tester 的接口 port1、port2 分别向 DUT 的接口 port1、port2 发布 Type类型的 LSA，总数为被测交换机路由表容量的规定值。\n\n Criteria    \t:   预期结果1: 查看并记录被测交换机的 OSPF 生成的路由表统计信息。\n\n Created by   \t:  \tTester-001\n\n Tags   \t    :  \tperformance\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective       :   Test Objective: 6.6.2 Routing Table Capacity\n\nStep            :   Test Step 1: Set up the test environment according to the topology diagram;\n                Test Step 2: Tester port1 IP address is 192.168.1.100/24, port2 is 192.168.2.100/24;\n                Test Step 3: DUT port1 IP address is 192.168.1.1/24, port2 IP address is 192.168.2.1/24;\n                Test Step 4: Configure DUT and Tester in the same OSPF Area, establishing OSPF neighbors between DUT interfaces 1,2 and Tester respectively;\n                Test Step 5: Tester interfaces port1 and port2 advertise Type LSAs to DUT interfaces port1 and port2 respectively, with the total number matching the specified routing table capacity of the DUT switch.\n\nCriteria        :   Expected Result 1: Check and record the OSPF-generated routing table statistics of the DUT switch.\n\nCreated by      :   Tester-001\n\nTags            :   performance\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建OSPFv2协议会话\n    session_1 = create_ospf(Port=port_up, Priority=cfg['arg']['ospf']['default']['priority_session_up']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n    session_2 = create_ospf(Port=port_down, Priority=cfg['arg']['ospf']['default']['priority_session_down']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    route_count = int(cfg['arg']['ospf']['default']['advertise_count']['default'] / 2)\n    # OSPFv2协议会话创建External Lsa\n    external_lsa_1 = create_ospf_external_lsa(Session=session_1, RouteCount=route_count)\n    external_lsa_2 = create_ospf_external_lsa(Session=session_2, RouteCount=route_count)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=external_lsa_1)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa_2)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['rate']['default'])\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats', 'Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 启动协议\n        printf(message='Test start')\n        start_protocol()\n        time.sleep(3)\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        advertise_ospf_lsa(Lsa=[external_lsa_1, external_lsa_2])\n        time.sleep(cfg['arg']['ospf']['default']['advertise_wait']['default'])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 发送流量\n        printf(message='Stream test start')\n        start_stream()\n        time.sleep(3)\n        df = get_streamblock_statistic()\n        wait_stream_state(State='RUNNING')\n        time.sleep(3)\n        result = get_streamblock_statistic()\n        # 使用 concat 拼接 DataFrame\n        df = pd.concat([df, result])\n        # 重置索引\n        df = df.reset_index(drop=True)\n        printf(message='Test completed')\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        stop_protocol()\n        time.sleep(3)\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "advertise_ospf_lsa:通告 OSPFv2 协议会话 lsa",
      "create_ospf:创建OSPFv2协议会话对象",
      "create_ospf_external_lsa:创建OSPFv2 External LSA对象",
      "get_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象",
      "get_ospf_statistic:获取OSPFv2协议会话统计结果",
      "wait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "add_stream:测试仪表创建流量",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize test equipment and reserve ports according to topology specifications.\",\n  \"Subtask 2\": \"Configure tester port1 interface with IP address 192.168.1.100/24 and gateway 192.168.1.1.\",\n  \"Subtask 3\": \"Configure tester port2 interface with IP address 192.168.2.100/24 and gateway 192.168.2.1.\",\n  \"Subtask 4\": \"Create OSPFv2 sessions on both tester ports with identical Area ID to establish neighbor relationships with DUT.\",\n  \"Subtask 5\": \"Bind OSPFv2 sessions to respective tester interfaces (port1 and port2).\",\n  \"Subtask 6\": \"Create OSPF external LSAs with total route count matching DUT's routing table capacity, equally distributed between both ports.\",\n  \"Subtask 7\": \"Start OSPF protocol and wait until neighbor adjacencies reach FULL state.\",\n  \"Subtask 8\": \"Advertise created OSPF LSAs from both tester ports to DUT.\",\n  \"Subtask 9\": \"Retrieve and record OSPF-generated routing table statistics from DUT switch.\",\n  \"Subtask 10\": \"Release reserved ports and clean up test environment.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective       :   Test Objective: 6.6.2 Routing Table Capacity\n\nStep            :   Test Step 1: Set up the test environment according to the topology diagram;\n                Test Step 2: Tester port1 IP address is 192.168.1.100/24, port2 is 192.168.2.100/24;\n                Test Step 3: DUT port1 IP address is 192.168.1.1/24, port2 IP address is 192.168.2.1/24;\n                Test Step 4: Configure DUT and Tester in the same OSPF Area, establishing OSPF neighbors between DUT interfaces 1,2 and Tester respectively;\n                Test Step 5: Tester interfaces port1 and port2 advertise Type LSAs to DUT interfaces port1 and port2 respectively, with the total number matching the specified routing table capacity of the DUT switch.\n\nCriteria        :   Expected Result 1: Check and record the OSPF-generated routing table statistics of the DUT switch.\n\nCreated by      :   Tester-001\n\nTags            :   performance\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建OSPFv2协议会话\n    session_1 = create_ospf(Port=port_up, Priority=cfg['arg']['ospf']['default']['priority_session_up']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n    session_2 = create_ospf(Port=port_down, Priority=cfg['arg']['ospf']['default']['priority_session_down']['default'], AreaId=cfg['arg']['ospf']['default']['area_id']['default'])\n\n    # OSPFv2协议会话与接口绑定\n    select_interface(Session=session_1, Interface=interfaces_up)\n    select_interface(Session=session_2, Interface=interfaces_down)\n\n    route_count = int(cfg['arg']['ospf']['default']['advertise_count']['default'] / 2)\n    # OSPFv2协议会话创建External Lsa\n    external_lsa_1 = create_ospf_external_lsa(Session=session_1, RouteCount=route_count)\n    external_lsa_2 = create_ospf_external_lsa(Session=session_2, RouteCount=route_count)\n\n    # 获取OSPFv2协议绑定流端点对象\n    point_1 = get_ospf_router_from_lsa(Lsa=external_lsa_1)\n    point_2 = get_ospf_router_from_lsa(Lsa=external_lsa_2)\n\n    # 创建OSPFv2绑定流\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 负载模式：Base On Port, （端口负载：, 负载单位：PERCENT 传输模式：Time\n    edit_port_load_profile(Ports=[port_up, port_down],\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"TIME\",\n                           Rate=cfg['arg']['load_profile']['default']['rate']['default'],\n                           Seconds=cfg['arg']['load_profile']['default']['rate']['default'])\n\n    # 订阅统计\n    subscribe_result(Types=['PortStats', 'StreamBlockStats', 'Ospfv2SessionResultPropertySet', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        # 启动协议\n        printf(message='Test start')\n        start_protocol()\n        time.sleep(3)\n        # 等待OSPFv2协议会话达到Full状态\n        wait_ospf_adjacency_state(Sessions=[session_1, session_2])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        advertise_ospf_lsa(Lsa=[external_lsa_1, external_lsa_2])\n        time.sleep(cfg['arg']['ospf']['default']['advertise_wait']['default'])\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 发送流量\n        printf(message='Stream test start')\n        start_stream()\n        time.sleep(3)\n        df = get_streamblock_statistic()\n        wait_stream_state(State='RUNNING')\n        time.sleep(3)\n        result = get_streamblock_statistic()\n        # 使用 concat 拼接 DataFrame\n        df = pd.concat([df, result])\n        # 重置索引\n        df = df.reset_index(drop=True)\n        printf(message='Test completed')\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n        data.write_report(df)\n        printf(message='Test data save successfully')\n\n        stop_protocol()\n        time.sleep(3)\n        result = get_ospf_statistic()\n        # 使用tabulate库表格化输出DataFrame二维数据\n        print('\\n' + tabulate(result, headers='keys', tablefmt='psql') + '\\n', flush=True)\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\nadvertise_ospf_lsa:通告 OSPFv2 协议会话 lsa;\ncreate_ospf:创建OSPFv2协议会话对象;\ncreate_ospf_external_lsa:创建OSPFv2 External LSA对象;\nget_ospf_router_from_lsa:获取OSPF LSA对应的绑定流源或目的端点对象;\nget_ospf_statistic:获取OSPFv2协议会话统计结果;\nwait_ospf_adjacency_state:等待OSPFv2或OSPFv3协议会话达到指定邻接状态;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nadd_stream:测试仪表创建流量;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_9/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.9 支持网关数\n\n Step\t\t\t:\t测试步骤1: 记录三层交换机配置网络层地址的方式（路由口配置方式或者VLANInterface 方式）。\n                   测试步骤2: 记录三层交换机可配置的网关数目\n                   测试步骤3: 按图10建立测试环境\n                   测试步骤4: tester port1 地 址 为 192.168.9.100/24 ， port2 地 址 为192.168.11.100/24；DUT port1\n                   和 port2 分别配置 192.168.9.0 网段和192.168.11.0 网段网关，抽样验证网关是否配置成功。\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: 6.7.9 Supported Number of Gateways\n\nStep: Test Step 1: Record the Layer 3 switch's network layer address configuration method (routed port configuration or VLAN Interface method).\nTest Step 2: Record the maximum number of configurable gateways on the Layer 3 switch.\nTest Step 3: Establish the test environment according to Figure 10.\nTest Step 4: Set tester port1 address to 192.168.9.100/24 and port2 address to 192.168.11.100/24; configure DUT port1 and port2 as gateways for the 192.168.9.0 and 192.168.11.0 network segments respectively, and verify gateway configuration success through sampling.\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.9.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n        ipv4_ping(Interface=interfaces_down, IpAddr='192.168.11.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Record the Layer 3 switch's network layer address configuration method (routed port or VLAN Interface) as specified in the test objective.\",\n  \"Subtask 2\": \"Record the maximum number of configurable gateways supported by the Layer 3 switch according to its specifications.\",\n  \"Subtask 3\": \"Establish the test environment per Figure 10 by initializing the tester and reserving required ports.\",\n  \"Subtask 4\": \"Configure DUT port1 as gateway for 192.168.9.0/24 segment and DUT port2 as gateway for 192.168.11.0/24 segment.\",\n  \"Subtask 5\": \"Set tester port1 IP address to 192.168.9.100/24 with gateway 192.168.9.1 using interface configuration.\",\n  \"Subtask 6\": \"Set tester port2 IP address to 192.168.11.100/24 with gateway 192.168.11.1 using interface configuration.\",\n  \"Subtask 7\": \"Verify gateway configuration by sending ICMP echo requests from tester port1 to DUT gateway 192.168.9.1.\",\n  \"Subtask 8\": \"Verify gateway configuration by sending ICMP echo requests from tester port2 to DUT gateway 192.168.11.1.\",\n  \"Subtask 9\": \"Check ICMP reply status for both test paths to confirm gateway functionality.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: 6.7.9 Supported Number of Gateways\n\nStep: Test Step 1: Record the Layer 3 switch's network layer address configuration method (routed port configuration or VLAN Interface method).\nTest Step 2: Record the maximum number of configurable gateways on the Layer 3 switch.\nTest Step 3: Establish the test environment according to Figure 10.\nTest Step 4: Set tester port1 address to 192.168.9.100/24 and port2 address to 192.168.11.100/24; configure DUT port1 and port2 as gateways for the 192.168.9.0 and 192.168.11.0 network segments respectively, and verify gateway configuration success through sampling.\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        ping = ipv4_ping(Interface=interfaces_up, IpAddr='192.168.9.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=4, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=4, result=False)\n        ipv4_ping(Interface=interfaces_down, IpAddr='192.168.11.1', PacketCount=5)\n        if ping:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is avalible',\n                step=5, result=True)\n        else:\n            CustomData.verdict, CustomData.errInfo = printf(\n                message=f'ping is not avalible',\n                step=5, result=False)\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_2/main.py",
    "intent": "-*- coding: utf-8 -*-\n =================================================================================\n Objective   \t:   测试目的 : 6.5.2 优先级QoS\n\n Step\t\t\t:\t测试步骤1: 按图6，从交换机任意选取三个端口与测试仪相连接，分别定为端口1、端口2 和端口3，交换机配置为绝对优先级，交换机设置端口trunk模式保证不剥掉vlan1；\n                   测试步骤2: 端口1 和端口2 同时端口3 发送数据；\n                   测试步骤3: 在端口1 构造两条优先级分别为7 和5 的数据流，在端口2 构造两条优先级分别为3 和1 的数据流，vlan1 的优先级设置为7 和5，3 和1；\n                   测试步骤4: 测试帧长度为64 字节，测试时间30s，端口负荷设置为100%；\n                   测试步骤5: 记录不同数据流的帧丢失率，判断优先级是否设置成功。\n\n Criteria    \t:   预期结果1: 不同数据流的帧丢失率，与优先级设置一致。\n\n Created by   \t:  \tTester-008\n\n Tags   \t    :  \tfunction\n =================================================================================",
    "intent_en": "-*- coding: utf-8 -*-\n=================================================================================\nObjective     : Test Objective: 6.5.2 Priority QoS\n\nStep          : Test Step 1: As shown in Figure 6, connect any three switch ports to the tester, designated as Port 1, Port 2, and Port 3. Configure the switch for absolute priority and set ports to trunk mode to prevent stripping VLAN 1.\n                Test Step 2: Transmit data simultaneously from Port 1 and Port 2 to Port 3.\n                Test Step 3: Construct two data streams with priorities 7 and 5 on Port 1, and two streams with priorities 3 and 1 on Port 2. Set VLAN 1 priorities to 7, 5, 3, and 1 respectively.\n                Test Step 4: Use 64-byte test frames, 30-second test duration, and 100% port load.\n                Test Step 5: Record frame loss rates for different data streams to verify priority configuration.\n\nCriteria      : Expected Result 1: Frame loss rates for different data streams align with priority settings.\n\nCreated by    : Tester-008\n\nTags          : function\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    port1,port2,port3=ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建流量\n    # 数据流 1：qos优先级为 7 的 IPv4 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_7')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    edit_header_vlan(Stream=stream, Priority=7)\n    # 数据流 2：qos优先级为 5 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_5')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, Priority=5)\n\n    # 端口2创建流量\n    # 数据流 1：qos优先级为 3 的 IPv4 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_3')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, Priority=3)\n    # 数据流 2：qos优先级为 1 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_1')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[3])\n    edit_header_vlan(Stream=stream, Priority=1)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(5)\n        # 检查统计结果\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxPortID'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            TxPortID = Result['TxPortID']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=5, result=True)\n            if RxStreamFrames != TxStreamFrames:\n                if TxPortID == port2.Name:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=5, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "edit_header_vlan:修改测试仪表流量模板中vlan报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "get_streams:获取测试仪表流量对象",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester using init_tester API to prepare for testing.\",\n  \"Subtask 2\": \"Reserve three test ports (Port1, Port2, Port3) using reserve_port API based on configured locations.\",\n  \"Subtask 3\": \"Configure port parameters including force, debug, and wait settings using edit_port API.\",\n  \"Subtask 4\": \"Set load profile parameters: 100% port load, 30-second duration, and TIME transmit mode using edit_port_load_profile API.\",\n  \"Subtask 5\": \"Create stream on Port1 with VLAN priority 7: use add_stream to create, edit_stream to set 64-byte frames and Port3 as receiver, create_stream_header for EthernetII/VLAN/IPv4 headers, edit_header_ethernet for MAC addresses, and edit_header_vlan to set priority 7.\",\n  \"Subtask 6\": \"Create stream on Port1 with VLAN priority 5: repeat steps from Subtask 5 with priority 5 and distinct MAC addresses.\",\n  \"Subtask 7\": \"Create stream on Port2 with VLAN priority 3: repeat steps from Subtask 5 with priority 3 and distinct MAC addresses.\",\n  \"Subtask 8\": \"Create stream on Port2 with VLAN priority 1: repeat steps from Subtask 5 with priority 1 and distinct MAC addresses.\",\n  \"Subtask 9\": \"Subscribe to StreamBlockStats view using subscribe_result API for statistics collection.\",\n  \"Subtask 10\": \"Save test case configuration using save_case API.\",\n  \"Subtask 11\": \"Start Layer 2 learning using start_l2_learning API to enable MAC address discovery.\",\n  \"Subtask 12\": \"Simultaneously transmit all streams from Port1 and Port2 using start_stream API.\",\n  \"Subtask 13\": \"Wait for stream transmission completion using wait_stream_state API.\",\n  \"Subtask 14\": \"For each stream on Port1 and Port2: retrieve TxStreamFrames and RxStreamFrames using get_streams and get_streamblock_statistic APIs.\",\n  \"Subtask 15\": \"Verify high-priority streams (Port1 priorities 7/5) show 0% frame loss (RxStreamFrames == TxStreamFrames) and low-priority streams (Port2 priorities 3/1) show frame loss (RxStreamFrames < TxStreamFrames).\",\n  \"Subtask 16\": \"Clear statistical results using clear_result API.\",\n  \"Subtask 17\": \"Release reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  -*- coding: utf-8 -*-\n=================================================================================\nObjective     : Test Objective: 6.5.2 Priority QoS\n\nStep          : Test Step 1: As shown in Figure 6, connect any three switch ports to the tester, designated as Port 1, Port 2, and Port 3. Configure the switch for absolute priority and set ports to trunk mode to prevent stripping VLAN 1.\n                Test Step 2: Transmit data simultaneously from Port 1 and Port 2 to Port 3.\n                Test Step 3: Construct two data streams with priorities 7 and 5 on Port 1, and two streams with priorities 3 and 1 on Port 2. Set VLAN 1 priorities to 7, 5, 3, and 1 respectively.\n                Test Step 4: Use 64-byte test frames, 30-second test duration, and 100% port load.\n                Test Step 5: Record frame loss rates for different data streams to verify priority configuration.\n\nCriteria      : Expected Result 1: Frame loss rates for different data streams align with priority settings.\n\nCreated by    : Tester-008\n\nTags          : function\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n\n    edit_port_load_profile(Ports=ports, TransmitMode='TIME', Rate=100, Seconds=30)\n    port1,port2,port3=ports\n    smac_address_list = ['00:00:00:13:40:21', '00:00:00:13:40:22', '00:00:00:13:40:23', '00:00:00:13:40:24']\n    dmac_address_list = ['00:00:01:13:40:20', '00:00:01:13:40:21', '00:00:01:13:40:22', '00:00:01:13:40:23']\n    # 端口1创建流量\n    # 数据流 1：qos优先级为 7 的 IPv4 报文\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_7')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n    edit_header_vlan(Stream=stream, Priority=7)\n    # 数据流 2：qos优先级为 5 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port1, Names=f'{port1.Name}_Priority_5')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[1], DestMacAdd=dmac_address_list[1])\n    edit_header_vlan(Stream=stream, Priority=5)\n\n    # 端口2创建流量\n    # 数据流 1：qos优先级为 3 的 IPv4 报文\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_3')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[2], DestMacAdd=dmac_address_list[2])\n    edit_header_vlan(Stream=stream, Priority=3)\n    # 数据流 2：qos优先级为 1 的标识 的 IPv4 报文；\n    stream = add_stream(Ports=port2, Names=f'{port2.Name}_Priority_1')\n    edit_stream(Stream=stream, FixedLength=64, RxPorts=port3)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii','vlan', 'ipv4'])\n    edit_header_ethernet(Stream=stream, SourceMacAdd=smac_address_list[3], DestMacAdd=dmac_address_list[3])\n    edit_header_vlan(Stream=stream, Priority=1)\n\n    # 订阅StreamBlockStats统计视图\n    subscribe_result(Types=['StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='port', Objects=ports)\n        time.sleep(5)\n        wait_stream_state()\n        time.sleep(5)\n        # 检查统计结果\n        # 获取端口流量结果\n        # 获取端口1,2下所有流量统计结果\n        streams_obj = get_streams(ports[:2])\n        for stream in streams_obj:\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames', 'TxPortID'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            TxPortID = Result['TxPortID']\n            StreamBlockID = Result['StreamBlockID']\n            if TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is equal to 0',\n                    step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} TxStreamFrames({TxStreamFrames}) is not equal to 0',\n                    step=5, result=True)\n            if RxStreamFrames != TxStreamFrames:\n                if TxPortID == port2.Name:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=True)\n                else:\n                    CustomData.verdict, CustomData.errInfo = printf(\n                        message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                        step=5, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'{StreamBlockID} RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=5, result=True)\n        clear_result()\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nedit_header_vlan:修改测试仪表流量模板中vlan报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nget_streams:获取测试仪表流量对象;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_8/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 :   6.7.8 互联网组管理协议（IGMP)\n\n Step\t\t\t:\t测试步骤1:  按图10建立测试环境；\n                   测试步骤2:  tester port1 地 址 为 192.168.1.100/24 ， port2 地 址 为192.168.2.100/24\n                   测试步骤3:  DUT port1 地址为192.168.1.1/24，port2 地址为192.168.2.1/24\n                   测试步骤4:   DUT 设置IGMPv2组播查询；\n                   测试步骤5:   tester 向port1 发目的地址为225.1.1.1，TTL=1的IGMPv2应答报文，其组地址域也为225.1.1.1，周期为1秒\n                   测试步骤6:   停止发送步骤5中的IGMPv2应答报文，观察交换机组播组成员变化；\n                   测试步骤7:    tester 向port1 发目的地址为225.1.1.1，TTL=1的IGMPv2应答报文，\n                               其组地址域也为225.1.1.1，周期为1秒，停止发送应答报文之后tester\n                               立刻向port1发目的地址为224.0.0.2，TTL=1的IGMPv2离开报文，其组地址域为225.1.1.1。观察交换机组播组成员变化\n                   测试步骤8:   停止发送步骤7中的报文；\n                   测试步骤9:   检查DUT配置，看是否支持IGMPv1、IGMPv2、IGMPv3\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective\t:\tTest Objective: 6.7.8 Internet Group Management Protocol (IGMP)\n\nStep\t\t:\tTest Step 1: Establish test environment according to Figure 10;\nTest Step 2: tester port1 address is 192.168.1.100/24, port2 address is 192.168.2.100/24\nTest Step 3: DUT port1 address is 192.168.1.1/24, port2 address is 192.168.2.1/24\nTest Step 4: DUT configures IGMPv2 multicast query;\nTest Step 5: tester sends to port1 an IGMPv2 report message with destination address 225.1.1.1, TTL=1, group address field also 225.1.1.1, period of 1 second\nTest Step 6: Stop sending the IGMPv2 report message from step 5, observe changes in switch multicast group members;\nTest Step 7: tester sends to port1 an IGMPv2 report message with destination address 225.1.1.1, TTL=1, group address field also 225.1.1.1, period of 1 second; after stopping the report message, tester immediately sends to port1 an IGMPv2 leave message with destination address 224.0.0.2, TTL=1, group address field 225.1.1.1. Observe changes in switch multicast group members;\nTest Step 8: Stop sending the messages from step 7;\nTest Step 9: Check DUT configuration to see if it supports IGMPv1, IGMPv2, IGMPv3\n\nCriteria\t:\tExpected Result 1:\n\nCreated by\t:\tTester-006\n\nBugs\t\t:\tNone\n=================================================================================",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_up, Version='IGMPV2')\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interfaces_up)\n\n    # 创建组播组\n    multicast_group = create_multicast_group(Start='225.1.1.1')\n\n    # IGMP协议会话创建组成员关系\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=port_down, Version='IGMPV2')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_down)\n\n    # 创建IGMP绑定流\n\n    # point = get_layer_from_interfaces(Interfaces=interfaces_down)\n    #\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints='224.0.0', Bidirection=False)\n\n\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        Rate=100,\n    #                        Unit='FRAME_PER_SEC',\n    #                        TransmitMode=\"STEP\",\n    #                        Frames=20)\n\n\n    #创建IGMPv2报文\n    # stream1 = add_stream(Ports=port_up, Names=f'igmpv2_report')\n    # edit_stream(Stream=stream1, FixedLength=128)\n    # create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4','igmpv2'])\n    # edit_header_ipv4(Stream=stream1, Source='192.168.1.100', Destination= '225.1.1.1', TTl=1)\n    #\n    # stream2 = add_stream(Ports=port_up, Names=f'igmpv2_query')\n    # edit_stream(Stream=stream2, FixedLength=128)\n    # create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4','igmpv2query'])\n    # edit_header_ipv4(Stream=stream2, Source='192.168.1.100', Destination= '224.0.0.2', TTl=1)\n\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        #停止协议\n        stop_protocol()\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "select_interface:协议绑定测试仪表接口",
      "start_protocol:测试仪表启动协议",
      "stop_protocol:测试仪表停止协议",
      "create_igmp:创建IGMP协议会话对象",
      "create_igmp_querier:创建IGMP Querier协议会话对象",
      "edit_igmp:编辑IGMP协议会话对象",
      "edit_igmp_querier:编辑IGMP Querier协议会话对象",
      "wait_igmp_state:等待Igmp协议会话达到指定状态",
      "binding_multicast_group:将全局组播组绑定到组播协议会话上",
      "create_memberships:创建组播协议和组播组绑定关系对象",
      "create_multicast_group:创建全局组播组对象",
      "subscribe_result:订阅测试仪表统计视图"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize test equipment and reserve necessary ports according to testbed configuration.\",\n  \"Subtask 2\": \"Configure tester interface parameters: set port1 IP to 192.168.1.100/24 and port2 IP to 192.168.2.100/24 using edit_interface API.\",\n  \"Subtask 3\": \"Execute DUT configuration commands: set port1 IP to 192.168.1.1/24, port2 IP to 192.168.2.1/24, and enable IGMPv2 multicast query functionality.\",\n  \"Subtask 4\": \"Create IGMPv2 host session on tester port1 with report interval of 1 second, binding multicast group 225.1.1.1 using create_igmp, create_multicast_group, create_memberships, and binding_multicast_group APIs.\",\n  \"Subtask 5\": \"Start IGMP protocol operation using start_protocol API and wait for session stabilization with wait_igmp_state API.\",\n  \"Subtask 6\": \"Stop IGMP protocol using stop_protocol API and verify DUT multicast group removal by querying DUT multicast group table.\",\n  \"Subtask 7\": \"Restart IGMP protocol to send reports, then immediately stop protocol and send IGMPv2 leave message (destined to 224.0.0.2 with group 225.1.1.1) using stream creation/transmission APIs.\",\n  \"Subtask 8\": \"Terminate all message transmissions from step 7 using protocol/stream control APIs.\",\n  \"Subtask 9\": \"Query DUT configuration to validate support for IGMPv1, IGMPv2, and IGMPv3 through DUT command execution.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective\t:\tTest Objective: 6.7.8 Internet Group Management Protocol (IGMP)\n\nStep\t\t:\tTest Step 1: Establish test environment according to Figure 10;\nTest Step 2: tester port1 address is 192.168.1.100/24, port2 address is 192.168.2.100/24\nTest Step 3: DUT port1 address is 192.168.1.1/24, port2 address is 192.168.2.1/24\nTest Step 4: DUT configures IGMPv2 multicast query;\nTest Step 5: tester sends to port1 an IGMPv2 report message with destination address 225.1.1.1, TTL=1, group address field also 225.1.1.1, period of 1 second\nTest Step 6: Stop sending the IGMPv2 report message from step 5, observe changes in switch multicast group members;\nTest Step 7: tester sends to port1 an IGMPv2 report message with destination address 225.1.1.1, TTL=1, group address field also 225.1.1.1, period of 1 second; after stopping the report message, tester immediately sends to port1 an IGMPv2 leave message with destination address 224.0.0.2, TTL=1, group address field 225.1.1.1. Observe changes in switch multicast group members;\nTest Step 8: Stop sending the messages from step 7;\nTest Step 9: Check DUT configuration to see if it supports IGMPv1, IGMPv2, IGMPv3\n\nCriteria\t:\tExpected Result 1:\n\nCreated by\t:\tTester-006\n\nBugs\t\t:\tNone\n=================================================================================\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip']['default'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # 创建IGMP协议会话\n    igmp = create_igmp(Port=port_up, Version='IGMPV2')\n    edit_igmp(Session=igmp, InitialJoin=True)\n\n    # IGMP协议会话与接口绑定\n    select_interface(Session=igmp, Interface=interfaces_up)\n\n    # 创建组播组\n    multicast_group = create_multicast_group(Start='225.1.1.1')\n\n    # IGMP协议会话创建组成员关系\n    memberships = create_memberships(Session=igmp, DeviceGroupMapping='ROUNDROBIN')\n\n    # IGMP协议会话组成员关系与组播组绑定\n    binding_multicast_group(Session=igmp, Memberships=memberships, MulticastGroup=multicast_group)\n\n    # 创建IGMP Querier协议会话\n\n    igmp_querier = create_igmp_querier(Port=port_down, Version='IGMPV2')\n\n    edit_igmp_querier(Session=igmp_querier, RobustnessVariable=3)\n\n    # IGMP Querier协议会话与接口绑定\n\n    select_interface(Session=igmp_querier, Interface=interfaces_down)\n\n    # 创建IGMP绑定流\n\n    # point = get_layer_from_interfaces(Interfaces=interfaces_down)\n    #\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints=multicast_group, Bidirection=False)\n    # streams1 = add_stream(Type='binding', SrcPoints=point, DstPoints='224.0.0', Bidirection=False)\n\n\n    # edit_port_load_profile(Ports=ports,\n    #                        LoadProfileType='PORT_BASE',\n    #                        Rate=100,\n    #                        Unit='FRAME_PER_SEC',\n    #                        TransmitMode=\"STEP\",\n    #                        Frames=20)\n\n\n    #创建IGMPv2报文\n    # stream1 = add_stream(Ports=port_up, Names=f'igmpv2_report')\n    # edit_stream(Stream=stream1, FixedLength=128)\n    # create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4','igmpv2'])\n    # edit_header_ipv4(Stream=stream1, Source='192.168.1.100', Destination= '225.1.1.1', TTl=1)\n    #\n    # stream2 = add_stream(Ports=port_up, Names=f'igmpv2_query')\n    # edit_stream(Stream=stream2, FixedLength=128)\n    # create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4','igmpv2query'])\n    # edit_header_ipv4(Stream=stream2, Source='192.168.1.100', Destination= '224.0.0.2', TTl=1)\n\n    # 订阅统计\n    subscribe_result(Types=['StreamBlockStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['tc_no'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 启动协议\n        start_protocol()\n\n        # 等待IGMP协议会话稳定状态\n        wait_igmp_state(Sessions=[igmp])\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n        #停止协议\n        stop_protocol()\n\n        # 查询igmp group\n        cmd_cfg = '_'.join('DeviceA_Step4'.split('_')[1:])\n        for _ in range(3):\n            flag = device['DeviceA'].execute(row=cmd_cfg)\n            if flag:\n                break\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nselect_interface:协议绑定测试仪表接口;\nstart_protocol:测试仪表启动协议;\nstop_protocol:测试仪表停止协议;\ncreate_igmp:创建IGMP协议会话对象;\ncreate_igmp_querier:创建IGMP Querier协议会话对象;\nedit_igmp:编辑IGMP协议会话对象;\nedit_igmp_querier:编辑IGMP Querier协议会话对象;\nwait_igmp_state:等待Igmp协议会话达到指定状态;\nbinding_multicast_group:将全局组播组绑定到组播协议会话上;\ncreate_memberships:创建组播协议和组播组绑定关系对象;\ncreate_multicast_group:创建全局组播组对象;\nsubscribe_result:订阅测试仪表统计视图\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_5_10/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.5.10 环网倒换时间\n\n Step\t\t\t:\t测试步骤1: 将4台交换机按照图9连接，允许交换机启用私有环网协议；\n                   测试步骤2: 在整个试验过程中，端口1、端口2互发数据流，测试帧长度为64字节，测试时间为30s，负荷率分别为10%和95%；\n                   测试步骤3: 分别拔插A、B、C路径，测试环网恢复时间。环网倒换时间（ms）=帧丢失数/总发送帧数×测试时间（ms）。\n\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: 6.5.10 Ring Network Switching Time\n\nStep: Test Step 1: Connect four switches according to Figure 9, allowing switches to enable private ring network protocol;\n      Test Step 2: Throughout the test, have Port 1 and Port 2 send bidirectional traffic streams. Use 64-byte test frames with 30-second duration at 10% and 95% load rates respectively;\n      Test Step 3: Disconnect and reconnect paths A, B, and C separately to measure ring recovery time. Ring switching time (ms) = (Number of lost frames / Total transmitted frames) × Test duration (ms).\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None\n=================================================================================",
    "code": "from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=10,)\n    edit_port_load_profile(Ports=port2,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95, )\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插路径\n        time.sleep(30)\n\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time1 =( TxStreamFrames - RxStreamFrames)/TxStreamFrames * 3000\n        print(switch_time1)\n        stop_stream()\n\n        start_stream(Type='stream', Objects=stream2)\n        # 拔插路径\n        time.sleep(30)\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time2 = (TxStreamFrames - RxStreamFrames) / TxStreamFrames * 3000\n        print(switch_time2)\n        stop_stream()\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_l2_learning:启动测试仪表流量二层学习",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize tester and reserve ports for Port1 and Port2 using reserve_port API.\",\n  \"Subtask 2\": \"Configure load profiles: set Port1 to 10% load and Port2 to 95% load using edit_port_load_profile API.\",\n  \"Subtask 3\": \"Create two bidirectional traffic streams (Stream1 and Stream2) with 64-byte frames using add_stream API.\",\n  \"Subtask 4\": \"Configure Ethernet headers for both streams with specified MAC addresses using edit_header_ethernet API.\",\n  \"Subtask 5\": \"Subscribe to PortStats and StreamBlockStats views using subscribe_result API.\",\n  \"Subtask 6\": \"Start both streams simultaneously using start_stream API.\",\n  \"Subtask 7\": \"Simulate path disconnection (Path A) during traffic transmission (manual intervention step).\",\n  \"Subtask 8\": \"Maintain traffic for 30 seconds after disconnection.\",\n  \"Subtask 9\": \"Simulate path reconnection (Path A) after test duration (manual intervention step).\",\n  \"Subtask 10\": \"Stop both streams using stop_stream API.\",\n  \"Subtask 11\": \"Retrieve transmitted (TxStreamFrames) and received (RxStreamFrames) counts for both streams using get_streamblock_statistic API.\",\n  \"Subtask 12\": \"Calculate ring switching time using formula: (Tx - Rx)/Tx * 30000 ms for each stream.\",\n  \"Subtask 13\": \"Clear statistics using clear_result API.\",\n  \"Subtask 14\": \"Repeat steps 6-13 for Path B disconnection/reconnection.\",\n  \"Subtask 15\": \"Repeat steps 6-13 for Path C disconnection/reconnection.\",\n  \"Subtask 16\": \"Release all reserved ports using release_port API.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: 6.5.10 Ring Network Switching Time\n\nStep: Test Step 1: Connect four switches according to Figure 9, allowing switches to enable private ring network protocol;\n      Test Step 2: Throughout the test, have Port 1 and Port 2 send bidirectional traffic streams. Use 64-byte test frames with 30-second duration at 10% and 95% load rates respectively;\n      Test Step 3: Disconnect and reconnect paths A, B, and C separately to measure ring recovery time. Ring switching time (ms) = (Number of lost frames / Total transmitted frames) × Test duration (ms).\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\n# from NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    # if testbed['nto']['enable']['default']:\n    #     nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n    #     nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    port1, port2 = ports\n    edit_port_load_profile(Ports=port1,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=10,)\n    edit_port_load_profile(Ports=port2,\n                           LoadProfileType='PORT_BASE',\n                           Unit='PERCENT',\n                           TransmitMode=\"CONTINUOUS\",\n                           Rate=95, )\n\n    smac_address_list = ['00:00:00:13:40:21']\n    dmac_address_list = ['00:00:01:13:40:20']\n\n    stream1 = add_stream(Ports=port1, Names=f'stream1')\n    edit_stream(Stream=stream1, FixedLength=64)\n    create_stream_header(Stream=stream1, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream1, SourceMacAdd=smac_address_list[0], DestMacAdd=dmac_address_list[0])\n\n\n    stream2 = add_stream(Ports=port1, Names=f'stream2')\n    edit_stream(Stream=stream2, FixedLength=64)\n    create_stream_header(Stream=stream2, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ethernet(Stream=stream2, SourceMacAdd='00:00:00:00:00:00', DestMacAdd=dmac_address_list[0])\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n\n        # 端口1测试\n        # 启动二层学习\n        start_l2_learning()\n        time.sleep(5)\n        # 启动流量测试\n        start_stream(Type='stream', Objects=stream1)\n        #拔插路径\n        time.sleep(30)\n\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream1, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time1 =( TxStreamFrames - RxStreamFrames)/TxStreamFrames * 3000\n        print(switch_time1)\n        stop_stream()\n\n        start_stream(Type='stream', Objects=stream2)\n        # 拔插路径\n        time.sleep(30)\n        # 计算倒换时间\n        Result = get_streamblock_statistic(Stream=stream2, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n        TxStreamFrames = Result['TxStreamFrames']\n        RxStreamFrames = Result['RxStreamFrames']\n        switch_time2 = (TxStreamFrames - RxStreamFrames) / TxStreamFrames * 3000\n        print(switch_time2)\n        stop_stream()\n\n        clear_result()\n\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ethernet:修改测试仪表流量模板中Ethernet报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_l2_learning:启动测试仪表流量二层学习;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/cepri-dev-new/Testcase/tc_6_7_7/main.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 6.7.7 虚拟路由冗余协议（VRRP）\n\n Step\t\t\t:\t测试步骤1:  按图12建立测试环境\n                   测试步骤2:  DUT1 和DUT4为二层接入交换机\n                   测试步骤3:  DUT2（主机）和DUT3（备机）组成双机冗余，两机之间可增加心跳线；\n                   测试步骤4:  tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24\n                   测试步骤5:   DUT2 port1 与DUT3 port1作为192.168.1.0网段网关，代表IP为192.168.1.1/24；\n                   测试步骤6:   DUT2 port2 与DUT3 port2作为192.168.2.0网段网关，代表IP为192.168.2.1/24；\n                   测试步骤7:   tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，\n                               网关设置为VRRP组的虚拟IP地址，查看并记录数据的接收\n                   测试步骤8:  断开交换机DUT1与VRRP主机的连接，查看并记录DUT2、DUT3上VRRP\n                               的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间；\n                               恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流；\n                   测试步骤9:   重复步骤7、8两次。\n Criteria    \t:   预期结果1:\n\n Created by   \t:  \tTester-006\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "Objective: Test Objective: 6.7.7 Virtual Router Redundancy Protocol (VRRP)\n\nStep:\nTest Step 1: Establish the test environment as shown in Figure 12.\nTest Step 2: Configure DUT1 and DUT4 as Layer 2 access switches.\nTest Step 3: Configure DUT2 (Master) and DUT3 (Backup) for device redundancy; a heartbeat cable may be added between them.\nTest Step 4: Set tester port1 IP address to 192.168.1.100/24, port2 to 192.168.2.100/24.\nTest Step 5: Configure DUT2 port1 and DUT3 port1 as gateways for the 192.168.1.0 network segment, with virtual IP 192.168.1.1/24.\nTest Step 6: Configure DUT2 port2 and DUT3 port2 as gateways for the 192.168.2.0 network segment, with virtual IP 192.168.2.1/24.\nTest Step 7: Generate traffic from tester port1 to port2 with frame size 256 bytes at 10,000 frames/second. Set the gateway to the VRRP group's virtual IP address. Observe and record data reception.\nTest Step 8: Disconnect the link between switch DUT1 and the VRRP master device. Observe and record VRRP status on DUT2/DUT3 and data loss. Calculate VRRP convergence time based on packet loss count and transmission rate. Restore the switch link, observe VRRP status on DUT2/DUT3, and resend data traffic.\nTest Step 9: Repeat steps 7 and 8 twice.\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None",
    "code": "import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，10.1.1.111\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Frames=10000)\n\n    stream = add_stream(Ports=port_up, Names=f'stream1')\n    edit_stream(Stream=stream, FixedLength=256)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=cfg['arg']['interface']['default']['ipv4_up_address'],\n                     Destination=cfg['arg']['interface']['default']['ipv4_down_address'],Gateway ='10.1.1.111')\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        for i in range(2):\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n            start_stream()\n            # 断开交换机DUT1与VRRP主机的连接,，查看并记录DUT2、DUT3上VRRP的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            #VRRP的收敛时间\n            Convergence_time = (TxStreamFrames - RxStreamFrames)/TxStreamFrames\n            clear_result()\n            #恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "edit_port:修改测试仪表端口参数",
      "edit_port_load_profile:编辑测试仪表负载配置文件参数",
      "release_port:释放测试仪表的端口",
      "reserve_port:预约测试仪表的端口",
      "wait_port_state:等待测试仪表端口链路达到指定状态",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "clear_result:清除测试仪表统计",
      "get_streamblock_statistic:获取测试仪表流模板块统计结果",
      "subscribe_result:订阅测试仪表统计视图",
      "edit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容",
      "add_stream:测试仪表创建流量",
      "create_stream_header:创建流量报文头部",
      "edit_stream:修改测试仪表流量模板参数",
      "start_stream:测试仪表开始发送数据流",
      "stop_stream:测试仪表停止发送数据流",
      "wait_stream_state:测试仪表停止发送数据流"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Establish test environment by initializing tester equipment and reserving ports as per topology.\",\n  \"Subtask 2\": \"Configure DUT1 and DUT4 as Layer 2 access switches using device-specific commands.\",\n  \"Subtask 3\": \"Configure DUT2 as VRRP master and DUT3 as backup with heartbeat connection between them.\",\n  \"Subtask 4\": \"Set tester port1 IP address to 192.168.1.100/24 and port2 to 192.168.2.100/24 using interface configuration APIs.\",\n  \"Subtask 5\": \"Configure DUT2 port1 and DUT3 port1 as gateways for 192.168.1.0/24 network with virtual IP 192.168.1.1/24.\",\n  \"Subtask 6\": \"Configure DUT2 port2 and DUT3 port2 as gateways for 192.168.2.0/24 network with virtual IP 192.168.2.1/24.\",\n  \"Subtask 7\": \"Create traffic stream from tester port1 to port2 with frame size 256 bytes and rate of 10,000 frames/second, setting gateway to VRRP virtual IP.\",\n  \"Subtask 8\": \"Start traffic transmission, wait for stabilization, then stop stream and record baseline frame statistics (Tx and Rx).\",\n  \"Subtask 9\": \"Verify baseline traffic: confirm received frames equal transmitted frames with no loss.\",\n  \"Subtask 10\": \"Disconnect link between DUT1 and VRRP master device while traffic is running.\",\n  \"Subtask 11\": \"Monitor VRRP status changes on DUT2/DUT3 and record traffic loss statistics during failure event.\",\n  \"Subtask 12\": \"Calculate VRRP convergence time using formula: (Tx frames - Rx frames) / transmission rate (10,000 fps).\",\n  \"Subtask 13\": \"Restore DUT1-VRRP master link and observe VRRP status recovery on DUT2/DUT3.\",\n  \"Subtask 14\": \"Restart traffic stream and record post-recovery frame statistics.\",\n  \"Subtask 15\": \"Verify post-recovery traffic: confirm received frames equal transmitted frames after link restoration.\",\n  \"Subtask 16\": \"Clear all test statistics and repeat failure/recovery test cycle (Subtask 8 to 15) for two additional iterations.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  Objective: Test Objective: 6.7.7 Virtual Router Redundancy Protocol (VRRP)\n\nStep:\nTest Step 1: Establish the test environment as shown in Figure 12.\nTest Step 2: Configure DUT1 and DUT4 as Layer 2 access switches.\nTest Step 3: Configure DUT2 (Master) and DUT3 (Backup) for device redundancy; a heartbeat cable may be added between them.\nTest Step 4: Set tester port1 IP address to 192.168.1.100/24, port2 to 192.168.2.100/24.\nTest Step 5: Configure DUT2 port1 and DUT3 port1 as gateways for the 192.168.1.0 network segment, with virtual IP 192.168.1.1/24.\nTest Step 6: Configure DUT2 port2 and DUT3 port2 as gateways for the 192.168.2.0 network segment, with virtual IP 192.168.2.1/24.\nTest Step 7: Generate traffic from tester port1 to port2 with frame size 256 bytes at 10,000 frames/second. Set the gateway to the VRRP group's virtual IP address. Observe and record data reception.\nTest Step 8: Disconnect the link between switch DUT1 and the VRRP master device. Observe and record VRRP status on DUT2/DUT3 and data loss. Calculate VRRP convergence time based on packet loss count and transmission rate. Restore the switch link, observe VRRP status on DUT2/DUT3, and resend data traffic.\nTest Step 9: Repeat steps 7 and 8 twice.\n\nCriteria: Expected Result 1:\n\nCreated by: Tester-006\n\nBugs: None\n- Code Snippet: \n  ```python\n  import sys\nimport os\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\nntolibrary_path = os.path.join(dirname, os.path.pardir, os.path.pardir)\n\n# 将库的路径添加到 sys.path\nif ntolibrary_path not in sys.path:\n    sys.path.append(ntolibrary_path)\n\nfrom CustomLibrary.common import cfg, testbed, setup, teardown, printf, temp_dir, get_locations, CustomData, edit_port_params\nfrom NtoLibrary.common import NTO\nfrom TesterLibrary.base import *\n\n\ndirname, filename = os.path.split(os.path.abspath(__file__))\ndata = CustomData()\n# 测试前下发配罿\ndevice = setup(cfg, testbed)\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n    # 初始化仪表\n    printf(message='Initialize tester')\n    if testbed['tester']['rtsm']['ip']:\n        init_tester(Rtsm=testbed['tester']['rtsm']['ip'])\n    else:\n        init_tester()\n\n    locations = get_locations(cfg['port'])\n    # 创建端口，并预约端口\n    ports = reserve_port(Locations=locations, Force=testbed['tester']['force']['default'], Debug=testbed['tester']['debug']['default'], WaitForStatusUp=False)\n    port_up, port_down = ports\n    if testbed['nto']['enable']['default']:\n        nto = NTO(host=testbed['nto']['ip'], port=testbed['nto']['port']['default'], username=testbed['nto']['username']['default'], password=testbed['nto']['password']['default'], content_type='multipart/form-data')\n        nto.actions_import(os.path.join(dirname, 'topu.ata'))\n    if not testbed['tester']['debug']['default']:\n        for k, v in testbed['tester'].items():\n            edit_port_kwargs = {}\n            if k in edit_port_params:\n                edit_port_kwargs.update({k: v['default']})\n        if edit_port_kwargs:\n            edit_port(Ports=ports, **edit_port_kwargs)\n            time.sleep(10)\n        if  testbed['tester']['wait_for_status_up']['default']:\n            wait_port_state(ports)\n\n    # 创建接口\n    interfaces_up = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_down = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_up,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_up_address']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='EthIILayer',\n                   Address=cfg['arg']['interface']['default']['mac_down_address']['default'])\n\n    edit_interface(Interface=interfaces_up,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_up_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_up_gateway']['default'])\n\n    edit_interface(Interface=interfaces_down,\n                   Layer='IPv4Layer',\n                   Address=cfg['arg']['interface']['default']['ipv4_down_address']['default'],\n                   Gateway=cfg['arg']['interface']['default']['ipv4_down_gateway']['default'])\n\n    # tester 构建port1至port2 的流量，帧长设置为256bytes，流量设置为10000 帧/秒，10.1.1.111\n    edit_port_load_profile(Ports=ports,\n                           LoadProfileType='PORT_BASE',\n                           Unit='FRAME_PER_SEC',\n                           TransmitMode=\"CONTINUOUS\",\n                           Frames=10000)\n\n    stream = add_stream(Ports=port_up, Names=f'stream1')\n    edit_stream(Stream=stream, FixedLength=256)\n    create_stream_header(Stream=stream, HeaderTypes=['ethernetii', 'ipv4'])\n    edit_header_ipv4(Stream=stream, Source=cfg['arg']['interface']['default']['ipv4_up_address'],\n                     Destination=cfg['arg']['interface']['default']['ipv4_down_address'],Gateway ='10.1.1.111')\n\n    # 订阅统计视图\n    subscribe_result(Types=['PortStats', 'StreamBlockStats'])\n    # 保存配置文件\n    save_case(Path=os.path.join(temp_dir, 'xcfg', '{}.xcfg'.format(cfg['name'])))\n    printf(message='Save case to xcfg')\n\n\n    if not testbed['tester']['debug']['default']:\n        printf(message='Test start')\n        # 执行测试\n        # 启动流量测试\n        for i in range(2):\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n            start_stream()\n            # 断开交换机DUT1与VRRP主机的连接,，查看并记录DUT2、DUT3上VRRP的状态及数据的丢失情况，根据丢包数量和发包速率计算VRRP的收敛时间\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            #VRRP的收敛时间\n            Convergence_time = (TxStreamFrames - RxStreamFrames)/TxStreamFrames\n            clear_result()\n            #恢复交换机链路，查看DUT2、DUT3上VRRP的状态，重新发送数据流\n            start_stream()\n            time.sleep(5)\n            wait_stream_state()\n            stop_stream()\n            Result = get_streamblock_statistic(Stream=stream, StaItems=['TxStreamFrames', 'RxStreamFrames'])\n            TxStreamFrames = Result['TxStreamFrames']\n            RxStreamFrames = Result['RxStreamFrames']\n            if RxStreamFrames != TxStreamFrames or TxStreamFrames == 0:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is not equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=False)\n            else:\n                CustomData.verdict, CustomData.errInfo = printf(\n                    message=f'RxStreamFrames({RxStreamFrames}) is equal to TxStreamFrames({TxStreamFrames})',\n                    step=4, result=True)\n\n            clear_result()\n\n        # 测试结束\n        printf(message='Test completed')\n\n        # 释放端口资源\n        release_port(locations)\n\nexcept Exception as e:\n    CustomData.verdict = 'fail'\n    CustomData.errInfo = repr(e)\nfinally:\n    # 关闭仪表进程\n    shutdown_tester()\n    # 测试结束清除配置\n    teardown(cfg, testbed)\n    print(f'errInfo:\\n{CustomData.errInfo}', flush=True)\n    print(f'verdict:{CustomData.verdict}', flush=True)\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nedit_port:修改测试仪表端口参数;\nedit_port_load_profile:编辑测试仪表负载配置文件参数;\nrelease_port:释放测试仪表的端口;\nreserve_port:预约测试仪表的端口;\nwait_port_state:等待测试仪表端口链路达到指定状态;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nclear_result:清除测试仪表统计;\nget_streamblock_statistic:获取测试仪表流模板块统计结果;\nsubscribe_result:订阅测试仪表统计视图;\nedit_header_ipv4:修改测试仪表流量模板中IPv4报文头部内容;\nadd_stream:测试仪表创建流量;\ncreate_stream_header:创建流量报文头部;\nedit_stream:修改测试仪表流量模板参数;\nstart_stream:测试仪表开始发送数据流;\nstop_stream:测试仪表停止发送数据流;\nwait_stream_state:测试仪表停止发送数据流\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Port/Interface/create_interface.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查仪表创建接口正常\n\n Step\t\t\t:\t测试步骤1: 预约两个自环端口Port_1、Port_2;\n                   测试步骤2: 两个端口分别创建各种类型接口;\n\n Criteria    \t:   预期结果1: 步骤2中所有接口创建成功;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \tNone\n =================================================================================",
    "intent_en": "=================================================================================\nObjective: Purpose: To verify that the instrument's interface creation functions properly.\n\nStep 1: Reserve two loopback ports, Port_1 and Port_2.\nStep 2: Create various types of interfaces on each port.\n\nCriteria: Expected Result 1: All interfaces in step 2 are created successfully.\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    # ------------------------------------------------------------------------------\n    # 链路层: eth,  网络层: None\n    interface = create_interface(Port=Port_UP, Layers='eth')\n    # 等价写法, 先使用create_interface创建接口，再使用edit_interface_stack修改接口结构\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth')\n\n    # 链路层: eth,  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers='eth', Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth', Tops='ipv4')\n\n    # 链路层: eth,  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers='eth', Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth', Tops='ipv6')\n\n    # 链路层: eth,  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers='eth', Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth', Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------单层vlan-----------------------------------------\n    # 链路层: eth, vlan  网络层: None\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'])\n\n    # 链路层: eth, vlan  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'], Tops='ipv4')\n\n    # 链路层: eth, vlan  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'], Tops='ipv6')\n\n    # 链路层: eth, vlan  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'], Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------双层vlan-----------------------------------------\n    # 链路层: eth, vlan, vlan  网络层: None\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'])\n\n    # 链路层: eth, vlan, vlan  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'], Tops='ipv4')\n\n    # 链路层: eth, vlan, vlan  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'], Tops='ipv6')\n\n    # 链路层: eth, vlan, vlan  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'], Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------pppoe-----------------------------------------\n    # 链路层: eth, pppoe  网络层: None\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'])\n\n    # 链路层: eth, pppoe  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'], Tops='ipv4')\n\n    # 链路层: eth, pppoe  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'], Tops='ipv6')\n\n    # 链路层: eth, pppoe  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'], Tops=['ipv4', 'ipv6'])\n\n    # 链路层: eth, vlan, pppoe  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n\n    # 链路层: eth, vlan, vlan, pppoe  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------l2tp-----------------------------------------\n    # 链路层: eth, l2tp 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp'], Tops='ipv4')\n    # 链路层: eth, l2tp 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp'], Tops='ipv6')\n\n    # 链路层: eth, l2tp, ipv4 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    # 链路层: eth, l2tp, ipv4 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv6')\n\n    # 链路层: eth, l2tp, ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, l2tp, ipv4 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv6')\n\n    # 链路层: eth, l2tp, ipv4/ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, l2tp, ipv4/ipv6 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n\n    # 链路层: eth, vlan, l2tp, ipv4/ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, vlan, l2tp, ipv4/ipv6 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n\n    # 链路层: eth, vlan, vlan, l2tp, ipv4/ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, vlan, vlan, l2tp, ipv4/ipv6 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface_stack:修改测试仪表接口的结构"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product (default 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports (Port_UP and Port_Down) from provided locations using reserve_port API.\",\n  \"Subtask 3\": \"For each port, create interfaces with Ethernet layer only and verify successful creation using create_interface API.\",\n  \"Subtask 4\": \"For each port, create interfaces with Ethernet+IPv4 layers using both create_interface with parameters and create_interface+edit_interface_stack methods, verifying success after each operation.\",\n  \"Subtask 5\": \"For each port, create interfaces with Ethernet+IPv6 layers using both direct creation and stack editing methods, verifying success after each operation.\",\n  \"Subtask 6\": \"For each port, create interfaces with Ethernet+IPv4+IPv6 layers using both creation approaches, verifying success after each operation.\",\n  \"Subtask 7\": \"For each port, create interfaces with Ethernet+VLAN layers (single/double VLAN) and various network layers (none/IPv4/IPv6/dual-stack) using both creation methods, verifying success after each operation.\",\n  \"Subtask 8\": \"For each port, create interfaces with Ethernet+PPPoE layers and various network layers using both creation methods, verifying success after each operation.\",\n  \"Subtask 9\": \"For each port, create interfaces with Ethernet+VLAN+PPPoE layers (single/double VLAN) and dual-stack network layers using both creation methods, verifying success after each operation.\",\n  \"Subtask 10\": \"For each port, create interfaces with Ethernet+L2TP layers and various inner IP configurations (none/IPv4/IPv6/dual-stack) using both creation methods, verifying success after each operation.\",\n  \"Subtask 11\": \"For each port, create interfaces with Ethernet+VLAN+L2TP layers and various inner IP configurations using both creation methods, verifying success after each operation.\",\n  \"Subtask 12\": \"Save the test configuration to file using save_case API for traceability.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\nObjective: Purpose: To verify that the instrument's interface creation functions properly.\n\nStep 1: Reserve two loopback ports, Port_1 and Port_2.\nStep 2: Create various types of interfaces on each port.\n\nCriteria: Expected Result 1: All interfaces in step 2 are created successfully.\n\nCreated by: Tester-001\n\nBugs: None\n=================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/15', '//10.0.11.191/1/16'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\ntry:\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    Port_UP, Port_Down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    # ------------------------------------------------------------------------------\n    # 链路层: eth,  网络层: None\n    interface = create_interface(Port=Port_UP, Layers='eth')\n    # 等价写法, 先使用create_interface创建接口，再使用edit_interface_stack修改接口结构\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth')\n\n    # 链路层: eth,  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers='eth', Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth', Tops='ipv4')\n\n    # 链路层: eth,  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers='eth', Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth', Tops='ipv6')\n\n    # 链路层: eth,  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers='eth', Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers='eth', Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------单层vlan-----------------------------------------\n    # 链路层: eth, vlan  网络层: None\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'])\n\n    # 链路层: eth, vlan  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'], Tops='ipv4')\n\n    # 链路层: eth, vlan  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'], Tops='ipv6')\n\n    # 链路层: eth, vlan  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan'], Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------双层vlan-----------------------------------------\n    # 链路层: eth, vlan, vlan  网络层: None\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'])\n\n    # 链路层: eth, vlan, vlan  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'], Tops='ipv4')\n\n    # 链路层: eth, vlan, vlan  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'], Tops='ipv6')\n\n    # 链路层: eth, vlan, vlan  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan'], Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------pppoe-----------------------------------------\n    # 链路层: eth, pppoe  网络层: None\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'])\n\n    # 链路层: eth, pppoe  网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'], Tops='ipv4')\n\n    # 链路层: eth, pppoe  网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'], Tops='ipv6')\n\n    # 链路层: eth, pppoe  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'pppoe'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'pppoe'], Tops=['ipv4', 'ipv6'])\n\n    # 链路层: eth, vlan, pppoe  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n\n    # 链路层: eth, vlan, vlan, pppoe  网络层: ipv4, ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan', 'pppoe'], Tops=['ipv4', 'ipv6'])\n\n    # -------------------------------------l2tp-----------------------------------------\n    # 链路层: eth, l2tp 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp'], Tops='ipv4')\n    # 链路层: eth, l2tp 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp'], Tops='ipv6')\n\n    # 链路层: eth, l2tp, ipv4 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv4')\n    # 链路层: eth, l2tp, ipv4 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4'], Tops='ipv6')\n\n    # 链路层: eth, l2tp, ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, l2tp, ipv4 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv6'], Tops='ipv6')\n\n    # 链路层: eth, l2tp, ipv4/ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, l2tp, ipv4/ipv6 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n\n    # 链路层: eth, vlan, l2tp, ipv4/ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, vlan, l2tp, ipv4/ipv6 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n\n    # 链路层: eth, vlan, vlan, l2tp, ipv4/ipv6 网络层: ipv4\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv4')\n    # 链路层: eth, vlan, vlan, l2tp, ipv4/ipv6 网络层: ipv6\n    interface = create_interface(Port=Port_UP, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n    # 等价写法\n    interface = create_interface(Port=Port_Down)\n    edit_interface_stack(Interfaces=interface, Layers=['eth', 'vlan', 'vlan', 'l2tp', 'ipv4', 'ipv6'], Tops='ipv6')\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface_stack:修改测试仪表接口的结构\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  }
]
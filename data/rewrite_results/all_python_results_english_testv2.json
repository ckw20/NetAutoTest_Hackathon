[
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_Congestion.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的拥塞控制\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项拥塞控制;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 4 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 5 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_congested, port_uncongested = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['congestionControl'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_1, port_2, port_congested, port_uncongested])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_1, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_2, Layers=['eth'])\n    interfaces_3 = create_interface(Port=port_congested, Layers=['eth'])\n    interfaces_4 = create_interface(Port=port_uncongested, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')[0]\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')[0]\n    point_congested = get_layer_from_interfaces(Interfaces=interfaces_3, Layer='eth')[0]\n    point_uncongested = get_layer_from_interfaces(Interfaces=interfaces_4, Layer='eth')[0]\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=[point_1, point_2],\n                                       DstPoints=[point_congested, point_uncongested], Mode='congestion')\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *拥塞控制参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='congestionControl',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with specified product using init_tester API.\",\n  \"Subtask 2\": \"Reserve four ports using reserve_port API with force reservation.\",\n  \"Subtask 3\": \"Create RFC2889 benchmark configuration for congestion control test using create_benchmark API.\",\n  \"Subtask 4\": \"Assign reserved ports to benchmark configuration using relate_benchmark_ports API.\",\n  \"Subtask 5\": \"Create Ethernet interfaces on all reserved ports using create_interface API.\",\n  \"Subtask 6\": \"Retrieve Ethernet layer objects from interfaces using get_layer_from_interfaces API.\",\n  \"Subtask 7\": \"Create congestion control test streams between source ports (1,2) and destination ports (congested, uncongested) using create_benchmark_streams API.\",\n  \"Subtask 8\": \"Configure latency settings (FIFO, delay before/after) using edit_benchmark_latency API.\",\n  \"Subtask 9\": \"Set result file storage path using edit_benchmark_path API.\",\n  \"Subtask 10\": \"Configure address learning parameters (frequency, rate, repeats, delay) using edit_benchmark_learning API.\",\n  \"Subtask 11\": \"Set test duration parameters (trial count, burst mode, burst count) using edit_benchmark_duration API.\",\n  \"Subtask 12\": \"Configure frame length to custom 64 bytes using edit_benchmark_frame API.\",\n  \"Subtask 13\": \"Set traffic load parameters (step mode, start/end/step percentage) using edit_benchmark_traffic_load_loop API.\",\n  \"Subtask 14\": \"Configure burst count to custom value [1] using edit_benchmark_burst_count_loop API.\",\n  \"Subtask 15\": \"Set custom result file name 'congestionControl' with timestamp using edit_benchmark_result_file_name API.\",\n  \"Subtask 16\": \"Generate test script by expanding benchmark configuration using expand_benchmark API.\",\n  \"Subtask 17\": \"Save test case configuration to .xcfg file using save_case API.\",\n  \"Subtask 18\": \"Execute benchmark test with analyzer enabled and 1200s timeout using run_benchmark API.\",\n  \"Subtask 19\": \"Retrieve RFC2889 test results from database using get_benchmark_result API.\",\n  \"Subtask 20\": \"Format test results into table using format_benchmark_result API.\",\n  \"Subtask 21\": \"Validate that test results correctly measure device address cache capacity as per expected criteria.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的拥塞控制\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项拥塞控制;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 4 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 5 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_congested, port_uncongested = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['congestionControl'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_1, port_2, port_congested, port_uncongested])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_1, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_2, Layers=['eth'])\n    interfaces_3 = create_interface(Port=port_congested, Layers=['eth'])\n    interfaces_4 = create_interface(Port=port_uncongested, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')[0]\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')[0]\n    point_congested = get_layer_from_interfaces(Interfaces=interfaces_3, Layer='eth')[0]\n    point_uncongested = get_layer_from_interfaces(Interfaces=interfaces_4, Layer='eth')[0]\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=[point_1, point_2],\n                                       DstPoints=[point_congested, point_uncongested], Mode='congestion')\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *拥塞控制参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='congestionControl',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_BroadcastForwarding.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastForwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester with the specified product type (default 'DarYu') using init_tester API.\",\n  \"Subtask 2\": \"Reserve two ports using reserve_port API with force option enabled and provided locations.\",\n  \"Subtask 3\": \"Create an RFC2889 benchmark test suite for 'broadcastForwarding' item using create_benchmark API.\",\n  \"Subtask 4\": \"Assign reserved ports to the benchmark using relate_benchmark_ports API.\",\n  \"Subtask 5\": \"Create Ethernet layer interfaces on both reserved ports using create_interface API.\",\n  \"Subtask 6\": \"Generate traffic streams between interfaces using create_benchmark_streams API with unidirectional configuration.\",\n  \"Subtask 7\": \"Configure benchmark options: set latency type to FIFO with 2ms delay before and 10ms after using edit_benchmark_latency, set result path using edit_benchmark_path, and configure MAC learning with 100 packets/sec rate using edit_benchmark_learning.\",\n  \"Subtask 8\": \"Configure broadcast frame parameters: set trial count to 1 with burst mode and 100 frames using edit_benchmark_duration, set frame size to 64 bytes using edit_benchmark_frame, configure load search from 10% to 20% in 10% steps using edit_benchmark_search, set burst count to 1 using edit_benchmark_burst_count_loop, and enable custom result file naming with timestamp using edit_benchmark_result_file_name.\",\n  \"Subtask 9\": \"Generate test script using expand_benchmark API and save configuration to file using save_case API.\",\n  \"Subtask 10\": \"Execute benchmark test with 1200s timeout and analyzer enabled using run_benchmark API, then retrieve and format results using get_benchmark_result and format_benchmark_result APIs.\",\n  \"Subtask 11\": \"Validate that the test correctly measures the device's address cache capacity as specified in the success criteria.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastForwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_imix.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查BLDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 获取仪表已有imix模板\n    imix_template = [get_imix_from_name(Name='Default'), get_imix_from_name(Name='4-Point'),\n                     get_imix_from_name(Name='IPSEC'), get_imix_from_name(Name='TCPv4')]\n\n    # 创建新imix模板\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_02')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_03')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    # 创建RFC2544 Throughput测试套件\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='imix', ImixTemplates=imix_template)\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n    imix = create_imix(Name='CTRI_IMIX424')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "add_imix_distribution_frame:在Imix模板添加自定义帧长",
      "create_imix:创建流量Imix模板",
      "get_imix_from_name:通过Imix模板名称获取流量Imix模板对象",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the tester platform using init_tester with the specified product parameter.\",\n  \"Subtask 2\": \"Reserve two physical ports using reserve_port with given location addresses.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on both reserved ports using create_interface.\",\n  \"Subtask 4\": \"Configure IPv4 address and gateway settings for the first interface (client-side) using edit_interface.\",\n  \"Subtask 5\": \"Configure IPv4 address and gateway settings for the second interface (provider-side router) using edit_interface.\",\n  \"Subtask 6\": \"Create bidirectional binding streams between IPv4 layers of both interfaces using get_layer_from_interfaces and add_stream.\",\n  \"Subtask 7\": \"Create new IMIX templates (Imix_01, Imix_02, Imix_03) using create_imix.\",\n  \"Subtask 8\": \"Add frame length distributions to each IMIX template using add_imix_distribution_frame with random size ranges and weights.\",\n  \"Subtask 9\": \"Create RFC2544 Throughput test suite (LDP VPLS wizard) using create_benchmark with 'throughput' type.\",\n  \"Subtask 10\": \"Associate reserved ports with the test suite using relate_benchmark_ports.\",\n  \"Subtask 11\": \"Configure test suite to use pre-created streams using benchmark_stream_use_exist.\",\n  \"Subtask 12\": \"Set address learning parameters for the test suite using edit_benchmark_learning (frequency='once', ARP disabled).\",\n  \"Subtask 13\": \"Configure test duration settings using edit_benchmark_duration (count=1).\",\n  \"Subtask 14\": \"Configure frame length settings using edit_benchmark_frame with multiple IMIX templates.\",\n  \"Subtask 15\": \"Configure search algorithm parameters using edit_benchmark_search (initial/lower/upper=100%).\",\n  \"Subtask 16\": \"Generate final LDP VPLS wizard configuration by expanding the benchmark using expand_benchmark.\",\n  \"Subtask 17\": \"Save the complete test configuration to file using save_case with derived filename path.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查BLDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 获取仪表已有imix模板\n    imix_template = [get_imix_from_name(Name='Default'), get_imix_from_name(Name='4-Point'),\n                     get_imix_from_name(Name='IPSEC'), get_imix_from_name(Name='TCPv4')]\n\n    # 创建新imix模板\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_02')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_03')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    # 创建RFC2544 Throughput测试套件\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='imix', ImixTemplates=imix_template)\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n    imix = create_imix(Name='CTRI_IMIX424')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nadd_imix_distribution_frame:在Imix模板添加自定义帧长;\ncreate_imix:创建流量Imix模板;\nget_imix_from_name:通过Imix模板名称获取流量Imix模板对象;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n{\n  \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n  \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n  \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n  \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n}\n"
  }
]
[
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_imix.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查BLDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 获取仪表已有imix模板\n    imix_template = [get_imix_from_name(Name='Default'), get_imix_from_name(Name='4-Point'),\n                     get_imix_from_name(Name='IPSEC'), get_imix_from_name(Name='TCPv4')]\n\n    # 创建新imix模板\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_02')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_03')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    # 创建RFC2544 Throughput测试套件\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='imix', ImixTemplates=imix_template)\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n    imix = create_imix(Name='CTRI_IMIX424')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "add_imix_distribution_frame:在Imix模板添加自定义帧长",
      "create_imix:创建流量Imix模板",
      "get_imix_from_name:通过Imix模板名称获取流量Imix模板对象",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定测试平台类型。\",\n  \"子任务2\": \"创建两个离线端口 Port_1 和 Port_2，并完成端口预约操作。\",\n  \"子任务3\": \"在 Port_1 上创建 IPv4 接口，配置 IP 地址和网关参数。\",\n  \"子任务4\": \"在 Port_2 上创建 IPv4 接口，配置 IP 地址和网关参数。\",\n  \"子任务5\": \"创建双向绑定流量流，源为 Port_1 的 IPv4 层，目的为 Port_2 的 IPv4 层。\",\n  \"子任务6\": \"创建 LDP VPLS 向导配置框架，指定测试套件类型为 VPLS。\",\n  \"子任务7\": \"关联测试套件使用的物理端口（Port_1 和 Port_2）。\",\n  \"子任务8\": \"配置向导的客户端侧端口（Port_1）和提供商侧端口（Port_2）。\",\n  \"子任务9\": \"配置提供商侧路由器参数（IP 地址和网关）。\",\n  \"子任务10\": \"配置 VPLS 实例参数（包括 VPLS ID 等关键属性）。\",\n  \"子任务11\": \"配置 Host 主机参数（IP 地址等网络属性）。\",\n  \"子任务12\": \"将已创建的流量流关联到测试套件。\",\n  \"子任务13\": \"配置测试套件的地址学习参数（频率和 ARP 设置）。\",\n  \"子任务14\": \"配置测试套件的帧长模板（IMIX 类型及分布）。\",\n  \"子任务15\": \"配置测试套件的负载搜索参数（初始值及上下限）。\",\n  \"子任务16\": \"生成完整的 LDP VPLS 向导配置。\",\n  \"子任务17\": \"验证配置生成过程无异常，检查错误信息输出。\",\n  \"子任务18\": \"保存生成的测试配置文件到指定路径。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查BLDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 获取仪表已有imix模板\n    imix_template = [get_imix_from_name(Name='Default'), get_imix_from_name(Name='4-Point'),\n                     get_imix_from_name(Name='IPSEC'), get_imix_from_name(Name='TCPv4')]\n\n    # 创建新imix模板\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_02')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_03')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    # 创建RFC2544 Throughput测试套件\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='imix', ImixTemplates=imix_template)\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n    imix = create_imix(Name='CTRI_IMIX424')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nadd_imix_distribution_frame:在Imix模板添加自定义帧长;\ncreate_imix:创建流量Imix模板;\nget_imix_from_name:通过Imix模板名称获取流量Imix模板对象;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_Congestion.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的拥塞控制\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项拥塞控制;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 4 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 5 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_congested, port_uncongested = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['congestionControl'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_1, port_2, port_congested, port_uncongested])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_1, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_2, Layers=['eth'])\n    interfaces_3 = create_interface(Port=port_congested, Layers=['eth'])\n    interfaces_4 = create_interface(Port=port_uncongested, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')[0]\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')[0]\n    point_congested = get_layer_from_interfaces(Interfaces=interfaces_3, Layer='eth')[0]\n    point_uncongested = get_layer_from_interfaces(Interfaces=interfaces_4, Layer='eth')[0]\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=[point_1, point_2],\n                                       DstPoints=[point_congested, point_uncongested], Mode='congestion')\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *拥塞控制参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='congestionControl',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台型号为'DarYu'。\",\n  \"子任务2\": \"预约测试仪表端口，指定端口位置列表并强制占用。\",\n  \"子任务3\": \"创建RFC2889测试向导，选择拥塞控制测试项。\",\n  \"子任务4\": \"为测试向导分配已预约的四个测试端口。\",\n  \"子任务5\": \"在四个测试端口上分别创建以太网接口层。\",\n  \"子任务6\": \"从接口层获取以太网封装层对象作为流量端点。\",\n  \"子任务7\": \"创建拥塞控制测试流量流，配置源/目的端点及拥塞模式。\",\n  \"子任务8\": \"配置测试时延参数：设置FIFO类型、延迟前后时间。\",\n  \"子任务9\": \"配置测试结果保存路径。\",\n  \"子任务10\": \"配置地址学习参数：频率、速率、重复次数及延迟。\",\n  \"子任务11\": \"配置测试时长参数：设置试验次数、突发模式和帧计数。\",\n  \"子任务12\": \"配置帧长度参数：设置为自定义64字节帧。\",\n  \"子任务13\": \"配置流量负载参数：设置步进模式、起始/结束负载及步长。\",\n  \"子任务14\": \"配置突发帧数参数：设置为自定义1帧突发。\",\n  \"子任务15\": \"配置测试结果文件名：启用自定义名称并添加时间戳。\",\n  \"子任务16\": \"生成测试智能脚本。\",\n  \"子任务17\": \"保存当前测试配置文件到指定路径。\",\n  \"子任务18\": \"执行测试套件，启用分析器并设置超时时间。\",\n  \"子任务19\": \"从测试结果数据库中获取RFC2889拥塞控制测试结果。\",\n  \"子任务20\": \"格式化测试结果为二维表格形式。\",\n  \"子任务21\": \"验证测试结果中设备地址缓存容量是否符合预期。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的拥塞控制\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项拥塞控制;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 4 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 5 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_congested, port_uncongested = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['congestionControl'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_1, port_2, port_congested, port_uncongested])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_1, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_2, Layers=['eth'])\n    interfaces_3 = create_interface(Port=port_congested, Layers=['eth'])\n    interfaces_4 = create_interface(Port=port_uncongested, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')[0]\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')[0]\n    point_congested = get_layer_from_interfaces(Interfaces=interfaces_3, Layer='eth')[0]\n    point_uncongested = get_layer_from_interfaces(Interfaces=interfaces_4, Layer='eth')[0]\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=[point_1, point_2],\n                                       DstPoints=[point_congested, point_uncongested], Mode='congestion')\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *拥塞控制参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='congestionControl',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_BroadcastForwarding.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastForwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"子任务1\": \"初始化测试仪表，指定仪表平台类型。\",\n  \"子任务2\": \"预约测试仪端口，指定端口位置并强制占用。\",\n  \"子任务3\": \"创建RFC2889测试套件，选择广播帧转发测试项。\",\n  \"子任务4\": \"关联测试套件与预约的端口。\",\n  \"子任务5\": \"在测试仪端口上创建以太网接口。\",\n  \"子任务6\": \"获取接口的以太网层对象作为流量端点。\",\n  \"子任务7\": \"为测试套件创建单向流量，指定源和目的端点。\",\n  \"子任务8\": \"配置测试套件时延参数（FIFO模式、延迟前后时间）。\",\n  \"子任务9\": \"配置测试套件地址学习参数（学习频率、速率、重复次数）。\",\n  \"子任务10\": \"配置测试结果保存路径。\",\n  \"子任务11\": \"设置测试时长参数（试验次数、突发模式、帧计数）。\",\n  \"子任务12\": \"配置测试帧长类型为自定义长度。\",\n  \"子任务13\": \"配置测试负载搜索模式（步进模式、上下限及步长）。\",\n  \"子任务14\": \"配置突发帧数模式为自定义值。\",\n  \"子任务15\": \"配置自定义测试结果文件名并启用时间戳。\",\n  \"子任务16\": \"生成测试套件智能脚本。\",\n  \"子任务17\": \"保存当前测试配置文件。\",\n  \"子任务18\": \"执行测试套件并设置超时时间。\",\n  \"子任务19\": \"从测试结果数据库中获取RFC2889测试数据。\",\n  \"子任务20\": \"验证测试结果是否准确反映设备地址缓存容量。\"\n}",
    "prompt": "你是一位资深的网络测试专家，擅长将复杂的自然语言测试意图分解为可执行的细粒度操作步骤。\n\n你将收到以下输入内容：\n\nTask Intent：用自然语言描述的网络测试用例目标与流程\nCode Snippet：测试脚本代码\nAPI Functions：用于生成测试脚本的 API 接口列表\n\n---\n\n你的任务是：\n\n请根据上述输入，将 Task Intent 改写为一个标准化化、细粒度的子任务列表，用于驱动自动化测试脚本生成。\n\n每个子任务应满足以下要求，重点注意！！！\n1. 遵循逻辑执行顺序，反映实际网络测试的步骤先后关系；\n2. 表述规范明确，便于后续通过语义匹配在 API Functions 中检索对应的函数；\n3. 确保不遗漏任何关键的测试意图或判断条件（例如配置、验证、预期结果等）；\n4. 任务之间具备上下文连贯性，确保后续任务能够衔接前面的输出。\n\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastForwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### 输出格式要求：\n\n请以 JSON 格式返回，键为 `\"子任务1\"`, `\"子任务2\"` 等，值为该任务的具体描述，不要输出多余内容。例如：\n{\n  \"子任务1\": \"配置交换机端口 eth1 与测试仪连接，设置为全双工模式。\",\n  \"子任务2\": \"使用 API 创建流量流，帧长度为 64 字节，测试时间为 60 秒。\",\n  \"子任务3\": \"开始流量发送，并记录测试期间的丢包率和吞吐量。\",\n  \"子任务4\": \"校验测试结果是否满足预期：吞吐率达 100%。\"\n}\n"
  }
]
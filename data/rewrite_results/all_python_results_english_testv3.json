[
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_BroadcastForwarding.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastForwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for product 'DarYu'.\",\n  \"Subtask 2\": \"Reserve two test ports from specified locations and assign them as port_up and port_down.\",\n  \"Subtask 3\": \"Create RFC2889 benchmark test suite with 'broadcastForwarding' test item selected.\",\n  \"Subtask 4\": \"Assign reserved ports (port_up and port_down) to the benchmark test suite.\",\n  \"Subtask 5\": \"Create Ethernet interfaces on both reserved ports (port_up and port_down).\",\n  \"Subtask 6\": \"Retrieve Ethernet layer objects from both created interfaces.\",\n  \"Subtask 7\": \"Create unidirectional test streams from port_up to port_down for broadcastForwarding test.\",\n  \"Subtask 8\": \"Configure benchmark latency settings (FIFO mode with delay before/after).\",\n  \"Subtask 9\": \"Set benchmark result save path.\",\n  \"Subtask 10\": \"Configure benchmark address learning parameters (frequency, rate, repeats, delay).\",\n  \"Subtask 11\": \"Set test duration parameters (trial count, burst mode).\",\n  \"Subtask 12\": \"Configure frame size settings (custom 64-byte frames).\",\n  \"Subtask 13\": \"Set load search parameters (step mode with lower/upper bounds and step value).\",\n  \"Subtask 14\": \"Configure burst count settings (custom value 1).\",\n  \"Subtask 15\": \"Set custom result file naming convention with timestamp.\",\n  \"Subtask 16\": \"Generate smart test script by expanding benchmark configuration.\",\n  \"Subtask 17\": \"Save test configuration to specified file path.\",\n  \"Subtask 18\": \"Execute benchmark test suite with analyzer enabled and timeout setting.\",\n  \"Subtask 19\": \"Retrieve benchmark results from output database.\",\n  \"Subtask 20\": \"Format and display benchmark test results.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastForwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n\nFor excmple:\n## Input:\n  - Task Intent:\n    =================================================================================\n    Objective      :   测试目的 :  开放式最短路径优先路由协议（OSPF)\n\n    Step           :   测试步骤1: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24；\n                      测试步骤2: DUT port1 IP地址为192.168.1.1/24，port2为 192.168.2.1/24；\n                      测试步骤3: 在DUT上配置OSPFv2路由协议；\n                      测试步骤4: 测试仪tester使用port1、port2建立OSPF路由器，在port1插入一些LSA，并使port1和DUT的port1达到FULL状态，port2和DUT的port2达到FULL状态，观察port2是否能得到port1的LSA。\n\n    Criteria       :   预期结果1: ospf建立成功，可以收到lsa\n    =================================================================================\n\n\n## Output:\n{\n  \"Subtask 1\": \"Initialize the test instrument and prepare for network testing.\",\n  \"Subtask 2\": \"Reserve the test instrument ports port1 and port2, and wait until the ports are in the UP state.\",\n  \"Subtask 3\": \"Create an IPv4 interface on port1, assign IP address 192.168.1.100/24, and configure the corresponding MAC address.\",\n  \"Subtask 4\": \"Create an IPv4 interface on port2, assign IP address 192.168.2.100/24, and configure the corresponding MAC address.\",\n  \"Subtask 5\": \"Configure DUT port1 with IP address 192.168.1.1/24, and port2 with IP address 192.168.2.1/24.\",\n  \"Subtask 6\": \"Enable and configure OSPFv2 protocol on DUT.\",\n  \"Subtask 7\": \"Establish an OSPFv2 session on port1, set the priority to 1, and bind it to the configured interface.\",\n  \"Subtask 8\": \"Establish an OSPFv2 session on port2, set the priority to 1, and bind it to the configured interface.\",\n  \"Subtask 9\": \"Check whether the OSPF session on port1 receives the Summary LSA.\",\n  \"Subtask 10\": \"Check whether the OSPF session on port2 receives the External LSA.\",\n  \"Subtask 11\": \"Create a routing entry on DUT with port2 as the next-hop output interface.\",\n  \"Subtask 12\": \"Inject an LSA at port1 and configure a routing prefix to be advertised.\",\n  \"Subtask 13\": \"Inject a stream at port1 targeting the advertised prefix.\",\n  \"Subtask 14\": \"Verify the current routing entry using xcfg and display the routing data.\",\n  \"Subtask 15\": \"Enable OSPF routing between DUT and port1, port2; verify that the neighbor status of DUT port2 reaches FULL.\",\n  \"Subtask 16\": \"Check whether DUT port2 receives Summary LSA and External LSA.\",\n  \"Subtask 17\": \"Stop traffic injection, keep session state unchanged.\",\n  \"Subtask 18\": \"Clear the OSPFv2 session on DUT and re-establish the session.\",\n  \"Subtask 19\": \"Capture traffic and send a packet reception report; verify whether DUT port2 successfully receives the LSA from port1.\",\n  \"Subtask 20\": \"Capture traffic and analyze packet sending and receiving statistics; verify whether DUT port2 successfully receives the LSA advertised by port1.\",\n  \"Subtask 21\": \"Release the test instrument and finish the test.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_Congestion.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的拥塞控制\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项拥塞控制;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 4 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 5 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_congested, port_uncongested = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['congestionControl'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_1, port_2, port_congested, port_uncongested])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_1, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_2, Layers=['eth'])\n    interfaces_3 = create_interface(Port=port_congested, Layers=['eth'])\n    interfaces_4 = create_interface(Port=port_uncongested, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')[0]\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')[0]\n    point_congested = get_layer_from_interfaces(Interfaces=interfaces_3, Layer='eth')[0]\n    point_uncongested = get_layer_from_interfaces(Interfaces=interfaces_4, Layer='eth')[0]\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=[point_1, point_2],\n                                       DstPoints=[point_congested, point_uncongested], Mode='congestion')\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *拥塞控制参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='congestionControl',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument for network testing.\",\n  \"Subtask 2\": \"Reserve the required test instrument ports.\",\n  \"Subtask 3\": \"Create an RFC2889 benchmark test suite specifically for congestion control testing.\",\n  \"Subtask 4\": \"Assign the reserved ports to the benchmark test suite.\",\n  \"Subtask 5\": \"Create Ethernet interfaces on each reserved port.\",\n  \"Subtask 6\": \"Extract Ethernet layer objects from the created interfaces.\",\n  \"Subtask 7\": \"Create congestion control traffic streams between source and destination endpoints.\",\n  \"Subtask 8\": \"Configure benchmark test options including latency parameters, result storage path, and address learning settings.\",\n  \"Subtask 9\": \"Configure congestion control parameters: trial duration, frame length, traffic load patterns, and burst count settings.\",\n  \"Subtask 10\": \"Set custom naming convention for test result files with timestamp inclusion.\",\n  \"Subtask 11\": \"Generate executable test scripts by expanding the benchmark configuration.\",\n  \"Subtask 12\": \"Save the test configuration to a specified file path.\",\n  \"Subtask 13\": \"Execute the generated test scripts and run the congestion control benchmark.\",\n  \"Subtask 14\": \"Retrieve and process the benchmark test results from the output database.\",\n  \"Subtask 15\": \"Analyze test results to verify correct measurement of device address cache capacity.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的拥塞控制\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项拥塞控制;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 4 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 5 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_congested, port_uncongested = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['congestionControl'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_1, port_2, port_congested, port_uncongested])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_1, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_2, Layers=['eth'])\n    interfaces_3 = create_interface(Port=port_congested, Layers=['eth'])\n    interfaces_4 = create_interface(Port=port_uncongested, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')[0]\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')[0]\n    point_congested = get_layer_from_interfaces(Interfaces=interfaces_3, Layer='eth')[0]\n    point_uncongested = get_layer_from_interfaces(Interfaces=interfaces_4, Layer='eth')[0]\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=[point_1, point_2],\n                                       DstPoints=[point_congested, point_uncongested], Mode='congestion')\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *拥塞控制参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='congestionControl',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n\nFor excmple:\n## Input:\n  - Task Intent:\n    =================================================================================\n    Objective      :   测试目的 :  开放式最短路径优先路由协议（OSPF)\n\n    Step           :   测试步骤1: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24；\n                      测试步骤2: DUT port1 IP地址为192.168.1.1/24，port2为 192.168.2.1/24；\n                      测试步骤3: 在DUT上配置OSPFv2路由协议；\n                      测试步骤4: 测试仪tester使用port1、port2建立OSPF路由器，在port1插入一些LSA，并使port1和DUT的port1达到FULL状态，port2和DUT的port2达到FULL状态，观察port2是否能得到port1的LSA。\n\n    Criteria       :   预期结果1: ospf建立成功，可以收到lsa\n    =================================================================================\n\n\n## Output:\n{\n  \"Subtask 1\": \"Initialize the test instrument and prepare for network testing.\",\n  \"Subtask 2\": \"Reserve the test instrument ports port1 and port2, and wait until the ports are in the UP state.\",\n  \"Subtask 3\": \"Create an IPv4 interface on port1, assign IP address 192.168.1.100/24, and configure the corresponding MAC address.\",\n  \"Subtask 4\": \"Create an IPv4 interface on port2, assign IP address 192.168.2.100/24, and configure the corresponding MAC address.\",\n  \"Subtask 5\": \"Configure DUT port1 with IP address 192.168.1.1/24, and port2 with IP address 192.168.2.1/24.\",\n  \"Subtask 6\": \"Enable and configure OSPFv2 protocol on DUT.\",\n  \"Subtask 7\": \"Establish an OSPFv2 session on port1, set the priority to 1, and bind it to the configured interface.\",\n  \"Subtask 8\": \"Establish an OSPFv2 session on port2, set the priority to 1, and bind it to the configured interface.\",\n  \"Subtask 9\": \"Check whether the OSPF session on port1 receives the Summary LSA.\",\n  \"Subtask 10\": \"Check whether the OSPF session on port2 receives the External LSA.\",\n  \"Subtask 11\": \"Create a routing entry on DUT with port2 as the next-hop output interface.\",\n  \"Subtask 12\": \"Inject an LSA at port1 and configure a routing prefix to be advertised.\",\n  \"Subtask 13\": \"Inject a stream at port1 targeting the advertised prefix.\",\n  \"Subtask 14\": \"Verify the current routing entry using xcfg and display the routing data.\",\n  \"Subtask 15\": \"Enable OSPF routing between DUT and port1, port2; verify that the neighbor status of DUT port2 reaches FULL.\",\n  \"Subtask 16\": \"Check whether DUT port2 receives Summary LSA and External LSA.\",\n  \"Subtask 17\": \"Stop traffic injection, keep session state unchanged.\",\n  \"Subtask 18\": \"Clear the OSPFv2 session on DUT and re-establish the session.\",\n  \"Subtask 19\": \"Capture traffic and send a packet reception report; verify whether DUT port2 successfully receives the LSA from port1.\",\n  \"Subtask 20\": \"Capture traffic and analyze packet sending and receiving statistics; verify whether DUT port2 successfully receives the LSA advertised by port1.\",\n  \"Subtask 21\": \"Release the test instrument and finish the test.\"\n}\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_imix.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查BLDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 获取仪表已有imix模板\n    imix_template = [get_imix_from_name(Name='Default'), get_imix_from_name(Name='4-Point'),\n                     get_imix_from_name(Name='IPSEC'), get_imix_from_name(Name='TCPv4')]\n\n    # 创建新imix模板\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_02')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_03')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    # 创建RFC2544 Throughput测试套件\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='imix', ImixTemplates=imix_template)\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n    imix = create_imix(Name='CTRI_IMIX424')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "add_imix_distribution_frame:在Imix模板添加自定义帧长",
      "create_imix:创建流量Imix模板",
      "get_imix_from_name:通过Imix模板名称获取流量Imix模板对象",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口"
    ],
    "rewrite_intent": "{\n  \"Subtask 1\": \"Initialize the test instrument with the specified product platform.\",\n  \"Subtask 2\": \"Reserve 8 offline ports (Port_1 to Port_8) on the test instrument and ensure they are in the UP state.\",\n  \"Subtask 3\": \"Create IPv4 interfaces on Port_1 and Port_2, configuring IP addresses and gateways.\",\n  \"Subtask 4\": \"Configure client-side ports (e.g., Port_1) and provider-side ports (e.g., Port_2) by assigning specific roles in the VPLS topology.\",\n  \"Subtask 5\": \"Set up provider-side router emulation on designated ports, including LDP protocol configuration.\",\n  \"Subtask 6\": \"Configure VPLS service parameters including VPLS ID, site creation, and pseudowire establishment.\",\n  \"Subtask 7\": \"Configure host parameters on client-side ports including IP/MAC addresses and VLAN settings.\",\n  \"Subtask 8\": \"Create bidirectional traffic streams between client-side hosts using binding streams.\",\n  \"Subtask 9\": \"Generate and customize IMIX templates for traffic frame size distribution.\",\n  \"Subtask 10\": \"Create LDP VPLS benchmark/wizard configuration and associate reserved ports.\",\n  \"Subtask 11\": \"Configure benchmark parameters: use existing streams, set address learning to 'once', duration to single iteration.\",\n  \"Subtask 12\": \"Apply IMIX templates to benchmark frame settings and configure throughput search parameters.\",\n  \"Subtask 13\": \"Generate the final LDP VPLS wizard configuration and verify error-free completion.\",\n  \"Subtask 14\": \"Save the test case configuration file to the specified path.\"\n}",
    "prompt": "You are a senior network testing expert, skilled at breaking down complex natural language test intents into executable fine-grained action steps.\n\nYou will receive the following inputs:\n\nTask Intent: A description in natural language of the goals and steps of a network testing case.  \nCode Snippet: The test script code.  \nAPI Functions: A list of available API interfaces used to generate the test script.\n\n---\n\nYour task is:\n\nBased on the above inputs, rewrite the Task Intent into a standardized and fine-grained list of subtasks to guide automated test script generation.\n\nEach subtask must satisfy the following critical requirements:\n1. Follow the logical execution order, reflecting the actual sequence of network testing steps;\n2. Be clearly and precisely described to facilitate semantic matching with API Functions;\n3. Ensure no key testing intent or condition is omitted (e.g., configurations, validations, expected outcomes);\n4. Maintain contextual consistency across tasks so that each subtask smoothly connects with the output of the previous one.\n\n---\n\n## Input:\n- Task Intent: \n  =================================================================================\n Objective   \t:   测试目的 : 检查BLDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n- Code Snippet: \n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 获取仪表已有imix模板\n    imix_template = [get_imix_from_name(Name='Default'), get_imix_from_name(Name='4-Point'),\n                     get_imix_from_name(Name='IPSEC'), get_imix_from_name(Name='TCPv4')]\n\n    # 创建新imix模板\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_02')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_03')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    # 创建RFC2544 Throughput测试套件\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='imix', ImixTemplates=imix_template)\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n    imix = create_imix(Name='CTRI_IMIX424')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n- API Functions: \n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nadd_imix_distribution_frame:在Imix模板添加自定义帧长;\ncreate_imix:创建流量Imix模板;\nget_imix_from_name:通过Imix模板名称获取流量Imix模板对象;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口\n\n### Output format requirement:\n\nPlease return the result in JSON format. Use keys like `\"Subtask 1\"`, `\"Subtask 2\"`, etc., and values as detailed task descriptions. Do not include any additional content. For example:\n\nFor excmple:\n## Input:\n  - Task Intent:\n    =================================================================================\n    Objective      :   测试目的 :  开放式最短路径优先路由协议（OSPF)\n\n    Step           :   测试步骤1: tester port1 IP地址为192.168.1.100/24，port2为192.168.2.100/24；\n                      测试步骤2: DUT port1 IP地址为192.168.1.1/24，port2为 192.168.2.1/24；\n                      测试步骤3: 在DUT上配置OSPFv2路由协议；\n                      测试步骤4: 测试仪tester使用port1、port2建立OSPF路由器，在port1插入一些LSA，并使port1和DUT的port1达到FULL状态，port2和DUT的port2达到FULL状态，观察port2是否能得到port1的LSA。\n\n    Criteria       :   预期结果1: ospf建立成功，可以收到lsa\n    =================================================================================\n\n\n## Output:\n{\n  \"Subtask 1\": \"Initialize the test instrument and prepare for network testing.\",\n  \"Subtask 2\": \"Reserve the test instrument ports port1 and port2, and wait until the ports are in the UP state.\",\n  \"Subtask 3\": \"Create an IPv4 interface on port1, assign IP address 192.168.1.100/24, and configure the corresponding MAC address.\",\n  \"Subtask 4\": \"Create an IPv4 interface on port2, assign IP address 192.168.2.100/24, and configure the corresponding MAC address.\",\n  \"Subtask 5\": \"Configure DUT port1 with IP address 192.168.1.1/24, and port2 with IP address 192.168.2.1/24.\",\n  \"Subtask 6\": \"Enable and configure OSPFv2 protocol on DUT.\",\n  \"Subtask 7\": \"Establish an OSPFv2 session on port1, set the priority to 1, and bind it to the configured interface.\",\n  \"Subtask 8\": \"Establish an OSPFv2 session on port2, set the priority to 1, and bind it to the configured interface.\",\n  \"Subtask 9\": \"Check whether the OSPF session on port1 receives the Summary LSA.\",\n  \"Subtask 10\": \"Check whether the OSPF session on port2 receives the External LSA.\",\n  \"Subtask 11\": \"Create a routing entry on DUT with port2 as the next-hop output interface.\",\n  \"Subtask 12\": \"Inject an LSA at port1 and configure a routing prefix to be advertised.\",\n  \"Subtask 13\": \"Inject a stream at port1 targeting the advertised prefix.\",\n  \"Subtask 14\": \"Verify the current routing entry using xcfg and display the routing data.\",\n  \"Subtask 15\": \"Enable OSPF routing between DUT and port1, port2; verify that the neighbor status of DUT port2 reaches FULL.\",\n  \"Subtask 16\": \"Check whether DUT port2 receives Summary LSA and External LSA.\",\n  \"Subtask 17\": \"Stop traffic injection, keep session state unchanged.\",\n  \"Subtask 18\": \"Clear the OSPFv2 session on DUT and re-establish the session.\",\n  \"Subtask 19\": \"Capture traffic and send a packet reception report; verify whether DUT port2 successfully receives the LSA from port1.\",\n  \"Subtask 20\": \"Capture traffic and analyze packet sending and receiving statistics; verify whether DUT port2 successfully receives the LSA advertised by port1.\",\n  \"Subtask 21\": \"Release the test instrument and finish the test.\"\n}\n"
  }
]
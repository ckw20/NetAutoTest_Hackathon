[
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_BroadcastForwarding.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastForwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n    \"Subtask 1\": \"Initialize the tester platform for the specified product (DarYu) using init_tester API.\",\n    \"Subtask 2\": \"Reserve two specified ports using reserve_port API with Force=True parameter.\",\n    \"Subtask 3\": \"Create an RFC2889 benchmark configuration for broadcastForwarding test item using create_benchmark API.\",\n    \"Subtask 4\": \"Assign the reserved ports to the benchmark configuration using relate_benchmark_ports API.\",\n    \"Subtask 5\": \"Create Ethernet interfaces on both reserved ports using create_interface API.\",\n    \"Subtask 6\": \"Retrieve Ethernet layer objects from created interfaces using get_layer_from_interfaces API.\",\n    \"Subtask 7\": \"Create unidirectional traffic streams between source and destination ports using create_benchmark_streams API.\",\n    \"Subtask 8\": \"Configure benchmark latency parameters (FIFO mode, delays) using edit_benchmark_latency API.\",\n    \"Subtask 9\": \"Set benchmark result save path using edit_benchmark_path API.\",\n    \"Subtask 10\": \"Configure address learning settings (frequency, rate, repeats) using edit_benchmark_learning API.\",\n    \"Subtask 11\": \"Set benchmark duration parameters (trial count, burst mode) using edit_benchmark_duration API.\",\n    \"Subtask 12\": \"Configure frame length to 64 bytes using edit_benchmark_frame API with custom type.\",\n    \"Subtask 13\": \"Set test load search parameters (step mode, range) using edit_benchmark_search API.\",\n    \"Subtask 14\": \"Configure burst count loop to custom value 1 using edit_benchmark_burst_count_loop API.\",\n    \"Subtask 15\": \"Set custom result filename with timestamp using edit_benchmark_result_file_name API.\",\n    \"Subtask 16\": \"Generate smart test script by expanding benchmark configuration using expand_benchmark API.\",\n    \"Subtask 17\": \"Save test case configuration to specified path using save_case API.\",\n    \"Subtask 18\": \"Execute benchmark test with analyzer enabled using run_benchmark API (1200s timeout).\",\n    \"Subtask 19\": \"Retrieve RFC2889 test results from database using get_benchmark_result API.\",\n    \"Subtask 20\": \"Format test results into tabular output using format_benchmark_result API.\"\n}",
    "prompt": "You are a senior network testing expert.\n\nYou will receive a task described in Chinese. Your task is to:\n\n1. First **translate the Task Intent from Chinese to English**;\n2. Then, based on the translated intent, the provided Python test script code, and the list of API functions,\n   generate a **standardized, fine-grained list of subtasks in English**.\n\n---\n\n## Requirements for subtasks:\n- Subtasks must **follow the logical execution order** and reflect the actual procedure of the test;\n- Each subtask should **map clearly to one or more API functions** used in the script;\n- Use **precise and professional English wording** (e.g., use \"reserve port\", \"configure interface\", \"create traffic stream\");\n- Ensure all critical test components are covered: testbed setup, traffic, protocol parameters, expected results;\n- Use **active voice**, starting each subtask with an action verb;\n- Each subtask should be short, clear, and complete.\n\n---\n\n## Input:\n- Task Intent (in Chinese):\n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的广播帧转发\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项广播帧转发;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n\n- Python Code Snippet:\n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['broadcastForwarding'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_up, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=point_1, DstPoints=point_2,\n                                       Bidirectional=False)\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *广播帧转发参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_search(Config=Config, Mode='step', Lower=10, Upper=20, Step=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='broadcastForwarding',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n\n- API Function List:\n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n---\n\n## Output format:\n{\n    \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n    \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n    \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n    \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n  }\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2544_imix.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 检查BLDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 获取仪表已有imix模板\n    imix_template = [get_imix_from_name(Name='Default'), get_imix_from_name(Name='4-Point'),\n                     get_imix_from_name(Name='IPSEC'), get_imix_from_name(Name='TCPv4')]\n\n    # 创建新imix模板\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_02')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_03')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    # 创建RFC2544 Throughput测试套件\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='imix', ImixTemplates=imix_template)\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n    imix = create_imix(Name='CTRI_IMIX424')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "edit_interface:修改测试仪表接口的参数",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "add_stream:测试仪表创建流量",
      "add_imix_distribution_frame:在Imix模板添加自定义帧长",
      "create_imix:创建流量Imix模板",
      "get_imix_from_name:通过Imix模板名称获取流量Imix模板对象",
      "benchmark_stream_use_exist:编辑测试套件使用已存在流量",
      "create_benchmark:创建测试仪表测试套件",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_search:编辑测试套件测试负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口"
    ],
    "rewrite_intent": "{\n    \"Subtask 1\": \"Initialize the tester for the DarYu platform.\",\n    \"Subtask 2\": \"Reserve two physical ports at specified locations.\",\n    \"Subtask 3\": \"Create IPv4 interfaces on both reserved ports.\",\n    \"Subtask 4\": \"Configure IPv4 address and gateway settings for the first interface (192.168.1.2/192.168.1.3).\",\n    \"Subtask 5\": \"Configure IPv4 address and gateway settings for the second interface (192.168.1.3/192.168.1.2).\",\n    \"Subtask 6\": \"Retrieve IPv4 layer objects from both interfaces.\",\n    \"Subtask 7\": \"Create bidirectional binding traffic streams between the IPv4 endpoints.\",\n    \"Subtask 8\": \"Retrieve existing IMIX templates (Default, 4-Point, IPSEC, TCPv4).\",\n    \"Subtask 9\": \"Create new IMIX template 'Imix_01' with six random frame length distributions.\",\n    \"Subtask 10\": \"Create new IMIX template 'Imix_02' with six random frame length distributions.\",\n    \"Subtask 11\": \"Create new IMIX template 'Imix_03' with six random frame length distributions.\",\n    \"Subtask 12\": \"Create RFC2544 Throughput test suite benchmark.\",\n    \"Subtask 13\": \"Assign reserved ports to the benchmark configuration.\",\n    \"Subtask 14\": \"Configure benchmark to use existing traffic streams.\",\n    \"Subtask 15\": \"Set benchmark address learning to run once with ARP disabled.\",\n    \"Subtask 16\": \"Configure benchmark test duration for 1 iteration.\",\n    \"Subtask 17\": \"Set benchmark frame type to IMIX and apply all IMIX templates.\",\n    \"Subtask 18\": \"Configure benchmark search parameters with 100% initial/lower/upper load.\",\n    \"Subtask 19\": \"Expand benchmark to generate final test configuration.\",\n    \"Subtask 20\": \"Create additional IMIX template 'CTRI_IMIX424'.\",\n    \"Subtask 21\": \"Save complete test case configuration to file.\"\n}",
    "prompt": "You are a senior network testing expert.\n\nYou will receive a task described in Chinese. Your task is to:\n\n1. First **translate the Task Intent from Chinese to English**;\n2. Then, based on the translated intent, the provided Python test script code, and the list of API functions,\n   generate a **standardized, fine-grained list of subtasks in English**.\n\n---\n\n## Requirements for subtasks:\n- Subtasks must **follow the logical execution order** and reflect the actual procedure of the test;\n- Each subtask should **map clearly to one or more API functions** used in the script;\n- Use **precise and professional English wording** (e.g., use \"reserve port\", \"configure interface\", \"create traffic stream\");\n- Ensure all critical test components are covered: testbed setup, traffic, protocol parameters, expected results;\n- Use **active voice**, starting each subtask with an action verb;\n- Each subtask should be short, clear, and complete.\n\n---\n\n## Input:\n- Task Intent (in Chinese):\n  =================================================================================\n Objective   \t:   测试目的 : 检查BLDP VPLS向导配置生成正常\n\n Step\t\t\t:\t测试步骤1: 创建8个离线端口Port_1、Port_2;\n                   测试步骤2: 创建LDP VPLS向导;\n                   测试步骤3: 配置客户端侧端口和提供商侧端口;\n                   测试步骤4: 配置提供商侧路由器;\n                   测试步骤5: 配置VPLS;\n                   测试步骤6: 配置Host;\n                   测试步骤7: 配置流量;\n                   测试步骤8: 生成LDP VPLS向导配置;\n\n Criteria    \t:   预期结果1: 步骤8 LDP VPLS向导配置生成无异常;\n\n Created by   \t:  \tTester-001\n\n Bugs   \t    :  \t None\n =================================================================================\n\n- Python Code Snippet:\n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/13', '//10.0.11.191/1/14'] if len(sys.argv) < 2 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 3 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_up, port_down = reserve_port(Locations=locations, Debug=True)\n\n    # 创建接口\n    interfaces_1 = create_interface(Port=port_up, Layers=['ipv4'])\n    interfaces_2 = create_interface(Port=port_down, Layers=['ipv4'])\n    edit_interface(Interface=interfaces_1,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.2',\n                   Gateway='192.168.1.3')\n\n    edit_interface(Interface=interfaces_2,\n                   Layer='IPv4Layer',\n                   Address='192.168.1.3',\n                   Gateway='192.168.1.2')\n\n    # 创建绑定流\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='ipv4')\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='ipv4')\n    streams = add_stream(Type='binding', SrcPoints=point_1, DstPoints=point_2, Bidirection=True)\n\n    # 获取仪表已有imix模板\n    imix_template = [get_imix_from_name(Name='Default'), get_imix_from_name(Name='4-Point'),\n                     get_imix_from_name(Name='IPSEC'), get_imix_from_name(Name='TCPv4')]\n\n    # 创建新imix模板\n    imix = create_imix(Name='Imix_01')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_02')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=5)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    imix = create_imix(Name='Imix_03')\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=64, Max=128, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=128, Max=256, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=256, Max=512, Weight=20)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=512, Max=1024, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1024, Max=1280, Weight=10)\n    add_imix_distribution_frame(IMix=imix, Type='random', Min=1280, Max=1518, Weight=10)\n    imix_template.append(imix)\n\n    # 创建RFC2544 Throughput测试套件\n    wizard, Config = create_benchmark(Type='rfc2544', Items=['throughput'])\n    relate_benchmark_ports(Config=wizard, Ports=[port_up, port_down])\n    benchmark_stream_use_exist(Config=wizard, Streams=streams)\n    edit_benchmark_learning(Configs=Config, Frequency='once', EnableArp=False)\n    edit_benchmark_duration(Config=Config, Count=1)\n    edit_benchmark_frame(Config=Config, Type='imix', ImixTemplates=imix_template)\n    edit_benchmark_search(Config=Config, Init=100, Lower=100, Upper=100)\n    expand_benchmark(Config=wizard)\n    imix = create_imix(Name='CTRI_IMIX424')\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n\n- API Function List:\n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nedit_interface:修改测试仪表接口的参数;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\nadd_stream:测试仪表创建流量;\nadd_imix_distribution_frame:在Imix模板添加自定义帧长;\ncreate_imix:创建流量Imix模板;\nget_imix_from_name:通过Imix模板名称获取流量Imix模板对象;\nbenchmark_stream_use_exist:编辑测试套件使用已存在流量;\ncreate_benchmark:创建测试仪表测试套件;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_search:编辑测试套件测试负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口\n\n---\n\n## Output format:\n{\n    \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n    \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n    \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n    \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n  }\n"
  },
  {
    "path": "/root/NetAutoTest/data/ref_projects/Examples/Python/Wizard/TestSuite/rfc2889_Congestion.py",
    "intent": "=================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的拥塞控制\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项拥塞控制;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================",
    "code": "from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 4 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 5 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_congested, port_uncongested = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['congestionControl'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_1, port_2, port_congested, port_uncongested])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_1, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_2, Layers=['eth'])\n    interfaces_3 = create_interface(Port=port_congested, Layers=['eth'])\n    interfaces_4 = create_interface(Port=port_uncongested, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')[0]\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')[0]\n    point_congested = get_layer_from_interfaces(Interfaces=interfaces_3, Layer='eth')[0]\n    point_uncongested = get_layer_from_interfaces(Interfaces=interfaces_4, Layer='eth')[0]\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=[point_1, point_2],\n                                       DstPoints=[point_congested, point_uncongested], Mode='congestion')\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *拥塞控制参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='congestionControl',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')",
    "functions": [
      "init_tester:初始化测试仪表",
      "save_case:测试仪表保存配置文件",
      "reserve_port:预约测试仪表的端口",
      "create_interface:在指定端口上創建接口",
      "get_layer_from_interfaces:获取测试仪表接口的封装层对象",
      "create_benchmark:创建测试仪表测试套件",
      "create_benchmark_streams:创建测试仪表测试套件流量",
      "edit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试",
      "edit_benchmark_duration:编辑测试套件测试时长设置",
      "edit_benchmark_frame:编辑测试套件帧长度设置",
      "edit_benchmark_latency:编辑测试套件时间参数",
      "edit_benchmark_learning:编辑测试套件地址学习设置",
      "edit_benchmark_path:编辑测试套件地址学习设置",
      "edit_benchmark_result_file_name:配置自定义测试结果名称",
      "edit_benchmark_traffic_load_loop:编辑测试套件负载设置",
      "expand_benchmark:测试仪表生成测试仪表测试套件",
      "format_benchmark_result:格式化列表为二维表格形式",
      "get_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据",
      "relate_benchmark_ports:指定测试仪表测试套件使用的端口",
      "run_benchmark:执行测试仪表配置中的测试套件"
    ],
    "rewrite_intent": "{\n    \"Subtask 1\": \"Initialize the tester platform for product 'DarYu'.\",\n    \"Subtask 2\": \"Reserve four physical ports using specified locations.\",\n    \"Subtask 3\": \"Create RFC2889 benchmark suite with congestion control test item.\",\n    \"Subtask 4\": \"Assign reserved ports to the benchmark configuration.\",\n    \"Subtask 5\": \"Create Ethernet interfaces on all four reserved ports.\",\n    \"Subtask 6\": \"Retrieve Ethernet layer objects from each interface.\",\n    \"Subtask 7\": \"Create congestion mode traffic streams with source and destination endpoints.\",\n    \"Subtask 8\": \"Configure benchmark latency parameters with FIFO type, 2ms delay before, and 10ms delay after.\",\n    \"Subtask 9\": \"Set benchmark result storage path to 'D:/test'.\",\n    \"Subtask 10\": \"Configure address learning settings with per-trial frequency, 100% learning rate, 3 repeats, and 5ms delay.\",\n    \"Subtask 11\": \"Set benchmark duration to 1 trial in burst mode with 100 bursts.\",\n    \"Subtask 12\": \"Configure frame length to custom 64 bytes.\",\n    \"Subtask 13\": \"Set traffic load loop to step mode from 10% to 20% with 10% step.\",\n    \"Subtask 14\": \"Configure burst count loop to custom mode with 1 burst.\",\n    \"Subtask 15\": \"Set custom result filename to 'congestionControl' with timestamp.\",\n    \"Subtask 16\": \"Expand benchmark configuration to generate smart scripts.\",\n    \"Subtask 17\": \"Save test case configuration to specified file path.\",\n    \"Subtask 18\": \"Execute benchmark with 1200-second timeout and analyzer enabled.\",\n    \"Subtask 19\": \"Retrieve RFC2889 benchmark results from database.\",\n    \"Subtask 20\": \"Format benchmark results into tabular output.\"\n}",
    "prompt": "You are a senior network testing expert.\n\nYou will receive a task described in Chinese. Your task is to:\n\n1. First **translate the Task Intent from Chinese to English**;\n2. Then, based on the translated intent, the provided Python test script code, and the list of API functions,\n   generate a **standardized, fine-grained list of subtasks in English**.\n\n---\n\n## Requirements for subtasks:\n- Subtasks must **follow the logical execution order** and reflect the actual procedure of the test;\n- Each subtask should **map clearly to one or more API functions** used in the script;\n- Use **precise and professional English wording** (e.g., use \"reserve port\", \"configure interface\", \"create traffic stream\");\n- Ensure all critical test components are covered: testbed setup, traffic, protocol parameters, expected results;\n- Use **active voice**, starting each subtask with an action verb;\n- Each subtask should be short, clear, and complete.\n\n---\n\n## Input:\n- Task Intent (in Chinese):\n  =================================================================================\n Objective   \t:   测试目的 : 确定局域网交换机设备的拥塞控制\n\n Step\t\t\t:\t测试步骤1: 创建端口，并预约端口\n                   测试步骤2: 创建RFC2889向导, 选择测试项拥塞控制;\n                   测试步骤3: 选择端口;\n                   测试步骤4: 配置端点;\n                   测试步骤5: 配置流;\n                   测试步骤6: 配置测试选项;\n                   测试步骤7: 地址速率参数设置;\n                   测试步骤8: 生成智能脚本;\n                   测试步骤8: 执行智能脚本测试;\n\n Criteria    \t:   预期结果1: 步骤9 正确测出设备地址缓存容量;\n\n Created by   \t:  \tTester-002\n\n Bugs   \t    :  \t None\n =================================================================================\n\n- Python Code Snippet:\n  ```python\n  from TesterLibrary.base import *\n\nlocations = ['//10.0.11.191/1/3', '//10.0.11.191/1/4', '//10.0.11.191/1/5', '//10.0.11.191/1/6'] if len(sys.argv) < 4 else sys.argv[1].split(' ')\nProduct = 'DarYu' if len(sys.argv) < 5 else sys.argv[2].split(' ')\n\nverdict = 'pass'\nerrInfo = ''\n\ntry:\n\n    # 初始化仪表，执行仪表平台为DarYu\n    init_tester(Product=Product)\n\n    # 创建端口，并预约端口\n    port_1, port_2, port_congested, port_uncongested = reserve_port(Locations=locations, Force=True)\n\n    # =============== *选择测试项* ===============\n    wizard, Config = create_benchmark(Type='RFC2889', Items=['congestionControl'])\n\n    # =============== *选择端口* ===============\n    relate_benchmark_ports(Config=wizard, Ports=[port_1, port_2, port_congested, port_uncongested])\n\n    # =============== *配置端点* ===============\n    interfaces_1 = create_interface(Port=port_1, Layers=['eth'])\n    interfaces_2 = create_interface(Port=port_2, Layers=['eth'])\n    interfaces_3 = create_interface(Port=port_congested, Layers=['eth'])\n    interfaces_4 = create_interface(Port=port_uncongested, Layers=['eth'])\n\n    # =============== *配置流* ===============\n    point_1 = get_layer_from_interfaces(Interfaces=interfaces_1, Layer='eth')[0]\n    point_2 = get_layer_from_interfaces(Interfaces=interfaces_2, Layer='eth')[0]\n    point_congested = get_layer_from_interfaces(Interfaces=interfaces_3, Layer='eth')[0]\n    point_uncongested = get_layer_from_interfaces(Interfaces=interfaces_4, Layer='eth')[0]\n    streams = create_benchmark_streams(Config=wizard, Items=Config, Type='eth', SrcPoints=[point_1, point_2],\n                                       DstPoints=[point_congested, point_uncongested], Mode='congestion')\n\n    # =============== *配置测试选项* ===============\n    # 时延设置\n    edit_benchmark_latency(Configs=Config, Type='FIFO', DelayBefore=2, DelayAfter=10)\n    edit_benchmark_path(Configs=Config, Path='D:/test')\n    edit_benchmark_learning(Configs=Config, Frequency='trial', EnableLearning=True, LearningRate=100, LearningRepeat=3,\n                            DelayBefore=5)\n\n    # =============== *拥塞控制参数设置* ===============\n    # 试验次数\n    edit_benchmark_duration(Config=Config, Trial=1, Mode='burst', Count=100)\n    # 帧长设置\n    edit_benchmark_frame(Config=Config, Type='custom', Custom=[64])\n    # 负载\n    edit_benchmark_traffic_load_loop(Config=Config, LoadMode='step', LoadStart=10, LoadEnd=20, LoadStep=10)\n    # 突发帧数\n    edit_benchmark_burst_count_loop(Config=Config, Mode='custom', Custom=[1])\n    # 配置自定义测试结果名称\n    edit_benchmark_result_file_name(Config=Config, EnableCustomResult=True, ResultFileName='congestionControl',\n                                    AddTimeStamp=True)\n\n    # =============== *生成智能脚本* ===============\n    expand_benchmark(Config=wizard)\n\n    # 保存配置文件\n    dirname, tempfilename = os.path.split(os.path.abspath(__file__))\n    filename, extension = os.path.splitext(tempfilename)\n    save_case(Path=f'{dirname}/xcfg/{filename}.xcfg')\n\n    # =============== *执行智能脚本测试* ===============\n    db = run_benchmark(Mode=0, Timer=1200, Analyzer=True)\n    result = get_benchmark_result(DB=db, Type='RFC2889')\n    tmp = format_benchmark_result(Result=result)\n    print(tmp)\n\nexcept Exception as e:\n    verdict = 'fail'\n    errInfo = repr(e)\nfinally:\n    print(f'errInfo:\\n{errInfo}')\n    print(f'verdict:{verdict}')\n  ```\n\n- API Function List:\n  init_tester:初始化测试仪表;\nsave_case:测试仪表保存配置文件;\nreserve_port:预约测试仪表的端口;\ncreate_interface:在指定端口上創建接口;\nget_layer_from_interfaces:获取测试仪表接口的封装层对象;\ncreate_benchmark:创建测试仪表测试套件;\ncreate_benchmark_streams:创建测试仪表测试套件流量;\nedit_benchmark_burst_count_loop:编辑RFC2889测试套件突发帧数，设置测试项: 广播帧转发测试、拥塞控制测试、错误帧过滤测试、转发测试;\nedit_benchmark_duration:编辑测试套件测试时长设置;\nedit_benchmark_frame:编辑测试套件帧长度设置;\nedit_benchmark_latency:编辑测试套件时间参数;\nedit_benchmark_learning:编辑测试套件地址学习设置;\nedit_benchmark_path:编辑测试套件地址学习设置;\nedit_benchmark_result_file_name:配置自定义测试结果名称;\nedit_benchmark_traffic_load_loop:编辑测试套件负载设置;\nexpand_benchmark:测试仪表生成测试仪表测试套件;\nformat_benchmark_result:格式化列表为二维表格形式;\nget_benchmark_result:从测试套件执行结果DB文件中获取指定测试结果数据;\nrelate_benchmark_ports:指定测试仪表测试套件使用的端口;\nrun_benchmark:执行测试仪表配置中的测试套件\n\n---\n\n## Output format:\n{\n    \"Subtask 1\": \"Configure switch port eth1 to connect with the tester and set it to full-duplex mode.\",\n    \"Subtask 2\": \"Use the API to create a traffic stream with a frame length of 64 bytes and a test duration of 60 seconds.\",\n    \"Subtask 3\": \"Start the traffic transmission and record the packet loss and throughput during the test.\",\n    \"Subtask 4\": \"Verify whether the test results meet expectations: throughput reaches 100%.\"\n  }\n"
  }
]